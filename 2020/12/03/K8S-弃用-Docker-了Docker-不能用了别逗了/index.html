<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>K8S 弃用 Docker 了？Docker 不能用了？别逗了！ - MoeLove</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-1876963677156202",enable_page_level_ads:true});</script><meta name=author content="张晋涛"><meta name=description content="Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。
 概览 2013 年 Docker 是在 2013 年的 PyCon 上首次正式对外公布的。 它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。 工程师们只需要简单的 docker build 命令即可制作出自己的镜像，并通过 docker push 将其发布至 DockerHub 上。 通过简单的 docker run 命令即可快速的使用指定镜像启动自己的服务。
通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 Build once, Run anywhere 的目标。
从此 Docker 也基本成为了容器的代名词，并成为容器时代的引领者。
2014 年 2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。
这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。 Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。
同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：
 We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker."><meta name=keywords content="MoeLove,Linux,Docker,Kubernetes,Golang,Python,Container,Vim,容器,k8s"><meta name=baidu-site-verification content="jO2rMlnjJi"><meta name=google-site-verification content="googlefe3fc086c62f7210.html"><meta name=generator content="Hugo 0.62.2 with theme even"><link rel=canonical href=https://moelove.info/2020/12/03/K8S-%E5%BC%83%E7%94%A8-Docker-%E4%BA%86Docker-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%E5%88%AB%E9%80%97%E4%BA%86/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.8c3cbcb0324c2bb4875ceccba4007cbad4b4ac8377f33af9953c3e7684534a50.css rel=stylesheet><link href=/lib/fancybox/jquery.fancybox-3.1.20.min.css rel=stylesheet><meta property="og:title" content="K8S 弃用 Docker 了？Docker 不能用了？别逗了！"><meta property="og:description" content="Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。
 概览 2013 年 Docker 是在 2013 年的 PyCon 上首次正式对外公布的。 它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。 工程师们只需要简单的 docker build 命令即可制作出自己的镜像，并通过 docker push 将其发布至 DockerHub 上。 通过简单的 docker run 命令即可快速的使用指定镜像启动自己的服务。
通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 Build once, Run anywhere 的目标。
从此 Docker 也基本成为了容器的代名词，并成为容器时代的引领者。
2014 年 2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。
这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。 Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。
同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：
 We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker."><meta property="og:type" content="article"><meta property="og:url" content="https://moelove.info/2020/12/03/K8S-%E5%BC%83%E7%94%A8-Docker-%E4%BA%86Docker-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%E5%88%AB%E9%80%97%E4%BA%86/"><meta property="article:published_time" content="2020-12-03T22:32:59+08:00"><meta property="article:modified_time" content="2020-12-03T22:32:59+08:00"><meta itemprop=name content="K8S 弃用 Docker 了？Docker 不能用了？别逗了！"><meta itemprop=description content="Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。
 概览 2013 年 Docker 是在 2013 年的 PyCon 上首次正式对外公布的。 它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。 工程师们只需要简单的 docker build 命令即可制作出自己的镜像，并通过 docker push 将其发布至 DockerHub 上。 通过简单的 docker run 命令即可快速的使用指定镜像启动自己的服务。
通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 Build once, Run anywhere 的目标。
从此 Docker 也基本成为了容器的代名词，并成为容器时代的引领者。
2014 年 2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。
这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。 Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。
同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：
 We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker."><meta itemprop=datePublished content="2020-12-03T22:32:59+08:00"><meta itemprop=dateModified content="2020-12-03T22:32:59+08:00"><meta itemprop=wordCount content="571"><meta itemprop=keywords content="Kubernetes,Docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="K8S 弃用 Docker 了？Docker 不能用了？别逗了！"><meta name=twitter:description content="Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。
 概览 2013 年 Docker 是在 2013 年的 PyCon 上首次正式对外公布的。 它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。 工程师们只需要简单的 docker build 命令即可制作出自己的镜像，并通过 docker push 将其发布至 DockerHub 上。 通过简单的 docker run 命令即可快速的使用指定镜像启动自己的服务。
通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 Build once, Run anywhere 的目标。
从此 Docker 也基本成为了容器的代名词，并成为容器时代的引领者。
2014 年 2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。
这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。 Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。
同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：
 We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>MoeLove</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/about/><li class=mobile-menu-item>About</li></a><a href=/friends/><li class=mobile-menu-item>Friends</li></a><a href=/projects/><li class=mobile-menu-item>Projects</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>MoeLove</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/about/>About</a></li><li class=menu-item><a class=menu-item-link href=/friends/>Friends</a></li><li class=menu-item><a class=menu-item-link href=/projects/>Projects</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>K8S 弃用 Docker 了？Docker 不能用了？别逗了！</h1><div class=post-meta><span class=post-time>2020-12-03</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#概览>概览</a><ul><li><a href=#2013-年>2013 年</a></li><li><a href=#2014-年>2014 年</a></li><li><a href=#2015-年>2015 年</a></li><li><a href=#2016-年>2016 年</a></li><li><a href=#2017-年>2017 年</a></li><li><a href=#2018-年>2018 年</a></li><li><a href=#2019-年>2019 年</a></li><li><a href=#2020-年>2020 年</a></li></ul></li><li><a href=#说明>说明</a></li><li><a href=#qa>Q&A</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=post-content><blockquote><p>Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。</p></blockquote><h2 id=概览>概览</h2><h3 id=2013-年>2013 年</h3><p>Docker 是在 2013 年的 PyCon 上首次正式对外公布的。
它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。
工程师们只需要简单的 <code>docker build</code> 命令即可制作出自己的镜像，并通过 <code>docker push</code> 将其发布至 DockerHub 上。
通过简单的 <code>docker run</code> 命令即可快速的使用指定镜像启动自己的服务。</p><p>通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 <strong>Build once, Run anywhere</strong> 的目标。</p><p>从此 <strong>Docker 也基本成为了容器的代名词，并成为容器时代的引领者。</strong></p><h3 id=2014-年>2014 年</h3><p>2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。</p><p><strong>这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。</strong> Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。</p><p>同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：</p><blockquote><p>We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker.</p></blockquote><p><a href=https://cloudplatform.googleblog.com/2014/06/an-update-on-container-support-on-google-cloud-platform.html title="An update on container support on Google Cloud Platform">An update on container support on Google Cloud Platform</a></p><blockquote><p>Kubernetes is an open source manager for Docker containers, based on Google’s years of experience using containers at Internet scale.
Docker is delivering the full container stack that Kubernetes schedules into, and is looking to move critical capabilities upstream and align the Kubernetes framework with Libswarm.</p></blockquote><p><a href=https://cloudplatform.googleblog.com/2014/07/welcome-microsoft-redhat-ibm-docker-and-more-to-the-kubernetes-community.html title="Welcome Microsoft, RedHat, IBM, Docker and more to the Kubernetes community">Welcome Microsoft, RedHat, IBM, Docker and more to the Kubernetes community</a></p><p>并在同一个月的 DockerCon 上发布演讲，介绍了 Kubernetes 并受到了广泛的关注。</p><p>此时 <strong>Docker Inc. 也发布了其容器编排工具， libswarm （也就是后来的 swarmkit） 。</strong></p><h3 id=2015-年>2015 年</h3><p>2015 年 OCI （Open Container Initiative）由 Docker 和其他容器行业领导者共同成立（它也是 Linux 基金会旗下项目）</p><p>OCI 主要包含两个规范：</p><ul><li><p>运行时规范（runtime-spec）：容器运行时，如何运行指定的 文件系统上的包</p></li><li><p>容器镜像规范（image-spec）：如何创建一个 OCI 运行时可运行的文件系统上的包</p></li></ul><p>Docker 把它自己的容器镜像格式和 runtime ( <strong>现在的 runc</strong> ) 都捐给了 OCI 作为初始工作。</p><h3 id=2016-年>2016 年</h3><p>2016 年 6 月，Docker v1.12 发布，带来了 <strong>Docker 在多主机多容器的编排解决方案，Docker Swarm 。</strong>
这里也需要注意的是，Docker v1.12 的设计原则：</p><ul><li>Simple Yet Powerful （简单而强大）</li><li>Resilient（弹性）</li><li>Secure（安全）</li><li>Optional Features and Backward Compatibility（可选功能及向后兼容）</li></ul><p>所以你可以通过配置自行选择是否需要使用 Docker Swarm ，而无需担心有什么副作用。</p><p>2016 年 12 月， <strong>Kubernetes 发布 CRI （Container Runtime Interface）</strong> ，这当中一部分原因是由于 Kubernetes 尝试支持另一个由 CoreOS 领导的容器运行时项目 rkt ，但是需要写很多兼容的代码之类的，为了避免后续兼容其他运行时带来的维护工作，所以发布了统一的 CRI 接口，凡是支持 CRI 的运行时，皆可直接作为 Kubernetes 的底层运行时；</p><p>当然， <strong>Kubernetes 也是在 2016 年逐步取得那场容器编排战争的胜利的。</strong></p><h3 id=2017-年>2017 年</h3><p>2017 年， Docker 将自身从 v1.11 起开始引入的<a href=https://github.com/containerd/containerd/ title=containerd>容器运行时 containerd</a> 捐给了 <a href=https://www.cncf.io/ title="CNCF website">CNCF</a></p><p>2017 年，Docker 的网络组件 libnetwork 增加了 CNI 的支持；
同时通过<a href=https://github.com/kubernetes/kubernetes/pull/46580 title="在 K8S 中增加 IPvs 的负载均衡">使用 Docker 为 Docker Swarm 提供的 ipvs 相关的代码</a>，也在 Kubernetes 中实现了基于 IPvs 的 service 负载均衡。不过在 v1.18 中开始移除了相关的依赖。</p><p>同年 11 月，<a href=https://kubernetes.io/blog/2017/11/containerd-container-runtime-options-kubernetes/ title="Containerd Brings More Container Runtime Options for Kubernetes">Kubernetes 中新增了 containerd 的支持</a></p><p><img src=https://lh5.googleusercontent.com/sfkhKO3jiLZ9_TtPpxTsKxkbe1KHg1nrfqkbJYrjN2DbNQE_y31NJVSyDIXe0oQjSwVcQ4gFCyr1MZ9_V4GZuuiHwuU3Pq6ldpRhcRiiuTJaRVuezPK9KFLKovP8mQ6sXTYF_eru alt=cri-containerd></p><h3 id=2018-年>2018 年</h3><p>2018 年， <a href=https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/ title="Kubernetes Containerd Integration Goes GA">Kubernetes 的 containerd 集成，正式 GA</a></p><p>之前版本的架构：</p><p><img src=https://d33wubrfki0l68.cloudfront.net/6b4290afef76cad8a084292cd1b5e468e31c9bb3/c26ce/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png alt="containerd 1.0 cri-containerd"></p><p>新的架构：</p><p><img src=https://d33wubrfki0l68.cloudfront.net/f8dfc688157620f656f96bfd8872deccfbd409e7/51b10/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/containerd.png alt="containerd 1.1 cri-containerd"></p><h3 id=2019-年>2019 年</h3><p>2019 年，上文中提到的另一个容器运行时项目 rkt 被 CNCF 归档，终止使命了；
2019 年 Mirantis 收购 Docker 的企业服务。</p><h3 id=2020-年>2020 年</h3><p>时间回到今年，Docker 主要被误会的两件事：</p><ul><li>Docker Inc. 修改 DockerHub 的定价和 TOS 。国内争论较多的主要是关于合规性的问题（但是被标题党带歪了，免不了恐慌）；</li><li>Kubernetes 宣布开始进入废弃 dockershim 支持的倒计时，被人误以为 Docker 不能再用了；</li></ul><h2 id=说明>说明</h2><p><strong>关于 DockerHub 修改定价和 TOS 的事情，这里就不再多说了，毕竟 DockerHub 目前大家仍然用的很欢乐，远不像当初那些标题党宣称的那样。</strong></p><p>重点来说一下第二件事情吧。</p><p>Kubernetes 当初选择 Docker 作为其容器运行时，本身就是因为当时它没有其他的选择，并且选择 Docker 可为它带来众多的用户。
所以，开始时，它便提供了内置的对 Docker 运行时的支持。</p><p>而 Docker 其实创建之初，并没有考虑到“编排”的这个功能，当然也没有考虑到 Kubernetes 的存在（因为当时还没有）。</p><p><strong>dockershim</strong> 一直都是 Kubernetes 社区为了能让 Docker 成为其支持的容器运行时，所维护的一个兼容程序。 <strong>本次所谓的废弃，也仅仅是 Kubernetes 要放弃对现在 Kubernetes 代码仓库中的 dockershim 的维护支持。</strong> 以便其可以像开始时计划的那样，仅负责维护其 CRI ，任何兼容 CRI 的运行时，皆可作为 Kubernetes 的 runtime 。</p><p>在 Kubernetes 提出 CRI 时，有人建议在 Docker 中实现它。但是这种方式也会带来一个问题，即使 Docker 实现了 CRI，但它仍然不是一个单纯的容器运行时，它本身包含了大量的非 “纯底层容器运行时” 所具备的功能。</p><p>所以后来 <strong>自 Docker 中分离出来的 containerd 项目，作为一个底层容器运行时出现了，它是 Kubernetes 容器运行时更好的选择。</strong></p><p>Docker 使用 containerd 作为其底层容器运行时以及众多的云厂商及公司在生产环境中使用 containerd 作为其 Kubernetes 的运行时，这也从侧面验证了 containerd 的稳定性。</p><p>现在 Kubernetes 和 Docker 社区都相信 containerd 已经足够成熟可直接作为 Kubernetes 的运行时了，而无需再通过 dockershim 使用 Docker 作为 Kubernetes 的运行时了。这也标志着 Docker 为 Kubernetes 提供一个现代化的容器运行时的承诺最终兑现了。</p><p><strong>而本次事件中，重点的 dockershim 之后的方向如何呢？Kubernetes 代码仓库中的 dockershim 将会在未来版本中移除，但是 Mirantis 公司已经和 Docker 达成合作，在未来会共同维护一份 dockershim 组件，以便支持 Docker 作为 Kubernetes 的容器运行时。</strong></p><p><strong>Otherwise, if you’re using the open source Docker Engine, the dockershim project will be available as an open source component, and you will be able to continue to use it with Kubernetes; it will just require a small configuration change, which we will document.</strong></p><p><a href=https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-2/ title="Mirantis to take over support of Kubernetes dockershim">Mirantis 公司宣布将维护 dockershim</a></p><h2 id=qa>Q&A</h2><p>Q：本次 Kubernetes 放弃对 dockershim 的维护，到底有什么影响？
A：对于普通用户而言，没有任何影响；对于在 Kubernetes 之上进行开发的工程师，没什么太大影响；对于集群管理员，需要考虑是否要在未来版本中，将容器运行时，升级为支持 CRI 的运行时，比如 containerd 。
当然，如果你并不想切换容器运行时，那也没关系，Mirantis 公司未来会和 Docker 共同维护 dockershim , 并作为一个开源组件提供。</p><p>Q: Docker 不能用了吗？
A：Docker 仍然是本地开发，或者单机部署最佳的容器工具，它提供了更为人性化的用户体验，并且也有丰富的特性。目前 Docker 已经和 AWS 达成合作，可直接通过 Docker CLI 与 AWS 集成。另外，Docker 也仍然可以作为 Kubernetes 的容器运行时，并没有立即中止对其支持。</p><p>Q：听说 Podman 可以借机上位了？
A：想太多。Podman 也并不兼容 CRI ，并且它也不具备作为 Kubernetes 容器运行时的条件。我个人也偶尔有在用 Podman， 并且我们在 KIND 项目中也提供了对 Podman 的支持， 但实话讲，它也就是只是一个 CLI 工具，某些情况下会有些作用，比如如果你的 Kubernetes 容器运行时使用 cri-o 的情况下，可以用来本地做下调试。</p><h2 id=总结>总结</h2><p>本文主要介绍了 Docker 和 Kubernetes 的发展历程，也解释了本次 Kubernetes 仅仅是放弃其对 dockershim 组件的支持。未来更推荐的 Kubernetes 运行时是 兼容 CRI 的 containerd 之类的底层运行时。</p><p>Mirantis 公司将会和 Docker 共同维护 dockershim 并作为开源组件提供。</p><p>Docker 仍然是一款最佳的本地开发测试和部署的工具。</p><hr><p>欢迎订阅我的文章公众号【MoeLove】</p><p><img src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/mp-qrcode.png alt=TheMoeLove></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>张晋涛</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-12-03</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>CC BY-SA 4.0</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/wx_pay.jpg>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/alipay.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/kubernetes/>Kubernetes</a>
<a href=/tags/docker/>Docker</a></div><nav class=post-nav><a class=prev href=/2020/12/19/Go-1.16-%E4%B8%AD%E5%85%B3%E4%BA%8E-go-get-%E5%92%8C-go-install-%E4%BD%A0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Go 1.16 中关于 go get 和 go install 你需要注意的地方</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/2020/11/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-v1.9.0-%E5%B8%A6%E6%9D%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/><span class="next-text nav-default">K8S 生态周报| Cilium v1.9.0 带来更好的性能</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script><script type=text/javascript>var gitalk=new Gitalk({id:'2020-12-03 22:32:59 \x2b0800 CST',title:'K8S 弃用 Docker 了？Docker 不能用了？别逗了！',clientID:'68312db64e870efbd0a0',clientSecret:'a062c51a15de76546aa52351e0dd5b3cfb0cc7d8',repo:'tao12345666333.github.io',owner:'tao12345666333',admin:['tao12345666333'],body:decodeURI(location.href)});gitalk.render('gitalk-container');</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:zhangjintao9020@gmail.com class="iconfont icon-email" title=email></a><a href=https://twitter.com/BeierTao class="iconfont icon-twitter" title=twitter></a><a href=https://github.com/tao12345666333 class="iconfont icon-github" title=github></a><a href=http://weibo.com/9020taobeier class="iconfont icon-weibo" title=weibo></a><a href=https://www.zhihu.com/people/TaoBeier class="iconfont icon-zhihu" title=zhihu></a><a href=https://moelove.info/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2013 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>张晋涛</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/lib/fancybox/jquery.fancybox-3.1.20.min.js></script><script type=text/javascript src=/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script></body></html>