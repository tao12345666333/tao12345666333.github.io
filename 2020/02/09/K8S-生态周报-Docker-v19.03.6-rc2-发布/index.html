<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>K8S 生态周报| Docker v19.03.6-rc2 发布 - MoeLove</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-1876963677156202",enable_page_level_ads:true});</script><meta name=author content="TaoBeier"><meta name=description content="「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
 Docker v19.03.6-rc2 发布 自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。
v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：
 buildkit: 修复了在触发 ONBUILD 规则之后，未清理掉 ONBUILD 规则的问题。对于依赖 ONBUILD 指令，且使用 buildkit 的用户而言是个重要修复； buildkit: 修复了启用了 userns 时，可能导致权限错误的问题； 使用了 libnetwork 的短 ID, 以避免遇到 UNIX_PATH_MAX 的错误;  说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 UNIX_PATH_MAX 的问题上稍微多聊一点。
这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？
其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下如何目前的限制是什么，这个限制可以在 Linux 的源码中找到的。
// include/uapi/linux/un.h #ifndef _LINUX_UN_H #define _LINUX_UN_H #include &amp;lt;linux/socket.h&amp;gt; #define UNIX_PATH_MAX	108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX];	/* pathname */ }; #define SIOCUNIXFILE (SIOCPROTOPRIVATE &#43; 0) /* open a socket file with O_PATH */ #endif /* _LINUX_UN_H */  可以看到现在头文件中定义的是 108 。（ 注意我此处使用的是 Linux 5."><meta name=keywords content="MoeLove,Linux,Docker,Kubernetes,Golang,Python,Container,Vim,容器,k8s"><meta name=baidu-site-verification content="jO2rMlnjJi"><meta name=google-site-verification content="googlefe3fc086c62f7210.html"><meta name=generator content="Hugo 0.55.6"><link rel=canonical href=https://moelove.info/2020/02/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.6-rc2-%E5%8F%91%E5%B8%83/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href="/dist/even.min.css?v=3.2.0" rel=stylesheet><link href=/lib/fancybox/jquery.fancybox-3.1.20.min.css rel=stylesheet><meta property="og:title" content="K8S 生态周报| Docker v19.03.6-rc2 发布"><meta property="og:description" content="「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
 Docker v19.03.6-rc2 发布 自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。
v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：
 buildkit: 修复了在触发 ONBUILD 规则之后，未清理掉 ONBUILD 规则的问题。对于依赖 ONBUILD 指令，且使用 buildkit 的用户而言是个重要修复； buildkit: 修复了启用了 userns 时，可能导致权限错误的问题； 使用了 libnetwork 的短 ID, 以避免遇到 UNIX_PATH_MAX 的错误;  说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 UNIX_PATH_MAX 的问题上稍微多聊一点。
这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？
其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下如何目前的限制是什么，这个限制可以在 Linux 的源码中找到的。
// include/uapi/linux/un.h #ifndef _LINUX_UN_H #define _LINUX_UN_H #include &lt;linux/socket.h&gt; #define UNIX_PATH_MAX	108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX];	/* pathname */ }; #define SIOCUNIXFILE (SIOCPROTOPRIVATE &#43; 0) /* open a socket file with O_PATH */ #endif /* _LINUX_UN_H */  可以看到现在头文件中定义的是 108 。（ 注意我此处使用的是 Linux 5."><meta property="og:type" content="article"><meta property="og:url" content="https://moelove.info/2020/02/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.6-rc2-%E5%8F%91%E5%B8%83/"><meta property="article:published_time" content="2020-02-09T17:14:37&#43;08:00"><meta property="article:modified_time" content="2020-02-09T17:14:37&#43;08:00"><meta itemprop=name content="K8S 生态周报| Docker v19.03.6-rc2 发布"><meta itemprop=description content="「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
 Docker v19.03.6-rc2 发布 自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。
v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：
 buildkit: 修复了在触发 ONBUILD 规则之后，未清理掉 ONBUILD 规则的问题。对于依赖 ONBUILD 指令，且使用 buildkit 的用户而言是个重要修复； buildkit: 修复了启用了 userns 时，可能导致权限错误的问题； 使用了 libnetwork 的短 ID, 以避免遇到 UNIX_PATH_MAX 的错误;  说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 UNIX_PATH_MAX 的问题上稍微多聊一点。
这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？
其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下如何目前的限制是什么，这个限制可以在 Linux 的源码中找到的。
// include/uapi/linux/un.h #ifndef _LINUX_UN_H #define _LINUX_UN_H #include &lt;linux/socket.h&gt; #define UNIX_PATH_MAX	108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX];	/* pathname */ }; #define SIOCUNIXFILE (SIOCPROTOPRIVATE &#43; 0) /* open a socket file with O_PATH */ #endif /* _LINUX_UN_H */  可以看到现在头文件中定义的是 108 。（ 注意我此处使用的是 Linux 5."><meta itemprop=datePublished content="2020-02-09T17:14:37&#43;08:00"><meta itemprop=dateModified content="2020-02-09T17:14:37&#43;08:00"><meta itemprop=wordCount content="400"><meta itemprop=keywords content="Linux,Weekly,Kubernetes,"><meta name=twitter:card content="summary"><meta name=twitter:title content="K8S 生态周报| Docker v19.03.6-rc2 发布"><meta name=twitter:description content="「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。
 Docker v19.03.6-rc2 发布 自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。
v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：
 buildkit: 修复了在触发 ONBUILD 规则之后，未清理掉 ONBUILD 规则的问题。对于依赖 ONBUILD 指令，且使用 buildkit 的用户而言是个重要修复； buildkit: 修复了启用了 userns 时，可能导致权限错误的问题； 使用了 libnetwork 的短 ID, 以避免遇到 UNIX_PATH_MAX 的错误;  说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 UNIX_PATH_MAX 的问题上稍微多聊一点。
这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？
其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下如何目前的限制是什么，这个限制可以在 Linux 的源码中找到的。
// include/uapi/linux/un.h #ifndef _LINUX_UN_H #define _LINUX_UN_H #include &lt;linux/socket.h&gt; #define UNIX_PATH_MAX	108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX];	/* pathname */ }; #define SIOCUNIXFILE (SIOCPROTOPRIVATE &#43; 0) /* open a socket file with O_PATH */ #endif /* _LINUX_UN_H */  可以看到现在头文件中定义的是 108 。（ 注意我此处使用的是 Linux 5."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>MoeLove</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/about/><li class=mobile-menu-item>About</li></a><a href=/friends/><li class=mobile-menu-item>Friends</li></a><a href=/projects/><li class=mobile-menu-item>Projects</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>MoeLove</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/about/>About</a></li><li class=menu-item><a class=menu-item-link href=/friends/>Friends</a></li><li class=menu-item><a class=menu-item-link href=/projects/>Projects</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>K8S 生态周报| Docker v19.03.6-rc2 发布</h1><div class=post-meta><span class=post-time>2020-02-09</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#docker-v19-03-6-rc2-发布>Docker v19.03.6-rc2 发布</a></li><li><a href=#containerd-v1-3-3-发布>containerd v1.3.3 发布</a></li><li><a href=#cncf-发布了-containerd-项目的旅程报告>CNCF 发布了 containerd 项目的旅程报告</a></li><li><a href=#docker-将关闭旧的-apt-和-yum-仓库>Docker 将关闭旧的 APT 和 YUM 仓库</a></li><li><a href=#上游进展>上游进展</a></li><li><a href=#题外话>题外话</a></li></ul></li></ul></nav></div></div><div class=post-content><blockquote><p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏<a href=https://zhuanlan.zhihu.com/container>「k8s生态」</a>。</p></blockquote><h2 id=docker-v19-03-6-rc2-发布>Docker v19.03.6-rc2 发布</h2><p>自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。</p><p>v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：</p><ul><li>buildkit: 修复了在触发 <code>ONBUILD</code> 规则之后，未清理掉 <code>ONBUILD</code> 规则的问题。对于依赖 <code>ONBUILD</code> 指令，且使用 buildkit 的用户而言是个重要修复；</li><li>buildkit: 修复了启用了 userns 时，可能导致权限错误的问题；</li><li><strong>使用了 libnetwork 的短 ID, 以避免遇到 <code>UNIX_PATH_MAX</code> 的错误</strong>;</li></ul><p>说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 <code>UNIX_PATH_MAX</code> 的问题上稍微多聊一点。</p><p>这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？</p><p>其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下如何目前的限制是什么，这个限制可以在 <a href=https://github.com/torvalds/linux.git>Linux 的源码</a>中找到的。</p><pre><code class=language-c>// include/uapi/linux/un.h
#ifndef _LINUX_UN_H
#define _LINUX_UN_H

#include &lt;linux/socket.h&gt;

#define UNIX_PATH_MAX	108

struct sockaddr_un {
	__kernel_sa_family_t sun_family; /* AF_UNIX */
	char sun_path[UNIX_PATH_MAX];	/* pathname */
};

#define SIOCUNIXFILE (SIOCPROTOPRIVATE + 0) /* open a socket file with O_PATH */

#endif /* _LINUX_UN_H */
</code></pre><p>可以看到现在头文件中定义的是 <code>108</code> 。（ <strong>注意我此处使用的是 Linux 5.4 版本的内核</strong> ）</p><p>另外，这个头文件定义在 <code>include/uapi/linux/un.h</code> 这个 <code>uapi</code> 目录可能有些人会觉得陌生，其实它是在 Linux 3.x 新增的，其中包含的内容基本就是原本散落在各处的头文件。这也是为了解决 Linux 中循环引用的问题。</p><p>有点跑题了，回到 Docker v19.03.6 版本上，如果你对此版本有所期待，可以抢先尝试下当前的 rc 版。如果追求稳定，可以再稍微等几天，等正式版本发布（大概在两周内）。</p><p>此处破例推荐下我的专栏 <a href=https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f>《Docker 核心知识必知必会》</a>，当前内容已经更新了一半以上，以 Docker 的最新版本为基础，对比旧版本及 Docker 上游发展的差异，并对每个核心知识点进行由浅入深、从实践到内部原理的讲解，其中也包含了一些 Linux 内核相关的知识。感谢订阅。</p><h2 id=containerd-v1-3-3-发布>containerd v1.3.3 发布</h2><p>本周 containerd v1.3.3 发布，带来了一些重要的修复和更新：</p><ul><li>runtime v2 方面，将 runc shim 中 <code>platform</code> 的关闭流程移到了 <code>Shutdown</code> 方法中，这样可以确保 <code>platform</code> 只关闭一次；</li><li><strong>修复了一个 containerd v1.3.0+ 版本及以上 exec 时存在的 eventfd 泄漏的 bug ；</strong></li></ul><p>另外，本周 <strong>containerd 也发布了 v1.2.12 版本</strong> 。</p><p>这两个版本中均包含了一系列重要的安全更新 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19921">CVE-2019-19921</a> 、<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16884">CVE-2019-16884</a> 和 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0601">CVE-2020-0601</a></p><p>建议，如果有在使用 containerd 的朋友请尽早更新。这两个版本更详细的变更，请参考 <a href=https://github.com/containerd/containerd/releases/tag/v1.2.12>containerd v1.2.12 的 ReleaseNote</a> 和 <a href=https://github.com/containerd/containerd/releases/tag/v1.3.3>containerd v1.3.3 的 ReleaseNote</a></p><h2 id=cncf-发布了-containerd-项目的旅程报告>CNCF 发布了 containerd 项目的旅程报告</h2><p>CNCF 对 containerd 自创建到毕业后项目的活跃度及社区发展等维度进行了调研，并给出了相应的报告。</p><p>整体来看，containerd 自打从 Docker 中诞生开始，截至目前项目及社区发展都挺不错。</p><p>对此报告感兴趣的朋友可以参考 <a href=https://www.cncf.io/cncf-containerd-project-journey/>CNCF 的报告: CNCF containerd Project Journey Report</a> 。</p><h2 id=docker-将关闭旧的-apt-和-yum-仓库>Docker 将关闭旧的 APT 和 YUM 仓库</h2><p>Docker project 于 2013 年在 PyCon 上首次正式亮相，并逐步成长为社区项目，所以当时就注册了 <code>dockerproject.org</code> 和 <code>dockerproject.com</code> 的域名，并且后来在这两个域名之下托管了 APT 和 YUM 仓库。</p><p>后期随着 Docker Inc. 的成立，为了更好的专注于 Docker 的产品 （CE 和 EE），所以就注册了 <code>docker.com</code> 的域名。并且正式将 APT 和 YUM 仓库托管到了 <a href=https://download.docker.com/><code>download.docker.com</code></a>。</p><p>现在几乎所有人都已经在使用新的 <code>download.docker.com</code> 的仓库了（如果你还没有使用，请尽快更新）。</p><p>重点： <strong>Docker Inc 计划在 2020 年 3 月 31 日停止老旧的 <code>dockerproject.org</code> 和 <code>dockerproject.com</code> 域名下托管的 APT 和 YUM 仓库了！</strong></p><p>请大家尽早<a href=https://docs.docker.com/install/>按 Docker 官方文档中的安装说明</a> 安装 Docker，并停止使用老旧的仓库域名。</p><h2 id=上游进展>上游进展</h2><p><code>kubectl run</code> 想必大家都不陌生吧，可以用它来手动创建各种资源。</p><p><strong>在 Kubernetes v1.18 中，会将之前已标注过期的各类 generator 都移除掉。</strong> 也就是说，自 v1.18 起使用 <code>kubectl run</code> 命令主要就是创建 Pod 了，而不会创建多余的 deploy 之类的。</p><p>至于像 <code>service</code> 加了 <code>--expose</code> 倒也还可以创建，只不过类似 <code>--service-generator</code> 这类参数就也都标记废弃了。</p><p>v1.18 之前版本的执行结果是这样：</p><pre><code>(MoeLove) ➜  ~ kubectl run redis --image=&quot;redis:alpine&quot;
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/redis created
(MoeLove) ➜  ~ kubectl get all -l run=redis
NAME                         READY   STATUS    RESTARTS   AGE
pod/redis-8544698fd7-tvz5q   1/1     Running   0          14s

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/redis   1/1     1            1           14s

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/redis-8544698fd7   1         1         1       14s
</code></pre><p>v1.18 版本：</p><pre><code>(MoeLove) ➜  bin ./kubectl run redis-new --image=&quot;redis:alpine&quot;
pod/redis-new created
(MoeLove) ➜  bin ./kubectl get all -l run=redis-new
NAME            READY   STATUS    RESTARTS   AGE
pod/redis-new   1/1     Running   0          12s
</code></pre><h2 id=题外话>题外话</h2><p>还是那句老话，注意勤洗手，多喝水，注意休息，照顾好家人。</p><p>在家宅着也别忘记学习，再次推荐我的专栏 <a href=https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f>《Docker 核心知识必知必会》</a></p><hr><p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。</p><p><img src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg alt=TheMoeLove></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>TaoBeier</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-02-09</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>CC BY-SA 4.0</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/wx_pay.jpg>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/alipay.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/linux/>Linux</a>
<a href=/tags/weekly/>Weekly</a>
<a href=/tags/kubernetes/>Kubernetes</a></div><nav class=post-nav><a class=next href=/2020/02/05/%E4%BD%BF%E7%94%A8-Kind-%E5%9C%A8%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA-K8S-%E9%9B%86%E7%BE%A4/><span class="next-text nav-default">使用 Kind 在离线环境创建 K8S 集群</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=/lib/gitalk/gitalk-1.5.2.min.css><script src=/lib/gitalk/gitalk-1.5.2.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:'2020-02-09 17:14:37 \x2b0800 CST',title:'K8S 生态周报| Docker v19.03.6-rc2 发布',clientID:'68312db64e870efbd0a0',clientSecret:'a062c51a15de76546aa52351e0dd5b3cfb0cc7d8',repo:'tao12345666333.github.io',owner:'tao12345666333',admin:['tao12345666333'],body:decodeURI(location.href)});gitalk.render('gitalk-container');</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:zhangjintao9020@gmail.com class="iconfont icon-email" title=email></a><a href=https://twitter.com/BeierTao class="iconfont icon-twitter" title=twitter></a><a href=https://github.com/tao12345666333 class="iconfont icon-github" title=github></a><a href=http://weibo.com/9020taobeier class="iconfont icon-weibo" title=weibo></a><a href=https://www.zhihu.com/people/TaoBeier class="iconfont icon-zhihu" title=zhihu></a><a href=https://moelove.info/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2013 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>TaoBeier</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/lib/fancybox/jquery.fancybox-3.1.20.min.js></script><script type=text/javascript src="/dist/even.min.js?v=3.2.0"></script></body></html>