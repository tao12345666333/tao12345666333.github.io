<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>runc 1.0-rc7 发布之际 - MoeLove</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-1876963677156202",enable_page_level_ads:true});</script><meta name=author content="张晋涛"><meta name=description content="在 18 年 11 月底时，我写了一篇文章 《runc 1.0-rc6 发布之际》 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。
在 runc 1.0-rc6 发布之时，给版本的别名为 &amp;ldquo;For Real This Time&amp;rdquo;，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：
 不够规范； 发布周期不明确;  为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 runc 1.0-rc6。
为何有 runc 1.0-rc7 存在 前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？
CVE-2019-5736 我们首先要介绍今年 runc 的一个提权漏洞 CVE-2019-5736 。
2019 年 2 月 11 日在oss-security 邮件组正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。
简单补充下可能被攻击的方式：
 运行恶意的 Docker 镜像 在主机上执行 docker exec 进入容器内  关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 《基于 GitLab 的 CI 实践》 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。"><meta name=keywords content="MoeLove,Linux,Docker,Kubernetes,Golang,Python,Container,Vim,容器,k8s"><meta name=baidu-site-verification content="jO2rMlnjJi"><meta name=google-site-verification content="googlefe3fc086c62f7210.html"><meta name=generator content="Hugo 0.59.1"><link rel=canonical href=https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href="/dist/even.min.css?v=3.2.0" rel=stylesheet><link href=/lib/fancybox/jquery.fancybox-3.1.20.min.css rel=stylesheet><meta property="og:title" content="runc 1.0-rc7 发布之际"><meta property="og:description" content="在 18 年 11 月底时，我写了一篇文章 《runc 1.0-rc6 发布之际》 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。
在 runc 1.0-rc6 发布之时，给版本的别名为 &ldquo;For Real This Time&rdquo;，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：
 不够规范； 发布周期不明确;  为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 runc 1.0-rc6。
为何有 runc 1.0-rc7 存在 前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？
CVE-2019-5736 我们首先要介绍今年 runc 的一个提权漏洞 CVE-2019-5736 。
2019 年 2 月 11 日在oss-security 邮件组正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。
简单补充下可能被攻击的方式：
 运行恶意的 Docker 镜像 在主机上执行 docker exec 进入容器内  关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 《基于 GitLab 的 CI 实践》 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。"><meta property="og:type" content="article"><meta property="og:url" content="https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/"><meta property="article:published_time" content="2019-03-29T10:42:25+08:00"><meta property="article:modified_time" content="2019-03-29T10:42:25+08:00"><meta itemprop=name content="runc 1.0-rc7 发布之际"><meta itemprop=description content="在 18 年 11 月底时，我写了一篇文章 《runc 1.0-rc6 发布之际》 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。
在 runc 1.0-rc6 发布之时，给版本的别名为 &ldquo;For Real This Time&rdquo;，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：
 不够规范； 发布周期不明确;  为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 runc 1.0-rc6。
为何有 runc 1.0-rc7 存在 前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？
CVE-2019-5736 我们首先要介绍今年 runc 的一个提权漏洞 CVE-2019-5736 。
2019 年 2 月 11 日在oss-security 邮件组正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。
简单补充下可能被攻击的方式：
 运行恶意的 Docker 镜像 在主机上执行 docker exec 进入容器内  关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 《基于 GitLab 的 CI 实践》 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。"><meta itemprop=datePublished content="2019-03-29T10:42:25+08:00"><meta itemprop=dateModified content="2019-03-29T10:42:25+08:00"><meta itemprop=wordCount content="543"><meta itemprop=keywords content="Linux,Docker,Container,runc,"><meta name=twitter:card content="summary"><meta name=twitter:title content="runc 1.0-rc7 发布之际"><meta name=twitter:description content="在 18 年 11 月底时，我写了一篇文章 《runc 1.0-rc6 发布之际》 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。
在 runc 1.0-rc6 发布之时，给版本的别名为 &ldquo;For Real This Time&rdquo;，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：
 不够规范； 发布周期不明确;  为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 runc 1.0-rc6。
为何有 runc 1.0-rc7 存在 前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？
CVE-2019-5736 我们首先要介绍今年 runc 的一个提权漏洞 CVE-2019-5736 。
2019 年 2 月 11 日在oss-security 邮件组正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。
简单补充下可能被攻击的方式：
 运行恶意的 Docker 镜像 在主机上执行 docker exec 进入容器内  关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 《基于 GitLab 的 CI 实践》 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>MoeLove</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/about/><li class=mobile-menu-item>About</li></a><a href=/friends/><li class=mobile-menu-item>Friends</li></a><a href=/projects/><li class=mobile-menu-item>Projects</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>MoeLove</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/about/>About</a></li><li class=menu-item><a class=menu-item-link href=/friends/>Friends</a></li><li class=menu-item><a class=menu-item-link href=/projects/>Projects</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>runc 1.0-rc7 发布之际</h1><div class=post-meta><span class=post-time>2019-03-29</span><div class=post-category><a href=/categories/linux/>Linux</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#为何有-runc-1-0-rc7-存在>为何有 <code>runc 1.0-rc7</code> 存在</a><ul><li><a href=#cve-2019-5736>CVE-2019-5736</a></li><li><a href=#修复方式>修复方式</a></li><li><a href=#影响>影响</a><ul><li><a href=#内核相关>内核相关</a></li><li><a href=#内存相关>内存相关</a></li><li><a href=#其他>其他</a></li></ul></li></ul></li><li><a href=#等待-rc8-发布>等待 rc8 发布</a></li></ul></li></ul></nav></div></div><div class=post-content><p>在 18 年 11 月底时，我写了一篇文章 <a href=https://moelove.info/2018/11/23/runc-1.0-rc6-发布之际/>《runc 1.0-rc6 发布之际》</a> 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。</p><p>在 runc 1.0-rc6 发布之时，给版本的别名为 <strong>&ldquo;For Real This Time&rdquo;</strong>，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：</p><ul><li>不够规范；</li><li>发布周期不明确;</li></ul><p>为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 <code>runc 1.0-rc6</code>。</p><h2 id=为何有-runc-1-0-rc7-存在>为何有 <code>runc 1.0-rc7</code> 存在</h2><p>前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？</p><h3 id=cve-2019-5736>CVE-2019-5736</h3><p>我们首先要介绍今年 runc 的一个提权漏洞 <strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5736"><code>CVE-2019-5736</code></a></strong> 。</p><p>2019 年 2 月 11 日在<a href=https://seclists.org/oss-sec/2019/q1/119> oss-security 邮件组</a>正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。</p><p>简单补充下可能被攻击的方式：</p><ul><li>运行恶意的 Docker 镜像</li><li>在主机上执行 <code>docker exec</code> 进入容器内</li></ul><p>关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 <a href=https://moelove.info/2018/08/05/基于-GitLab-的-CI-实践/#详解-docker-in-docker>《基于 GitLab 的 CI 实践》</a> 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。</p><p>不过本文主要看的是 runc 如何修复该漏洞的，以及后续产生的影响。</p><h3 id=修复方式>修复方式</h3><pre><code class=language-c>// 对 memfd_create 系统调用做了个封装 省略部分代码
#if !defined(SYS_memfd_create) &amp;&amp; defined(__NR_memfd_create)
#  define SYS_memfd_create __NR_memfd_create
#endif
#ifdef SYS_memfd_create
#  define HAVE_MEMFD_CREATE
#  ifndef MFD_CLOEXEC
#    define MFD_CLOEXEC       0x0001U
#    define MFD_ALLOW_SEALING 0x0002U
#  endif
int memfd_create(const char *name, unsigned int flags)
{
	return syscall(SYS_memfd_create, name, flags);
}

// 一个简单的只读缓存区
static char *read_file(char *path, size_t *length)
{
	int fd;
	char buf[4096], *copy = NULL;

	if (!length)
		return NULL;

	fd = open(path, O_RDONLY | O_CLOEXEC);
	if (fd &lt; 0)
		return NULL;

	*length = 0;
	for (;;) {
		int n;

		n = read(fd, buf, sizeof(buf));
		if (n &lt; 0)
			goto error;
		if (!n)
			break;

		copy = must_realloc(copy, (*length + n) * sizeof(*copy));
		memcpy(copy + *length, buf, n);
		*length += n;
	}
	close(fd);
	return copy;

error:
	close(fd);
	free(copy);
	return NULL;
}

// 将复制后的 fd 重赋值/执行
static int clone_binary(void)
{
	int binfd, memfd;
	ssize_t sent = 0;

#ifdef HAVE_MEMFD_CREATE
	memfd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
#else
	memfd = open(&quot;/tmp&quot;, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0711);
#endif
	if (memfd &lt; 0)
		return -ENOTRECOVERABLE;

	binfd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
	if (binfd &lt; 0)
		goto error;

	sent = sendfile(memfd, binfd, NULL, RUNC_SENDFILE_MAX);
	close(binfd);
	if (sent &lt; 0)
		goto error;

#ifdef HAVE_MEMFD_CREATE
	int err = fcntl(memfd, F_ADD_SEALS, RUNC_MEMFD_SEALS);
	if (err &lt; 0)
		goto error;
#else

	int newfd;
	char *fdpath = NULL;

	if (asprintf(&amp;fdpath, &quot;/proc/self/fd/%d&quot;, memfd) &lt; 0)
		goto error;
	newfd = open(fdpath, O_RDONLY | O_CLOEXEC);
	free(fdpath);
	if (newfd &lt; 0)
		goto error;

	close(memfd);
	memfd = newfd;
#endif
	return memfd;

error:
	close(memfd);
	return -EIO;
}

int ensure_cloned_binary(void)
{
	int execfd;
	char **argv = NULL, **envp = NULL;

	int cloned = is_self_cloned();
	if (cloned &gt; 0 || cloned == -ENOTRECOVERABLE)
		return cloned;

	if (fetchve(&amp;argv, &amp;envp) &lt; 0)
		return -EINVAL;

	execfd = clone_binary();
	if (execfd &lt; 0)
		return -EIO;

	fexecve(execfd, argv, envp);
	return -ENOEXEC;
}

</code></pre><p>省略掉了部分代码，完整代码可直接参考 <a href=https://github.com/opencontainers/runc>runc 代码仓库</a> 。</p><p>整个的修复逻辑我在上面的代码中加了备注，总结来讲其实就是：</p><ul><li>创建了一个只存在于内存中的 memfd ；</li><li>将原本的 runc 拷贝至这个 memfd ；</li><li>在进入 namespace 前，通过这个 memfd 重新执行 runc ; (这是为了确保之后即使被攻击/替换也操作的还是内存中的这个只读的 runc)</li></ul><p>经过以上的操作，就基本修复了 CVE-2019-5736 。</p><h3 id=影响>影响</h3><h4 id=内核相关>内核相关</h4><p>在上面讲完修复方式后，我们来看下会产生哪些影响。</p><ul><li>涉及到了系统调用 <strong><code>memfd_create(2)</code></strong> 和 <strong><code>fcntl(2)</code></strong></li></ul><p>增加了系统调用，那自然就要看内核是否支持了。实际上，这些函数是在 2015 年 2 月（距这次修复整整 4 年，也挺有趣）被加入到 Linux 3.17 内核中的。</p><p>换句话说就是 <strong>凡是在此内核版本之前的系统，均无法正常使用该功能</strong>，对我们的影响就是，<strong>如果你在此版本内核之前的机器上使用了包含上述修复代码的 runc 或构建在其之上的 containerd、 Docker 等都无法正常工作</strong> 。</p><p>以 Docker 举例：安装 docker-ce-18.09.2 或 docker-ce-18.06.3 可避免受 CVE-2019-5736 影响，但如果内核版本较低，在运行容器时可能会有如下情况出现: （不同版本/内核可能出现其他情况）</p><pre><code>[tao@moelove ~]# docker run --rm my-registry/os/debian echo Hello     
docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container
process caused &quot;process_linux.go:293: copying bootstrap data to pipe caused \&quot;write init-p: broken pipe\&quot;&quot;: unknown.
</code></pre><ul><li><p><strong>解决办法</strong></p><ul><li>升级内核；这是最直接的办法，而且使用一个新版本的内核也能省去很多不必要的麻烦:)</li><li>rancher 提供了一个 <a href=https://github.com/rancher/runc-cve>runc-cve</a> 的 patch，可兼容部分 3.x 内核的系统（我没有测试过）</li><li>如果你不升级 runc/containerd/Docker 等版本的话，那建议你 1. 将 runc 可执行程序放到只读文件系统上，可避免被覆盖；2. 启动容器时，启用 <code>SELinux</code>; 3. 在容器内使用低权限用户或者采用映射的方式，但保证用户对主机上的 runc 程序无写权限。</li></ul></li></ul><p><strong>注意</strong>:</p><p><code>memfd_create</code> 等相关系统调用，也被加入到了 Debian 3.16 和 Ubuntu 14.04 updates 中，当然也被反向移植到了 CentOS 7.3 内核 <code>3.10.0-514</code> 版本之后。 (Red Hat 给 CentOS 7.x 的 3.10 内核上反向移植了很多特性)</p><h4 id=内存相关>内存相关</h4><p>从上面的说明中，也很容易可以看到, 内存的使用上会有所增加，不过之后已做了修复。这里不再进行展开。</p><h4 id=其他>其他</h4><p>偶尔可能触发一些内核 bug 之类的（总之建议升级 :)</p><h2 id=等待-rc8-发布>等待 rc8 发布</h2><p>上面已经介绍了 1.0-rc7 出现的主要原因 CVE-2019-5736；当然这个版本中也有一些新特性和一些 bugfix 不过不是本文的主要内容，不再赘述。</p><p>值得一提的是这次的版本命名：<code>runc 1.0-rc7 -- "The Eleventh Hour"</code> 后面这个别名其实来自于一部英剧，感兴趣也可以去看看。</p><p>至于下个版本是不是会是 1.0 正式版呢？目前来看应该不是，有极大可能会发布 <code>runc 1.0-rc8</code> 做一些 bugfix，让我们拭目以待。</p><hr><p>可以通过下面二维码订阅我的文章公众号【MoeLove】</p><p><img src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg alt=TheMoeLove></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>张晋涛</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2019-03-29</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>CC BY-SA 4.0</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/wx_pay.jpg>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=https://raw.githubusercontent.com/tao12345666333/collection/master/images/alipay.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/linux/>Linux</a>
<a href=/tags/docker/>Docker</a>
<a href=/tags/container/>Container</a>
<a href=/tags/runc/>runc</a></div><nav class=post-nav><a class=prev href=/2019/03/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.03.25~2019.03.31/><i class="iconfont icon-left"></i><span class="prev-text nav-default">K8S 生态周报| 2019.03.25~2019.03.31</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/2019/03/25/%E4%BD%BF%E7%94%A8-Kind-%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0-Kubernetes-%E9%9B%86%E7%BE%A4/><span class="next-text nav-default">使用 Kind 搭建你的本地 Kubernetes 集群</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=/lib/gitalk/gitalk-1.5.2.min.css><script src=/lib/gitalk/gitalk-1.5.2.min.js></script><script type=text/javascript>var gitalk=new Gitalk({id:'2019-03-29 10:42:25 \x2b0800 CST',title:'runc 1.0-rc7 发布之际',clientID:'68312db64e870efbd0a0',clientSecret:'a062c51a15de76546aa52351e0dd5b3cfb0cc7d8',repo:'tao12345666333.github.io',owner:'tao12345666333',admin:['tao12345666333'],body:decodeURI(location.href)});gitalk.render('gitalk-container');</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:zhangjintao9020@gmail.com class="iconfont icon-email" title=email></a><a href=https://twitter.com/BeierTao class="iconfont icon-twitter" title=twitter></a><a href=https://github.com/tao12345666333 class="iconfont icon-github" title=github></a><a href=http://weibo.com/9020taobeier class="iconfont icon-weibo" title=weibo></a><a href=https://www.zhihu.com/people/TaoBeier class="iconfont icon-zhihu" title=zhihu></a><a href=https://moelove.info/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2013 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>张晋涛</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/lib/fancybox/jquery.fancybox-3.1.20.min.js></script><script type=text/javascript src="/dist/even.min.js?v=3.2.0"></script></body></html>