<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Webpack on MoeLove</title><link>https://moelove.info/tags/Webpack/</link><description>Recent content in Webpack on MoeLove</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Mon, 26 Dec 2016 00:43:02 +0000</lastBuildDate><atom:link href="https://moelove.info/tags/Webpack/index.xml" rel="self" type="application/rss+xml"/><item><title>关于 webpack 你可能忽略的细节（附源码分析）</title><link>https://moelove.info/2016/12/26/%E5%85%B3%E4%BA%8E-webpack-%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82%E9%99%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 26 Dec 2016 00:43:02 +0000</pubDate><guid>https://moelove.info/2016/12/26/%E5%85%B3%E4%BA%8E-webpack-%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82%E9%99%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>注：本篇不是入门教程，入门请直接查看官方文档。本篇的主要目标是通过实际问题来介绍 webpack 中容易被人忽略的细节, 以及源码分析(以最新发布的 release 版本1.14.0的源码为例), 并且提供几种解决方案。
随着前端技术的火热发展，工程化，模块化和组件化的思想已逐步成为主流，与之相应的，就需要有一整套工具流可以支撑起它。
现在比较热门的前端资源模块化管理和打包工具应该非 Webpack 莫属了。
Webpack 是什么 它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 &amp;ndash;引自 Webpack 中文指南
使用举例 我们来看一下官方文档中的最小用例，新建并写入以下内容到这两个文件：
cats.js
var cats = [&amp;#39;dave&amp;#39;, &amp;#39;henry&amp;#39;, &amp;#39;martha&amp;#39;]; module.exports = cats; app.js (Entry Point)
cats = require(&amp;#39;./cats.js&amp;#39;); console.log(cats); 这个时候，就可以使用 webpack 进行打包了：
webpack ./app.js app.bundle.js 我们来看一下发生了什么， 目录下生成了一个打包后的文件 app.bundle.js ，这就是最基础的打包过程。
提出问题 如何判断打包是否成功？
通用方案 下面是我们常用的两种判断任务是否执行成功的方案
通过 return code 通过命令执行后的 return code 来判断（在 shell 中使用 $?</description></item></channel></rss>