<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Git workflow 详谈 - MoeLove</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-1876963677156202",
    enable_page_level_ads: true
  });
</script>


<meta name="author" content="TaoBeier" />
  <meta name="description" content="作为一名工程师， Git 在日常开发中是不可或缺的工具。 这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。
中心化工作流 使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。 而且在使用过程中还可以看到 Git 优于 SVN 的地方： 第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 add 和 commit ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。 第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。
工作细节 中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 clone 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 push 进主仓库的 master 分支即可。
在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。 所以，在提交之前要先 fetch 最新提交，在这些提交之上作出自己的更改(一般我们使用 rebase来完成)。
如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 rebase ，并让你来解决这些冲突。我们可以很简单的使用 git status 和 git add 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 git rebase --abort 很容易的退出 rebase 的过程。
这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。" />

  <meta name="keywords" content="MoeLove, Linux, Docker, Kubernetes" />


<meta name="baidu-site-verification" content="jO2rMlnjJi" />
<meta name="google-site-verification" content="googlefe3fc086c62f7210.html" />


<meta name="generator" content="Hugo 0.46" />


<link rel="canonical" href="https://moelove.info/2016/12/05/Git-workflow-%E8%AF%A6%E8%B0%88/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Git workflow 详谈" />
<meta property="og:description" content="作为一名工程师， Git 在日常开发中是不可或缺的工具。 这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。
中心化工作流 使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。 而且在使用过程中还可以看到 Git 优于 SVN 的地方： 第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 add 和 commit ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。 第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。
工作细节 中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 clone 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 push 进主仓库的 master 分支即可。
在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。 所以，在提交之前要先 fetch 最新提交，在这些提交之上作出自己的更改(一般我们使用 rebase来完成)。
如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 rebase ，并让你来解决这些冲突。我们可以很简单的使用 git status 和 git add 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 git rebase --abort 很容易的退出 rebase 的过程。
这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://moelove.info/2016/12/05/Git-workflow-%E8%AF%A6%E8%B0%88/" />



<meta property="article:published_time" content="2016-12-05T22:40:41&#43;00:00"/>

<meta property="article:modified_time" content="2016-12-05T22:40:41&#43;00:00"/>











<meta itemprop="name" content="Git workflow 详谈">
<meta itemprop="description" content="作为一名工程师， Git 在日常开发中是不可或缺的工具。 这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。
中心化工作流 使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。 而且在使用过程中还可以看到 Git 优于 SVN 的地方： 第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 add 和 commit ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。 第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。
工作细节 中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 clone 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 push 进主仓库的 master 分支即可。
在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。 所以，在提交之前要先 fetch 最新提交，在这些提交之上作出自己的更改(一般我们使用 rebase来完成)。
如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 rebase ，并让你来解决这些冲突。我们可以很简单的使用 git status 和 git add 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 git rebase --abort 很容易的退出 rebase 的过程。
这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。">


<meta itemprop="datePublished" content="2016-12-05T22:40:41&#43;00:00" />
<meta itemprop="dateModified" content="2016-12-05T22:40:41&#43;00:00" />
<meta itemprop="wordCount" content="333">



<meta itemprop="keywords" content="Git,Tool," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Git workflow 详谈"/>
<meta name="twitter:description" content="作为一名工程师， Git 在日常开发中是不可或缺的工具。 这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。
中心化工作流 使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。 而且在使用过程中还可以看到 Git 优于 SVN 的地方： 第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 add 和 commit ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。 第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。
工作细节 中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 clone 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 push 进主仓库的 master 分支即可。
在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。 所以，在提交之前要先 fetch 最新提交，在这些提交之上作出自己的更改(一般我们使用 rebase来完成)。
如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 rebase ，并让你来解决这些冲突。我们可以很简单的使用 git status 和 git add 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 git rebase --abort 很容易的退出 rebase 的过程。
这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">MoeLove</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/friends/">
        <li class="mobile-menu-item">Friends</li>
      </a><a href="/projects/">
        <li class="mobile-menu-item">Projects</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">MoeLove</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friends/">Friends</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/projects/">Projects</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Git workflow 详谈</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-12-05 </span>
        <div class="post-category">
            
              <a href="/categories/linux/"> Linux </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#中心化工作流">中心化工作流</a>
<ul>
<li><a href="#工作细节">工作细节</a></li>
<li><a href="#示例">示例</a></li>
</ul></li>
<li><a href="#特性分支工作流">特性分支工作流</a>
<ul>
<li><a href="#工作细节-1">工作细节</a></li>
</ul></li>
<li><a href="#gitflow-工作流">Gitflow 工作流</a></li>
<li><a href="#fork-工作流">fork 工作流</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<p>作为一名工程师， <code>Git</code> 在日常开发中是不可或缺的工具。
这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。</p>

<h1 id="中心化工作流">中心化工作流</h1>

<p>使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。  而且在使用过程中还可以看到 Git 优于 SVN 的地方：
第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 <code>add</code> 和 <code>commit</code> ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。
第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。</p>

<h2 id="工作细节">工作细节</h2>

<p>中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 <code>clone</code> 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 <code>push</code> 进主仓库的 master 分支即可。</p>

<p>在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。  所以，在提交之前要先 <code>fetch</code> 最新提交，在这些提交之上作出自己的更改(一般我们使用 <code>rebase</code>来完成)。</p>

<p>如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 <code>rebase</code> ，并让你来解决这些冲突。我们可以很简单的使用 <code>git status</code> 和 <code>git add</code> 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 <code>git rebase --abort</code> 很容易的退出 <code>rebase</code> 的过程。</p>

<p>这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。</p>

<h2 id="示例">示例</h2>

<p>我们有两位程序员, A 和 B, 两人同时在对一个项目做开发, 并且使用 Git 的中心化工作流方式。</p>

<p><strong>1.创建远端中心仓库</strong></p>

<p>这里我们有两种方式：</p>

<ul>
<li><p>借助于已经搭建好的平台 GitHub/GitLab 之类的，点击 <code>create repo</code> 即可。</p></li>

<li><p>在远端(这里只是为了区别本地仓库，事实上，使用任何一个其他人可以连通的机器都可以,包括自己本地其他目录) 创建一个 <strong>裸仓库</strong> ，创建裸仓库和我们平时创建本地仓库的区别，可以参考我另一篇文章 <a href="http://www.jianshu.com/p/9a4e8750aea6">Git 本地仓库和裸仓库</a> 。</p></li>
</ul>

<p>这里以第二种方式为例：</p>

<pre><code class="language-bash"># --bare 参数必须有
git init --bare /the/repo/path.git
</code></pre>

<p><strong>2.所有人都 clone 中心仓库到本地作为本地仓库</strong></p>

<pre><code class="language-bash">git clone /the/repo/path.git
</code></pre>

<p>注意仓库地址必须是正确的， 且有权限访问才能 <code>clone</code> 成功。</p>

<p><strong>3.程序员 A 在他的本地仓库进行功能开发并进行发布</strong></p>

<p>一般情况下，我们通过 <code>git status</code> 看看当前状态，并通过 <code>git add</code> 和 <code>git commit</code> 等命令完成本地仓库的提交。 当然这个提交影响的也只是本地仓库而已，并没有对中心仓库产生任何影响，所以我们既不需要关心别人有什么提交，也不用担心我们当前的提交是否对别人造成了影响。当 A 认为自己所开发的功能已经完成， 那他将执行 <code>git push origin master</code> 这样的操作，将自己本地仓库所有不存在于中心仓库的提交都 <code>push</code> 到远端的中心仓库上。</p>

<p><strong>4.程序员 B 在他本地仓库进行功能开发</strong></p>

<p>B 在 <code>clone</code> 中心仓库后所做的操作和 A 一样，在本地仓库进行项目开发，并在本地仓库进行提交，他不需要知道中心仓库发生了什么样的变化。</p>

<p><strong>5.程序员 B 将自己开发的功能并进行发布</strong></p>

<p>B 在确认自己开发的功能已经完成后，想要将自己的代码通过 <code>git push origin master</code> 这样的操作发布至中心仓库，但是却被中心仓库提示他的修改已经和中心仓库有了分叉， 需要他先执行 <code>git pull</code> 之类的操作， 将中心仓库上 A 的提交与 B 本地的提交进行合并才允许他并入中心仓库。所以，他执行了 <code>git pull --rebase origin master</code> 来将中心仓库的修改并入他的本地仓库。使用 <code>--rebase</code> 参数的意义在于 <code>fetch</code> 执行完成后，将把 B 的所有提交移至 <code>master</code> 顶端。</p>

<p>当然这里不使用 <code>--rebase</code> 参数也会成功，只不过是会生成一个合并提交，有些情况下使用 <code>--ff</code> 参数也可以避免产生合并提交。在这里使用 <code>--rebase</code> 只是一个建议操作。</p>

<p>如果 A 和 B 修改的文件没有关联，一般情况下会直接完成合并，如果发生冲突，Git 将会暂停 <code>rebase</code> 的过程，并列出当前冲突的文件，你可以简单的使用 <code>git status</code> 和 <code>git add</code> 等命令进行合并，合并后使用 <code>git rebase --continue</code> 继续 rebase 的过程。或者使用 <code>git rebase --abort</code> 退出 rebase 过程。</p>

<p>在 B 合并完成后，可以执行 <code>git push origin master</code> 将自己开发的功能发布至中心仓库。</p>

<p>至此，基础的中心化工作流方式就介绍完了，但是这里也很容易看出来其中的问题，除了前面说到过的以外，还有就是效率低下，如果很多人都在持续进行提交，那很影响新功能的提交（多人持续性进行提交）。 一个比较容易提升效率的方式就是切换到<strong>特性分支工作流</strong>的方式。</p>

<h1 id="特性分支工作流">特性分支工作流</h1>

<p>基于特性的分支工作流，可以为每个特性做隔离，避免对中心仓库主干代码造成影响。</p>

<h2 id="工作细节-1">工作细节</h2>

<p>顾名思义， 就是根据每个特性都会开一个新的分支，每个分支都应该包含着描述性的名称，无论是一个人开发，还是多人协同，该特性的全部开发工作都在这个分支上进行。待该特性开发完成后， 并入主分支，然后删除分支，代码上线。</p>

<p>这种情况下， 最大的优势在于， 所有的特性开发都可以并行处理。 不必要像中心化工作流方式， 每个人的变动都可能引起其他的人的代码合并， 并且所有功能都杂糅在一起， 从测试和回滚都会变得很繁琐。 另外的一个好处就是特性分支可以推送到中心仓库，这样也便于单独测试。</p>

<p>这里需要注意的是，特性分支往主分支合并的时机，应该是该特性开发完成，并测试通过，避免对主干代码造成污染。</p>

<p>在进行分支隔离后，我们发现，我们当前只处理了开发模式，但并没有涵盖一个很完备的产品生命周期， 开发、发布、维护等过程，所以，我们有了 Gitflow 工作流。</p>

<h1 id="gitflow-工作流">Gitflow 工作流</h1>

<p>基于Gitflow 的工作流方式， 这种工作流方式， 主要是管理着新功能开发，发布及维护等模式，根据不同类型的工作对分支进行定义， 分为 <strong>特性分支</strong> ，<strong>修复分支</strong>，<strong>release 分支</strong>，<strong>开发分支</strong> 和 <strong>主分支</strong> 。</p>

<p>主分支：中心仓库建立后的默认 master 分支（当然使用其他分支也可以，但要保证该分支是受保护的）。主分支随时保持代码是稳定的，并且有明确的版本标签，后续代码回滚等操作都将从主分支进行。</p>

<p>开发分支：中心仓库建立后，从 master 分支切出来，此时与 master 分支保持一致。后续演进中，开发分支随时保持代码最新，但却不一定是线上实际运行的代码。</p>

<pre><code class="language-bash">git checkout -b develop
</code></pre>

<p>特性分支：应该从开发分支切出，开发完成后， 再合并进入开发分支， 如果达到了发布标准， 则从开发分支切出 release 分支， 切出来的这个分支，只做该版本内的代码修复， 不再加入新功能， 这时此分支处于锁定的状态。</p>

<p>修复分支， 用于对线上主分支代码的及时修复， 待修复完成后， 合并进入主分支， 再并入开发分支。  修复分支只能从主分支切出。</p>

<p>发版分支， 一般命名为 <code>release-xxx</code> 这个分支只能从开发分支切出， 最后并入主分支，打上版本号的标签，它也应该并入开发分支，如果中间有其他修复的话。</p>

<h1 id="fork-工作流">fork 工作流</h1>

<p>fork 分支流和上面介绍的所有工作流都不太一样。它的上游有一个唯一仓库， 所有人都是 fork 这个仓库， 在自己的远端和自己的本地各维护一个仓库，待开发完成后推入自己的远端仓库，并结合 GitHub/GitLab等提交 Pull Request，进入了 review 阶段，待通过后，将会被合并入上游唯一的仓库。这种方式比较适合 GitHub 中的大型开源项目， 对于小团队的内部项目， 这种方式可能未必合适。
而且 fork 工作流， 会占用更多的资源（毕竟每个人都维护一份远端仓库）。 而且每个人都看不到其他人的动态，只有当提交 Pull Request 的时候， 才知道每个人发生了什么。</p>

<h1 id="总结">总结</h1>

<p>我个人比较推荐的是 Gitflow 的开发工作流， 这种方式下，一切都是可控的， 每个分支都有各自独立的功能，目的性很明确， 同时，在做代码回滚之类的操作也是可以直接剔除。 另外， 在这种工作流方式下， 团队中的每个人都能很轻易的知道其他人在做什么， 做出了什么样的改变， 对于团队协作， 或许更加合适。</p>

<p>当然所有的工作流并不一定能完全套用， 可以吸取一些规范， 合并入自己的日常工作， 将代码仓库的合作流程标准化和规范化， 这也是一切自动化的基础。</p>

<p>&lt;全文完&gt;</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">TaoBeier</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2016-12-05</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/wx_pay.jpg">
        <span>微信打赏</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/git/">Git</a>
          
          <a href="/tags/tool/">Tool</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2016/12/16/Composer-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AE%80%E8%BF%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Composer 使用技巧简述</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/">
            <span class="next-text nav-default">Git 本地仓库和裸仓库</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="/lib/gitalk/gitalk-1.2.2.min.css">
    <script src="/lib/gitalk/gitalk-1.2.2.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    id: '2016-12-05 22:40:41 \x2b0000 UTC',
    title: 'Git workflow 详谈',
    clientID: '68312db64e870efbd0a0',
    clientSecret: 'a062c51a15de76546aa52351e0dd5b3cfb0cc7d8',
    repo: 'tao12345666333.github.io',
    owner: 'tao12345666333',
    admin: ['tao12345666333'],
    body: decodeURI(location.href)
  });
  gitalk.render('gitalk-container');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zhangjintao9020@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://plus.google.com/111099802544541897352" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/tao12345666333" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/9020taobeier" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/TaoBeier" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://moelove.info/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2013 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">TaoBeier</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
