<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">MoeLove</title><subtitle type="html">Jintao Zhang's Blog MoeLove. Container, Docker, Go, Kubernetes, Python, Vim.</subtitle><updated>2022-10-24T08:32:17+08:00</updated><id>https://moelove.info/</id><link rel="alternate" type="text/html" href="https://moelove.info/"/><link rel="self" type="application/atom+xml" href="https://moelove.info/atom.xml"/><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.84.0-DEV">Hugo</generator><entry><title type="text">K8S 生态周报| Lima 已正式加入 CNCF</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/10/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Lima-%E5%B7%B2%E6%AD%A3%E5%BC%8F%E5%8A%A0%E5%85%A5-CNCF/"/><id>https://moelove.info/2022/10/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Lima-%E5%B7%B2%E6%AD%A3%E5%BC%8F%E5%8A%A0%E5%85%A5-CNCF/</id><updated>2022-10-24T06:12:17+08:00</updated><published>2022-10-16T19:39:07+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>上周太忙，缺席了一周。本周继续更新。&lt;/p>
&lt;h1 id="cert-manager-成为-cncf-孵化级项目">cert-manager 成为 CNCF 孵化级项目&lt;/h1>
&lt;p>本周我花时间写了篇文章，介绍 &lt;a href="https://github.com/cert-manager/cert-manager">cert-manager&lt;/a> 如何通过 &lt;a href="https://www.github.com/hashicorp/vault">Vault&lt;/a> 进行证书签发，
并且在 &lt;a href="https://github.com/apache/apisix-ingress-controller/">Apache APISIX Ingress controller&lt;/a> 中配合使用，为部署在 Kubernetes 中的服务提供 TLS 代理。（这篇文章过几天会发布出来）&lt;/p>
&lt;p>写文章的时候 cert-manager 还是 CNCF sandbox 级别的项目，写完它就已经成为 CNCF incubating 级别的项目了。&lt;/p>
&lt;p>cert-manager 可以说是当前云原生场景下，证书管理方面应用最多的软件了。它除了可用于证书管理，还可以与多种服务集成，进行证书的签发和续期。
并且它还积极的融入到了很多项目的生态中，比如和各类 Ingress controller 项目的集成，和服务网格相关的项目进行整合等。&lt;/p>
&lt;p>目前该项目已经有 9.4k star ,300 名贡献者。&lt;/p>
&lt;p>本次成为 CNCF incubating 级别的项目，是个里程碑，希望它继续扩展生态。&lt;/p>
&lt;p>(而且我想起来我草稿箱里还有一篇未完成的关于 cert-manager 的文章，过段时间抽空完成后再发出来)&lt;/p>
&lt;h1 id="nerdctl-正式发布-v10">nerdctl 正式发布 v1.0&lt;/h1>
&lt;p>去年在我为大家介绍 &lt;a href="https://moelove.info/2021/09/05/%E8%AF%91LimaDocker-Desktop-for-Mac-%E7%9A%84%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E4%B8%94%E8%87%AA%E7%94%B1%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/">Docker Desktop 的替代品 Lima 的文章&lt;/a>中，曾为大家介绍过 &lt;a href="https://github.com/containerd/nerdctl" title="nerdctl">nerdctl&lt;/a> 。&lt;/p>
&lt;p>nerdctl 出现的原因是由于 &lt;a href="https://containerd.io/scope/" title="containerd 项目的核心目标">containerd 项目的核心范围仅限于非面向用户的区域&lt;/a>，因此用户很难直接与 containerd 进行交互。&lt;/p>
&lt;p>nerdctl 的功能和用法几乎与 Docker CLI 相同，但是 nerdctl 还支持 Docker 中不存在的几个 containerd 的前沿功能。此类功能包括但不限于 &lt;a href="https://github.com/containerd/nerdctl/blob/master/docs/stargz.md">延迟拉取(stargz)&lt;/a> 和 &lt;a href="https://github.com/containerd/nerdctl/blob/master/docs/ocicrypt.md">运行加密镜像（ocicrypt）&lt;/a>等。&lt;/p>
&lt;p>到目前为止，nerdctl 已经开发了将近 2 年的时间，有超过 80 个贡献者和 4600 star ，以及大量的用户。这里我主要介绍几个 nerdctl 的重要阶段：&lt;/p>
&lt;ul>
&lt;li>v0.3 (2020 年 12 月): &lt;code>nerdctl run --publish=&amp;lt;PORT&amp;gt;&lt;/code>&lt;/li>
&lt;li>v0.8 (2021 年 4 月): &lt;code>nerdctl compose up&lt;/code> 支持 compose&lt;/li>
&lt;li>v0.9 (2021 年 6 月): &lt;code>nerdctl run --gpus=&amp;lt;GPU&amp;gt;&lt;/code> 支持 GPU&lt;/li>
&lt;li>v0.13 (2021 年 11 月): &lt;code>nerdctl run --platform=&amp;lt;PLATFORM&amp;gt;&lt;/code> 支持多平台&lt;/li>
&lt;li>v0.19 (2022 年 4 月): &lt;code>nerdctl cp&lt;/code> 支持文件复制&lt;/li>
&lt;li>v0.22 (2022 年 7 月): &lt;code>nerdctl system prune&lt;/code> 允许清理未使用的数据&lt;/li>
&lt;/ul>
&lt;p>到目前为止，nerdctl 已经实现了所有除了 &lt;code>swarm&lt;/code> 相关的 Docker CLI 的命令，也额外实现了类似 &lt;code>nerdctl diff&lt;/code> 之类的命令。&lt;/p>
&lt;p>近期 nerdctl 有很多新的特性，比如：&lt;/p>
&lt;ul>
&lt;li>增加了多种日志驱动：&lt;code>journald&lt;/code> , &lt;code>fluentd&lt;/code>, &lt;code>syslog&lt;/code> 和外部驱动；&lt;/li>
&lt;li>除了默认的 &lt;code>bridge&lt;/code> CNI 外，还支持了 &lt;code>macvlan&lt;/code> 和 &lt;code>ipvlan&lt;/code> 网络驱动；&lt;/li>
&lt;li>支持了多种清理命令， &lt;code>nerdctl (container|image|volume|network|system) prune&lt;/code>；&lt;/li>
&lt;/ul>
&lt;p>目前 containerd 正在被越来越多的 Kubernetes 集群使用，所以一个好用的 CLI 也非常的重要。
不出意外的话，以后 nerdctl 的用户应该会变的更多，期待它发展的更好。&lt;/p>
&lt;p>此外另一个很重要的事情是： Lima 已经正式加入 CNCF 成为 Sandbox 级别的项目。
Lima 实际运行的就是 &lt;code>containerd&lt;/code> 和 &lt;code>nerdctl&lt;/code> ，这样也会加速 nerdctl 的发展。&lt;/p>
&lt;h1 id="docker-v201020-发布">Docker v20.10.20 发布&lt;/h1>
&lt;p>Docker 最近相继发布了 v20.10.19 和 v20.10.20，主要是一些 bugfix 和安全修复。这里我主要介绍一个比较有意思的 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-39253">CVE-2022-39253&lt;/a> 。&lt;/p>
&lt;h2 id="cve-2022-39253">CVE-2022-39253&lt;/h2>
&lt;p>这个漏洞其实和 Docker 没有直接的关系。这个漏洞是 Git 的。&lt;/p>
&lt;p>之所以在这里聊是因为 Docker 中进行 &lt;code>docker build&lt;/code> 时，可以直接指向 Git 仓库进行构建。
在构建过程中，实际上会先将 Git 仓库拉入到本地的临时目录，并作为构建上下文传递给 Docker daemon 。&lt;/p>
&lt;p>而且可以通过为指定的 Git 仓库后添加参数的方式来扩展具体构建使用的内容。比如：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/10/23/57oYBPrbIsktNyT.png" alt="2022-10-23.png">&lt;/p>
&lt;p>这次 Git 的 CVE-2022-39253 漏洞，是由于 Git 在 clone 的时候存在对本地仓库的优化，可以绕过 &amp;quot;Git aware&amp;quot; 的传输机制，然后可以通过硬链接的方式来节省空间。
但是攻击者可以通过诱导受害者在同一个机器上 clone 恶意仓库，并且利用这种硬链接的方式来将敏感信息暴露给恶意攻击者。&lt;/p>
&lt;p>具体的修复方式包括避免使用 &lt;code>--recurse-submodules&lt;/code> 和增加 &lt;code>protocol.file.allow=never&lt;/code> 参数，以此来避免受漏洞的影响。&lt;/p>
&lt;p>另外，这个漏洞也在 Git 的 2.37.4 之后的版本进行了修复。&lt;/p>
&lt;h2 id="其他修复">其他修复&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/44122">moby/moby#44122&lt;/a> 通过更新 buildkit 的依赖，修复了执行 &lt;code>docker builder prune&lt;/code> 和 &lt;code>docker system prune&lt;/code> 期间可能出现的 panic ；&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/44238">moby/moby#44238&lt;/a> 修复了一个当已经开启 &amp;quot;live restore&amp;quot; 并进行了重启，当执行 &lt;code>docker volume prune&lt;/code> 时，有可能会删掉仍然在使用的 volume ，解决办法是在 restore 的时候，先确保准备好了 volume ;&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/commit/4b9902bad44373b43f2ba55d6b587dbe8505b86f">moby/moby#4b9902b&lt;/a> 更新了 Docker daemon 在处理通过 digest pull 镜像时的处理逻辑，即使用 &lt;code>image:tag@digest&lt;/code> 的形式。原先是直接通过内容寻址的方式直接获取镜像的，并没有利用到 &lt;code>tag&lt;/code> 和 &lt;code>digest&lt;/code> ，这有可能会被攻击者利用来运行已经存在于本地的镜像。现在 Docker daemon 将会检查 digest 是否与其名字匹配；&lt;/li>
&lt;/ul>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112945">kubeadm: Inherit &lt;code>dry-run&lt;/code> flags for each sub-phases by chendave · Pull Request #112945 · kubernetes/kubernetes&lt;/a> kubeadm 所有的阶段都支持了 dry-run 模式；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111096">Add categories to kubectl api-resources wide output and add --categories flag by brianpursley · Pull Request #111096 · kubernetes/kubernetes&lt;/a> 为 &lt;code>kubectl api-resources -o wide&lt;/code> 的输出中增加了一列 &amp;quot;Categories&amp;quot;；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/108501">add &lt;code>--concurrent-horizontal-pod-autoscaler-syncs&lt;/code> flag to kube-controller-manager by zroubalik · Pull Request #108501 · kubernetes/kubernetes&lt;/a> 为 kube-controller-manager 增加了 &lt;code>--concurrent-horizontal-pod-autoscaler-syncs&lt;/code> 的参数，原先 HPA 中默认只有一个 worker，在大规模集群中处理效率很低。本次的 PR 可以通过此参数来自行配置 worker 数量，以便于提升效率；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Prometheus 新版本内存用量大幅度优化！</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/10/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-%E6%96%B0%E7%89%88%E6%9C%AC%E5%86%85%E5%AD%98%E7%94%A8%E9%87%8F%E5%A4%A7%E5%B9%85%E5%BA%A6%E4%BC%98%E5%8C%96/"/><id>https://moelove.info/2022/10/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-%E6%96%B0%E7%89%88%E6%9C%AC%E5%86%85%E5%AD%98%E7%94%A8%E9%87%8F%E5%A4%A7%E5%B9%85%E5%BA%A6%E4%BC%98%E5%8C%96/</id><updated>2022-10-10T06:50:58+08:00</updated><published>2022-10-09T20:59:15+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>由于上周在假期，所以没有推送新的文章。大家的假期过的如何呢？&lt;/p>
&lt;p>我有一个托管在 &lt;a href="https://pipedream.com/">Pipedream&lt;/a> 上的 workflow ，
该 workflow 订阅了我博客的 RSS， 当有新文章发布后，会调用 Bitly 生成短网址，然后自动发推。
正常情况下，它会保持 RSS 的处理状态，仅处理增量数据。&lt;/p>
&lt;p>但是在两周前某天早上醒来，我收到一堆的告警和消息提醒，发现该 workflow 工作异常了，它将我的很多历史博客都推送了一遍。
（事实上，幸好触发了 Bitly 的请求限制，否则它确实会把我的所有博客都推一遍）&lt;/p>
&lt;p>经过与该司的 Co-founder 沟通，问题出现的原因是该平台出现了一些故障，导致 RSS 处理的状态数据丢失了。所以会将 RSS 的任务重新进行处理。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/10/10/9AF8e5X76aDwMoJ.png" alt="">&lt;/p>
&lt;p>问题出现的原因和影响面这和我关系不大，知道在个结论已经足够了。简单说下如何避免后续再出现这种情况。&lt;/p>
&lt;p>该平台提供了一个 Data Stores 的服务，用于进行一些持久化数据的存储。所以后续的处理办法就是选择了 guid 作为唯一值，存储在该服务中。
该平台首选支持的语言是 NodeJS，所以也比较简单，如下配置即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="nx">defineComponent&lt;/span>&lt;span class="p">({&lt;/span>
&lt;span class="nx">props&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">db&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">type&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;data_store&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">label&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s2">&amp;#34;RSS item keys&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="kr">async&lt;/span> &lt;span class="nx">run&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="nx">steps&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">$&lt;/span> &lt;span class="p">})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">guid&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">steps&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">trigger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">event&lt;/span>
&lt;span class="c1">// Exit early if no GUID found
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">guid&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">$&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">flow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;No GUID found&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Exit early if key is found
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kr">await&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">guid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">$&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">flow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;GUID already found&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Else set and continue
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kr">await&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">guid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外为了防止再重复推送，所以在恢复 workflow 运行前，
我创建了一个新的 workflow，使用了 RSS 和上述的处理步骤，对数据做了下预热，确保已经都存储到了 Data Stores，并且能按预期工作。&lt;/p>
&lt;p>既然 Data Stores 是一个持久化服务，这应该不至于再出问题了吧（笑&lt;/p>
&lt;h1 id="prometheus-v239-正式发布">Prometheus v2.39 正式发布&lt;/h1>
&lt;p>Prometheus v2.39 近期正式发布了，这个版本中做了大量的资源优化和增加了一些新的特性。我聊一下我觉得比较关键的部分。&lt;/p>
&lt;h2 id="大幅度优化内存资源用量">大幅度优化内存资源用量&lt;/h2>
&lt;p>在这个版本中 @bboreham 提交了一系列的 PR 来进行资源用量相关的优化，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11147">Optimise relabeling by re-using memory by bboreham · Pull Request #11147 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11317">tsdb: turn off transaction isolation for head compaction by bboreham · Pull Request #11317 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11280">tsdb: remove chunk pool from memSeries by bboreham · Pull Request #11280 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11288">tsdb: remove chunkRange and oooCapMax from memSeries by bboreham · Pull Request #11288 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11307">WAL loading: check sample time is valid earlier by bboreham · Pull Request #11307 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>此外还有一些PR，我就不一一列举了。总结来说是改进了 relabeling 中的内存重用，优化了 WAL 重放处理，从 TSDB head series 中删除了不必要的内存使用，
以及关闭了 head compaction 的事务隔离等。&lt;/p>
&lt;p>尽管这些优化会根据不同的 Prometheus 使用情况造成不同的实际效果，
但在 Grafana Labs 的一个大型 Prometheus 实例中可以看到，通过升级最新的版本，内存用量减少了一半左右。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/10/10/9QrDyXBdORksM8E.jpg" alt="prometheus memory usage">&lt;/p>
&lt;h2 id="实验特性增加对无序样本的支持">实验特性：增加对无序样本的支持&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/11075">Add out-of-order sample support to the TSDB by jesusvazquez · Pull Request #11075 · prometheus/prometheus&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个特性确实可以多聊一点。我们知道对于 Prometheus 而言，它默认使用了自己的 TSDB，并且有两个主要的限制：&lt;/p>
&lt;ul>
&lt;li>在给定的时间序列中，只能以基于时间戳的顺序附加样本，因此当相同 series 已有较新的样本时，不能摄取较旧的样本；&lt;/li>
&lt;li>在整个 TSDB 中，最多只能追加比 TSDB 中最新样本早 1 小时的样本（这里假设默认是 2h 的 block 设置）；&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>虽然这通常适用于实时监控用例，但有时您可能有指标生产者需要摄取无序数据或超过一小时的数据。这可能是因为生产者并不总是连接到网络，需要在发送数据之前在更长的时间内聚合数据，或者类似的限制。在技术层面上，此类生产者可以以度量标准公开格式公开自定义客户端时间戳，或者使用 Prometheus 中的远程写入接收器来覆盖 Prometheus 自己的抓取时间戳。但是，Prometheus 的 TSDB 通常不会在这些样本出现故障或太旧时接受这些样本。&lt;/p>
&lt;/blockquote>
&lt;p>现在添加个这个实验特性是允许生产者发送无序数据，或者超 1 小时的数据（和上述假设一致）。可以通过 &lt;code>out_of_order_time_window&lt;/code> 配置项进行配置。
它接受的是一个时间周期的配置。比如可以进行如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">tsdb&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">out_of_order_time_window&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">12h&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示允许无序数据的时间窗口为 12h 。&lt;/p>
&lt;p>但是请注意，尽管这个特性不需要额外的开启，但它确实是实验特性，后续有可能还会进行调整，请按需进行使用。&lt;/p>
&lt;p>此外就是一些小的特性修改了，当然顺便一说，这个版本仍然还是延续了之前的习惯，在发布了 v2.39.0 后，很快就发布了 v2.39.1 版本来进行 bugfix 。
如果你要对生产环境中的 Prometheus 升级，建议先做个测试，跑几天看看效果。&lt;/p>
&lt;h1 id="istio-正式成为-cncf-孵化项目">Istio 正式成为 CNCF 孵化项目&lt;/h1>
&lt;p>其实在之前的 「K8S 生态周报」中，我一直都有同步 Istio 进入 CNCF 相关的信息和进展，这个事情确实耗时比较长了。
可能已经一年多了？但印象较深的最近一次的正式公告应该是 IstioCon 2022 上的 keynote 。&lt;/p>
&lt;p>Istio 正式成为 CNCF 孵化项目，意味着其将会使用 CNCF 的治理模式，社区可以更加多样化的发展。
当然，以后在一些 CNCF 的会议上来分享 Istio 也就变的很自然了，(比如我们正在做的 APISIX 作为 Istio 数据面的 Service Mesh 项目)&lt;/p>
&lt;p>期待它的后续发展！&lt;/p>
&lt;h1 id="cilium-v1130-rc1-发布">Cilium v1.13.0-rc1 发布&lt;/h1>
&lt;p>这里我简单介绍下比较重要的一些特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/20995">add support for k8s 1.25.0 by aanm · Pull Request #20995 · cilium/cilium&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>增加了对 Kubernetes v1.25 的支持，一些文档，测试和依赖等。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/20349">Add IPv6 BIG TCP support by NikAleksandrov · Pull Request #20349 · cilium/cilium&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>如有此方面需求的小伙伴可以查看 PR 的描述，还是比较详细的，这里就不展开了。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/20033">Add preliminary support for SCTP by DolceTriade · Pull Request #20033 · cilium/cilium&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>增加了部分 SCTP 协议的支持，包含如下方面：&lt;/p>
&lt;ul>
&lt;li>Pod 和 Pod 之间的交流&lt;/li>
&lt;li>Pod 和 Service 之间的交流，这里需要注意，由于不支持对 SCTP 包的端口该写，所以定义 Service 的时候， &lt;strong>targetPort 必须与 port 保持一致，否则包会被丢弃&lt;/strong>。&lt;/li>
&lt;li>Pod 与 Pod 之间通过增加了 SCTP 流量的网络策略&lt;/li>
&lt;/ul>
&lt;p>不支持的部分是：&lt;/p>
&lt;ul>
&lt;li>Multihoming&lt;/li>
&lt;li>pod-to-VIP 的策略&lt;/li>
&lt;li>KPR&lt;/li>
&lt;li>BPF masquerading&lt;/li>
&lt;li>Egress gateway&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/20492">Add trace points for socket-LB by aditighag · Pull Request #20492 · cilium/cilium&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>对用户的表现上是增加了一个 &lt;code>--trace-sock&lt;/code> 的参数，默认是开启的。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/21386">ingress: Support shared load balancer mode by sayboras · Pull Request #21386 · cilium/cilium&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在之前 Cilium 会为每个 Ingress 资源创建一个 LoadBalancer service ，但这个方式并不高效。
所以现在引入了两种模式。&lt;/p>
&lt;p>一种就是当前的实现，称之为 dedicated mode ，每个 Ingress 一个 LB。&lt;/p>
&lt;p>另一种是新增的，称之为 shared mode ，所有的 Ingress 共享一个 LB。如果出现 path/host 冲突，请求将被分发到各个后端。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112414">kubelet: append options to pod if there are multi options in /etc/resolv.conf by pacoxu · Pull Request #112414 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>当前 kubelet 创建 Pod 的时候，如果 &lt;code>/etc/resolv.conf&lt;/code> 中存在多行 options 配置，则只取最后一行。&lt;/p>
&lt;p>例如 /etc/resolv.conf 包含的配置如下：&lt;/p>
&lt;pre>&lt;code>options timeout:1
options attempts:3
&lt;/code>&lt;/pre>&lt;p>则 Pod 中的 /etc/resolv.conf 只包含如下内容&lt;/p>
&lt;pre>&lt;code>options attempts:3
&lt;/code>&lt;/pre>&lt;p>但事实上即使在 /etc/resolv.conf 中配置多行 options ，DNS 也是可以正常工作的。所以当前的 kubelet 行为就不一致了。&lt;/p>
&lt;p>通过这个 PR， 会将主机的 /etc/resolv.conf 中的多行配置合并为一行。如果还是上面的例子，则 Pod 内看到的就是如下内容了.&lt;/p>
&lt;pre>&lt;code>options timeout:1 attempts:3
&lt;/code>&lt;/pre>&lt;p>稍微聊点其他的，这个修复其实在 &lt;a href="https://github.com/kubernetes/kubernetes/pull/91052">fix resolv.conf multi options cover issue by xiaoanyunfei · Pull Request #91052 · kubernetes/kubernetes&lt;/a>
就尝试做过了，并且是在 2 年多之前。&lt;/p>
&lt;p>未合并的原因是由于之前 reviewer 说没有看到 SPEC 描述这种多行的行为，所以不确定这是否能工作，之后便关掉了。&lt;/p>
&lt;p>事实上本次的修复，同样也没有找到任何的 SPEC 描述这个行为，只不过是翻了 musl libc 的代码，发现它可以对这种行为进行支持，所以 reviewer 也就接受了。&lt;/p>
&lt;p>我想要说的是，在开源项目/社区中进行贡献或者协作的时候，每个人都可以有一些特定的理由去接受或者拒绝一些特性，但不存在绝对。（如果你发现某个开源项目/社区是这样的，那说明该项目并不健康）&lt;/p>
&lt;p>假如你是一个贡献者，
&lt;strong>并且你认为你所做的修改是有意义的，那么你需要更主动的去推进该事情，而不是对方给出意见后就默默接受。&lt;/strong>&lt;/p>
&lt;p>和谐有善并不意味着默默接受全部，该 battle 的时候就应该据理力争，管它是谁&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/10/10/ASD9jFGoYC4K61N.jpg" alt="1038420994.jpg">&lt;/p>
&lt;p>当然，记得要有理有据&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/10/10/nIftz6GDUo91jBF.jpg" alt="572730798.jpg">&lt;/p>
&lt;p>好了，以上就是本次的全部内容，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes 新增 auth whoami 子命令，可获取用户属性</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/09/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E6%96%B0%E5%A2%9E-auth-whoami-%E5%AD%90%E5%91%BD%E4%BB%A4%E5%8F%AF%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7/"/><id>https://moelove.info/2022/09/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E6%96%B0%E5%A2%9E-auth-whoami-%E5%AD%90%E5%91%BD%E4%BB%A4%E5%8F%AF%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7/</id><updated>2022-09-26T02:21:15+08:00</updated><published>2022-09-25T05:25:01+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;h1 id="apache-apisix-ingress-v150-发布">Apache APISIX Ingress v1.5.0 发布&lt;/h1>
&lt;p>目前 &lt;a href="https://github.com/apache/apisix-ingress-controller" title="Apache APISIX Ingress">Apache APISIX Ingress controller&lt;/a> 项目已经进入了 v1.5 的发布窗口，之前已经发布了 1.5.0-rc1 版本，如今发现的一些 bug 已经得到修正，我们已经计划发布 v1.5.0 的正式版本了。
待投票流程结束后，将会有正式的公告和对应的 Release 发布。&lt;/p>
&lt;p>距离上一个特性版本 v1.4.0 发布已经过去了将近 7 个月的时间，这期间我们进行了大量的开发工作，有 155 次提交和 32 位贡献者参与，感谢大家的参与让这个版本有了很大的不同。
这里我列一些主要的变化，后续还会有专门的发版公告和特性解读文章等。&lt;/p>
&lt;p>在这个版本中，正式将所有 CRD 资源的 API version 升级到了 v2 stable ，这也标志着用户使用起来会更加的方便和统一，同时这些资源也已经过多个版本迭代和用户在生产环境的使用，达到了足够稳定的级别。&lt;/p>
&lt;p>此外，在这个版本中提供了对 Gateway API 的支持，不过此特性目前尚处于实验性质，默认不开启，用户可以通过为它传递 &lt;code>enable_gateway_api=true&lt;/code> 的配置项来开启此能力。在下个版本中我们将引入 Gateway API 项目的一致性测试，来保证我们的实现与 Gateway API 项目的一致性。这样做的好处在于凡是通过了 Gateway API 一致性校验的实现，均可进行互相替换，不会存在锁定的情况。而且在迁移的过程中，也可以保证配置的兼容性。&lt;/p>
&lt;p>Apache APISIX Ingress controller 项目是支持多种配置方式的，无论使用 CRD 的方式，或者使用 Kubernetes 中原生的 Ingress 资源都是可以的。但在之前版本中，对于 Ingress 资源来说，想要使用 APISIX 提供的 plugin 能力，就必须先实现一个对应的 annotation，这种方式可扩展能力很差。
在这个版本中，我们为 Ingress 资源提供了一个新的 annotation 允许所有的 Ingress 资源可以直接使用 APISIX 所提供的 70+ 种 plugin 的能力，这对于一些使用开源的仅支持配置 Ingress 资源的用户而言，是非常有用的。&lt;/p>
&lt;p>除去这些新功能外，目前无论是开源项目的维护者，还是使用者，都在积极的关注供应链安全。在 Apache APISIX Ingress controller 中，我们也升级了它使用的 Golang 版本，以及所有依赖的模块均升级到了最新版本，并且借助 GitHub 的 Dependabot 进行依赖的周期性扫描和更新，尽可能的提供安全可信的软件。&lt;/p>
&lt;p>这里我先介绍这么多，大家如果对此项目感兴趣，欢迎在 GitHub 加个 star &lt;a href="https://github.com/apache/apisix-ingress-controller">https://github.com/apache/apisix-ingress-controller&lt;/a>&lt;/p>
&lt;p>发布流程未结束前，也可直接从最新的代码中构建镜像尝试使用。&lt;/p>
&lt;h1 id="wasmtime-v10-正式发布">Wasmtime v1.0 正式发布&lt;/h1>
&lt;p>Wasmtime 是一个快速且安全的 WebAssembly 运行时，是 Bytecode Alliance （非营利组织）下的项目。&lt;/p>
&lt;blockquote>
&lt;p>字节码联盟是一个非营利组织，致力于创建安全的新软件基础，建立在WebAssembly和WebAssembly 系统接口 (WASI)等标准之上。
字节码联盟致力于建立一个功能强大、安全的平台，让应用程序开发人员和服务提供商能够自信地在任何基础设施、任何操作系统或设备上运行不受信任的代码，并利用数十年来在 Web 浏览器中的经验。
我们的愿景是为所有平台建立一个默认安全的 WebAssembly 生态系统。&lt;/p>
&lt;/blockquote>
&lt;p>关于 WebAssembly 的详细介绍，并不是此处的重点，推荐可以看看 &lt;a href="https://developer.mozilla.org/en-US/docs/WebAssembly">MDN 的 WebAssembly 文档&lt;/a> 进行了解。&lt;/p>
&lt;p>Wasmtime 的语言支持目前是有限的，其中最受支持的语言是 Rust。此外，多种语言都支持嵌入 Wasmtime，比如 Rust、C、Python、C#、Go 和 Bash 等。&lt;/p>
&lt;p>以下我使用 Rust 来快速的介绍下 Wasmtime 的使用。&lt;/p>
&lt;p>首先在安装完 Rust 和 Wasmtime 的环境后，写一个最简单的 &lt;code>hello.rs&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, Wasmtime!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后进行编译和运行即可：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ws rustup target add wasm32-wasi
info: component &lt;span class="s1">&amp;#39;rust-std&amp;#39;&lt;/span> &lt;span class="k">for&lt;/span> target &lt;span class="s1">&amp;#39;wasm32-wasi&amp;#39;&lt;/span> is up to date
➜ ws rustc hello.rs --target wasm32-wasi
➜ ws wasmtime hello.wasm
Hello, Wasmtime!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到非常简单，当然你也可以选择使用 &lt;code>cargo new &lt;/code> 的方式创建个新项目来进行使用，此处仅做为示例。&lt;/p>
&lt;p>来自 Fastly 的工程师提到，在一年多以前就可以将 Wasmtime 称为生产就绪了，之所以没有这样做，是希望能在正式宣布它生产就绪前，能在生产中稳定
运行 Wasmtime 很长一段时间。&lt;/p>
&lt;p>此事与 K8s 生态比较相关的一个重要内容是，Microsoft 在 Azure Kubernetes （AKS）服务中提供了一个预览版功能：
&lt;strong>允许创建具有 WASM/WASI 运行时的节点池，并运行 WASM 应用程序&lt;/strong> 。当然，此处可以使用的 WASM 运行时就是 Wasmtime 。&lt;/p>
&lt;p>期待后续 WebAssembly 生态在云原生领域中的发展！&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111333">Add auth API to get self subject attributes by nabokihms · Pull Request #111333 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这是 &lt;a href="https://github.com/kubernetes/enhancements/issues/3325">KEP-3325: Self subject attributes review API&lt;/a> 实现的一部分。&lt;/p>
&lt;p>大家想必都知道，Kubernetes 中并没有 User（用户）的资源，但是 Kubernetes 中有权限校验的方式，比如我们常用到的利用 x509 证书进行用户权限相关的校验，或者
通过外部的 OIDC 和 webhook 等进行校验。&lt;/p>
&lt;p>此功能实际上是为了添加一个新的接口，以便于用户身份通过校验后，获取其所具有的属性。这样就可以简单的通过增加一个 &lt;code>kubectl auth whoami&lt;/code> 的命令，来了解当前用户的相关信息了。
这功能比较类似于我们做 OAuth 的时候，可能会做个 UserInfo 之类的接口，用来查看用户相关的属性。&lt;/p>
&lt;p>该功能是通过在 &lt;code>authentication.k8s.io&lt;/code> Group 下添加了 &lt;code>SelfSubjectReview&lt;/code> 资源来实现的，具体如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request.
&lt;/span>&lt;span class="c1">// When using impersonation, users will receive the user info of the user being impersonated.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">SelfSubjectReview&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TypeMeta&lt;/span> &lt;span class="s">`json:&amp;#34;,inline&amp;#34;`&lt;/span>
&lt;span class="c1">// Standard object&amp;#39;s metadata.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// +optional
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span> &lt;span class="s">`json:&amp;#34;metadata,omitempty&amp;#34; protobuf:&amp;#34;bytes,1,opt,name=metadata&amp;#34;`&lt;/span>
&lt;span class="c1">// Status is filled in by the server with the user attributes.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">Status&lt;/span> &lt;span class="nx">SelfSubjectReviewStatus&lt;/span> &lt;span class="s">`json:&amp;#34;status,omitempty&amp;#34; protobuf:&amp;#34;bytes,2,opt,name=status&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">type&lt;/span> &lt;span class="nx">SelfSubjectReviewStatus&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// User attributes of the user making this request.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// +optional
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">UserInfo&lt;/span> &lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UserInfo&lt;/span> &lt;span class="s">`json:&amp;#34;userInfo,omitempty&amp;#34; protobuf:&amp;#34;bytes,1,opt,name=userInfo&amp;#34;`&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此功能在 v1.26 版本开始引入，并作为 Alpha 特性提供，可通过 &lt;code>APISelfSubjectReview&lt;/code> feature gate 控制是否启用。&lt;/p>
&lt;p>同时，本次也在 kubectl 中添加了 &lt;code>kubectl alpha auth whoami&lt;/code> 子命令，可直接查看当前用户的相关属性信息。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112526">Limit redirect proxy handling to redirected responses by liggitt · Pull Request #112526 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在上一篇 &lt;a href="https://moelove.info/2022/09/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E7%88%86%E5%87%BA%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/">《K8S 生态周报| Kubernetes 爆出全版本漏洞》&lt;/a> 中，
我曾介绍过 CVE-2022-3172 漏洞相关的信息。&lt;/p>
&lt;p>上游中的修复方式是提供了一个选项 &lt;code>--aggregator-reject-forwarding-redirect=true&lt;/code> 来设置拒绝跟随重定向，避免 SSRF 。
但同时该修复也引入了新的问题，由于该修复仅判断了 HTTP Code 是否在 300～399 ，但这是个不完整的假设，并非所有的 3xx 状态码都是重定向，
比如 &lt;code>304 Not Modified&lt;/code> 表示无需再次传输请求的内容。&lt;/p>
&lt;p>所以本次的修复额外增加了对 &lt;code>Location&lt;/code> Header 的判断。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gh">diff --git a/staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go b/staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go
&lt;/span>&lt;span class="gh">index a3a14241cc6..278ed089d95 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -263,7 +263,7 @@ func (h *UpgradeAwareHandler) ServeHTTP(w http.ResponseWriter, req *http.Request
&lt;/span>&lt;span class="gu">&lt;/span> oldModifyResponse := proxy.ModifyResponse
proxy.ModifyResponse = func(response *http.Response) error {
code := response.StatusCode
&lt;span class="gd">- if code &amp;gt;= 300 &amp;amp;&amp;amp; code &amp;lt;= 399 {
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ if code &amp;gt;= 300 &amp;amp;&amp;amp; code &amp;lt;= 399 &amp;amp;&amp;amp; len(response.Header.Get(&amp;#34;Location&amp;#34;)) &amp;gt; 0 {
&lt;/span>&lt;span class="gi">&lt;/span> // close the original response
response.Body.Close()
msg := &amp;#34;the backend attempted to redirect this request, which is not permitted&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此修复也会被 cherry-pick 到其他的分支中，并将在下个版本进行发布。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112015">Removal of GlusterFS code from the repo by humblec · Pull Request #112015 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在之前的 「K8S 生态周报」中我曾介绍过，在 v1.25 中将树内的 GlusterFS plugin 标记为废弃，并建议迁移至使用 CSI ，
如今这些插件已经被彻底删除了。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes 爆出全版本漏洞</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/09/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E7%88%86%E5%87%BA%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/><id>https://moelove.info/2022/09/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E7%88%86%E5%87%BA%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/</id><updated>2022-09-19T08:03:19+08:00</updated><published>2022-09-18T15:01:09+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;h1 id="kubernetes-cve-2022-3172-安全漏洞">Kubernetes CVE-2022-3172 安全漏洞&lt;/h1>
&lt;p>扩展 Kubernetes 的方法有很多种，目前扩展 API 方面用到最多的是 自定义资源定义（CRD）和聚合 API（Aggregation API）。
自定义资源定义主要是为了让 Kubernetes 集群中可以识别到新的资源，此处我主要说明下后者。&lt;/p>
&lt;p>聚合 API 实际上是在 kube-apiserver 中运行的，在新 API 注册之前，它并不会工作。如果要添加新的 API，则需要创建一个
&lt;code>APIService&lt;/code> 对象，用来申请 Kubernetes 中新的 URL 路径。注册成功后，当有发送到此路径中的请求，则会被转发到已经注册
的 APIService 上。&lt;/p>
&lt;p>本次公布的 CVE-2022-3172 便与聚合 API 有关。&lt;/p>
&lt;p>就像我前面介绍的那样，当新的 URL 被注册成功后，发送到该路径的请求便会被转发到已经注册的 APIService 上。
安全人员发现，目前的实现中存在一个漏洞，APIService 可以将客户端的请求转发到任意的 URL 上，这就有可能会导致
Client 发送请求时，所携带的一些认证信息可能会被发送给第三方。&lt;/p>
&lt;p>这也就是我们在安全领域常提到的 SSRF（Server Side Request Forgery），即：服务端请求伪造。
与之对应的是 CSRF（Client Side Request Forgery）,即：客户端请求伪造。
它们的区别主要在于攻击目标和过程不同，这里不展开了。&lt;/p>
&lt;p>想要知道自己是否可能受到影响？可以执行如下命令进行验证：&lt;/p>
&lt;pre>&lt;code>kubectl get apiservices.apiregistration.k8s.io -o=jsonpath='{range .items[?(@.spec.service)]}{.metadata.name}{&amp;quot;\n&amp;quot;}{end}'
&lt;/code>&lt;/pre>&lt;p>比如，我在我的某一个集群中执行该命令得到的结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ kubectl get apiservices.apiregistration.k8s.io -o&lt;span class="o">=&lt;/span>&lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{range .items[?(@.spec.service)]}{.metadata.name}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>
v1alpha1.cluster.karmada.io
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是由于该集群是 Karmada 的一个 host 集群，而 Karmada 的主要实现方式便是通过聚合 API 来实现的。
当然，大家比较容易接触到的利用聚合 API 的另一服务可能是 metrics-server 。&lt;/p>
&lt;h2 id="影响范围">影响范围&lt;/h2>
&lt;p>此漏洞几乎影响了当前所有的 Kubernetes 版本。具体如下：&lt;/p>
&lt;ul>
&lt;li>kube-apiserver v1.25.0&lt;/li>
&lt;li>kube-apiserver v1.24.0 - v1.24.4&lt;/li>
&lt;li>kube-apiserver v1.23.0 - v1.23.10&lt;/li>
&lt;li>kube-apiserver v1.22.0 - v1.22.13&lt;/li>
&lt;li>kube-apiserver &amp;lt;= v1.21.14&lt;/li>
&lt;/ul>
&lt;h2 id="解决办法">解决办法&lt;/h2>
&lt;p>由于聚合 API 默认是 Kubernetes control plane 受信任的部分，之前并没有规避它的办法。所以想要彻底解决该问题的话， &lt;strong>仅能通过升级&lt;/strong> 进行解决。
新版本中增加对来自 APIService 响应状态码的判断，如果是 3xx 的，则按照配置来决定是否要跟随重定向。&lt;/p>
&lt;p>集群维护者可以通过设置 &lt;code>--aggregator-reject-forwarding-redirect=true&lt;/code> (默认 true) 来设置拒绝跟随重定向，来避免 SSRF 。&lt;/p>
&lt;h2 id="缓解办法">缓解办法&lt;/h2>
&lt;p>由于本次问题主要是在聚合 API 上，缓解办法可以通过限制对 APIService 资源的操作来达到。
也可以仅仅部署可信来源的 APIService 来避免受到影响。&lt;/p>
&lt;h2 id="检测">检测&lt;/h2>
&lt;p>此外，除了验证自己是否有使用聚合 API 外，也可以通过审计日志中的 &lt;code>responseStatus.code&lt;/code> 来进行判断是否有出现重定向的情况。&lt;/p>
&lt;h1 id="helm-v3100-rc1-发布">Helm v3.10.0-rc.1 发布&lt;/h1>
&lt;p>Helm 其实一直都在比较积极的进行开发和迭代，只不过 Helm 目前功能上已经非常丰富了，所以最近的一些版本中并没有特别大的变更。
更多的都是一些 UX 和 bugfix 之类的。&lt;/p>
&lt;p>相比于 v3.9.4 而言，此版本中一些值得聊的变更如下：&lt;/p>
&lt;ul>
&lt;li>新增 &lt;code>helm list --no-headers&lt;/code> 参数，可以在执行 helm list 的时候不输出表头。尽管原先我们通过 jq 或者 shell 等都可以实现；&lt;/li>
&lt;li>增加了 &lt;code>--burst-limit&lt;/code> 参数，用于控制 client-side throttling limit；&lt;/li>
&lt;li>新增 &lt;code>--kube-insecure-skip-tls-verify&lt;/code> 和 &lt;code>HELM_KUBEINSECURE_SKIP_TLS_VERIFY&lt;/code>，用于控制是否要跳过 kube-apiserver 的证书校验；&lt;/li>
&lt;/ul>
&lt;p>更多内容可以参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.10.0-rc.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="trivy-v032-发布">Trivy v0.32 发布&lt;/h1>
&lt;p>Trivy 我之前的文章中已经介绍过多次了，这里就不再重复了。&lt;/p>
&lt;p>Trivy 其实与上面提到的 Helm 类似，功能上已经相对丰富了，所以每次版本中并没有特别显著的新特性，整体趋于平稳。&lt;/p>
&lt;p>此版本中值得关注的内容如下：&lt;/p>
&lt;ul>
&lt;li>增加了对 Rust 二进制文件的依赖扫描；&lt;/li>
&lt;li>增加了对 gradle.lockfile 和 conan.lock 文件的支持；&lt;/li>
&lt;li>还有一些对 SBOM 的支持，比如增加对 SPDX 的扫描；&lt;/li>
&lt;/ul>
&lt;p>更多内容可以参考其 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.32.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111122">support removal of event handlers from SharedIndexInformers by alexzielenski · Pull Request #111122 · kubernetes/kubernetes&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112046">rate limite etcd healthcheck request by aojea · Pull Request #112046 · kubernetes/kubernetes&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可控制 kube-apiserver 和 etcd 健康检查之间的流量。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112017">exec auth: support TLS config caching by enj · Pull Request #112017 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes 社区发布 CVE 漏洞订阅列表</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/09/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B8%83-CVE-%E6%BC%8F%E6%B4%9E%E8%AE%A2%E9%98%85%E5%88%97%E8%A1%A8/"/><id>https://moelove.info/2022/09/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B8%83-CVE-%E6%BC%8F%E6%B4%9E%E8%AE%A2%E9%98%85%E5%88%97%E8%A1%A8/</id><updated>2022-09-13T00:54:15+08:00</updated><published>2022-09-12T20:05:30+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;h1 id="kubernetes-ingress-nginx-发布-v131-版本">Kubernetes Ingress-NGINX 发布 v1.3.1 版本&lt;/h1>
&lt;p>这是 &lt;a href="https://moelove.info/2022/07/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Ingress-NGINX-%E9%A1%B9%E7%9B%AE%E6%9A%82%E5%81%9C%E6%8E%A5%E6%94%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E5%B0%86%E4%B8%93%E6%B3%A8%E4%BA%8E%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8F%90%E5%8D%87/">Kubernetes Ingress-NGINX 项目在进入功能冻结&lt;/a>之后，发布的第一个版本。&lt;/p>
&lt;p>由于这个版本只是 patch 版本，所以并没有过多大的新增特性。&lt;/p>
&lt;p>但这里也有一些需要注意的变更：&lt;/p>
&lt;ul>
&lt;li>为了能兼容 Kubernetes 的更高版本，所以我们将 controller 中用于选举的机制修改成了使用 Lease API 的方式，而不再是原先的 configmap 的方式。其实在 Kubernetes Ingress-NGINX v1.3.0 版本中，我增加了往 Lease API 平滑迁移的逻辑，在使用 v1.3.0 版本的时候，可以自动的完成 ConfigMap 往 Lease API 迁移的逻辑。 &lt;strong>所以，如果是想要从旧版本进行平滑升级，建议先升级到 v1.3.0，待完成自动的迁移后，再往更新版本升级&lt;/strong>。&lt;/li>
&lt;li>将基础镜像和 Go 版本均升级到最新版本，修正了一些漏洞。&lt;/li>
&lt;li>从这个版本开始，也逐步开始了数据面和控制面的拆分。&lt;/li>
&lt;/ul>
&lt;p>如果你在使用 Kubernetes Ingress-NGINX，请帮忙提交一下我们的用户调查： &lt;a href="https://www.surveymonkey.com/r/ingressngx2022">https://www.surveymonkey.com/r/ingressngx2022&lt;/a>&lt;/p>
&lt;p>更多相关信息可查看 &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.3.1">Release Note&lt;/a>&lt;/p>
&lt;h1 id="docker-v201018-发布">Docker v20.10.18 发布&lt;/h1>
&lt;p>这个版本主要是一些 bugfix，其中有个比较值得注意的修复：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/44018">[20.10 backport] daemon: kill exec process on ctx cancel by thaJeztah · Pull Request #44018 · moby/moby&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Dockerfile 中有一个 &lt;code>HEALTHCHECK&lt;/code> 的指令，该指令支持 &lt;code>--interval&lt;/code> 和 &lt;code>--timeout&lt;/code> 参数，但是 docker daemon 在 healthcheck 的 timeout 之后，并没有回收对应的进程，这样就会导致容器内可能会产生很多 healthcheck 的进程。
本次修复了该处理逻辑，在超时后会自动的发送 &lt;code>KILL&lt;/code> 信号进行进程的清理。&lt;/p>
&lt;ul>
&lt;li>升级 runc 和 containerd 版本等，上次的周报 &lt;a href="https://moelove.info/2022/08/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D-Dockercontainerd-%E5%92%8C-K8s/">K8S 生态周报| runc 修复多个漏洞，影响 Docker、containerd 和 K8s | MoeLove&lt;/a> 里面我介绍过其背景，有兴趣的小伙伴可以看看。&lt;/li>
&lt;/ul>
&lt;p>更多相关信息可查看 &lt;a href="https://github.com/moby/moby/releases/tag/v20.10.18">Release Note&lt;/a>&lt;/p>
&lt;h1 id="kubernetes-社区发布官方-cve-订阅列表">Kubernetes 社区发布官方 CVE 订阅列表&lt;/h1>
&lt;p>Kubernetes Security Response Committee 近期发布了官方 Kubernetes CVE 订阅列表。&lt;/p>
&lt;p>这是一个会自动更新的 JSON feed, 可以直接通过此列表订阅更新。&lt;/p>
&lt;p>其包含的内容如下如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ curl -Ls https://k8s.io/docs/reference/issues-security/official-cve-feed/index.json &lt;span class="p">|&lt;/span> jq -r &lt;span class="s1">&amp;#39;.items[0]&amp;#39;&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;id&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;CVE-2021-25741&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;url&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;https://github.com/kubernetes/kubernetes/issues/104980&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;external_url&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;https://www.cvedetails.com/cve-details.php?cve_id=CVE-2021-25741&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;summary&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Symlink Exchange Can Allow Host Filesystem Access&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些内容来自 GitHub 上加了 &lt;code>official-cve-feed&lt;/code> 标签的漏洞公告 issue ，并同步到 Google Cloud Bucket 进行存储。&lt;/p>
&lt;p>其实这个事情从去年就已经开始做了。不过由于其中涉及的事务较多，直到现在也才正式宣布。&lt;/p>
&lt;p>此外，Kubernetes 社区也计划在今后逐步增加 osv.dev 的支持，期待后续的进展!&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112172">kubeadm: Add the option to cleanup the &lt;code>tmp&lt;/code> directory by chendave · Pull Request #112172 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>kubeadm 新增 &lt;code>cleanup-tmp-dir&lt;/code> 配置项，在 &lt;code>kubeadm reset&lt;/code> 时，可以通过传递此参数将 kubeadm 产生的临时文件给清理干净。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112157">Avoid propagating &amp;quot;search .&amp;quot; into containers /etc/resolv.conf by dghubble · Pull Request #112157 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>从 Kubernetes v1.25 开始，&lt;code>/etc/resolv.conf&lt;/code> 中的 &lt;code>search .&lt;/code> 会被传递到容器内。&lt;/p>
&lt;p>这会导致任意基于 musl libc 系统的 DNS 查询失败，比如任何基于 Alpinelinux 的镜像都会失败。&lt;/p>
&lt;p>要验证自己的集群是否会受该问题影响，只需要查看系统的 &lt;code>/etc/resolv.conf&lt;/code> 文件的内容即可。比如：&lt;/p>
&lt;pre>&lt;code>nameserver 127.0.0.53
options edns0 trust-ad
search .
&lt;/code>&lt;/pre>&lt;p>如果是上述的情况，一般说明是被 systemd resove 接管了，并且会受到此处描述的问题所影响。
该修正会携带到 Kubernetes v1.25.1 版本中。&lt;/p>
&lt;h1 id="其他">其他&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://istio.io/latest/blog/2022/introducing-ambient-mesh/">Istio / Introducing Ambient Mesh&lt;/a> 这是 Istio 新增的一种无 sidecar 代理的数据面模式，有兴趣的小伙伴可以看看。&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/releases/tag/v0.59.1">Release 0.59.1 / 2022-09-12 · prometheus-operator/prometheus-operator&lt;/a> Prometheus operator 发布了新版本。&lt;/li>
&lt;/ul>
&lt;p>以上就是本期的全部内容，
好了，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| runc 修复多个漏洞，影响 Docker、containerd 和 K8s</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/08/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D-Dockercontainerd-%E5%92%8C-K8s/"/><id>https://moelove.info/2022/08/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D-Dockercontainerd-%E5%92%8C-K8s/</id><updated>2022-09-12T20:06:06+08:00</updated><published>2022-08-29T01:32:35+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;h1 id="runc-v114-发布">runc v1.1.4 发布&lt;/h1>
&lt;p>runc 是一个底层容器运行时，我在之前已经写过很多篇文章介绍它了，感兴趣的小伙伴可以翻翻历史文章。上周它发布了 v1.1.4 版本，
这是 v1.1 系列的第 4 个 patch 版本。当前该项目正在积极的进行 v1.2 版本的开发。&lt;/p>
&lt;p>大多数人都不会直接操作 runc 来启动容器，但是 runc 却是 Docker, containerd 等主流容器工具的底层依赖。本次 runc 新版本中修复的问题，
同样的也都会出现在 Docker 和 containerd 环境中。&lt;/p>
&lt;p>具体包含如下内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/3510">libct: fix mounting via wrong proc fd by kolyshkin · Pull Request #3510 · opencontainers/runc&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 bug 确实存在挺长时间了，但由于触发的条件比较严格，所以一直未发现。究其原因是 mountFd 未被清理，并且它可能被用于后续的挂载操作所使用。&lt;/p>
&lt;p>这里介绍下它的触发条件：&lt;/p>
&lt;ul>
&lt;li>userns 和 mountns 都被使用；&lt;/li>
&lt;li>cgroupns 未被使用；&lt;/li>
&lt;li>使用 cgroup v1 ；&lt;/li>
&lt;li>&lt;code>/sys/fs/cgroup&lt;/code> 的挂载在 bind mount 之后;&lt;/li>
&lt;/ul>
&lt;p>本身这些条件要同时都满足就概率比较小，加上现在 containerd，Docker，Kubernetes，runc 等都已经支持了 cgroup v2 ，并且在逐步完成往
cgroup v2 的迁移，所以被这个 bug 影响的可能性相对较小。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/3522">Fix error from runc run on noexec fs by kolyshkin · Pull Request #3522 · opencontainers/runc&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 PR 修正了 &lt;code>runc run&lt;/code> 命令在 noexec fs 上的权限问题。本质上来说它替换了 &lt;code>exec.LookPath&lt;/code> 函数，
使用了如下函数进行替代。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">Eaccess&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">path&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Faccessat2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AT_FDCWD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">X_OK&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AT_EACCESS&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ENOSYS&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EPERM&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//nolint:errorlint // unix errors are bare
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Faccessat2() not available; check if we are a set[ug]id binary.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Getuid&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Geteuid&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Getgid&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Getegid&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// For a non-set[ug]id binary, use access(2).
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Access&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">unix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">X_OK&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// For a setuid/setgid binary, there is no fallback way
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// so assume we can execute the binary.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里值得注意的一点是 &lt;code>faccessat2&lt;/code> 使用 &lt;code>AT_EACCESS&lt;/code> 是从 Linux v5.8 才开始提供支持的，不过这里通过 Go 的封装进行解决了。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/3554">[1.1] Fix failed exec after systemctl daemon-reload (regression in 1.1.3) by kolyshkin · Pull Request #3554 · opencontainers/runc&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>此处修正了一处自 v1.1.3 起存在的一个 bug，可能导致在 &lt;code>systemctl daemon-reload&lt;/code> 后，&lt;code>runc exec&lt;/code> 失败的情况。&lt;/p>
&lt;pre>&lt;code>exec failed: unable to start container process: open /dev/pts/0: operation not permitted: unknown
&lt;/code>&lt;/pre>&lt;p>这是由于 runc v1.1.3 中不再添加 &lt;code>DeviceAllow=char-pts rwm&lt;/code> 规则了，当执行 &lt;code>systemctl daemon-reload&lt;/code> 后，
会导致重新应用 systemd 的规则，进而导致这条规则的缺失。&lt;/p>
&lt;p>该问题不仅仅会影响 runc，包括 containerd 和 Docker 都受到了影响，以及一些使用它们作为容器运行时的 Kubernetes 集群也受到了影响。
解决办法是升级到 runc 的 v1.1.4 或者 containerd v1.6.8 版本即可。&lt;/p>
&lt;p>以上就是 runc 新版本中值得关注的变更。 &lt;strong>建议仔细检查，尽早进行修复&lt;/strong> 。&lt;/p>
&lt;h1 id="linkerd-212-正式发布">Linkerd 2.12 正式发布&lt;/h1>
&lt;p>Linkerd 是 Service Mesh 领域中很重要的组成部分，近期发布了 v2.12 版本，其中有两个很重要的特性：&lt;/p>
&lt;ul>
&lt;li>支持了 Gateway API （中的 HTTPRoute) ，具体信息可参考：https://buoyant.io/blog/linkerd-and-the-gateway-api&lt;/li>
&lt;li>支持更细粒度的单路由策略，详情可参考：https://linkerd.io/2.12/tasks/configuring-per-route-policy/&lt;/li>
&lt;/ul>
&lt;p>我觉得上面的文章写的挺好的，我想聊的事情，在那篇文章中基本都聊到了，就不再重复了。&lt;/p>
&lt;p>额外一点，Gateway API 被越来越多的厂商支持，整体而言是个好事情，可以促进 Gateway API 逐步达到毕业标准。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111093">Fix rollout history bug by brianpursley · Pull Request #111093 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在执行 &lt;code>kubectl rollout history&lt;/code> 的时候可以传递 &lt;code>--revision=3&lt;/code> 拿到指定版本的信息。但是如果指定了 output format ，则 &lt;code>--revision&lt;/code> 可能会失效。
通过此 PR 便可解决此问题，但要到 v1.26 才会携带。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111726">Expose a pending pods summary in scheudler's dummper output by Huang-Wei · Pull Request #111726 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>调度程序可以 dump 出更多信息。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/112076">Revert &amp;quot;promote LocalStorageCapacityIsolationFSQuotaMonitoring to beta&amp;quot; by rphillips · Pull Request #112076 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>由于 OpenShift 团队发现在使用它的时候存在一些问题, 将 &lt;code>LocalStorageCapacityIsolationFSQuotaMonitoring&lt;/code> 重新回退到 Alpha 阶段。&lt;/p>
&lt;p>以上就是本期的全部内容，
好了，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.25.0 正式发布，新特性一览</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/08/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/><id>https://moelove.info/2022/08/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</id><updated>2022-09-06T08:47:45+08:00</updated><published>2022-08-24T00:19:52+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 Kubernetes 正式发布了，包含了 40 项目增强更新。 本次 LOGO 的主要表达的意思是 尊重协作和开放的精神 ，这种精神将我们凝聚到一起转……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>Kubernetes 正式发布了，包含了 40 项目增强更新。&lt;/p>
&lt;p>本次 LOGO 的主要表达的意思是 &lt;strong>尊重协作和开放的精神&lt;/strong> ，这种精神将我们凝聚到一起转变为能改变世界的力量。&lt;/p>
&lt;p>其实我每期的 「k8s生态周报」都有一个叫上游进展的部分，所以很多值得关注的内容在之前的文章中已经发过了。&lt;/p>
&lt;p>这篇中我会再额外介绍一些之前未涵盖的，和之前介绍过的值得关注的内容。&lt;/p>
&lt;h2 id="core-csi-migration-达到-stable">core CSI Migration 达到 Stable&lt;/h2>
&lt;p>Kubernetes 对 CSI 的支持是自 v1.9 开始引入的，到 2019 年的 v1.13 时已经正式 GA 。
最近几个版本中，社区正在将原本的 in-tree 插件逐步废弃或删除，并迁移至使用 CSI 驱动的方式。&lt;/p>
&lt;p>迁移至使用 CSI 的好处在于，能提高可维护性，并减少因 in-tree 代码导致的漏洞或者错误的发生。&lt;/p>
&lt;p>但是迁移也并不是直接替换，社区考虑到用户的迁移成本，于是提出了一种解决方案：CSI Migration ，这个方案是将
in-tree API 转换为等效 CSI API，并将操作委托给 CSI 驱动程序的功能。目前该功能达到 GA，in-tree 的迁移也有很多进展。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111485">deprecate GlusterFS plugin from available in-tree drivers. by humblec · Pull Request #111485 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在这个 PR 中废弃了 in-tree 的 GlusterFS 的 plugin，这其实是最早的 dynamic provisioner ，自 Kubernetes v1.4 版本开始引入。&lt;/p>
&lt;p>在后来 CSI 驱动出现的时候，社区中也立刻出现了对应的驱动实现 &lt;a href="https://github.com/gluster/gluster-csi-driver/">https://github.com/gluster/gluster-csi-driver/&lt;/a> ，只不过该项目并没有积极的进行维护。
现在还有另一个比较推荐的替代方案，可以考虑使用 &lt;a href="https://github.com/kadalu/kadalu/">https://github.com/kadalu/kadalu/&lt;/a> 此项目最新的版本为 v0.8.15 。&lt;/p>
&lt;p>经过社区之前的讨论，还是决定在 v1.25 版本开始将 in-tree 的 GlusterFS plugin 标记为废弃，并在后续的版本中进行移除。&lt;/p>
&lt;p>如果有正在使用此插件的小伙伴，我建议可以尽早的评估 kadalu 的可行性 &amp;amp; 迁移成本。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111620">cleanup: Remove storageos volume plugins from k8s codebase by Jiawei0227 · Pull Request #111620 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111618">cleanup: Remove flocker volume plugins from k8s codebase by Jiawei0227 · Pull Request #111618 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111619">cleanup: Remove quobyte volume plugins from k8s codebase by Jiawei0227 · Pull Request #111619 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>上述的这几个 PR 所做的事情基本类似，是一些清理操作。
将 Kubernetes 项目中 &lt;code>StorageOS&lt;/code>，&lt;code>Flocker&lt;/code> 和 &lt;code>Quobyte&lt;/code> 等 in-tree 的卷插件都删除掉了。&lt;/p>
&lt;p>其中 &lt;code>StorageOS&lt;/code> 和 &lt;code>Quobyte&lt;/code> 如果有在使用，建议往 CSI plugin 进行迁移，而 &lt;code>Flocker&lt;/code> 则是由于不再维护了，所以并没有任何迁移计划。&lt;/p>
&lt;h2 id="cgroup-v2-支持达到-ga">cgroup v2 支持达到 GA&lt;/h2>
&lt;p>在 2019 年 GitChat 对我的访谈中让我聊 2020 年的技术趋势，我当时的主要观点摘录如下：&lt;/p>
&lt;blockquote>
&lt;p>作为云原生技术的基石，Kubernetes 在 2020 年的热度将会持续上升。而各个公司的集群规模，以及对容器技术的推进都将会持续加大。在经历了初步容器化后，更多的公司将面临的问题是稳定性和性能优化问题。与此同时，service mesh，serverless 等技术也都会逐步得到普遍应用。 从底层次技术的角度来看，cgroups v2 将逐步普及，进而取代 cgroups v1，但这个过程可能需要两三年左右。 整体而言，稳定性和性能优化将会是未来的主旋律。&lt;/p>
&lt;/blockquote>
&lt;p>如今，3 年时间已经过去，Kubernetes v1.25 中对 cgroup v2 的支持已经达到 GA ，和我之前的判断是一样的。&lt;/p>
&lt;p>我之前也写了一篇 &lt;a href="https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/">《一篇搞懂容器技术的基石： cgroup》&lt;/a> ，可能该考虑写篇新的 cgroup v2 了 （笑&lt;/p>
&lt;h2 id="podsecurity-特性达到-ga">PodSecurity 特性达到 GA&lt;/h2>
&lt;p>在 &lt;a href="https://github.com/kubernetes/kubernetes/pull/110459">#110459 · kubernetes/kubernetes&lt;/a> 中正式将 PodSecurity 特性升级到 GA 。如果我没有记错，这个
特性应该是从引入到 GA 最快的特性之一了。&lt;/p>
&lt;p>PodSecurity 是自 Kubernetes v1.22 引入的 alpha 特性，作为 PodSecurityPolicy 的一个替代。在 v1.23 达到 beta 级别，通过上述 PR，在 v1.25 正式 GA ，并且默认启用，可以看到
整个发展过程还是很快的。&lt;/p>
&lt;p>PodSecurity 定义了 3 种级别：&lt;/p>
&lt;ul>
&lt;li>Enforce：如果 Pod 违反策略，则不会被创建；&lt;/li>
&lt;li>Audit：如果 Pod 违反策略，则在审计日志中会被记录，但是 Pod 仍将正常创建；&lt;/li>
&lt;li>Warn：如果 Pod 违反策略，则会在 console 中打印 warning 信息，Pod 仍将正常创建；&lt;/li>
&lt;/ul>
&lt;p>使用起来也很简单，只需要给 namespace 添加 &lt;code>pod-security.kubernetes.io/&amp;lt;mode&amp;gt;=&amp;lt;standard&amp;gt;&lt;/code> 标签即可。&lt;/p>
&lt;p>只要你的 Kubernetes 集群版本先升级到 v1.22 以上，并且开启 PodSecurity 特性，那么就可以按照 &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/">Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller | Kubernetes&lt;/a> 进行迁移了。&lt;/p>
&lt;p>但是如果你的集群版本较低，并且还希望能有一个相对通用的方法，我建议你可以看看我之前写的文章。&lt;a href="https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2-admission-webhook">《理清 Kubernetes 中的准入控制（Admission Controller)》&lt;/a>
和 &lt;a href="https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/">《云原生策略引擎 Kyverno （上）》&lt;/a>
通过使用 Admission controller 、OPA/GateKeeper、Kyverno 等来完成统一配置。&lt;/p>
&lt;h2 id="初步支持-user-namespaces">初步支持 user namespaces&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111090">Add support for user namespaces phase 1 (KEP 127) by rata · Pull Request #111090 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 PR 实现了 KEP127 的第一阶段，KEP127 旨在为 Pod 添加 user namespaces 的支持。
对 user namespaces 不太熟悉的小伙伴，可以看看我之前的系列文章：&lt;a href="https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/">《搞懂容器技术的基石： namespace （上）》&lt;/a> 和 &lt;a href="https://moelove.info/2021/12/13/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8B/">《搞懂容器技术的基石： namespace （下）》&lt;/a> 。&lt;/p>
&lt;p>在 Kubernetes 中支持使用 user namespaces 的好处在于，可以在与主机有不同 UID/GID 的 Pod 中运行进程，这样在 Pod 内的特权进程
实际是作为主机中的普通进程运行的。这样，假设 Pod 内的特权进程由于安全漏洞被攻破，对主机的影响也可以降到比较低。&lt;/p>
&lt;p>直接相关的漏洞，比如 CVE-2019-5736 ，我也曾在 2019 年的文章 &lt;a href="https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/">《runc 1.0-rc7 发布之际》&lt;/a> 专门介绍过，
感兴趣的小伙伴可以到该文章中了解详情。&lt;/p>
&lt;p>该实现是在 Pod 的 Spec 中添加了布尔类型的 &lt;code>HostUsers&lt;/code> 字段，以决定是否启用主机的 user namespaces，默认是 true 。&lt;/p>
&lt;p>此外，目前可预见的情况是，如果 Kubernetes 集群使用的 Linux 内核版本在 v5.19 以下的话，那么使用该特性可能会导致 Pod 的启动时间增加。&lt;/p>
&lt;h2 id="cronjobtimezone-达到-beta-级别">CronJobTimeZone 达到 Beta 级别&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111435/files">Promote CronJobTimeZone to beta by soltysh · Pull Request #111435 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>CronJob TimeZone 的特性达到了 Beta 阶段。不过根据 Kubernetes 最新的特性策略，该特性仍然需要手动开启 &lt;code>CronJobTimeZone&lt;/code> feature gate 。&lt;/p>
&lt;p>注意，CronJob 如果不设置 TimeZone 的话，默认使用的是 kube-controller-manager 进程的 TimeZone 。
之前有遇到小伙伴在这个问题上浪费了一些时间。&lt;/p>
&lt;h2 id="引入-alpha-特性-containercheckpoint">引入 alpha 特性 ContainerCheckpoint&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/104907">#104907 · kubernetes/kubernetes&lt;/a> 这是一个持续了将近一年的 PR，在这个 PR 中引入了一项新的特性：&lt;code>ContainerCheckpoint&lt;/code>。&lt;/p>
&lt;p>对 Docker 比较熟悉的小伙伴，可能知道在 Docker 中存在一个 &lt;code>docker checkpoint&lt;/code> 的子命令。
这个子命令实际上是可以帮助我们为某个正在运行的容器创建一个状态点的快照，并将其保存到磁盘中。&lt;/p>
&lt;p>后续，我们可以使用此 checkpoint 启动容器，恢复其原先的状态，或者将容器迁移到其他的机器上。&lt;/p>
&lt;p>同样的，在 Kubernetes 中提供的这个 &lt;code>ContainerCheckpoint&lt;/code> 的新特性是自 v1.25 开始作为 alpha 特性加入的，默认是关闭的。
利用此特性可以通过 kubelet 提供的 API，为 container 创建一个有状态的快照，然后将其移动到另一个节点上进行调试，或者其他类似的需求。&lt;/p>
&lt;p>此处需要注意的是，创建 checkpoint 可能会产生一些安全隐患，比如 checkpoint 实际上是对当前运行中 container 的内存快照，所以如果在
container 的内存中包含了某些隐私数据，那么有可能在迁移到其他机器上也可以访问到。&lt;/p>
&lt;p>另一方面，创建 checkpoint 会产生一些文件，这些文件是需要占用磁盘的。如果频繁的创建 checkpoint 则可能导致磁盘压力过大。
checkpoint 的存档，默认情况下会放在 &lt;code>/var/lib/kubelet/checkpoints&lt;/code> 目录下，并且以 &lt;code>checkpoint-&amp;lt;podFullName&amp;gt;-&amp;lt;containerName&amp;gt;-&amp;lt;timestamp&amp;gt;.tar&lt;/code> 进行命名。&lt;/p>
&lt;p>这个特性使用起来也很简单，直接给 Kubelet 发送一个请求即可：&lt;/p>
&lt;pre>&lt;code>POST /checkpoint/{namespace}/{pod}/{container}
&lt;/code>&lt;/pre>&lt;p>然后将获取到的归档文件，通过以下命令进行恢复：&lt;/p>
&lt;pre>&lt;code>crictl restore --import=&amp;lt;archive&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="为-kubectl-引入-kuberc-配置文件">为 kubectl 引入 kuberc 配置文件&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/enhancements/pull/3392">KEP-3104&lt;/a> 这个 KEP 旨在为 kubectl 引入一个新的配置文件 &lt;code>kuberc&lt;/code>，用来配置一些用户的自定义配置。这在很多的项目，或者工具中都有类似的用法。比如 Vim 中可以通过 &lt;code>-u&lt;/code> 指定用户自己的配置文件，或者使用默认的 &lt;code>~/.vimrc&lt;/code> 来完成自定义配置。&lt;/p>
&lt;p>这样做的好处就在于可以让 &lt;code>kubeconfig&lt;/code> 更加的专注，仅仅需要保留和集群、用户凭证相关的信息即可，对于用户的自定义配置则分离开来。具体而言，这个配置文件看起来就会是这样：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Preferences&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">aliases&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">alias&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">getdbprod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">get pods -l what=database --namespace us-2-production&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">overrides&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apply&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">server-side&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">delete&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">confirm&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">exec-auth-allowlist&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/kubectl/exec/...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来也比较直观，可以用来增加一些 &lt;code>alias&lt;/code> 和覆盖一些默认的配置，这样大家不再需要定义很多的 alias，以后使用 kubectl 的时候敲的命令也能少很多。
此特性未实现之前，
在这里顺便推荐另一个项目 &lt;a href="https://github.com/ahmetb/kubectl-aliases">kubectl-aliases&lt;/a>，此项目中包含了很多 alias，可以让使用 kubectl 的过程更加简单。&lt;/p>
&lt;p>但也有一些弊端，就像是每个 Vim 用户都要有自己的 vimrc 配置文件一样，这会养成一定的习惯。在一些没有自己自定义配置的机器上使用时，会有些不习惯。
同时，这在排查问题时，也可能增加排查的链路（比如 kuberc 中增加了一个错误的配置之类的）。&lt;/p>
&lt;p>举例来说，我在排查 Vim 的问题时候，通常会直接 &lt;code>vim -u /dev/null&lt;/code> 这样，以防使用了任何自定义配置造成影响。那么后续如果这个功能完全实现了，那么大家在
排查问题的时候，需要注意使用 &lt;code>kubectl --kuberc /dev/null&lt;/code> 类似这样的方式来避免本地自定义配置造成影响。&lt;/p>
&lt;h2 id="为-kubectl-添加---subresource-的补全">为 kubectl 添加 --subresource 的补全&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109070">Add shell completion for new --subresource flag by marckhouzam · Pull Request #109070 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在 Kubernetes v1.24 中，给 kubectl 增加了 subresource 的支持（指 &lt;code>status&lt;/code> 和 &lt;code>scale&lt;/code>），这样就可以很方便的直接对 subresource 进行操作了，而不需要每次都 &lt;code>-o yaml&lt;/code> 之类的直接进行查看，或者通过 curl 之类的调用 API 来完成其他操作。
使用了此特性后，可以有如下效果：&lt;/p>
&lt;pre>&lt;code># v1.24+
tao@moelove:~$ kubectl get -n apisix --subresource status deploy apisix-ingress-controller
NAME AGE
apisix-ingress-controller 2d23h
tao@moelove:~$ kubectl get -n apisix --subresource scale deploy apisix-ingress-controller -ojson
{
&amp;quot;apiVersion&amp;quot;: &amp;quot;autoscaling/v1&amp;quot;,
&amp;quot;kind&amp;quot;: &amp;quot;Scale&amp;quot;,
&amp;quot;metadata&amp;quot;: {
&amp;quot;creationTimestamp&amp;quot;: &amp;quot;2022-08-04T18:57:45Z&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;apisix-ingress-controller&amp;quot;,
&amp;quot;namespace&amp;quot;: &amp;quot;apisix&amp;quot;,
&amp;quot;resourceVersion&amp;quot;: &amp;quot;1656&amp;quot;,
&amp;quot;uid&amp;quot;: &amp;quot;7c191a14-ee55-4254-80ba-7c91b4c833bd&amp;quot;
},
&amp;quot;spec&amp;quot;: {
&amp;quot;replicas&amp;quot;: 1
},
&amp;quot;status&amp;quot;: {
&amp;quot;replicas&amp;quot;: 1,
&amp;quot;selector&amp;quot;: &amp;quot;app.kubernetes.io/instance=apisix,app.kubernetes.io/name=ingress-controller&amp;quot;
}
}
&lt;/code>&lt;/pre>&lt;p>但是在此之前版本使用该参数的话，会直接提示错误：&lt;/p>
&lt;pre>&lt;code># v1.23
tao@moelove:~$ kubectl-v1.23 get -n apisix --subresource status deploy apisix-ingress-controller
Error: unknown flag: --subresource
See 'kubectl get --help' for usage.
&lt;/code>&lt;/pre>&lt;p>此处我提到的这个在 v1.25 中的 PR 实际上是为了给 &lt;code>--subresource&lt;/code> 提供一个命令补全的能力（虽然如上文提到的，目前就两种资源），还是比较方便的。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109074">#109074 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>kubeadm 中为 etcd 的 static Pod 增加了一个 &lt;code>--experimental-initial-corrupt-check&lt;/code> 选项，可以用来确认 etcd member 中数据的一致性。这个特性预期在 etcd 的 v3.6 版本中会正式可用。此外，etcd 的 Release 页面也写了，当前不建议将 etcd 3.5.x 用于生产环境，如果尚未进行升级，可以先继续使用 3.4.x。如果已经升级了，那么可以自行增加此参数；&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109111">Migrate Ginkgo from v1 to v2 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 PR 持续了将近三个月，主要是将 Kubernetes 项目中使用的 Ginkgo 从已经废弃的 v1 版本升级到 v2 版本。&lt;/p>
&lt;p>其实目前很多项目都在积极的推进此事，但不同的项目对 Ginkgo 的依赖和使用程度不同，在这个 PR 中修改了超过 600 个文件，非常的庞大。
而之前在 Apache APISIX Ingress controller 项目中，从 Ginkgo v1 升级到 v2 时，仅仅用了一周时间，修改文件不算太多。
此外目前 Kubernetes Ingress-NGINX 项目也同样在进行此升级，可能工作量也不小。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109479">Introduce KUBECACHEDIR environment variable to override default discovery cache dir by ardaguclu · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 PR 说起来是比较小的一个改动，但是它的影响却很大。&lt;/p>
&lt;p>在这个 PR 中引入了一个新的 &lt;code>KUBECACHEDIR&lt;/code> 环境变量，来替代默认的 &lt;code>~/.kube/cache&lt;/code> 缓存目录。通过这个 PR 就有可能会导致用户在使用 kubectl 的时候，可以通过这个环境变量来跳过
缓存。进而可能会引起一些性能问题。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/110738">kube-apiserver: default --enable-logs-handler flag to false · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>kube-apiserver 中的 &lt;code>/logs&lt;/code> 由于安全问题，默认情况下会进行关闭，然后通过 &lt;code>--enable-logs-handler&lt;/code> 标签进行启用。如果要进行日志采集的话，需要额外注意下。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111060">#111060 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>kube-proxy 的 container image 将要变更为 distroless 的了。
这可以规避很多安全隐患，提升集群的安全性。&lt;/p>
&lt;p>以上就是 Kubernetes v1.25 中比较值得关注的内容。在进行集群升级前一定要注意检查。
好了，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| kube-scheduler 频繁抢占时内存泄漏问题得到修正</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/08/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-kube-scheduler-%E9%A2%91%E7%B9%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%BE%97%E5%88%B0%E4%BF%AE%E6%AD%A3/"/><id>https://moelove.info/2022/08/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-kube-scheduler-%E9%A2%91%E7%B9%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%BE%97%E5%88%B0%E4%BF%AE%E6%AD%A3/</id><updated>2022-08-22T03:24:09+08:00</updated><published>2022-08-21T19:23:19+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周在小伙伴的提醒下，发现在 Kubernetes 官方博客的 &lt;a href="https://kubernetes.io/blog/2022/08/15/meet-our-contributors-china-ep-03/">Meet Our Contributors - APAC (China region)&lt;/a> 中有关于自己的介绍：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/08/21/ujCV6OHay8dJtKB.png" alt="">&lt;/p>
&lt;p>很多人问过我，并且我也在很多场合下聊过，关于 &amp;quot;新人如何参与开源项目&amp;quot; 的话题。&lt;/p>
&lt;p>虽然有不少人会直接建议，&amp;quot;不要想那么多，做就完了。&amp;quot;&lt;/p>
&lt;p>但就我个人而言，我建议在参与开源项目之前，稍微花一点时间进行思考。
当然，我指的 &amp;quot;参与开源项目&amp;quot;，并不仅仅说你给某个项目偶然的提交了一个 issue 或者贡献了一个 PR ，然后就不再去看这个项目了。
我也经常会有在看某个项目的时候，顺手去提个 issue 或者 PR 的情况，但后续可能就不再去关注这个项目了。&lt;/p>
&lt;p>我指的是长期投入。&lt;/p>
&lt;p>如果你真的想要融入某个开源项目/社区，那么我建议你按自己的兴趣来选择项目，这样才更容易会主动的投入时间，
并在其中收获快乐。&lt;/p>
&lt;p>本周仍然很忙, 本篇中主要涉及一些开源项目社区方面的事情，和几个上游相关的 bugfix 。&lt;/p>
&lt;p>下周需要去趟深圳，回来后 Kubernetes v1.25 应该就发布正式版本了。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111773">Fix memory leak on kube-scheduler preemption by amewayne · Pull Request #111773 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这是一个很小的 PR，通过增加了一行 &lt;code>defer cancel()&lt;/code>，修复了 kube-scheduler 频繁抢占时的内存泄漏问题。&lt;/p>
&lt;p>不过社区中其他人也发现了原本那段代码需要进行优化，于是提交了另一个 PR &lt;a href="https://github.com/kubernetes/kubernetes/pull/111775">fix(scheduler): split scheduleOne into two functions for schedulingCycle and bindingCycle by sanposhiho · Pull Request #111775 · kubernetes/kubernetes&lt;/a> 来进行更加彻底的修复。（尚未合并）&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111477">Share a single etcd3 client logger across all clients by negz · Pull Request #111477 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>来自 Crossplane 项目的 @negz 指出，在 Crossplane 项目中，有时候会有上千种 CRD 资源。
他发现当存在约 1900 种 CRD 资源时，kube-apiserver 大约使用了 8Gi RSS 。&lt;/p>
&lt;p>经过分析，发现这是由于未在实例化 etcd3 client 时候共享 logger，所以每个 etcd3 client 实例的时候，都会创建一个自己的 logger，从而导致占用了很多的资源。&lt;/p>
&lt;p>在这个 PR 中是通过在创建 etcd3 client 的时候，传递已经创建好的 logger，让所有的 clients 共享，以此来减少资源的浪费。&lt;/p>
&lt;p>当然，和上述的 PR 类似，他发现目前 Kubernetes 是为每个 CRD 创建一个 etcd client，显然，这应该也是可以优化的，仅仅创建一个 client，共享即可。&lt;/p>
&lt;p>我有点记不清为什么原来是为每个 CRD 创建一个 client 了，但目前他在积极的完成新的 PR #111559 ，期待能顺利完成！&lt;/p>
&lt;h1 id="etcd-项目健康度的担忧">etcd 项目健康度的担忧&lt;/h1>
&lt;p>众所周知，etcd 是 Kubernetes 的核心组件之一，同时它也被大量其他的开源项目所依赖，比如 Apache APISIX 也是使用 etcd 作为其默认的数据存储的。&lt;/p>
&lt;p>但是 etcd 最早的两个维护者，基本上都由于工作变动的原因已经不在 etcd 项目中积极活跃了。后来社区中剩余的一些贡献者开始承担起了该项目的维护工作。&lt;/p>
&lt;p>在几个月之前，etcd 项目现有的维护者们，由于难以达到大多数人的同意，也发起了一次社区治理方案的调整，在决策时改成了惰性共识
&lt;a href="https://github.com/etcd-io/etcd/pull/14053">https://github.com/etcd-io/etcd/pull/14053&lt;/a>&lt;/p>
&lt;p>当前 CNCF TOC 正在讨论 etcd 项目的健康度问题，也许我们可以做点什么，让这个项目变的更好。&lt;/p>
&lt;h1 id="argo-项目毕业提案">Argo 项目毕业提案&lt;/h1>
&lt;p>&lt;a href="https://github.com/cncf/toc/pull/604">Argo Project Graduation Proposal by edlee2121 · Pull Request #604 · cncf/toc&lt;/a>&lt;/p>
&lt;p>这是一个从 2021 年 2 月开始提交的提案，不过中间由于需要进行一些安全审查，以及其他的一些审查及挑战，所以一直没有完成。
近期又重新进行了更新，并且大多数的报告也已经补充，
至少今年应该是可以毕业的吧（我猜测）。&lt;/p>
&lt;p>另外也看到在进行报告补充过程中，Argo 相关的两篇不错的文章，推荐给大家：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.argoproj.io/argo-security-automation-with-oss-fuzz-da38c1f86452">Argo Security Automation with OSS-Fuzz | by Yuan Tang | Argo Project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.argoproj.io/best-practices-for-multi-tenancy-in-argo-cd-273e25a047b0">Best Practices for Multi-tenancy in Argo CD | by Dan Garfield | Argo Project&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="新版本发布">新版本发布&lt;/h1>
&lt;ul>
&lt;li>Trivy 发布了 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.31.0">v0.31 版本&lt;/a>&lt;/li>
&lt;li>Kyma 发布了 &lt;a href="https://github.com/kyma-project/kyma/releases/tag/2.5.0">v2.5 版本&lt;/a>&lt;/li>
&lt;li>Cilium 发布了 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.12.1">v1.12.1 版本&lt;/a>&lt;/li>
&lt;li>Helm 发布了 &lt;a href="https://github.com/helm/helm/releases/tag/v3.9.3">v3.9 版本&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>好了，以上就是这期的内容，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.25 将添加 user namespaces 的支持</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/08/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25-%E5%B0%86%E6%B7%BB%E5%8A%A0-user-namespaces-%E7%9A%84%E6%94%AF%E6%8C%81/"/><id>https://moelove.info/2022/08/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25-%E5%B0%86%E6%B7%BB%E5%8A%A0-user-namespaces-%E7%9A%84%E6%94%AF%E6%8C%81/</id><updated>2022-08-21T22:37:17+08:00</updated><published>2022-08-14T23:25:24+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周同样是忙碌的一周，一个经验分享给大家，优先回答问题而非解释细节。这也就是为什么我经常在文章的开头都会先说明下文章主要涵盖的内容，这样有助于节省时间。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/08/15/LZ3GXudlOpEI4Mc.png" alt="">&lt;/p>
&lt;p>我本周空闲时间基本都在关注上游的进展，没空折腾其他的东西。
Kubernetes v1.25.0-rc.0 已于本周发布，正常情况下会在本月发布正式版本。&lt;/p>
&lt;p>我来介绍一些本周关注到比较值得注意的内容：&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111090">Add support for user namespaces phase 1 (KEP 127) by rata · Pull Request #111090 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这个 PR 实现了 KEP127 的第一阶段，KEP127 旨在为 Pod 添加 user namespaces 的支持。
对 user namespaces 不太熟悉的小伙伴，可以看看我之前的系列文章：&lt;a href="https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/">《搞懂容器技术的基石： namespace （上）》&lt;/a> 和 &lt;a href="https://moelove.info/2021/12/13/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8B/">《搞懂容器技术的基石： namespace （下）》&lt;/a> 。&lt;/p>
&lt;p>在 Kubernetes 中支持使用 user namespaces 的好处在于，可以在与主机有不同 UID/GID 的 Pod 中运行进程，这样在 Pod 内的特权进程
实际是作为主机中的普通进程运行的。这样，假设 Pod 内的特权进程由于安全漏洞被攻破，对主机的影响也可以降到比较低。&lt;/p>
&lt;p>直接相关的漏洞，比如 CVE-2019-5736 ，我也曾在 2019 年的文章 &lt;a href="https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/">《runc 1.0-rc7 发布之际》&lt;/a> 专门介绍过，
感兴趣的小伙伴可以到该文章中了解详情。&lt;/p>
&lt;p>该实现是在 Pod 的 Spec 中添加了布尔类型的 &lt;code>HostUsers&lt;/code> 字段，以决定是否启用主机的 user namespaces，默认是 true 。&lt;/p>
&lt;p>此外，目前可预见的情况是，如果 Kubernetes 集群使用的 Linux 内核版本在 v5.19 以下的话，那么使用该特性可能会导致 Pod 的启动时间增加。&lt;/p>
&lt;p>期待后续的进展。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111620">cleanup: Remove storageos volume plugins from k8s codebase by Jiawei0227 · Pull Request #111620 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111618">cleanup: Remove flocker volume plugins from k8s codebase by Jiawei0227 · Pull Request #111618 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111619">cleanup: Remove quobyte volume plugins from k8s codebase by Jiawei0227 · Pull Request #111619 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在上周的 「k8s生态」中我曾介绍过，in-tree 的 GlusterFS plugin 在 PR #111485 中被废弃。
上述的这几个 PR 所做的事情基本类似，是一些清理操作。&lt;/p>
&lt;p>将 Kubernetes 项目中 &lt;code>StorageOS&lt;/code>，&lt;code>Flocker&lt;/code> 和 &lt;code>Quobyte&lt;/code> 等 in-tree 的卷插件都删除掉了。&lt;/p>
&lt;p>其中 &lt;code>StorageOS&lt;/code> 和 &lt;code>Quobyte&lt;/code> 如果有在使用，建议往 CSI plugin 进行迁移，而 &lt;code>Flocker&lt;/code> 则是由于不再维护了，所以并没有任何迁移计划。&lt;/p>
&lt;p>尽管 &lt;code>Flocker&lt;/code> 不再维护了，不过我觉得还是可以稍微介绍下它 （算是把自己曾记得的一些事情倒出来，大概以后就可以安全删除了，hahah）&lt;/p>
&lt;p>如果是比较早期参与到 Docker/Kubernetes 生态的小伙伴，可能还会记得 Flocker 这个工具，
这个工具主要解决的是容器化应用中数据卷管理的问题，这在 2015 年左右算是容器生态圈最主要解决的问题之一。&lt;/p>
&lt;p>在那个时候，涌现出来很多 Docker volume plugin，做的事情其实都差不多，但这个项目背后的公司/团队却比较有意思。&lt;/p>
&lt;p>这家名为 ClusterHQ 的公司，和现在很多的开源商业化公司类似，以开源软件 Flocker 作为其出发点，先后完成了 Docker/Kubernetes/Mosos 等各种平台的集成，
后续推出了其 SaaS 服务 FlockerHub。&lt;/p>
&lt;p>团队成员也大多数来自于知名开源项目 &lt;a href="https://github.com/twisted/twisted">Twisted&lt;/a>，用 Python 的小伙伴应该很少有人不知道这个项目。
很自然的，Flocker 也是用 Python 构建的。&lt;/p>
&lt;p>但就是这样一家看起来都还不错的公司，在它的 SaaS 服务推出预览版后的一段时间后，就突然宣布关闭了。&lt;/p>
&lt;p>当年很多人猜测，也许是公司将商业核心放在了 SaaS 上，但是该产品并没有真正流行起来。&lt;/p>
&lt;p>其实这类事情在整个容器生态领域，已经发生了很多，并且还在持续的发生。
这背后更多的其实是商业化逻辑，尽管 Flocker 也曾火热一时，但在商业公司关闭后，也就直接停止维护了。&lt;/p>
&lt;p>现在从 Kubernetes 中将其删除，很可能在是流行项目中最后一次看到 Flocker 的名字了。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111435/files">Promote CronJobTimeZone to beta by soltysh · Pull Request #111435 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>CronJob TimeZone 的特性达到了 Beta 阶段。不过根据 Kubernetes 最新的特性策略，该特性仍然需要手动开启 &lt;code>CronJobTimeZone&lt;/code> feature gate 。&lt;/p>
&lt;p>注意，CronJob 如果不设置 TimeZone 的话，默认使用的是 kube-controller-manager 进程的 TimeZone 。
之前有遇到小伙伴在这个问题上浪费了一些时间。&lt;/p>
&lt;h1 id="cloud-native-security-whitepaper-version-10-有声读物发布">Cloud Native Security Whitepaper version 1.0 有声读物发布&lt;/h1>
&lt;p>该音频是 2020 年版本的 Cloud Native Security Whitepaper，可以从 &lt;a href="https://soundcloud.com/user-769472014/sets/cncf-tag-security-cloud-native-security-whitepaper-version-v1">soundcloud&lt;/a> 听到。&lt;/p>
&lt;p>现在 Cloud Native Security Whitepaper v2 的文字版也已经发布，可以从以下仓库中获取到。&lt;/p>
&lt;p>&lt;a href="https://github.com/cncf/tag-security/tree/main/security-whitepaper">https://github.com/cncf/tag-security/tree/main/security-whitepaper&lt;/a>&lt;/p>
&lt;h1 id="cri-dockerd-发布-v025">cri-dockerd 发布 v0.2.5&lt;/h1>
&lt;p>想必大家还记得之前讨论比较多的 Kubernetees 移除其 dockershim 组件的事件，我也专门曾写了一篇文章 &lt;a href="https://moelove.info/2020/12/03/K8S-%E5%BC%83%E7%94%A8-Docker-%E4%BA%86Docker-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%E5%88%AB%E9%80%97%E4%BA%86/">《K8S 弃用 Docker 了？Docker 不能用了？别逗了！》&lt;/a> 对此事件进行说明。&lt;/p>
&lt;p>如今 Kubernetes 已经将其 in-tree 的 dockershim 组件彻底移除，而 Mirantis 也正在如履行其之前的承诺，在维护 &lt;a href="https://github.com/Mirantis/cri-dockerd">Mirantis/cri-dockerd&lt;/a> 项目。&lt;/p>
&lt;p>该项目已经逐步的进入相对规范的维护期，也正在跟随上游进行持续的演进。&lt;/p>
&lt;p>比如在 v0.2.5 版本中，将默认的网络插件修改成了 CNI 。&lt;/p>
&lt;p>如果有小伙伴的 Kubernetes 集群中，仍然使用 Docker 作为容器运行时，并且想要对 Kubernetes 集群进行升级的话，可以查看此项目。
使用起来并不麻烦。&lt;/p>
&lt;p>期待后续的表现。&lt;/p>
&lt;p>好了，以上就是本期的内容，我想发起一个投票了解下大家目前在用的 Kubernetes 版本，欢迎大家参与，在 v1.25 发布后投票自动关闭，届时再和大家分享数据。&lt;/p>
&lt;p>&lt;a href="https://wj.qq.com/s2/10618008/29e3/">https://wj.qq.com/s2/10618008/29e3/&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.25 将 GlusterFS 卷插件废弃</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/08/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25-%E5%B0%86-GlusterFS-%E5%8D%B7%E6%8F%92%E4%BB%B6%E5%BA%9F%E5%BC%83/"/><id>https://moelove.info/2022/08/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.25-%E5%B0%86-GlusterFS-%E5%8D%B7%E6%8F%92%E4%BB%B6%E5%BA%9F%E5%BC%83/</id><updated>2022-08-08T04:16:09+08:00</updated><published>2022-08-07T15:46:01+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周事情比较多，空闲时间基本都在关注上游的进展，没折腾其他的东西。
Kubernetes v1.25 正常情况下会在本月发布正式版本。&lt;/p>
&lt;p>我来介绍一些本周关注到比较值得注意的内容：&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/111485">deprecate GlusterFS plugin from available in-tree drivers. by humblec · Pull Request #111485 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在这个 PR 中废弃了 in-tree 的 GlusterFS 的 plugin，这其实是最早的 dynamic provisioner ，自 Kubernetes v1.4 版本开始引入。&lt;/p>
&lt;p>在后来 CSI 驱动出现的时候，社区中也立刻出现了对应的驱动实现 &lt;a href="https://github.com/gluster/gluster-csi-driver/">https://github.com/gluster/gluster-csi-driver/&lt;/a> ，只不过该项目并没有积极的进行维护。
现在还有另一个比较推荐的替代方案，可以考虑使用 &lt;a href="https://github.com/kadalu/kadalu/">https://github.com/kadalu/kadalu/&lt;/a> 此项目最新的版本为 v0.8.15 。&lt;/p>
&lt;p>经过社区之前的讨论，还是决定在 v1.25 版本开始将 in-tree 的 GlusterFS plugin 标记为废弃，并在后续的版本中进行移除。&lt;/p>
&lt;p>如果有正在使用此插件的小伙伴，我建议可以尽早的评估 kadalu 的可行性 &amp;amp; 迁移成本。&lt;/p>
&lt;p>此外， &lt;strong>这个修改属于完全删除 in-tree 卷插件的一部分，无论你在使用哪种 in-tree 的卷插件，建议尽早迁移至使用 CSI 驱动的模式。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109070">Add shell completion for new --subresource flag by marckhouzam · Pull Request #109070 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在 Kubernetes v1.24 中，给 kubectl 增加了 subresource 的支持（指 &lt;code>status&lt;/code> 和 &lt;code>scale&lt;/code>），这样就可以很方便的直接对 subresource 进行操作了，而不需要每次都 &lt;code>-o yaml&lt;/code> 之类的直接进行查看，或者通过 curl 之类的调用 API 来完成其他操作。
使用了此特性后，可以有如下效果：&lt;/p>
&lt;pre>&lt;code># v1.24+
tao@moelove:~$ kubectl get -n apisix --subresource status deploy apisix-ingress-controller
NAME AGE
apisix-ingress-controller 2d23h
tao@moelove:~$ kubectl get -n apisix --subresource scale deploy apisix-ingress-controller -ojson
{
&amp;quot;apiVersion&amp;quot;: &amp;quot;autoscaling/v1&amp;quot;,
&amp;quot;kind&amp;quot;: &amp;quot;Scale&amp;quot;,
&amp;quot;metadata&amp;quot;: {
&amp;quot;creationTimestamp&amp;quot;: &amp;quot;2022-08-04T18:57:45Z&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;apisix-ingress-controller&amp;quot;,
&amp;quot;namespace&amp;quot;: &amp;quot;apisix&amp;quot;,
&amp;quot;resourceVersion&amp;quot;: &amp;quot;1656&amp;quot;,
&amp;quot;uid&amp;quot;: &amp;quot;7c191a14-ee55-4254-80ba-7c91b4c833bd&amp;quot;
},
&amp;quot;spec&amp;quot;: {
&amp;quot;replicas&amp;quot;: 1
},
&amp;quot;status&amp;quot;: {
&amp;quot;replicas&amp;quot;: 1,
&amp;quot;selector&amp;quot;: &amp;quot;app.kubernetes.io/instance=apisix,app.kubernetes.io/name=ingress-controller&amp;quot;
}
}
&lt;/code>&lt;/pre>&lt;p>但是在此之前版本使用该参数的话，会直接提示错误：&lt;/p>
&lt;pre>&lt;code># v1.23
tao@moelove:~$ kubectl-v1.23 get -n apisix --subresource status deploy apisix-ingress-controller
Error: unknown flag: --subresource
See 'kubectl get --help' for usage.
&lt;/code>&lt;/pre>&lt;p>此处我提到的这个在 v1.25 中的 PR 实际上是为了给 &lt;code>--subresource&lt;/code> 提供一个命令补全的能力（虽然如上文提到的，目前就两种资源），还是比较方便的。&lt;/p>
&lt;ul>
&lt;li>PodSecurityPolicy 已经被删除，请迁移至 PodSecurity Admission Controller&lt;/li>
&lt;/ul>
&lt;p>持续关注「k8s生态」的小伙伴应该还记得，我从去年 Kubernetes v1.21 时候就介绍过，PodSecurityPolicy （PSP）被废弃，将通过内置 PodSecurity Admission 来进行替代。
并且在后续的文章中也曾对 PodSecurity Admission 进行了介绍。&lt;/p>
&lt;p>此外我之前写过 &lt;a href="https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/">《理清 Kubernetes 中的准入控制（Admission Controller)》&lt;/a> 和 &lt;a href="https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/">《云原生策略引擎 Kyverno》&lt;/a> 等文章，介绍一些 Kubernetes 中的 Admission 机制和通用的策略引擎，使用它们也可以作为 PodSecurityPolicy 的替代。&lt;/p>
&lt;p>目前在 v1.25 中，PodSecurityPolicy 已经被删除，如果你之前有在使用 PodSecurityPolicy，并且打算将 Kubernetes 集群升级到 v1.25 的话，请先进行迁移。&lt;/p>
&lt;p>只要你的 Kubernetes 集群版本先升级到 v1.22 以上，并且开启 PodSecurity 特性，那么就可以按照 &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/">Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller | Kubernetes&lt;/a> 进行迁移了。&lt;/p>
&lt;p>或者使用通用的引擎，比如 Kyverno 或者 OPA/Gatekeeper 等进行替代。&lt;/p>
&lt;ul>
&lt;li>cgroup v2 支持达到 GA&lt;/li>
&lt;/ul>
&lt;p>在 2019 年 GitChat 对我的访谈中让我聊 2020 年的技术趋势，我当时的主要观点摘录如下：&lt;/p>
&lt;blockquote>
&lt;p>作为云原生技术的基石，Kubernetes 在 2020 年的热度将会持续上升。而各个公司的集群规模，以及对容器技术的推进都将会持续加大。在经历了初步容器化后，更多的公司将面临的问题是稳定性和性能优化问题。与此同时，service mesh，serverless 等技术也都会逐步得到普遍应用。 从底层次技术的角度来看，cgroups v2 将逐步普及，进而取代 cgroups v1，但这个过程可能需要两三年左右。 整体而言，稳定性和性能优化将会是未来的主旋律。&lt;/p>
&lt;/blockquote>
&lt;p>如今，3 年时间已经过去，Kubernetes v1.25 中对 cgroup v2 的支持已经达到 GA ，和我之前的判断是一样的。&lt;/p>
&lt;p>我之前也写了一篇 &lt;a href="https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/">《一篇搞懂容器技术的基石： cgroup》&lt;/a> ，可能该考虑写篇新的 cgroup v2 了 （笑&lt;/p>
&lt;h1 id="nutanix-objects-违反了-minio-开源许可的后续">Nutanix Objects 违反了 MinIO 开源许可的后续&lt;/h1>
&lt;p>在我上上篇周报中，曾介绍过 Nutanix Objects 违反 MinIO 开源许可事件的背景，如今该事件可能是因为发酵了，
所以 Nutanix 给出了正式的回应，承认他们的违规行为。&lt;/p>
&lt;p>这里简单说一下为什么 Nutanix 坚持不说他们使用了 MinIO 呢？这是由于对于海外的 Gartner 魔力象限和 GigaOm Radar 之类的行业顶级评估报告而言，
如果他们使用了 MinIO 那么就不再是一个独立的软件，在进行评估的时候，会把它们排除在外。当然，应该还会有一些其他商业上的原因。&lt;/p>
&lt;p>另一方面，Nutanix 的客户如果根据此事件要求 Nutanix 的赔偿，需要检查下与 Nutanix 的赔偿条款是否有覆盖的这个部分。&lt;/p>
&lt;p>从 2019 年至今，这算是一个耗时相对较久的侵权事件了。这也可以反映出开源软件协议/许可被侵权，其实是一个相对不那么容易维权的事情。
维权成本比较高。&lt;/p>
&lt;p>如果不是 MinIO 背后还有个商业公司会盯着这个事情，也许这事情就不了了之了。&lt;/p>
&lt;p>好了，以上就是本期的内容，我想发起一个投票了解下大家目前在用的 Kubernetes 版本，欢迎大家参与，在 v1.25 发布后投票自动关闭，届时再和大家分享数据。&lt;/p>
&lt;p>&lt;a href="https://wj.qq.com/s2/10618008/29e3/">https://wj.qq.com/s2/10618008/29e3/&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes 新版本引入 ContainerCheckpoint 特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/07/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E6%96%B0%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5-ContainerCheckpoint-%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2022/07/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-%E6%96%B0%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5-ContainerCheckpoint-%E7%89%B9%E6%80%A7/</id><updated>2022-08-01T13:58:44+08:00</updated><published>2022-07-31T23:27:33+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周折腾的一个比较有意思的事情是在 Azure 的 VM 上跑了 Google Cloud Build，并修复了 Ingress-NGINX 的一个 &lt;a href="https://prow.k8s.io/view/gs/kubernetes-jenkins/logs/post-ingress-nginx-build-e2e-image/1548900213035372544#">CI 问题&lt;/a>。&lt;/p>
&lt;p>参与过 Kubernetes 社区相关项目贡献的小伙伴应该都知道，Kubernetes 社区相关项目的自动化主要都是构筑在 Prow 之上的。
而 Prow 使用的基础设施则是 Google Cloud，比如其中一项镜像构建的能力是使用了 Google Cloud Build，镜像存储也使用了它的 Container Registry。&lt;/p>
&lt;p>在这周之前我下意识认为如果想要对 CI 中的一些基础配置进行调试，那就需要在 PR 中触发 Google Cloud Build 的任务才行，或者
是直接在 Google Cloud 的控制台进行一些管理操作。&lt;/p>
&lt;p>但本周遇到的问题其实是在 Prow 的配置上(test-infra) ，并非 Ingress-NGINX 项目中具体的 cloudbuild.yml 任务的错误。而 test-infra 中的
配置并不容易调试，因为一旦 test-infra 中的 PR 合并就意味着配置发生变更，那么它将会直接影响到对应项目的所有后续 Job。&lt;/p>
&lt;p>所以 test-infra 中的配置变更，需要尽可能的保证它是正确的。这也就促使我需要去调试 Prow 中的任务了。&lt;/p>
&lt;p>在这个过程中我听取了两个小伙伴 @BenTheElder @Itsuugo 的建议，发现竟然可以在 &lt;a href="https://cloud.google.com/build/docs/build-debug-locally?hl=en">本地进行 Cloud Build 任务的调试&lt;/a>&lt;/p>
&lt;p>完成这件事本身倒是比较容易，找一个网络顺畅的机器，安装 Google Cloud CLI 和 &lt;code>cloud-build-local&lt;/code> 工具，主要需要安装一些依赖，比如 Docker 等。
安装完成后，进行 Google Cloud CLI 的授权，
然后 clone 具体需要进行调试的项目，通过传递 cloudbuild.yml 文件给 &lt;code>cloud-build-local&lt;/code> 工具即可。&lt;/p>
&lt;p>说这件事有意思，主要在于在我的潜意识里，各家云厂商的 CLI/SDK 都仅仅是给自家服务使用的，通常还都是使用内部的一些地址，以及特殊的授权。
从来没有考虑过竟然还可以在其他厂商的环境中使用（并且工作良好）。&lt;/p>
&lt;p>在这件事结束后，我发了条动态，也确实还有人问我 &amp;quot;这真的可能吗？&amp;quot; 2333&lt;/p>
&lt;p>遇到问题的时候还是多尝试，潜意识有可能会误导自己的。&lt;/p>
&lt;p>另外，在上一篇周报中，我提到的 mTLS 的问题已经得到解决，实际上只是一个低级的环境问题。
我也正在兑现上篇中的 flag，近期会分享一篇 mTLS 相关的文章，敬请期待！&lt;/p>
&lt;h1 id="apache-apisix-ingress-controller-150-rc1-发布">Apache APISIX Ingress controller 1.5.0-rc1 发布&lt;/h1>
&lt;p>目前 &lt;a href="https://github.com/apache/apisix-ingress-controller" title="Apache APISIX Ingress">Apache APISIX Ingress controller&lt;/a> 项目已经进入了 v1.5 的发布窗口，目前会先发布 1.5.0-rc1 版本，
待投票流程结束后，将会有正式的公告和对应的 Release 发布。&lt;/p>
&lt;p>距离上一个特性版本 v1.4.0 发布已经过去了将近 7 个月的时间，这期间我们进行了大量的开发工作，有 144 次提交和 28 位贡献者参与，感谢大家的参与让这个版本有了很大的不同。
这里我列一些主要的变化，后续还会有专门的发版公告和特性解读文章等。&lt;/p>
&lt;p>在这个版本中，正式将所有 CRD 资源的 API version 升级到了 v2 stable ，这也标志着用户使用起来会更加的方便和统一，同时这些资源也已经过多个版本迭代和用户在生产环境的使用，达到了足够稳定的级别。&lt;/p>
&lt;p>此外，在这个版本中提供了对 Gateway API 的支持，不过此特性目前尚处于实验性质，默认不开启，用户可以通过为它传递 &lt;code>enable_gateway_api=true&lt;/code> 的配置项来开启此能力。在下个版本中我们将引入 Gateway API 项目的一致性测试，来保证我们的实现与 Gateway API 项目的一致性。这样做的好处在于凡是通过了 Gateway API 一致性校验的实现，均可进行互相替换，不会存在锁定的情况。而且在迁移的过程中，也可以保证配置的兼容性。&lt;/p>
&lt;p>Apache APISIX Ingress controller 项目是支持多种配置方式的，无论使用 CRD 的方式，或者使用 Kubernetes 中原生的 Ingress 资源都是可以的。但在之前版本中，对于 Ingress 资源来说，想要使用 APISIX 提供的 plugin 能力，就必须先实现一个对应的 annotation，这种方式可扩展能力很差。
在这个版本中，我们为 Ingress 资源提供了一个新的 annotation 允许所有的 Ingress 资源可以直接使用 APISIX 所提供的 70+ 种 plugin 的能力，这对于一些使用开源的仅支持配置 Ingress 资源的用户而言，是非常有用的。&lt;/p>
&lt;p>除去这些新功能外，目前无论是开源项目的维护者，还是使用者，都在积极的关注供应链安全。在 Apache APISIX Ingress controller 中，我们也升级了它使用的 Golang 版本，以及所有依赖的模块均升级到了最新版本，并且借助 GitHub 的 Dependabot 进行依赖的周期性扫描和更新，尽可能的提供安全可信的软件。&lt;/p>
&lt;p>这里我先介绍这么多，大家如果对此项目感兴趣，欢迎在 GitHub 加个 star &lt;a href="https://github.com/apache/apisix-ingress-controller">https://github.com/apache/apisix-ingress-controller&lt;/a>&lt;/p>
&lt;p>发布流程未结束前，也可直接从最新的代码中构建镜像尝试使用。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/104907">#104907 · kubernetes/kubernetes&lt;/a> 这是一个持续了将近一年的 PR，在这个 PR 中引入了一项新的特性：&lt;code>ContainerCheckpoint&lt;/code>。&lt;/p>
&lt;p>对 Docker 比较熟悉的小伙伴，可能知道在 Docker 中存在一个 &lt;code>docker checkpoint&lt;/code> 的子命令。
这个子命令实际上是可以帮助我们为某个正在运行的容器创建一个状态点的快照，并将其保存到磁盘中。&lt;/p>
&lt;p>后续，我们可以使用此 checkpoint 启动容器，恢复其原先的状态，或者将容器迁移到其他的机器上。&lt;/p>
&lt;p>同样的，在 Kubernetes 中提供的这个 &lt;code>ContainerCheckpoint&lt;/code> 的新特性是自 v1.25 开始作为 alpha 特性加入的，默认是关闭的。
利用此特性可以通过 kubelet 提供的 API，为 container 创建一个有状态的快照，然后将其移动到另一个节点上进行调试，或者其他类似的需求。&lt;/p>
&lt;p>此处需要注意的是，创建 checkpoint 可能会产生一些安全隐患，比如 checkpoint 实际上是对当前运行中 container 的内存快照，所以如果在
container 的内存中包含了某些隐私数据，那么有可能在迁移到其他机器上也可以访问到。&lt;/p>
&lt;p>另一方面，创建 checkpoint 会产生一些文件，这些文件是需要占用磁盘的。如果频繁的创建 checkpoint 则可能导致磁盘压力过大。
checkpoint 的存档，默认情况下会放在 &lt;code>/var/lib/kubelet/checkpoints&lt;/code> 目录下，并且以 &lt;code>checkpoint-&amp;lt;podFullName&amp;gt;-&amp;lt;containerName&amp;gt;-&amp;lt;timestamp&amp;gt;.tar&lt;/code> 进行命名。&lt;/p>
&lt;p>这个特性使用起来也很简单，直接给 Kubelet 发送一个请求即可：&lt;/p>
&lt;pre>&lt;code>POST /checkpoint/{namespace}/{pod}/{container}
&lt;/code>&lt;/pre>&lt;p>然后将获取到的归档文件，通过以下命令进行恢复：&lt;/p>
&lt;pre>&lt;code>crictl restore --import=&amp;lt;archive&amp;gt;
&lt;/code>&lt;/pre>&lt;p>另一个值得注意的变更是，kube-proxy 的 container image 将要变更为 distroless 的了。&lt;a href="https://github.com/kubernetes/kubernetes/pull/111060">#111060 · kubernetes/kubernetes&lt;/a>&lt;/p>
&lt;p>这可以规避很多安全隐患，提升集群的安全性。&lt;/p>
&lt;p>好了，这期主要就这些内容，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Cilium 新版本 Ingress/ServiceMesh/MultiCluster 等特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/07/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-%E6%96%B0%E7%89%88%E6%9C%AC-Ingress/ServiceMesh/MultiCluster-%E7%AD%89%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2022/07/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-%E6%96%B0%E7%89%88%E6%9C%AC-Ingress/ServiceMesh/MultiCluster-%E7%AD%89%E7%89%B9%E6%80%A7/</id><updated>2022-07-25T03:25:11+08:00</updated><published>2022-07-25T00:17:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周我花费了比较多的时间在 mTLS (mutual TLS) 上。
主要解决两方面的问题：&lt;/p>
&lt;ul>
&lt;li>客户端与 APISIX 通过 mTLS 进行交互；&lt;/li>
&lt;li>将 APISIX 放入开启 mTLS 的 Istio 环境；&lt;/li>
&lt;/ul>
&lt;p>具体细节这里不再展开，简单聊聊这中间一些有趣的事情。&lt;/p>
&lt;p>不知道大家在进行自签证书的时候是如何来做的，
我个人是习惯于直接使用 &lt;code>openssl&lt;/code> 直接进行手动签发。 &lt;s>(搞 Kubernetes 的传统手艺)&lt;/s>&lt;/p>
&lt;p>但在我处理上述第一个问题时，发现未能按预期生效，这让我对自己产生了怀疑，难道是自己太久不自签证书手艺丢了？
毕竟现在包括 Kubernetes 集群证书到期也都是直接 renew 就可以，自签证书频度很低了。&lt;/p>
&lt;p>本着求真务实（&lt;s>盲目自信&lt;/s>）的心态，快速的用 Go 写了个小工具，把自己的这些证书丢进去验证了下，
果然，传统手艺没有丢，在自己的工具中使用这些证书是可以正常的进行 mTLS 通信的。所以我给 APISIX 提交了一个
&lt;a href="https://github.com/apache/apisix/issues/7526">issue&lt;/a>&lt;/p>
&lt;p>如果下周这个问题解决了，我会写篇文章给大家分享下 mTLS 相关的内容，敬请期待（flag++）&lt;/p>
&lt;h1 id="kube-vip-发布了-v050-版本">kube-vip 发布了 v0.5.0 版本&lt;/h1>
&lt;p>kube-vip 这个项目可能有些小伙伴不是很熟悉，我来简单介绍下。
这个项目为 Kubernetes 集群控制面高可用部署提供了虚 IP 和负载均衡。同时也为 &lt;code>LoadBalancer&lt;/code> 类型的 Service 提供了支持。
并且这些能力不依赖于任何外部的软硬件。&lt;/p>
&lt;p>这对于大多数自行部署 Kubernetes 集群的公司/团队来说都是很常见的需求，并且这个项目跟 kubeadm 搭配使用还是很方便的。&lt;/p>
&lt;p>本次发布的 v0.5.0 目前还是一个 pre-release 的状态。其中带来了非常重要的特性：&lt;/p>
&lt;ul>
&lt;li>Wireguard 模式，Wireguard 我在这里就不再介绍了，强烈推荐大家去了解下它；&lt;/li>
&lt;li>路由表模式，这允许进行配置一些额外的路由技术，比如 ECMP 等。这将极大的满足企业的一些具体的网络需求；&lt;/li>
&lt;li>支持了 Load Balancer Class；&lt;/li>
&lt;li>新增一种 local 的 External Policy 模式；&lt;/li>
&lt;/ul>
&lt;p>整体而言，这个版本还是非常值得期待的。
这个项目未来将会增加更多的网络模式以及提供更加丰富的功能。&lt;/p>
&lt;h1 id="cilium-v112-正式发布">Cilium v1.12 正式发布&lt;/h1>
&lt;p>可以说 Cilium v1.12 版本是最近几个版本中影响最大的一个版本，包含了很多新的特性和变更，我们一起来看看：&lt;/p>
&lt;p>在之前我曾经介绍过 Cilium 的 Service Mesh，也曾介绍如何使用 Cilium Ingress ，但那时候这些功能尚未完全稳定。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>现在的 v1.12 中携带了完整的 Ingress controller 实现，以便于提供 L7 的负载均衡能力，并且跟 cilium 的
NetworkPolicy 及可观测性等功能可以完美集成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service Mesh 功能，提供多控制面，Envoy CRD 等实现，并且利用其 eBPF 能力的加持，提供了无 sidecar 模式的
服务网格能力。这也是一个非常显著的特性，并且与现在主流使用的 sidecar 模型的服务网格方案有了极大的不同。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cilium 的出口网关 EgressGateway 也正式达到了 stable 级别，并且提供了 CiliumEgressGatewayPolicy 的 CRD
让用户可以更加方便的控制集群出口流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pod 的 BBR 拥塞控制能力，如果没有记错，Cilium 应该是第一个支持此特性的 CNI，这可以方便实现更大的吞吐和低延迟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cilium 现在可以安装一条路由，在 Pod 删除时会发送 ICMP unreachable host 通知，以避免其他的 Pod 访问到正在删除的 Pod, 这个功能我感觉是非常不错的。目前这是一个可选行为，但后续应该会成为一个默认行为。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于 Cilium v1.12 版本的新特性可参考其 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.12.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="nutanix-objects-违反了-minio-的开源协议">Nutanix Objects 违反了 MinIO 的开源协议&lt;/h1>
&lt;p>MinIO 我之前有稍微介绍过，不过可能有些小伙伴之前未接触过，我这里同样简单的介绍下。
MinIO 是一个高性能的云原生对象存储产品，可作为 Kubernetes 中分布式存储的一个技术选型。
我个人还是比较喜欢这个项目的，目前尚未遇到什么太大的坑，有兴趣的小伙伴可以去了解下。&lt;/p>
&lt;p>MinIO 使用 AGPL v3 进行开源许可，其创始团队坚信最优秀的软件一定是通过社区协作制作的，
因此人们可以随意的进行创新和改进。&lt;/p>
&lt;p>这里提到的 Nutanix Objects 则是一款基于 MinIO 构建的商业化产品，但类似于很多商业公司
侵权行为一样，Nutanix Objects 并未披露过其是基于 MinIO 进行构建的，以及也并未将任何对 MinIO
的修改进行公开。&lt;/p>
&lt;p>这导致了近期 MinIO 宣布会根据开源许可证的条款，撤销对 Nutanix 的一切许可。&lt;/p>
&lt;p>可能有小伙伴会好奇，为什么我会写到这个事情。其实商业公司对开源项目的侵权事件有很多，
这里提到对 MinIO 的侵权事件只是众多事件中的一例。
只不过我对 MinIO 这个项目还是比较看好的，所以就多关注了一些。&lt;/p>
&lt;p>另一方面，我也挺想看到这类 AGPL 协议侵权的事件会如何解决，毕竟它和我们常用到的 Apache v2 之类的协议
还是有很大不同的。&lt;/p>
&lt;p>具体的信息可以从 &lt;a href="https://blog.min.io/nutanix-objects-violates-minios-open-source-license/">MinIO 官方博客&lt;/a>
看到。&lt;/p>
&lt;p>最近没有关注到其他特别值得聊的内容了，我们下期再见！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes Ingress-NGINX 功能冻结前最后一个版本发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/07/17/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-Ingress-NGINX-%E5%8A%9F%E8%83%BD%E5%86%BB%E7%BB%93%E5%89%8D%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2022/07/17/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-Ingress-NGINX-%E5%8A%9F%E8%83%BD%E5%86%BB%E7%BB%93%E5%89%8D%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</id><updated>2022-07-18T00:59:17+08:00</updated><published>2022-07-17T21:07:24+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本周仍然是忙碌的一周，赶在 deadline 提交了 ApacheCon Asia 2022 的分享内容，活动是在月底进行，大家如果感兴趣的话可以参与到线上活动中。&lt;/p>
&lt;p>下周 7 月 20 日晚上，我也将在中国 DevOps 社区带来题目为 《打造 Kubernetes 上更好用的 Ingress controller》的直播分享，
大家如果感兴趣也可以参与在线直播。在公众号后台回复 &amp;quot;kic&amp;quot; 获取活动海报和直播地址等。&lt;/p>
&lt;h1 id="kubernetes-ingress-nginx-v130-正式发布">Kubernetes Ingress-NGINX v1.3.0 正式发布&lt;/h1>
&lt;p>本周我们发布了 Kubernetes Ingress-NGINX 的 v1.3.0 版本，
正如我在之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/537186167">K8S 生态周报| Ingress NGINX 项目暂停接收新功能将专注于稳定性提升&lt;/a> 中介绍的，
我们接下来会投入 6 个月的时间，用于项目稳定性的提升。&lt;/p>
&lt;p>本次发布的 v1.3.0 版本，将会是正式进入功能冻结期前的最后一个功能版本，接下来 6 个月不会再发布新的功能版本，但如果有需要会发布一些 bugfix 版本。&lt;/p>
&lt;p>以下是此版本中的最值得关注的变更：&lt;/p>
&lt;ul>
&lt;li>删除了对 Kubernetes v1.19 版本及以下的变更；&lt;/li>
&lt;li>增加了对 Kubernetes v1.24 版本的支持；&lt;/li>
&lt;li>从这个版本开始，需要增加 &lt;code>coordination.k8s.io/leases&lt;/code> 资源的授权来进行 leaderelection&lt;/li>
&lt;/ul>
&lt;p>本次共有 18 位贡献者参与，感谢大家的贡献！&lt;/p>
&lt;p>如果大家在使用中有遇到问题，或者发现 bug 等，欢迎在 GitHub 上提交 issue 进行反馈。&lt;/p>
&lt;p>更多详细变更，请参考其 &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.3.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="kubernetes-gateway-api-达到-beta-阶段">Kubernetes Gateway API 达到 Beta 阶段&lt;/h1>
&lt;p>随着 Kubernetes Gateway API 项目的 v0.5.0 版本的发布，其中最重要的几个 API 资源已经达到了 Beta 阶段，
同时社区也发展的很快，各类实现都在积极跟进。比如我正在做的 &lt;a href="https://github.com/apache/apisix-ingress-controller/">Apache APISIX Ingress 项目&lt;/a>，目前
已经基本实现了 Gateway API 中主要资源的支持，
如果有小伙伴想要体验可以直接使用项目源代码进行构建，或者等下个 Release 发布。&lt;/p>
&lt;p>那么什么是 Gateway API 呢？实际上它就是一套自定义资源的规范集合，各类 Ingress controller 项目通过实现此规范
来进行集成。并且 Gateway API 相比于 Ingress 资源来讲，它具备更加丰富的表现力，同时社区也在积极的扩展其应用场景。&lt;/p>
&lt;p>本次的 v0.5.0 版本的发布，主要是将以下 3 种资源升级到了 &lt;code>v1beta1&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>GatewayClass&lt;/li>
&lt;li>Gateway&lt;/li>
&lt;li>HTTPRoute&lt;/li>
&lt;/ul>
&lt;p>你可以通过官方文档中的 &lt;a href="https://gateway-api.sigs.k8s.io/implementations/">Implementations&lt;/a> 查看到当前各种实现对 Gateway API 的支持程度。&lt;/p>
&lt;p>另一方面：Gateway API 也在探索其与 Service mesh 的结合点。本次也重点宣布了其与
Cilium Service Mesh, Consul, Istio, Kuma, Linkerd, NGINX Service Mesh 以及 Open Service Mesh 等社区的协作，
共同组成 GAMMA Initiative ，共同探索 Gateway API 与这些项目的集成等。&lt;/p>
&lt;p>当然，Gateway API 项目也与另一个项目 SMI 进行了讨论，探索通过 Gateway API 来替换 SMI 规范中流量切割特性的可能性，
不过目前还没有讨论结果，我很期待后续的进展。&lt;/p>
&lt;p>如果真的实现了，那么相当于是使用一套 CRD 或者说使用一套规范来完成了南北向和东西向流量的定义。
对应的这些 controller 实现，也都将变成全流量代理平台！这其实和 Apache APISIX 做的事情是一样的，但 APISIX 是具体的实现，而非定义规范。&lt;/p>
&lt;p>我个人对 Gateway API 项目的发展是很看好的，无论是我在维护的 Kubernetes Ingress-NGINX 还是 Apache APISIX Ingress 项目都会很积极的拥抱此项目的。
期待后续进展！&lt;/p>
&lt;h1 id="kyverno-项目达到-cncf-孵化阶段">Kyverno 项目达到 CNCF 孵化阶段&lt;/h1>
&lt;p>Kyverno 是一个为 Kubernetes 实现的策略引擎，用户可以通过 YAML 配置策略，并应用到集群中。
如果对 Kyverno 不太熟悉的小伙伴可以看看我之前的文章 &lt;a href="https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/">《云原生策略引擎 Kyverno》&lt;/a>&lt;/p>
&lt;p>Kyverno 的上手是非常简单的，我在上述文章中也有介绍。&lt;/p>
&lt;p>此外，该项目是在 2020 年 11 月进入 CNCF 成为 sandbox 级别项目的，从进入 CNCF 至今，无论是社区，用户等都有着显著的发展和提升。
现在能达到 CNCF 的孵化阶段，也证明了该项目是非常成功的，有着丰富的用户基数，并且其社区也发展的很健康。&lt;/p>
&lt;p>对此项目感兴趣的小伙伴欢迎去其官网查看文档 &lt;a href="https://kyverno.io/">https://kyverno.io/&lt;/a> ，文档及示例很丰富。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;p>近期 Kubernetes 上游仓库处于特性冻结期，所以相对来说变更并不是特别多。这里说一些比较值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109111">Migrate Ginkgo from v1 to v2 · kubernetes/kubernetes&lt;/a> 这个 PR 持续了将近三个月，主要是将 Kubernetes 项目中使用的 Ginkgo 从已经废弃的 v1 版本升级到 v2 版本。&lt;/li>
&lt;/ul>
&lt;p>其实目前很多项目都在积极的推进此事，但不同的项目对 Ginkgo 的依赖和使用程度不同，在这个 PR 中修改了超过 600 个文件，非常的庞大。
而之前在 Apache APISIX Ingress controller 项目中，从 Ginkgo v1 升级到 v2 时，仅仅用了一周时间，修改文件不算太多。
此外目前 Kubernetes Ingress-NGINX 项目也同样在进行此升级，可能工作量也不小。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109479">Introduce KUBECACHEDIR environment variable to override default discovery cache dir by ardaguclu · kubernetes/kubernetes&lt;/a> 这个 PR 说起来是比较小的一个改动，但是它的影响却很大。&lt;/li>
&lt;/ul>
&lt;p>在这个 PR 中引入了一个新的 &lt;code>KUBECACHEDIR&lt;/code> 环境变量，来替代默认的 &lt;code>~/.kube/cache&lt;/code> 缓存目录。通过这个 PR 就有可能会导致用户在使用 kubectl 的时候，可以通过这个环境变量来跳过
缓存。进而可能会引起一些性能问题。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/110738">kube-apiserver: default --enable-logs-handler flag to false · kubernetes/kubernetes&lt;/a> kube-apiserver 中的 &lt;code>/logs&lt;/code> 由于安全问题，默认情况下会进行关闭，然后通过 &lt;code>--enable-logs-handler&lt;/code> 标签进行启用。如果要进行日志采集的话，需要额外注意下。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Cilium 新版本发布默认开启 ICMP 策略防护</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/07/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF-ICMP-%E7%AD%96%E7%95%A5%E9%98%B2%E6%8A%A4/"/><id>https://moelove.info/2022/07/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF-ICMP-%E7%AD%96%E7%95%A5%E9%98%B2%E6%8A%A4/</id><updated>2022-07-11T02:05:38+08:00</updated><published>2022-07-10T23:16:51+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>你有没有考虑过，也许作为工程师，我们的设备可以更简单？&lt;/p>
&lt;p>最近两周我进行了一些&lt;s>不开电脑的&lt;/s>尝试。尤其是本周，我的大多数工作都是用 iPad 完成的。&lt;/p>
&lt;p>具体而言，在写代码和测试方面，我使用了 GitHub 的 Codespaces，
这是 GitHub 推出的一个云端开发环境，与 Gitpod 比较类似。&lt;/p>
&lt;p>主要的区别在与 Gitpod 是通过启动一个安全容器来提供环境，而 GitHub Codespaces 则是启动了一个新的 VM，所以这两者比较
而言，GitHub Codespaces 会更贵一些。&lt;/p>
&lt;p>速度方面，Gitpod 号称自己更快，不过就目前的网络环境而言，我倒是没有明显的感觉。&lt;/p>
&lt;p>体验方面，GitHub Codespaces 其实就是云端的 Visual Studio Code，我之前没怎么用过，
偶尔还是会继续我之前的习惯，直接在它的终端下就 Vim 编辑文件了。启动环境后默认是 4C8G，比我的电脑差很多，
但只是用来编码和运行测试也足够。&lt;/p>
&lt;p>我觉得它做的比较好的点在于，启动环境后默认就进行了 Github 的授权，尽管代码仓库配置的都是 HTTPS 的连接，
但无需密码或者私钥均可直接提交代码。&lt;/p>
&lt;p>其余方面 iPad 上的应用也都能支持。&lt;s>飞书的屏幕共享弱了些，只能全屏直播&lt;/s>&lt;/p>
&lt;p>总的来说，体验还不错，基本的需求可以满足，也不需要自己额外维护云端环境。
弊端在于网络环境并不稳定，浏览器内进行操作，相比本地感觉慢了一点。而且我个人还是更喜欢直接用 Vim 能更快点。&lt;/p>
&lt;p>但从我这次的尝试来看，也许之后将环境都迁移到云端后，使用的设备可以更加简单轻量。
甚至用手机连到云端也可以完成很多事情。&lt;/p>
&lt;h1 id="thanos-v0270-正式发布">Thanos v0.27.0 正式发布&lt;/h1>
&lt;p>Thanos 从上个版本到现在也就不到 3 个月的时间，变化不算太大，如果想要升级则需要注意如下内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Ruler: 检查是否设置了 &lt;code>--eval-interval&lt;/code> 参数，如果你没有设置这个参数，并且在生成规则的时候还依赖这个值的话，那么本次升级就会带来比较严重的影响。新版本中将这个值从 30s 调整到了 1 分钟，这是为了能更好的符合 Prometheus 告警生成器规范。https://github.com/prometheus/compliance/blob/main/alert_generator/specification.md#executing-an-alerting-rule&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/thanos-io/thanos/pull/5410">#5410&lt;/a>: 在 Query 中添加了一些 &lt;code>defer qry.Close()&lt;/code>，添加这个代码可以在每次查询结束后，自动调用 &lt;code>Close()&lt;/code>，这可以在内存回收中减少一些波动；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>此外，这个版本中还添加了一个比较有趣的特性，为 &lt;code>Receive&lt;/code> 添加了一种新的哈希算法 &lt;a href="https://github.com/thanos-io/thanos/pull/5408">#5408&lt;/a>。之前的实现中默认都是使用 &lt;code>hashmod&lt;/code>，现在可以通过 &lt;code>--receive.hashrings-algorithm=ketama&lt;/code> 来使用 ketama 一致性哈希算法了。&lt;/p>
&lt;p>这里简单来说下之前算法的问题，使用 &lt;code>hashmod&lt;/code> 几乎是最为简单的分片方式，但是一旦副本数有调整的时候，这就会导致跳过某些分片。想要在生产环境中大规模使用此系统或者想要动态的使用此系统的时候，都是需要解决这个问题的。&lt;/p>
&lt;p>&lt;code>ketama&lt;/code> 算是一个可以比较好的解决扩/缩容场景，以及在平衡性方面表现还不错的算法了，在很多的系统中都可以使用类似的能力，比如设计缓存系统之类的。
当然，后续也许还会增加其他哈希算法，但这终究还是要看实际的规模，以及在性能 &amp;amp; 资源 &amp;amp; 功能 方面的权衡了。&lt;/p>
&lt;h1 id="cilium-v1120-rc3-发布">Cilium v1.12.0-rc3 发布&lt;/h1>
&lt;p>Cilium v1.12 即将正式发布，在 v1.12 版本中会将 Cilium Service Mesh Ingress 升级至 Stable ，算是一个大的飞跃了。关于此特性，可以查看我之前 Cilium Service Mesh 相关的文章。&lt;/p>
&lt;p>我这里主要介绍一个值得关注的特性，在 &lt;a href="https://github.com/cilium/cilium/pull/20174">#20174&lt;/a> 中将 ICMP network policy 功能默认开启了。&lt;/p>
&lt;p>其实 Cilium 在去年就已经支持在配置 CiliumNetworkPolicy 的时候配置 ICMP 协议了，但是由于 eBPF 程序 Size 的问题，默认没有启用。
现在该问题已经解决，所以可以默认将它开启了，
该配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium.io/v2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumNetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;icmp-policy-deny&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">description&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;ICMP policy deny&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">endpointSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">app1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ingressDeny&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">fromEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">app2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">icmps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">fields&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这可以用来提供更加安全的网络环境，避免攻击者利用 ICMP 了解你的网络，或者进行攻击。&lt;/p>
&lt;p>额外一说，在配置中 &lt;code>icmps[].fields[].type&lt;/code> 为 8 表示是 IPv4，如果是 IPv6 则是 128 。&lt;/p>
&lt;p>此外，如果你使用的 CNI 是 Calico 的话，也是支持 ICMP 的 NetworkPolicy 配置的。
我是 Calico 的社区大使，最近有篇对我的专访，有兴趣的小伙伴可以看看：https://sourl.cn/uG7bRn&lt;/p>
&lt;h1 id="cert-manager-v190-beta1-发布">cert-manager v1.9.0-beta.1 发布&lt;/h1>
&lt;p>cert-manager 想必大家不会太陌生，它是在 Kubernetes 和 OpenShift 集群中最简单的证书管理工具。&lt;/p>
&lt;p>在 v1.9 版本中主要是进行一些项目的稳定性和质量提升，以及增加一些新功能和提升用户体验。&lt;/p>
&lt;p>在这个版本中有几个比较值得注意的功能:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>为 Ingress 资源新增了一个 &lt;code>cert-manager.io/revision-history-limit&lt;/code> annotation，这样可以控制 CertificateRequests 的历史记录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为 Ingress 资源添加了一组关于 private-key 相关的 annotation，比如 &lt;code>cert-manager.io/private-key-algorithm&lt;/code> 之类的，可以控制其生成算法，编码格式，保存时间等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其他的功能则包含一些 bugfix，以及一些新的 metrics 等。如果想升级到新版本，基本上是比较平滑的。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;p>最近社区还在 Kubernetes v1.25 版本的发布流程中，此版本中目前有 55 个跟踪的功能。&lt;/p>
&lt;p>有个跨越了近一年的新特性目前还在 review 中，为 kubelet 提供 OpenTelemetry 的 tracing 能力。&lt;/p>
&lt;p>这样可以更容易的去进行 kubelet 的问题定位，以及可以通过 OpenTelemetry 采集 CNI/CRI/CSI 等接口的调用情况等。
希望它能顺利的在 v1.25 完成。&lt;/p>
&lt;p>感兴趣的小伙伴可以参考：&lt;a href="https://github.com/kubernetes/enhancements/pull/2832/files">KEP-2831: Instrumenting Kubelet for OpenTelemetry Tracing&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Ingress NGINX 项目暂停接收新功能将专注于稳定性提升</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/07/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Ingress-NGINX-%E9%A1%B9%E7%9B%AE%E6%9A%82%E5%81%9C%E6%8E%A5%E6%94%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E5%B0%86%E4%B8%93%E6%B3%A8%E4%BA%8E%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8F%90%E5%8D%87/"/><id>https://moelove.info/2022/07/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Ingress-NGINX-%E9%A1%B9%E7%9B%AE%E6%9A%82%E5%81%9C%E6%8E%A5%E6%94%B6%E6%96%B0%E5%8A%9F%E8%83%BD%E5%B0%86%E4%B8%93%E6%B3%A8%E4%BA%8E%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8F%90%E5%8D%87/</id><updated>2022-07-10T23:17:17+08:00</updated><published>2022-07-03T10:10:04+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 题外话 大家好，我是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本次我将这个部分放在开头。聊聊最近的一些情况。&lt;/p>
&lt;p>「K8S 生态周报」暂停了 2 个多月的时间，期间也有小伙伴来催更，感谢大家的持续关注！！！&lt;/p>
&lt;p>主要有两方面的原因，一是我近期确实比较忙，另一方面是我进行了一些思考和总结，分享给大家。&lt;/p>
&lt;p>「K8S 生态周报」从 2019 年的 3 月开始，到现在已经是第四年了，我也一直在思考，它能为我，还有关注我的读者小伙伴们带来什么。&lt;/p>
&lt;p>对我而言，这是一个总结归档，分享反馈的过程，在此期间我也成长了很多。&lt;/p>
&lt;p>我比较开心的事情是，相比于其他人/其他社区发的日报，周报等，「K8S 生态周报」并不单纯的是在搬运链接，或者搬运 ChangeLog，
在每期的内容中，除去资讯本身外，我也会增加我的一些个人看法，还有我所了解到的一些其他内容，包括一些背景知识等。
此外，还会包括一些代码的分析/功能的实践和对比等。可以说「K8S 生态周报」是更有技术性的内容。&lt;/p>
&lt;p>基于以上的一些分析和个人的一些思考，我决定后续「K8S 生态周报」中将加入更多我个人的思考的理解，
在提供这些有价值的资讯的同时，与小伙伴们增加更多的交流和沟通。&lt;/p>
&lt;h2 id="ingress-nginx-项目暂停接收新功能将专注于稳定性提升">Ingress NGINX 项目暂停接收新功能将专注于稳定性提升&lt;/h2>
&lt;p>熟悉我的小伙伴可能知道，我是 Kubernetes Ingress NGINX 项目的 maintainer 。&lt;/p>
&lt;p>经过我们开发团队的长时间讨论，我们发现 Kubernetes Ingress NGINX 项目自 2016 年到现在已经走过了 6 年时间，
在这 6 年的时间里，在 GitHub 上达到了 13K star，同时也有 800+ 位 Contributor 参与贡献此项目，
同时也收到了 4000+ 的 Issue 反馈，以及 4000+ 的 PR 。&lt;/p>
&lt;p>在这个过程中，Ingress NGINX 项目的功能得到了极大的丰富，但作为一个软件，不可避免的也会有各种 bug，漏洞等存在。
目前对于此项目来说，大家会在需要某些功能的时候快速的去实现它（感谢大家贡献的 PR），但是当出现 bug 或漏洞的时候，却很少有人
来修正它。（在开源项目中，这是一个普遍情况，修正 bug 或漏洞，相比于增加新功能，需要对项目自身更加的熟悉）&lt;/p>
&lt;p>这种情况实际上为维护者们增加了很多负担，我们需要把时间放在处理 issue，添加和 review 新功能的 PR，以及进行 bug 和漏洞修正，以及考虑
新功能是否可能会带来一些连锁反应等。&lt;/p>
&lt;p>在上面的数据中，可以看到此项目和社区都是比较活跃的，我们在业余时间进行此项目的维护和开发，整体上压力是比较大的，而且无法做到非常及时的响应。&lt;/p>
&lt;p>近期 Ingress NGINX 项目中报告了一些安全漏洞（已经进行了修复），但在修正过程中，我们发现要完美的修正这些漏洞是比较难的，而且任意的改动都
有可能会引起其他的连锁反应，包括引入其他的漏洞，或者影响用户的某些功能/行为等。&lt;/p>
&lt;p>基于以上的考虑，我们一致达成了决定， &lt;strong>暂停接收新功能，并专注于修复和提升 Ingress NGINX 项目的稳定性&lt;/strong> 。可能你有新的 PR 正在等待合并，
但是很抱歉，希望你能够理解，在我们提升了此项目的稳定性后，我们可以迭代的更快！&lt;/p>
&lt;p>目前我们的计划是用 6 个月的时间来完成此目标，并且我们已经确定了一些具体需要做的事情，你可以通过以下链接了解我们的进度：
&lt;a href="https://github.com/kubernetes/ingress-nginx/projects/52">https://github.com/kubernetes/ingress-nginx/projects/52&lt;/a>&lt;/p>
&lt;p>同时，我们也正式发出了一项社区调查，用于帮助我们决定在此冻结期后，我们应该发展的方向。如果你是 Ingress NGINX 的用户，请填写此表单，谢谢！&lt;/p>
&lt;p>&lt;a href="https://www.surveymonkey.com/r/ingressngx2022">https://www.surveymonkey.com/r/ingressngx2022&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;h3 id="为-kubectl-引入-kuberc-配置文件">为 kubectl 引入 kuberc 配置文件&lt;/h3>
&lt;p>&lt;a href="https://github.com/kubernetes/enhancements/pull/3392">KEP-3104&lt;/a> 这个 KEP 旨在为 kubectl 引入一个新的配置文件 &lt;code>kuberc&lt;/code>，用来配置一些用户的自定义配置。这在很多的项目，或者工具中都有类似的用法。比如 Vim 中可以通过 &lt;code>-u&lt;/code> 指定用户自己的配置文件，或者使用默认的 &lt;code>~/.vimrc&lt;/code> 来完成自定义配置。&lt;/p>
&lt;p>这样做的好处就在于可以让 &lt;code>kubeconfig&lt;/code> 更加的专注，仅仅需要保留和集群、用户凭证相关的信息即可，对于用户的自定义配置则分离开来。具体而言，这个配置文件看起来就会是这样：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Preferences&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">aliases&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">alias&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">getdbprod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">get pods -l what=database --namespace us-2-production&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">overrides&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apply&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">server-side&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">delete&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">confirm&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">exec-auth-allowlist&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">default&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/kubectl/exec/...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来也比较直观，可以用来增加一些 &lt;code>alias&lt;/code> 和覆盖一些默认的配置，这样大家不再需要定义很多的 alias，以后使用 kubectl 的时候敲的命令也能少很多。
此特性未实现之前，
在这里顺便推荐另一个项目 &lt;a href="https://github.com/ahmetb/kubectl-aliases">kubectl-aliases&lt;/a>，此项目中包含了很多 alias，可以让使用 kubectl 的过程更加简单。&lt;/p>
&lt;p>但也有一些弊端，就像是每个 Vim 用户都要有自己的 vimrc 配置文件一样，这会养成一定的习惯。在一些没有自己自定义配置的机器上使用时，会有些不习惯。
同时，这在排查问题时，也可能增加排查的链路（比如 kuberc 中增加了一个错误的配置之类的）。&lt;/p>
&lt;p>举例来说，我在排查 Vim 的问题时候，通常会直接 &lt;code>vim -u /dev/null&lt;/code> 这样，以防使用了任何自定义配置造成影响。那么后续如果这个功能完全实现了，那么大家在
排查问题的时候，需要注意使用 &lt;code>kubectl --kuberc /dev/null&lt;/code> 类似这样的方式来避免本地自定义配置造成影响。&lt;/p>
&lt;h3 id="podsecurity-特性达到-ga">PodSecurity 特性达到 GA&lt;/h3>
&lt;p>近期在 &lt;a href="https://github.com/kubernetes/kubernetes/pull/110459">#110459 · kubernetes/kubernetes&lt;/a> 中正式将 PodSecurity 特性升级到 GA 。如果我没有记错，这个
特性应该是从引入到 GA 最快的特性之一了。&lt;/p>
&lt;p>PodSecurity 是自 Kubernetes v1.22 引入的 alpha 特性，作为 PodSecurityPolicy 的一个替代。在 v1.23 达到 beta 级别，通过上述 PR，在 v1.25 正式 GA ，并且默认启用，可以看到
整个发展过程还是很快的。&lt;/p>
&lt;p>PodSecurity 定义了 3 种级别：&lt;/p>
&lt;ul>
&lt;li>Enforce：如果 Pod 违反策略，则不会被创建；&lt;/li>
&lt;li>Audit：如果 Pod 违反策略，则在审计日志中会被记录，但是 Pod 仍将正常创建；&lt;/li>
&lt;li>Warn：如果 Pod 违反策略，则会在 console 中打印 warning 信息，Pod 仍将正常创建；&lt;/li>
&lt;/ul>
&lt;p>使用起来也很简单，只需要给 namespace 添加 &lt;code>pod-security.kubernetes.io/&amp;lt;mode&amp;gt;=&amp;lt;standard&amp;gt;&lt;/code> 标签即可。&lt;/p>
&lt;p>但是如果你的集群版本较低，并且还希望能有一个相对通用的方法，我建议你可以看看我之前写的文章。&lt;a href="https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2-admission-webhook">《理清 Kubernetes 中的准入控制（Admission Controller)》&lt;/a>
和 &lt;a href="https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/">《云原生策略引擎 Kyverno （上）》&lt;/a>
通过使用 Admission controller 、OPA/GateKeeper、Kyverno 等来完成统一配置。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes CronJob 可直接配置时区了</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/04/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-CronJob-%E5%8F%AF%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%BD%AE%E6%97%B6%E5%8C%BA%E4%BA%86/"/><id>https://moelove.info/2022/04/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-CronJob-%E5%8F%AF%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%BD%AE%E6%97%B6%E5%8C%BA%E4%BA%86/</id><updated>2022-04-11T01:54:50+08:00</updated><published>2022-04-10T23:57:56+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Prometheus blackbox_exporter v0.20.0 正式发布 Prometheus 中……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="prometheus-blackbox_exporter-v0200-正式发布">Prometheus blackbox_exporter v0.20.0 正式发布&lt;/h1>
&lt;p>Prometheus 中的 blackbox_exporter 我们一般使用它进行黑盒监控，比如对一些 HTTP/HTTPS，DNS，TCP 等接口或者请求。&lt;/p>
&lt;p>在这个版本中又增加了很多有趣的特性，我们一起来看看。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/blackbox_exporter/pull/835">#835&lt;/a> 增加了对 gRPC 接口的健康检查，现在 gRPC 用的也越来越多了。要知道在两年前发起类似功能讨论的时候，当时的维护者还认为 gRPC 支持已经超过了项目的职责范围，不过目前可以看到 blackbox_exporter 已经基本涵盖到了我们所需要的各类协议。&lt;/li>
&lt;/ul>
&lt;p>如果你使用了这个功能的话，它会产生一些 metrics 可供我们进行监控告警。&lt;/p>
&lt;pre>&lt;code>probe_grpc_healthcheck_response{serving_status=&amp;quot;UNKNOWN&amp;quot;}=0
probe_grpc_healthcheck_response{serving_status=&amp;quot;SERVING&amp;quot;}=1
probe_grpc_healthcheck_response{serving_status=&amp;quot;NOT_SERVING&amp;quot;}=0
probe_grpc_healthcheck_response{serving_status=&amp;quot;SERVICE_UNKNOWN&amp;quot;}=0
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/blackbox_exporter/pull/823">#823&lt;/a> 为 HTTP 类型的任务增加了 &lt;code>Hostname&lt;/code> 参数，这可以在发起请求的时候传递过去 &lt;code>Host&lt;/code> 请求头，在配置任务的时候可以使用如下的配置作为参考：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">scrape_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">blackbox_all&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metrics_path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/probe&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">params&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">module&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http_2xx ] &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Look for a HTTP 200 response.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns_sd_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">names&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">prometheus.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">A&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">443&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">relabel_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">__address__]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">__param_target&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replacement&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://$1/ &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Make probe URL be like https://1.2.3.4:443/&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">__param_target]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">instance&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">__address__&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replacement&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">127.0.0.1&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">9115&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># The blackbox exporter&amp;#39;s real hostname:port.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">__meta_dns_name]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">__param_hostname &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Make domain name become &amp;#39;Host&amp;#39; header for probe requests&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">__meta_dns_name]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">vhost &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># and store it in &amp;#39;vhost&amp;#39; label&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多详细信息请参考其 &lt;a href="https://github.com/prometheus/blackbox_exporter/releases/tag/v0.20.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="runc-v111-发布">runc v1.1.1 发布&lt;/h1>
&lt;p>runc 是一个底层容器运行时。我之前的文章中有很多篇关于 runc 的内容，如有兴趣可以翻翻看。&lt;/p>
&lt;p>事实上 runc 作为一个底层容器运行时，它的发布频率是很低的，毕竟在云原生领域中有大量的项目都依赖于 runc 或者将 runc 作为依赖导入，
runc 每次发布新版本，这些项目一般也需要进行依赖的更新。&lt;/p>
&lt;p>本次发布的 v1.1.1 只是一个小版本更新，主要是进行一些 bugfix 。我们来看看其中值得关注的内容：&lt;/p>
&lt;p>在之前版本中，如果遇到了 &lt;code>statfs(&amp;quot;/sys/fs/cgroup/unified&amp;quot;)&lt;/code> 发生除了 &lt;code>ENOENT&lt;/code> 外的错误，都会引起 panic 。
本次在 &lt;a href="https://github.com/opencontainers/runc/pull/3433">#3433&lt;/a> 中对其进行了调整，不再会 panic ，而是会记录下
日志。&lt;/p>
&lt;p>此外, 通过在 &lt;a href="https://github.com/opencontainers/runc/pull/3389">#3398&lt;/a> 中修正了对
&lt;code>/sys/kernel/cgroup/delegate&lt;/code> 文件中包含的内容的检查。因为并非所有的 cgroup 中都包含了此内容。&lt;/p>
&lt;p>更多详细信息请参考其 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.1.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/109074">#109074 · kubernetes/kubernetes&lt;/a> kubeadm 中为 etcd 的 static Pod 增加了一个 &lt;code>--experimental-initial-corrupt-check&lt;/code> 选项，可以用来确认 etcd member 中数据的一致性。这个特性预期在 etcd 的 v3.6 版本中会正式可用。此外，etcd 的 Release 页面也写了，当前不建议将 etcd 3.5.x 用于生产环境，如果尚未进行升级，可以先继续使用 3.4.x。如果已经升级了，那么可以自行增加此参数；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/108032">#108032 · kubernetes/kubernetes&lt;/a> 这个 PR 为 CronJob 增加了一个 &lt;code>timeZone&lt;/code> 的字段，这是根据 KEP 3140 进行实现的。从此大家在 Kubernetes 中使用 CronJob 时，就可以比较方便的去设置时区了。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">企业级云原生应用交付及管理系列 - Helm 调试及维护 (二)</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/30/%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98%E5%8F%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97-Helm-%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%B4%E6%8A%A4-%E4%BA%8C/"/><id>https://moelove.info/2022/03/30/%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98%E5%8F%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97-Helm-%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%B4%E6%8A%A4-%E4%BA%8C/</id><updated>2022-04-10T23:56:14+08:00</updated><published>2022-03-30T20:21:07+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 在上一篇 《企业级云原生应用交付及管理系列 - Helm 基础 (一)》 中，我主要介绍了 Helm 的诞生及其发展，包括 Helm 各个版本的情……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在上一篇 &lt;a href="https://zhuanlan.zhihu.com/p/487412617">《企业级云原生应用交付及管理系列 - Helm 基础 (一)》&lt;/a> 中，我主要介绍了
Helm 的诞生及其发展，包括 Helm 各个版本的情况及社区的发展。&lt;/p>
&lt;p>此外，还介绍了 Helm 的架构，概念，插件以及其基本用法。&lt;/p>
&lt;p>本节我将默认读者已经有一定的 Helm 和 Kubernetes 基础，
介绍 Helm 的一些高阶特性和用法，
如果有不清楚的概念可以看我的历史文章。&lt;/p>
&lt;h2 id="准备">准备&lt;/h2>
&lt;p>这里我们使用 &lt;code>helm create&lt;/code> 命令来创建一个 Helm chart。执行完成后，会在当前目录创建一个新的目录，其中包含了 Helm 预先创建的一个模板。
本文中的后续内容均会基于该 Helm chart 完成。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm create moelove
Creating moelove
tao@moelove:~$ ls
moelove
tao@moelove:~$ tree
.
└── moelove
├── Chart.yaml
├── charts
├── templates
│   ├── NOTES.txt
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── hpa.yaml
│   ├── ingress.yaml
│   ├── service.yaml
│   ├── serviceaccount.yaml
│   └── tests
│   └── test-connection.yaml
└── values.yaml
&lt;span class="m">4&lt;/span> directories, &lt;span class="m">10&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="debug">Debug&lt;/h2>
&lt;p>在我们去创建/维护，或者使用 Helm chart 进行应用部署的时候，有时候可能会遇到一些错误。
那么如何对 Helm chart 进行 debug 呢？这是很多人都会遇到的一个问题。&lt;/p>
&lt;p>Helm chart 是通过 YAML 进行维护的，而 YAML 是缩进/语法敏感的。
假如你的缩进或者语法有问题，都将会导致报错。
最简单的检查办法是使用 &lt;code>helm lint&lt;/code> 进行检查。&lt;/p>
&lt;p>比如我们进行如下修改：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gh">diff --git a/values.yaml b/values.yaml
&lt;/span>&lt;span class="gh">index 4a8b237..696a77d 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/values.yaml
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/values.yaml
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -5,7 +5,7 @@
&lt;/span>&lt;span class="gu">&lt;/span> replicaCount: 1
image:
&lt;span class="gd">- repository: nginx
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ repository: nginx
&lt;/span>&lt;span class="gi">&lt;/span> pullPolicy: IfNotPresent
# Overrides the image tag whose default is the chart appVersion.
tag: &amp;#34;&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，我们将 &lt;code>image.repository&lt;/code> 的缩进搞错了。
这时进行安装将看到如下报错：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm install foo .
Error: INSTALLATION FAILED: cannot load values.yaml: error converting YAML to JSON: yaml: line 9: mapping values are not allowed in this context
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我建议你可以使用 &lt;code>helm lint&lt;/code> 先进行检查，避免一些低级错误。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm lint .
&lt;span class="o">==&lt;/span>&amp;gt; Linting .
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Chart.yaml: icon is recommended
&lt;span class="o">[&lt;/span>ERROR&lt;span class="o">]&lt;/span> values.yaml: unable to parse YAML: error converting YAML to JSON: yaml: line 9: mapping values are not allowed in this context
&lt;span class="o">[&lt;/span>ERROR&lt;span class="o">]&lt;/span> templates/: cannot load values.yaml: error converting YAML to JSON: yaml: line 9: mapping values are not allowed in this context
&lt;span class="o">[&lt;/span>ERROR&lt;span class="o">]&lt;/span> : unable to load chart
cannot load values.yaml: error converting YAML to JSON: yaml: line 9: mapping values are not allowed in this context
Error: &lt;span class="m">1&lt;/span> chart&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> linted, &lt;span class="m">1&lt;/span> chart&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> failed
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将该内容恢复原样，并进行如下变更：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gh">diff --git a/values.yaml b/values.yaml
&lt;/span>&lt;span class="gh">index 4a8b237..c86c0be 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/values.yaml
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/values.yaml
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -2,7 +2,7 @@
&lt;/span>&lt;span class="gu">&lt;/span> # This is a YAML-formatted file.
# Declare variables to be passed into your templates.
&lt;span class="gd">-replicaCount: 1
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+replicaCount: &amp;#34;this should not be string&amp;#34;
&lt;/span>&lt;span class="gi">&lt;/span>
image:
repository: nginx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>将 &lt;code>replicaCount&lt;/code> 修改成了一段字符串。这时候我们使用 &lt;code>helm lint&lt;/code> 是无法检查出来的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm lint .
&lt;span class="o">==&lt;/span>&amp;gt; Linting .
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Chart.yaml: icon is recommended
&lt;span class="m">1&lt;/span> chart&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> linted, &lt;span class="m">0&lt;/span> chart&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> failed
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为从 YAML 语法上是无法检查出来类型的，并且这也是我们具体的业务逻辑（Kubernetes）限制的。&lt;/p>
&lt;p>这时，如果进行安装将得到如下错误：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm install foo .
Error: INSTALLATION FAILED: unable to build kubernetes objects from release manifest: error validating &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>: error validating data: ValidationError&lt;span class="o">(&lt;/span>Deployment.spec.replicas&lt;span class="o">)&lt;/span>: invalid &lt;span class="nb">type&lt;/span> &lt;span class="k">for&lt;/span> io.k8s.api.apps.v1.DeploymentSpec.replicas: got &lt;span class="s2">&amp;#34;string&amp;#34;&lt;/span>, expected &lt;span class="s2">&amp;#34;integer&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，对于这种类型错误是可以很直接的得到反馈的。&lt;/p>
&lt;p>但还有一种情况，就是语法规则，类型均正常，但是不符合业务的实际预期。&lt;/p>
&lt;p>比如我们进行如下变更：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gh">diff --git a/values.yaml b/values.yaml
&lt;/span>&lt;span class="gh">index 4a8b237..8feedd6 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/values.yaml
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/values.yaml
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -8,7 +8,7 @@ image:
&lt;/span>&lt;span class="gu">&lt;/span> repository: nginx
pullPolicy: IfNotPresent
# Overrides the image tag whose default is the chart appVersion.
&lt;span class="gd">- tag: &amp;#34;&amp;#34;
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ tag: &amp;#34;1.20&amp;#34;
&lt;/span>&lt;span class="gi">&lt;/span>
imagePullSecrets: []
nameOverride: &amp;#34;&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时，可以安装成功，但可能我们预期想要安装的镜像是 &lt;code>1.20-alpine&lt;/code> 。
这种场景下，上述两种方式就都没有效果了。&lt;/p>
&lt;p>我们可以通过 &lt;code>helm install --dry-run --debug&lt;/code> 命令进行调试。
当然，如果你想通过 &lt;code>helm template&lt;/code> 进行调试也可以。&lt;/p>
&lt;p>这两者主要的区别在于，如果增加了 &lt;code>--debug&lt;/code> 参数的话，可以输出更加详细的信息，
包括最终使用的 Values 信息等。&lt;/p>
&lt;p>这是我比较推荐的做法，适合在你开发/调试 Helm chart 时使用。&lt;/p>
&lt;h2 id="helm-单元测试">Helm 单元测试&lt;/h2>
&lt;p>谈到 Helm chart 的单元测试，你可能会产生疑问，YAML 也要写单元测试？&lt;/p>
&lt;p>是的。如果你是 Helm chart 的维护者的话，写单元测试是个好主意，可以更好的保证大多数内容都是符合预期的。&lt;/p>
&lt;p>如果想要为 Helm chart 写单元测试，我有三个工具推荐。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/quintush/helm-unittest">quintush/helm-unittest&lt;/a> 是从 &lt;a href="https://github.com/helm-unittest/helm-unittest">helm-unittest/helm-unittest&lt;/a> fork 出来的，但是它更加活跃，并且包含了很多功能和修复，此外，它可以很好的与 Helm 3 配合使用；&lt;/li>
&lt;li>&lt;a href="https://github.com/open-policy-agent/conftest">conftest&lt;/a> 这是基于 Open Policy Agent (OPA) 的一个工具，通过使用 Rego 编写策略文件来完成配置的校验。我现在在 &lt;a href="https://github.com/apache/apisix-ingress-controller/">Apache APISIX Ingress controller&lt;/a> 项目中使用它，辅助用户进行升级检查；&lt;/li>
&lt;li>&lt;a href="https://github.com/gruntwork-io/terratest">terratest&lt;/a> 这是一个使用 Go 开发的通用测试框架，支持多种配置的测试，包括 Helm，AWS/Docker 等；&lt;/li>
&lt;/ul>
&lt;p>其中我最喜欢的是 conftest ，因为我更喜欢写 Rego ，对 OPA 感兴趣的小伙伴可以参考我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/442190502">《Open Policy Agent(OPA) 入门实践》&lt;/a> 。
最简单的则是 helm-unittest 了，它更加专注一些。&lt;/p>
&lt;p>这里我们使用 helm-unittest 作为示例。&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>helm-unittest 可以作为 Helm Plugin 进行安装，执行以下命令即可：&lt;/p>
&lt;pre>&lt;code>tao@moelove:~$ helm plugin install https://github.com/quintush/helm-unittest
Support linux-amd64
...
Installed plugin: unittest
&lt;/code>&lt;/pre>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>只要在 chart 目录下创建一个 &lt;code>tests&lt;/code> 目录，在其中编写测试文件即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">tao@moelove:~$ cat tests/deployment_test.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">suite&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">templates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">deployment.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">tests&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">it&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">should work&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">set&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image.tag&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">asserts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">isKind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">of&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchRegex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">metadata.name&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pattern&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>-&lt;span class="l">moelove$&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">equal&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">spec.template.spec.containers[0].image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我可以通过如下方式进行运行，注意，一定要增加 &lt;code>-3&lt;/code> 参数，以便可以和 Helm v3 进行兼容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm unittest -3 .
&lt;span class="c1">### Chart [ moelove ] .&lt;/span>
PASS &lt;span class="nb">test&lt;/span> deployment tests/deployment_test.yaml
Charts: &lt;span class="m">1&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Test Suites: &lt;span class="m">1&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Tests: &lt;span class="m">1&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Snapshot: &lt;span class="m">0&lt;/span> passed, &lt;span class="m">0&lt;/span> total
Time: 5.932023ms
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以此 case 做些调整，看看如果测试不通过会是什么情况：&lt;/p>
&lt;pre>&lt;code>tao@moelove:~$ cat tests/deployment_test.yaml
suite: test deployment
templates:
- deployment.yaml
tests:
- it: should work
set:
image.tag: alpine
asserts:
- isKind:
of: Deployment
- matchRegex:
path: metadata.name
pattern: -moelove$
- equal:
path: spec.template.spec.containers[0].image
value: nginx:latest
&lt;/code>&lt;/pre>&lt;p>这里我们给 &lt;code>image.tag&lt;/code> 设置为 &lt;code>alpine&lt;/code> ，但是在断言中没有让其匹配，所以执行测试后会看到失败。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">tao@moelove:~$ helm unittest -3 .
&lt;span class="c1">### Chart [ moelove ] .&lt;/span>
FAIL &lt;span class="nb">test&lt;/span> deployment tests/deployment_test.yaml
- should work
- asserts&lt;span class="o">[&lt;/span>2&lt;span class="o">]&lt;/span> &lt;span class="sb">`&lt;/span>equal&lt;span class="sb">`&lt;/span> fail
Template: moelove/templates/deployment.yaml
DocumentIndex: &lt;span class="m">0&lt;/span>
Path: spec.template.spec.containers&lt;span class="o">[&lt;/span>0&lt;span class="o">]&lt;/span>.image
Expected to equal:
nginx:latest
Actual:
nginx:alpine
Diff:
--- Expected
+++ Actual
@@ -1,2 +1,2 @@
-nginx:latest
+nginx:alpine
Charts: &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Test Suites: &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Tests: &lt;span class="m">1&lt;/span> failed, &lt;span class="m">0&lt;/span> passed, &lt;span class="m">1&lt;/span> total
Snapshot: &lt;span class="m">0&lt;/span> passed, &lt;span class="m">0&lt;/span> total
Time: 5.22252ms
Error: plugin &lt;span class="s2">&amp;#34;unittest&amp;#34;&lt;/span> exited with error
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以很清晰的看到具体失败的原因和位置。&lt;/p>
&lt;p>如果你在维护 Helm chart，并且需要保证其能够高质量交付，那么为其增加单元测试是个不错的办法。
至于工具的选择，主要看个人喜好。helm-unittest 只需要写 YAML， 而其他两个工具分别是写 Rego 和 Go 。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本文中，我们主要聚焦到了 Helm chart 的调试和维护这个主题上。
介绍了 Helm 内置的对 chart 的一些检查工具，同时也介绍了如何使用 helm-unittest 为 Helm chart 编写
单元测试。&lt;/p>
&lt;p>在维护，交付和使用 Helm chart 时，掌握这些内容都是非常有用的。如果这篇文章对你有所帮助，欢迎点赞、转发、留言讨论。&lt;/p>
&lt;p>如果大家对这个主题感兴趣的话，后续我还会更新 Helm 的一些进阶内容，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Helm/" term="Helm" label="Helm"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">K8S 生态周报| Docker，containerd 全版本漏洞公布，请及时更新</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Dockercontainerd-%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%85%AC%E5%B8%83%E8%AF%B7%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0/"/><id>https://moelove.info/2022/03/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Dockercontainerd-%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%85%AC%E5%B8%83%E8%AF%B7%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0/</id><updated>2022-03-28T10:40:59+08:00</updated><published>2022-03-27T21:59:33+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 CVE-2022-24769 近期在 Docker 中发现了……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="cve-2022-24769">CVE-2022-24769&lt;/h1>
&lt;p>近期在 Docker 中发现了一个 &lt;strong>影响所有版本的安全漏洞&lt;/strong> &lt;a href="https://www.cve.org/CVERecord?id=CVE-2022-24769">CVE-2022-24769&lt;/a>，该漏洞已经在 Docker 最新的版本
v20.10.14 中修复。&lt;/p>
&lt;p>这个漏洞主要是由于错误的设置了非空的 Linux 进程的 Inheritable capabilities 集合。导致在 &lt;code>execve(2)&lt;/code> 期间，可能会造成提权。&lt;/p>
&lt;p>我在&lt;a href="https://juejin.cn/book/7044052687779790880/section/7044055655014989827">《Kubernetes 安全原理与实践》&lt;/a> 中 Linux 的权限和能力模型中，
曾介绍过相关内容。&lt;/p>
&lt;p>Linux 中的 capabilities 可以作为每个线程的属性存在，也可以作用在可执行文件上。
如果用作线程属性存在，我们称之为 线程 capability 集合；如果用作可执行文件的扩展属性上，则称之为 文件 capability 集合。&lt;/p>
&lt;p>其中的线程 capability 集合主要包含以下五类：&lt;/p>
&lt;ul>
&lt;li>Permitted&lt;/li>
&lt;li>Inheritable&lt;/li>
&lt;li>Effective&lt;/li>
&lt;li>Bounding&lt;/li>
&lt;li>Ambient&lt;/li>
&lt;/ul>
&lt;p>本次漏洞受影响的就是 Inheritable 集合。 它主要定义了一组跨 execve(2) 系统调用时可继承的 capability 集合。
但是它的影响是会将 Inheritable 集合中的 capability 应用于新线程的 Permitted 集合中，而非直接设置成新线程的 Effective 集合。&lt;/p>
&lt;p>另一方面，文件 capability 集合则主要包含以下三类：&lt;/p>
&lt;ul>
&lt;li>Permitted&lt;/li>
&lt;li>Inheritable&lt;/li>
&lt;li>Effective&lt;/li>
&lt;/ul>
&lt;p>其中 Inheritable 集合的作用是它定义的 capability 会与线程的 Inheritable 取交集，
然后添加到 &lt;code>execve(2)&lt;/code> 产生的线程 Permitted 集合中。&lt;/p>
&lt;p>所以当上述关于 Inheritable 集合的 capability 都进行设置时，就可能会出现提权。&lt;/p>
&lt;p>以下是本次&lt;a href="https://github.com/moby/moby/commit/2bbc786e4c59761d722d2d1518cd0a32829bc07f">修正此漏洞时的主要变更&lt;/a>,
可以看到主要是将原先默认设置的 Inheritable 集合的部分去掉。
这样就可以创建出来一个典型的 Linux 环境了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">func SetCapabilities(s *specs.Spec, caplist []string) error {
&lt;span class="gd">- s.Process.Capabilities.Effective = caplist
&lt;/span>&lt;span class="gd">- s.Process.Capabilities.Bounding = caplist
&lt;/span>&lt;span class="gd">- s.Process.Capabilities.Permitted = caplist
&lt;/span>&lt;span class="gd">- s.Process.Capabilities.Inheritable = caplist
&lt;/span>&lt;span class="gd">&lt;/span> // setUser has already been executed here
&lt;span class="gd">- // if non root drop capabilities in the way execve does
&lt;/span>&lt;span class="gd">- if s.Process.User.UID != 0 {
&lt;/span>&lt;span class="gd">- s.Process.Capabilities.Effective = []string{}
&lt;/span>&lt;span class="gd">- s.Process.Capabilities.Permitted = []string{}
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ if s.Process.User.UID == 0 {
&lt;/span>&lt;span class="gi">+ s.Process.Capabilities = &amp;amp;specs.LinuxCapabilities{
&lt;/span>&lt;span class="gi">+ Effective: caplist,
&lt;/span>&lt;span class="gi">+ Bounding: caplist,
&lt;/span>&lt;span class="gi">+ Permitted: caplist,
&lt;/span>&lt;span class="gi">+ }
&lt;/span>&lt;span class="gi">+ } else {
&lt;/span>&lt;span class="gi">+ // Do not set Effective and Permitted capabilities for non-root users,
&lt;/span>&lt;span class="gi">+ // to match what execve does.
&lt;/span>&lt;span class="gi">+ s.Process.Capabilities = &amp;amp;specs.LinuxCapabilities{
&lt;/span>&lt;span class="gi">+ Bounding: caplist,
&lt;/span>&lt;span class="gi">+ }
&lt;/span>&lt;span class="gi">&lt;/span> }
return nil
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此漏洞虽然是在 Docker 中发现的，但实际上在 containerd 中也是存在的。
当前 Docker 已经发布了最新的 &lt;a href="https://github.com/moby/moby/releases/tag/v20.10.14">v20.10.14 版本&lt;/a>修正此漏洞。
同时 containerd 也相继发布了 v1.5.11 和 v1.6.2 来对此漏洞进行修复。
&lt;strong>建议大家进行升级。并且升级后需要对现有已经启动的容器进行重建操作。&lt;/strong>&lt;/p>
&lt;p>或者，如果在不升级的情况下，可以通过主动删除 Inheritable 集合的 capability 来进行安全防护。&lt;/p>
&lt;h1 id="cert-manager-v180-alpha0-发布">cert-manager v1.8.0-alpha.0 发布&lt;/h1>
&lt;p>cert-manager 是一个可以很方便在 Kubernetes 集群上用于自动化管理证书的工具。
这是 cert-manager v1.8.0 的 alpha 版本。其中有一些我很关注的内容：&lt;/p>
&lt;p>在 &lt;a href="https://github.com/cert-manager/cert-manager/pull/4789">#4789&lt;/a> 中删除了硬编码的 Ingress 的 &lt;code>whitelist-source-range&lt;/code> Annotation，
这样就可以通过 Ingress template 来自定义进行设置了。&lt;/p>
&lt;p>这对于用户想要去使用其他的 Ingress controller 是非常关键的。比如我正在做的 &lt;a href="https://github.com/apache/apisix-ingress-controller/">Apache APISIX Ingress controller&lt;/a>
项目，对于这类黑白名单需求的 Annotation 名称其实是 &lt;code>k8s.apisix.apache.org/allowlist-source-range&lt;/code> 和 &lt;code>k8s.apisix.apache.org/blocklist-source-range&lt;/code>，
经过此次修改就可以很方便的使用了。&lt;/p>
&lt;p>此外，对于 Kubernetes Ingress-nginx 项目而言，在 v1.x 版本中，我们将其中的 &lt;code>white/black&lt;/code> 等都修改成了 &lt;code>allowlist/blocklist&lt;/code> 了，所以此次修改也能对 Ingress-nginx 项目的
新版本进行兼容。&lt;/p>
&lt;p>此外，从这个版本开始引入了 &lt;code>ServerSideApply&lt;/code> 的特性，不过相关功能应该还会有些变更，这里就不展开了。&lt;/p>
&lt;p>更多关于此版本的变更请查看其 &lt;a href="https://github.com/cert-manager/cert-manager/releases/tag/v1.8.0-alpha.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/enhancements/pull/3137">KEP-3136: beta apis off by default · kubernetes/enhancements&lt;/a> 从 Kubernetes v1.24 开始默认情况下将会禁用新的 Beta 版本 API，但是不影响旧的/已存在的。&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/107979">#107979 · kubernetes/kubernetes&lt;/a> loadBalancerClass 特性达到 GA 状态，这是从 v1.21 开始引入的，跟 IngressClass/StorageClass 等比较类似。&lt;/li>
&lt;/ul>
&lt;h1 id="题外话">题外话&lt;/h1>
&lt;p>Kubernetes 的发布周期从 2021 年初改成了一年三个版本，至今已经一年了。Kubernetes 的发版节奏变慢，你感觉如何？欢迎留言交流讨论&lt;/p>
&lt;p>如果有兴趣的小伙伴也可以填一下 Kubernetes 社区的问卷 &lt;a href="https://www.surveymonkey.com/r/k8s-cadence-2022">https://www.surveymonkey.com/r/k8s-cadence-2022&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">企业级云原生应用交付及管理系列 - Helm 基础 (一)</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/25/%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98%E5%8F%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97-Helm-%E5%9F%BA%E7%A1%80-%E4%B8%80/"/><id>https://moelove.info/2022/03/25/%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98%E5%8F%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E5%88%97-Helm-%E5%9F%BA%E7%A1%80-%E4%B8%80/</id><updated>2022-03-25T02:32:35+08:00</updated><published>2022-03-25T00:01:32+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 在 Kubernetes 中，当我们要部署一个应用时，往往会涉及一个或多个部署资源。我们如果使用 YAML 文件来对这些资源的依赖及关联关系……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在 Kubernetes 中，当我们要部署一个应用时，往往会涉及一个或多个部署资源。我们如果使用 YAML 文件来对这些资源的依赖及关联关系进行组织、配置，这往往十分复杂繁琐并且可移植性较差。
Helm 这个 Kubernetes 环境中的包管理器可以帮助我们更快速便捷的来实现资源的组织和部署。&lt;/p>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648103928214-fc9e56ca-86ac-4466-ba41-543a305eca07.png" alt="img">&lt;/p>
&lt;p>本期的主要内容将围绕 Helm 来进行展开。欢迎小伙伴们留言讨论 （觉得内容还不错，就请点赞点在看及转发，谢谢）。&lt;/p>
&lt;h1 id="helm-的诞生及发展">Helm 的诞生及发展&lt;/h1>
&lt;h2 id="helm-1">Helm 1&lt;/h2>
&lt;p>最早期的 Helm 是一个内部黑客马拉松项目，旨在帮助独立开发人员创建 Kubernetes 资源包并将其部署至集群当中。它是于 2015 年在 Deis 创建，后被微软收购 。在同年的11月9日由 CNCF 主办的 KubeCon 上，正式推出（现在称之为 Helm Classic），这是 Helm 的第一个公开版本。&lt;/p>
&lt;h2 id="helm-2">Helm 2&lt;/h2>
&lt;p>2016 年 1 月，Helm Classic 与名为 Kubernetes Deployment Manager 的 GCS 工具合并成 Helm，并移至 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a>下。之后，Helm 加入了 CNCF，成为顶级项目，并已成功毕业。&lt;/p>
&lt;p>在 Helm 2 开发周期中，引入了一个服务端组件 Tiller。Tiller 可以让多个操作者在同一组发布中进行交互，在共享集群中的团队协作发挥了一定的作用。但是，基于 Kubernetes 1.6 的安全策略，在将 Tiller 安装到多租户集群时，DevOps 和 SRE 必须学习额外的操作步骤。此外，由于 Tiller 是一个服务端组件，在安全性上有很严重的缺陷，所有能访问 Tiller 的用户都具备了相同的权限。&lt;/p>
&lt;p>这就引出了：如何化繁为简，即不能陷入在安全控制的繁复上；又不能扩大非预期的权限授予。&lt;/p>
&lt;p>在 Helm 2 中，默认使用 ConfigMaps 来存储发布信息，在 Helm 2.7.0 版本中，实现了首个使用 Secrets 存储发布信息的特性。&lt;/p>
&lt;h2 id="helm-3">Helm 3&lt;/h2>
&lt;p>Tiller 的目标是可以通过 Kubernetes API 来获取信息，在客户端进行 charts 渲染并且将记录存储于 Kubernetes 。
Helm 3 做的第一个决定就是移除 Tiller。随着 Tiller 消失，Helm 的安全模型得到了简化。可以借助 kubeconfig 文件来为 Helm 进行授权。&lt;/p>
&lt;p>在 Helm 3 中，默认使用 Secrets 存储发布信息（Release）。并且也将其 Go 模块路径从 &lt;code>k8s.io/helm&lt;/code> 切换到了 &lt;code>helm.sh/helm/v3&lt;/code> 。&lt;/p>
&lt;h2 id="发展">发展&lt;/h2>
&lt;p>从 2015 年开始，Helm 的贡献者迅速扩张。下方图表显示了随时间推移的贡献者百分比，按国家/地区细分（这是基于 GitHub 上的数据）。自 Helm 加入 CNCF 后，贡献代码的公司总数增加了 41%，从 930 家增加到 1,314 家。（官网上 2015-2019 年的数据对比）&lt;/p>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648061801711-c5c46d4d-3544-49d8-8f31-82a9c4c5be73.png" alt="img">&lt;/p>
&lt;p>2020 年 4 月 30 日，CNCF 宣布 Helm 正式毕业，这是 CNCF 的第十个毕业项目。&lt;/p>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648061234704-1cf0b30b-6d4f-459c-886e-9ab23d8d0c10.png" alt="img">&lt;/p>
&lt;p>此外，CNCF 的 Artifact Hub 于 2020 年 10 月取代了 Helm Hub 。Artifact Hub 是一个基于 Web 的应用程序，可用于查找、安装和发布 CNCF 项目的包和配置。比如，我们想快速找到 Helm 的 Chart 和插件就可以借助于 Artifact Hub。&lt;/p>
&lt;h1 id="helm-基础介绍">Helm 基础介绍&lt;/h1>
&lt;h2 id="helm-架构">Helm 架构&lt;/h2>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648140716778-6359e541-5e3b-414f-a696-403836e1d740.png" alt="img">&lt;/p>
&lt;p>Helm 是使用 Go 语言编写的，使用 client-go 和 apiserver 进行交互。它将信息存储在 Kubernetes 内部的 Secrets 中（Release），不需要自己的数据库。&lt;/p>
&lt;p>Helm 有两个重要的部分：&lt;/p>
&lt;ul>
&lt;li>Helm CLI - &lt;strong>Helm Client&lt;/strong> 是面向最终用户的命令行客户端。主要负责：本地 chart 开发、管理存储库、管理发布、与 Helm registry 交互。&lt;/li>
&lt;li>Library - Helm 库是独立的，它封装了 Helm 逻辑，支持不同的客户端使用。（可以开心的随意导入使用）&lt;/li>
&lt;/ul>
&lt;h2 id="helm-基本概念">Helm 基本概念&lt;/h2>
&lt;ul>
&lt;li>Chart - Chart files ，即有组织的 YAML 。&lt;/li>
&lt;li>Chart package - Chart files 打包之后就是 Chart package 。&lt;/li>
&lt;li>Chart registry - 存储共享 Chart 。&lt;/li>
&lt;li>Release - 是在 Kubernetes 集群中运行的 Chart 实例。一个 Chart 可以多次安装到同一个集群，每次安装时都会创建一个新的 Release。&lt;/li>
&lt;/ul>
&lt;h2 id="helm-的-chart-托管">Helm 的 Chart 托管&lt;/h2>
&lt;p>helm charts registry 就是一个 HTTP Server。&lt;/p>
&lt;p>它包含一个 index.yaml 文件和一些 chart package。从 Helm 2.2.0 开始，支持对存储库的客户端 SSL 身份验证。其他身份验证协议可作为插件使用。index.yaml 包含存储库中所有 charts 的索引。&lt;/p>
&lt;p>chart registry 中的 chart 必须正确打包 ( helm package chart-name/) 并进行版本控制。&lt;/p>
&lt;p>Helm v3.8.0 支持通过 OCI Registry 进行 package 分发。chart package 能够在基于 OCI 的 registry 中存储和共享。&lt;/p>
&lt;ul>
&lt;li>v3.8.0 之前，是实验性的，需要开启。需要设置：export HELM_EXPERIMENTAL_OCI=1&lt;/li>
&lt;li>v3.8.0 之后，默认开启。&lt;/li>
&lt;/ul>
&lt;h2 id="helm-插件">Helm 插件&lt;/h2>
&lt;p>Helm 插件是一种可以通过helmCLI 访问的工具。Helm 插件存在于 &lt;code>$HELM_PLUGINS&lt;/code> 。&lt;/p>
&lt;ul>
&lt;li>Helm 插件可以在 Helm 中添加和删除，而不会影响核心 Helm 工具。&lt;/li>
&lt;li>Helm 插件可以用任何编程语言编写。&lt;/li>
&lt;li>Helm 插件与 Helm 集成，会出现在 helm help 等处。&lt;/li>
&lt;/ul>
&lt;h2 id="helm-版本支持">Helm 版本支持&lt;/h2>
&lt;h3 id="helm-vs-kubernetes-的版本支持">Helm vs Kubernetes 的版本支持&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648144017180-4b3e9f79-8327-41d3-8dff-d139c4e9999c.png" alt="img">&lt;/p>
&lt;h3 id="helm-不同操作系统下的默认路径">Helm 不同操作系统下的默认路径&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1648144264421-d2d4fb8c-bc7a-4617-b832-b41cace3151f.png" alt="img">&lt;/p>
&lt;h1 id="helm-实践操作">Helm 实践操作&lt;/h1>
&lt;h2 id="helm-的部署安装">Helm 的部署安装&lt;/h2>
&lt;p>Helm 是使用 Go 编写的，我们安装时只要下载其二进制文件即可。&lt;/p>
&lt;p>一般从 Helm 仓库的 Release 页面进行下载即可。&lt;/p>
&lt;p>当然，我们也可以使用下面的脚本自动化的进行安装。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 &lt;span class="p">|&lt;/span> bash
% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed
&lt;span class="m">100&lt;/span> &lt;span class="m">11156&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">11156&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">10399&lt;/span> &lt;span class="m">0&lt;/span> 0:00:01 0:00:01 --:--:-- &lt;span class="m">10406&lt;/span>
Helm v3.8.1 is available. Changing from version v3.8.0.
Downloading https://get.helm.sh/helm-v3.8.1-linux-amd64.tar.gz
Verifying checksum... Done.
Preparing to install helm into /usr/local/bin
&lt;span class="o">[&lt;/span>sudo&lt;span class="o">]&lt;/span> tao 的密码：
helm installed into /usr/local/bin/helm
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="helm-的常见操作">Helm 的常见操作&lt;/h2>
&lt;h3 id="创建-chart">创建 Chart&lt;/h3>
&lt;p>通过 &lt;code>helm create&lt;/code>命令，可以快速的创建一个 Helm Chart。 新创建的 Chart 中预先包含了一些必要的文件。&lt;/p>
&lt;p>比如 &lt;code>Chart.yaml&lt;/code>文件中，包含了 Chart 相关的一些元信息。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm create foo
Creating foo
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls
foo
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ tree
.
└── foo
├── charts
├── Chart.yaml
├── templates
│ ├── deployment.yaml
│ ├── _helpers.tpl
│ ├── hpa.yaml
│ ├── ingress.yaml
│ ├── NOTES.txt
│ ├── serviceaccount.yaml
│ ├── service.yaml
│ └── tests
│ └── test-connection.yaml
└── values.yaml
&lt;span class="m">4&lt;/span> directories, &lt;span class="m">10&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看-chart-的元信息">查看 Chart 的元信息&lt;/h3>
&lt;p>我们也可以直接通过 &lt;code>helm show&lt;/code> 查看 Chart 相关的一些信息，而无需打开各配置文件。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm show chart foo
apiVersion: v2
appVersion: 1.16.0
description: A Helm chart &lt;span class="k">for&lt;/span> Kubernetes
name: foo
type: application
version: 0.1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装">安装&lt;/h3>
&lt;p>可以通过 &lt;code>helm install&lt;/code>命令将 Helm Chart 安装到 Kubernetes 集群中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm install foo foo -n demo --create-namespace
NAME: foo
LAST DEPLOYED: Fri Mar &lt;span class="m">25&lt;/span> 01:55:11 &lt;span class="m">2022&lt;/span>
NAMESPACE: demo
STATUS: deployed
REVISION: &lt;span class="m">1&lt;/span>
NOTES:
1. Get the application URL by running these commands:
&lt;span class="nb">export&lt;/span> &lt;span class="nv">POD_NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>kubectl get pods --namespace demo -l &lt;span class="s2">&amp;#34;app.kubernetes.io/name=foo,app.kubernetes.io/instance=foo&amp;#34;&lt;/span> -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;{.items[0].metadata.name}&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;span class="nb">export&lt;/span> &lt;span class="nv">CONTAINER_PORT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>kubectl get pod --namespace demo &lt;span class="nv">$POD_NAME&lt;/span> -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;{.spec.containers[0].ports[0].containerPort}&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;Visit http://127.0.0.1:8080 to use your application&amp;#34;&lt;/span>
kubectl --namespace demo port-forward &lt;span class="nv">$POD_NAME&lt;/span> 8080:&lt;span class="nv">$CONTAINER_PORT&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看-release">查看 Release&lt;/h3>
&lt;p>通过 &lt;code>helm list&lt;/code>可以查看已经部署到 Kubernetes 中的 Release 资源。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm -n demo list
NAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSION
foo demo &lt;span class="m">1&lt;/span> 2022-03-25 01:55:11.18271151 +0800 CST deployed foo-0.1.0 1.16.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除-release">删除 Release&lt;/h3>
&lt;p>通过 &lt;code>helm uninstall&lt;/code>可以用于删除 Release。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm -n demo uninstall foo
release &lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span> uninstalled
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="打包">打包&lt;/h3>
&lt;p>通过 &lt;code>helm package&lt;/code>命令可以对 Chart 进行打包。然后通过 &lt;code>helm repo index&lt;/code>命令即可生成 &lt;code>index.yaml&lt;/code>文件。&lt;/p>
&lt;p>在此目录中启动一个 HTTP Server ，就可以作为 Helm repo 供下载/安装 Helm Chart 使用了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm package foo
Successfully packaged chart and saved it to: /tmp/helm/foo-0.1.0.tgz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls
foo foo-0.1.0.tgz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm repo index .
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls
foo foo-0.1.0.tgz index.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>在本篇中，主要介绍了 Helm 的发展历程，以及其中的核心概念及一些常见的操作方式。&lt;/p>
&lt;p>本系列的后续内容中会提供 Helm 的高级用法，以及企业级云原生应用的交付及管理相关的内容，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Argo Workflows 新版本发布，带来众多新特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Argo-Workflows-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2022/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Argo-Workflows-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/</id><updated>2022-03-21T08:58:13+08:00</updated><published>2022-03-21T00:01:32+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Trivy 新版本发布 本周 Trivy……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="trivy-新版本发布">Trivy 新版本发布&lt;/h1>
&lt;p>本周 Trivy 相继发布了 v0.24.3 和 v0.24.4 版本。最需要关注的变更是如下两个：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/1791">#1791&lt;/a> 更新了 hcl2json 的版本，以便于修正 hcl2json 在处理无效 HCL 配置时的发生的 &lt;a href="https://github.com/tmccombs/hcl2json/pull/39">panic&lt;/a>;&lt;/li>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/1852">#1852&lt;/a> 修正了一个自 v0.24.3 开始引入的 bug, 如果不提供镜像的 tag，在 v0.24.3 中将会报错，现在会遵循 Docker 的相关行为，如果不提供 tag 则默认使用 &lt;code>latest&lt;/code> ；&lt;/li>
&lt;/ul>
&lt;p>更多详情请参考其 &lt;a href="https://github.com/aquasecurity/trivy/releases">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="argo-workflows-v33-正式发布">Argo Workflows v3.3 正式发布&lt;/h1>
&lt;p>Argo Workflows 是一个 Kubernetes 上的通用 Workflow 引擎，近期发布的 v3.3 是它的一个特性版本。这里我主要列几个我所关注的变更：&lt;/p>
&lt;ul>
&lt;li>Plugin template 允许开发者使用任何语言对 workflow 进行扩展，这是一个非常棒的特性。在之前，如果我们想在 Workflow 中执行一些通知，或者做一些报告，那么我可能需要添加一个新的步骤。这样会让整个流程变长。而且，假如我需要上一步的执行结果或输出，那么我还需要单独的处理参数传递等事情，很繁琐。但是，v3.3 中增加的这个 Plugin template 能力，就让事情变得很简单了。比如我可以使用如下配置进行消息通知：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">argoproj.io/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Workflow&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">generateName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">plugin-example-&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">entrypoint&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">templates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">plugin&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">webhook&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">text&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{workflow.name}} finished!&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而要实现一个 Plugin template 也非常的简单，它可以用任何语言实现，只要实现一个 HTTP server，处理相关请求即可。具体内容可参考 &lt;a href="https://argoproj.github.io/argo-workflows/plugins/">https://argoproj.github.io/argo-workflows/plugins/&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Workflow Hooks 可以配置表达式了。在之前的版本中，Workflow 的 Hooks 是按照任务的实际执行情况进行触发的。这个版本中增加了条件判断，比如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">argoproj.io/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Workflow&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">generateName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-hook-&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">entrypoint&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">notice&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">running&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">expression&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">workflow.status == &amp;#34;Running&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">notice&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">templates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- - &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">step1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hello&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hello&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">alpine:3.15&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">sh, -c]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;echo \&amp;#34;Hello\&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">notice&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http://notice.webhook/api/v1/msg&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/argoproj-labs/hera-workflows">Hera&lt;/a> 是一个新的 Argo Python SDK 。我之前在用 Argo SDK 的时候，都是直接通过它的 OpenAPI 自动生成 SDK 来用的，如果对 Argo 不太了解的人会觉得很难用。这个项目主要是为了能让使用更加简单，易用。期待它的发展。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Debug 的增强。现在可以通过 &lt;code>ARGO_DEBUG_PAUSE&lt;/code> 来动态的 debug 任务了。在之前的 debug，比较原始的方法可能是去加 sleep 之类的。现在可以使用如下配置：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">argoproj.io/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Workflow&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">generateName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pause-before-after&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">entrypoint&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">whalesay&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">templates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">whalesay&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">argoproj/argosay:v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ARGO_DEBUG_PAUSE_BEFORE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;true&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ARGO_DEBUG_PAUSE_AFTER&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;true&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，对于 SSO + RBAC 等有了更多支持。更多详情请参考其 &lt;a href="https://github.com/argoproj/argo-workflows/blob/master/CHANGELOG.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/108107">#108107 · kubernetes/kubernetes&lt;/a> 我们知道 kubelet 会按照 &lt;code>node-status-update-frequency&lt;/code> 的配置定时跟 API Server 同步 Node 的状态，默认是 10 秒。如果心跳持续失败，那么会导致 Node 被标记为不可用以及所有的 Pod 都将被驱逐。不过自 v1.20 开始，默认&lt;a href="https://github.com/kubernetes/kubernetes/pull/95981">启用了 HTTP/2 健康检查&lt;/a>, 这允许自动的进行健康检查，把一些失败的连接自动断开。本次修改是让 kubelet 在心跳失败的时候不会强制关闭活跃连接，只是关闭 idle 的连接。如果用户不希望使用此特性，可以通过增加 &lt;code>DISABLE_HTTP2&lt;/code> 的环境变量来恢复成之前的行为。&lt;/p>
&lt;h1 id="题外话">题外话&lt;/h1>
&lt;p>最近的安全漏洞 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847">CVE-2022-0847&lt;/a> 对容器环境也有一定的影响，
但是注意，受影响的 Linux 内核版本为 5.8+，
并且已经在 5.16.11, 5.15.25 和 5.10.102 等版本的 Linux 内核中进行了修复。
此外 Docker Desktop for Mac/Windows 也均发布了最新版本用来修正此问题。
请注意及时更新。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.8 OCI 支持正式 GA，Docker 新版本修复多个严重 bug</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.8-OCI-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%BC%8F-GADocker-%E6%96%B0%E7%89%88%E6%9C%AC%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E4%B8%A5%E9%87%8D-bug/"/><id>https://moelove.info/2022/03/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.8-OCI-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%BC%8F-GADocker-%E6%96%B0%E7%89%88%E6%9C%AC%E4%BF%AE%E5%A4%8D%E5%A4%9A%E4%B8%AA%E4%B8%A5%E9%87%8D-bug/</id><updated>2022-03-13T17:30:35+08:00</updated><published>2022-03-12T02:34:36+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KIND v0.12.0 发布 KIND（……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="kind-v0120-发布">KIND v0.12.0 发布&lt;/h1>
&lt;p>KIND（Kubernetes In Docker）是我很喜欢，也是一直在参与的一个开源项目。
在我之前的文章中有过多次介绍，可以参考&lt;a href="">&lt;/a>
我基本上每天都会用到它，非常的方便。&lt;/p>
&lt;p>距离上个大版本，v0.11 已经过了近十个月，我们来看看这个新版本带来哪些值得关注的特性吧：&lt;/p>
&lt;p>目前 v0.12.0 默认使用的 Kubernetes 版本为 v1.23.4 版本。如果升级 KIND 的话，会重新拉取最新的镜像，镜像托管在 Docker Hub 上，
可能会比较耗时，建议确保网络顺畅。&lt;/p>
&lt;p>在 v0.12.0 中专门优化了对多架构的支持，默认的所有已发布镜像都包含了 amd64 和 arm64 的支持。
在镜像中也对相关组件都做了升级：&lt;/p>
&lt;ul>
&lt;li>containerd v1.5.10&lt;/li>
&lt;li>crictl 1.23.0&lt;/li>
&lt;li>CNI plugin v1.1.0&lt;/li>
&lt;/ul>
&lt;p>此外，也修复了 Docker + cgroup2 + rootless 环境下的支持，和 WSL2 环境下的支持。建议大家进行升级。&lt;/p>
&lt;p>更多详细信息请参考其 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.12.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="docker-v201013-发布">Docker v20.10.13 发布&lt;/h1>
&lt;p>本周 Docker 发布了 v20.10.13 版本，是的，你没有看错，现在发布的版本还是在给 v20.10 打 patch 。
实际上当前 Docker 仓库中最新的代码比 v20.10 已经多了很多功能特性，只不过尚未达到发布一个全新的大版本的目标，所以一直没有发布新的大版本。&lt;/p>
&lt;p>这个版本中主要是进行了一些 bugfix 和打包相关的变更。其中包括：&lt;/p>
&lt;ul>
&lt;li>将 buildx 升级到了 v0.8.0 版本。&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/43165">#43165&lt;/a> 修复了当使用 &lt;code>local&lt;/code> 日志驱动时，如果迅速产生大量日志，可能会产生 OOM 的问题。 &lt;strong>如果有在使用 &lt;code>local&lt;/code> 日志驱动的小伙伴，建议进行升级&lt;/strong> 。&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/43147">#43147&lt;/a> 修复了 fluentd 日志驱动配合 &lt;code>fluentd-async-connect=true&lt;/code> 使用，并且远端服务不可用时，可能会导致 docker daemon 发生 crash 。&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/43333">#43333&lt;/a> 当 pull image 的时候，如果在 image-manifests 时遇到网络连接失败，则进行重试。&lt;/li>
&lt;/ul>
&lt;p>所以，如果有使用 &lt;code>local&lt;/code> 或 &lt;code>fluentd&lt;/code> 等日志驱动的小伙伴，请尽量进行 Docker 的升级。其余场景可自行判断。&lt;/p>
&lt;p>更多详细信息请参考其 &lt;a href="https://github.com/moby/moby/releases/tag/v20.10.13">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="helm-v38-发布">Helm v3.8 发布&lt;/h1>
&lt;p>Helm v3.8 是一个特性版本，在这个版本中最大的变化就是对 OCI registry 的支持达到 GA。&lt;/p>
&lt;p>如果想要登陆一个 OCI registry 的话，可以使用类似 Docker CLI 的用法，使用 &lt;code>helm registry login 镜像仓库&lt;/code> 进行操作。&lt;/p>
&lt;p>例如，可以使用如下命令登陆 GitHub 的镜像仓库地址：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ &lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ~ helm registry login ghcr.io
Username: tao12345666333
Password:
Login Succeeded
&lt;/code>&lt;/pre>&lt;/div>&lt;p>它实际参考了 Docker CLI 的做法，包括配置文件的结构等都与 Docker CLI 保持一致。&lt;/p>
&lt;p>如果想要将 Helm chart 提交到 GitHub 镜像仓库的话，可以进行如下操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm create foo
Creating foo
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm package foo
Successfully packaged chart and saved it to: /tmp/foo-0.1.0.tgz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ helm push foo-0.1.0.tgz oci://ghcr.io/tao12345666333/foo-chart
Pushed: ghcr.io/tao12345666333/foo-chart/foo:0.1.0
Digest: sha256:1b0a889b4e0fee5b5679512182fc6c2e802f39bdc5ba9d11fff0affb962b9b49
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以通过如下命令完成 Chart 的 pull 操作：&lt;/p>
&lt;pre>&lt;code># Pull chart
(MoeLove) ➜ helm pull oci://ghcr.io/tao12345666333/foo-chart/foo --version 0.1.0
Pulled: ghcr.io/tao12345666333/foo-chart/foo:0.1.0
Digest: sha256:1b0a889b4e0fee5b5679512182fc6c2e802f39bdc5ba9d11fff0affb962b9b49
&lt;/code>&lt;/pre>&lt;p>或者安装操作：&lt;/p>
&lt;pre>&lt;code># Install
(MoeLove) ➜ helm install foo oci://ghcr.io/tao12345666333/foo-chart/foo --version 0.1.0
NAME: foo
LAST DEPLOYED: Sun Mar 13 16:52:55 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
export POD_NAME=$(kubectl get pods --namespace default -l &amp;quot;app.kubernetes.io/name=foo,app.kubernetes.io/instance=foo&amp;quot; -o jsonpath=&amp;quot;{.items[0].metadata.name}&amp;quot;)
export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath=&amp;quot;{.spec.containers[0].ports[0].containerPort}&amp;quot;)
echo &amp;quot;Visit http://127.0.0.1:8080 to use your application&amp;quot;
kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
&lt;/code>&lt;/pre>&lt;p>这次 OCI 支持达到 GA 最大的好处就在于，我们不再需要分别维护容器镜像仓库和 Helm chart 的仓库了。可以直接使用同一个，维护成本可以降低。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/108309">#108309 · kubernetes/kubernetes&lt;/a> 这是 &lt;a href="https://github.com/kubernetes/enhancements/pull/2800">KEP-2799: Reduction of Secret-based Service Account Tokens&lt;/a> 的实现，主要原因是由于 Kubernetes 默认情况下的 Service Account Token 的机制，如果 Pod 引用了某个 Service Account，则默认会为其挂载对应的 Token。当然，我们也可以通过配置 &lt;code>automountServiceAccountToken: false&lt;/code> 来避免此行为。&lt;/p>
&lt;p>在这个 PR 中，将 &lt;code>LegacyServiceAccountTokenNoAutoGeneration&lt;/code> 特性设置为 beta 级别，并且在 Kubernetes v1.24 版本中将默认启用。届时，所有新创建的 ServiceAccount 默认不会获取到 Token 信息。这是需要额外注意的，当然，这个变更并不会影响到 Pod 使用的。&lt;/p>
&lt;h1 id="其他一些变更">其他一些变更&lt;/h1>
&lt;ul>
&lt;li>Thanos v0.25 发布&lt;/li>
&lt;li>Knative v1.3 发布&lt;/li>
&lt;li>CNI plugins v1.1.0 发布&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Knative 进入 CNCF 孵化，K8S ingress-nginx 解决多实例问题</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Knative-%E8%BF%9B%E5%85%A5-CNCF-%E5%AD%B5%E5%8C%96K8S-ingress-nginx-%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/"/><id>https://moelove.info/2022/03/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Knative-%E8%BF%9B%E5%85%A5-CNCF-%E5%AD%B5%E5%8C%96K8S-ingress-nginx-%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/</id><updated>2022-03-07T01:25:28+08:00</updated><published>2022-03-06T23:39:51+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes ingress-nginx v1.1.2 发布 就在今天……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="kubernetes-ingress-nginx-v112-发布">Kubernetes ingress-nginx v1.1.2 发布&lt;/h1>
&lt;p>就在今天 Kubernetes &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.1.2">ingress-nginx&lt;/a> 项目发布了 v1.1.2 版本。
我是这个版本的 release manager 。&lt;/p>
&lt;p>距离上个版本发布有将近两个月了，我们来看看这个版本中值得关注的一些变更。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/kubernetes/ingress-nginx/pull/8221">#8221&lt;/a> 中，我们对 ingress-nginx 的 Admission controller 的逻辑做了一些调整，
主要是可以用来修正 &lt;strong>自 v1.0 版本后，如果 Kubernetes 集群中同时运行多个 ingress-nginx 的话，在创建 Ingress 资源的时候，可能导致每个 ingres-nginx 的 Admission 都会去进行检查的问题。&lt;/strong>
而该问题最大的影响是，如果创建的 Ingress 配置相同的话，则会被直接拒绝掉。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/kubernetes/ingress-nginx/pull/8253">#8253&lt;/a> 中则是为 ingress-nginx 增加了一个 &lt;code>ssl_certificate_info&lt;/code> 的 metric， 直接公开当前被加载的证书的信息。
这个功能的最大的好处就是可以避免 Ingress controller Pod 加载了旧证书，进而导致客户端连接失败的问题。&lt;/p>
&lt;p>此外 &lt;a href="https://github.com/kubernetes/ingress-nginx/pull/8256">#8256&lt;/a> 是为了修正在 &lt;code>nginx.ingress.kubernetes.io/auth-url&lt;/code> 中传递无效 URL 的问题，
&lt;strong>建议升级&lt;/strong> 。&lt;/p>
&lt;p>此外还有一些小的 bugfix 和优化，更多详细信息请参考 &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.1.2">ReleaseNote&lt;/a> 。&lt;/p>
&lt;p>在这次发布过程中还有一些比较有趣的事情，
本次发布过程从时间线看，从我开始发布流程，到最后完成发布，共持续了一周的时间，由几个人异步协作完成。
这跟往常差别还是比较大的，往常我们可能会约某个时间，同时在线一起来完成。这次各种原因吧，也比较忙，
往后也许就会保持这种模式了 （对多时区的协作比较友好）。&lt;/p>
&lt;h1 id="istio-1131-发布">Istio 1.13.1 发布&lt;/h1>
&lt;p>在之前的 &lt;a href="https://zhuanlan.zhihu.com/p/467974683">《K8S 生态周报| Istio 即将发布重大安全更新，多个版本受影响》&lt;/a> 中，我曾介绍过 Istio v1.13 的主要功能，
以及 Istio 会在 v1.13.1 中修复一个重大安全漏洞 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-23635">CVE-2022-23635&lt;/a>。&lt;/p>
&lt;p>现在包含该漏洞补丁的相关版本已经发布，包括 v1.11.7、v1.12.3 和 v1.13.1。
该漏洞主要是会影响在多集群中运行的 Istio ，或者暴露在公网环境中的 Istio。
攻击者可以通过访问未经身份验证的接口发送特定请求，进而导致 istiod 拒绝服务。&lt;/p>
&lt;p>更多详情请参考 &lt;a href="https://istio.io/latest/news/security/istio-security-2022-003/">Istio / ISTIO-SECURITY-2022-003&lt;/a>&lt;/p>
&lt;h1 id="knative-进入-cncf">Knative 进入 CNCF&lt;/h1>
&lt;p>上周，CNCF 技术监督委员会(TOC) 投票决定接受 Knative 作为 CNCF 孵化项目。&lt;/p>
&lt;p>这个事情早在 2021 年的 11 月，当时 Google&lt;a href="https://opensource.googleblog.com/2021/11/Knative-applies-to-become-CNCF-incubating-project.html">1&lt;/a> 和 Knative&lt;a href="https://knative.dev/blog/steering/knative-cncf-donation/">2&lt;/a> 项目均发布文章表示已经申请成为 CNCF 的孵化项目。&lt;/p>
&lt;p>如今终于顺利成为 CNCF 的孵化项目，这无论对 Knative，CNCF 还是社区都是非常好的。&lt;/p>
&lt;p>在我之前的文章中也曾介绍过， Knative 最早是由 Google 在 2018 年创立并开源的，之后又与 IBM，Red Hat，VMware 等公司合作
开发。&lt;/p>
&lt;p>如今 Knative 几乎可以说是云原生领域中安装最为广泛的 Serverless 项目了 （数据来自 CNCF 的报告），并且它也已经达到了 v1.0 版本。
此外 Google 还推出了基于 Knative 的 Cloud Run 和 Cloud Run For Anthos 等产品，这些都对 Knative 的普及起到了很大的作用。&lt;/p>
&lt;p>未来，Knative 将在 CNCF 下培育其社区，并在基金会下转向完全开放的治理模式，
很有可能就会是云原生时代下开源 Serverless 领域的事实标准了。&lt;/p>
&lt;p>公告详情请参考：&lt;a href="https://www.cncf.io/blog/2022/03/02/knative-accepted-as-a-cncf-incubating-project/">Knative accepted as a CNCF incubating project&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/107638">#107638 · kubernetes/kubernetes&lt;/a> 更新了 &lt;code>k8s.io/utils&lt;/code> 的依赖，主要是为了解决 kubelet 中的 inotify 泄漏的问题，更多细节可参考 &lt;a href="https://github.com/kubernetes/kubernetes/issues/100241">kubelet uses 120GB memory after 20,000 job created and retains 80GB memory after jobs completed and deleted · Issue #100241 · kubernetes/kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="其他">其他&lt;/h1>
&lt;ul>
&lt;li>containerd 发布了 v1.6.1 主要是为了修复 &lt;a href="https://github.com/containerd/containerd/security/advisories/GHSA-crp2-qrr5-8pq7">CVE-2022-23648&lt;/a>;&lt;/li>
&lt;li>rook 发布了 v1.8.6，为 Ceph v16.2.7 和更新版本支持 OSD 的 raw mode;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">云原生策略引擎 Kyverno （上）</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/"/><id>https://moelove.info/2022/03/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E-Kyverno-%E4%B8%8A/</id><updated>2022-03-03T09:06:50+08:00</updated><published>2022-03-02T21:39:12+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 在之前的 『K8S生态周报』 和 《搞懂 Kubernetes 准入控制（Admission Controller)》 等文章中，我曾提到过……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在之前的 &lt;a href="https://zhuanlan.zhihu.com/container">『K8S生态周报』&lt;/a> 和 &lt;a href="https://zhuanlan.zhihu.com/p/439329022">《搞懂 Kubernetes 准入控制（Admission Controller)》&lt;/a> 等文章中，我曾提到过 Kyverno 这个云原生策略引擎项目，很多小伙伴在后台私信我说对这个项目比较感兴趣。这篇文章我们专门来聊聊 Kyverno 吧。&lt;/p>
&lt;p>Kyverno 当前是一个 CNCF sandbox 级别的项目。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/KUYpoEOH9SFIdL3.png" alt="img">&lt;/p>
&lt;p>本文的大纲如下，小伙伴们可自行跳跃到感兴趣的部分查阅。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/gtcEG9vWfOqyp8C.png" alt="img">&lt;/p>
&lt;h2 id="kubernetes-的策略">Kubernetes 的策略&lt;/h2>
&lt;p>我们称 Kyverno 是云原生策略引擎，那么 Kubernetes 中的策略是什么呢？&lt;/p>
&lt;p>对于 Kubernetes 中的策略，大家可能比较熟悉的是 PodSecurityPolicy。 不过 PodSecurityPolicy 自 Kubernetes v1.21 起已弃用，并将在 v1.25 中删除（当前版本是 v1.23 ）。当前建议大家迁移到 Kubernetes 新增的替换方案 Pod Security Admission 或者类似本文中介绍的 Kyverno 等这种第三方策略插件。&lt;/p>
&lt;p>其实无论是 PodSecurityPolicy 还是它的替代方案 Pod Security Admission ，甚至包括 Kyverno 等，它们都是构筑在 Kubernetes 的 Admission 机制之上的。&lt;/p>
&lt;p>首先，我们主要从两个角度来理解为什么我们需要准入控制器（Admission Controller）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从安全的角度&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>比如，为避免攻击。需要对Kubernetes 集群中部署的镜像来源判定；&lt;/li>
&lt;li>比如，避免 Pod 使用 root 用户，或者尽量不开启特权容器等；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>从治理的角度&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>比如，通过 admission controller 校验服务是否拥有必须的 label；&lt;/li>
&lt;li>比如，避免出现资源超卖等；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>下图，是 kube-apiserver 处理 API 请求的流程图。每个 API 的请求从开始被 kube-apiserver 接收需要经过认证授权，然后就会进入准入控制（admission controllers）的部分。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/WVM6KdT8A4vQGRx.png" alt="img">&lt;/p>
&lt;p>如上图所示，准入控制的过程分为两个阶段：&lt;/p>
&lt;ul>
&lt;li>Mutating Admission - 变更，将相关资源作为请求处理的一部分进行变更&lt;/li>
&lt;li>Validating Admission - 验证，只验证不能进行任何修改&lt;/li>
&lt;/ul>
&lt;p>如果任一个阶段的准入控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回错误。&lt;/p>
&lt;p>Kubernetes 目前已经实现了很多内置的 Admission Controller ，默认情况是跟 kube-apiserver 构建打包到了一起，可以通过 &lt;code>--enable-admission-plugins&lt;/code> 和 &lt;code>--disable-admission-plugins&lt;/code> 控制是否启用。 你也可以参考官方文档来获取详细列表： &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do&lt;/a>&lt;/p>
&lt;p>我们可以发现，Admission controller 的作用很大，但如果想要增加新的 Admission controller 则需要跟 kube-apiserver 编译到一起，
并重启 kube-apiserver ，这是一件很繁琐的事情。&lt;/p>
&lt;p>所以 Kubernetes 中提供了两个特殊的 Admission controller，分别为：&lt;/p>
&lt;ul>
&lt;li>MutatingAdmissionWebhook&lt;/li>
&lt;li>ValidatingAdmissionWebhook&lt;/li>
&lt;/ul>
&lt;p>用户可以通过使用这两个 Admission controller 配置一些自定义的 HTTP server 提供 webhook，并在这些 HTTP server 中执行用户的一些特定逻辑，
以此实现无需重新编译 kube-apiserver 便可扩展 Admission controller 的能力。这便是动态准入控制器。&lt;/p>
&lt;p>使用动态准入控制器的时候，需要满足以下条件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Kubernetes 集群版本至少 v1.16（以便使用 &lt;code>admissionregistration.k8s.io/v1&lt;/code> API） 或者 v1.9 （以便使用 &lt;code>admissionregistration.k8s.io/v1beta1&lt;/code> API）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>已经启用 &lt;code>MutatingAdmissionWebhook&lt;/code> 和 &lt;code>ValidatingAdmissionWebhook&lt;/code> 准入控制器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启用了 &lt;code>admissionregistration.k8s.io/v1beta1&lt;/code> 或者 &lt;code>admissionregistration.k8s.io/v1&lt;/code> API;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当前的两种类型的准入 webhook，我们可以对照上方来理解：&lt;/p>
&lt;ul>
&lt;li>validating admission webhook - 验证，并行处理&lt;/li>
&lt;li>mutating admission webhook - 变更，串行处理，不保障顺序。所以需要做到幂等很重要。&lt;/li>
&lt;/ul>
&lt;p>Kubernetes 中的策略其实就是构筑在 Admission Controller 之上的各种规则，接下来我们看看利用了 Kubernetes 动态准入控制能力的 Kyverno 项目。&lt;/p>
&lt;h2 id="kyverno">Kyverno&lt;/h2>
&lt;p>Kyverno 是 Nirmata 在2019年重写并开源的一个项目。在一年后，也就是 2020年11月10日 Nirmata 将 Kyverno 捐给 CNCF。在实际生产环境中，也已经有了很多可参考的实践，包括 AWS、RedHat 等公司都有成功使用 Kyverno 案例。Kyverno 有一个很大的优势，开发人员不必学习一门新语言，只要直接使用 YAML 进行配置即可，入门门槛比较低（这里是跟 OPA 使用的 rego 语言进行对比。不过我个人写 Rego 比较多，我也很喜欢 OPA）。&lt;/p>
&lt;p>对于想了解 Kyverno 商业化的小伙伴建议可以从 BlakYaks 及 Nirmata 获取更多信息。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/wEfAcUl3geCrGkj.jpg" alt="img">&lt;/p>
&lt;h3 id="kyverno-的原理及架构">Kyverno 的原理及架构&lt;/h3>
&lt;p>Kyverno 在 Kubernetes 集群中是作为动态准入控制器运行的。Kyverno 策略可以使用资源种类、名称和标签选择器匹配资源。&lt;/p>
&lt;p>如下方架构图所示，Kyverno 的功能涵盖了验证、变更或生成资源；验证容器镜像的供应链安全；检查图像元数据；支持类似 Kustomize 的叠加验证和变更；跨命名空间同步配置；监控、报告；可以在 GitOps 的 CI/CD 部分集成测试验证等等。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/DPrWMHAwhOi9vNE.png" alt="img">&lt;/p>
&lt;p>从 Kyverno 的架构图中我们可以看到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Webhook 处理来自 Kubernetes API 服务器的 AdmissionReview 请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Monitor 组件创建和管理所需的配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>监视策略资源并根据 PolicyController 配置的扫描间隔启动后台扫描。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>管理生成资源的 GenerateController 生命周期。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Kyverno 的 Generate Controller 会分两个阶段处理：&lt;/p>
&lt;ul>
&lt;li>webhook 服务器接收源（触发）资源，并根据准入请求创建 GenerateRequest 对象。&lt;/li>
&lt;li>Generate Controller 接收 GenerateRequest 的事件，然后开始处理它（生成目标资源）。&lt;/li>
&lt;/ul>
&lt;p>Kyverno 的 Policy Controller 主要做了以下三件事：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在生成策略更新时更新 GenerateRequests。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在验证策略更新时构建和创建 ReportChangeRequest。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>监视 ReportChangeRequest 的事件以生成策略报告。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>此外，如果想要采用 Kyverno 的时候，可能也会考虑一些其他的问题，比如高可用。&lt;/p>
&lt;p>关于高可用这个问题，Kyverno 支持运行多个副本。当 Kyverno 运行多个实例时，服务将跨不同实例分发准入请求。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于 mutate 和 validate 执行策略 -- Kyverno 采用了一个同步的请求-响应过程，即将决定与响应一起返回。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 generate 和 validate 审计策略 -- Kyverno 采用异步处理数据，即将这些请求推送到队列中，并立即返回响应。审计处理程序中的队列 validate 会生成策略报告。由于 Kyverno 进程终止时是优雅退出的，所以不用担心队列是否排空；重启后，会对队列进行协调。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在高可用性的多副本场景下，Generate Controller 启用了领导者选举，实际上只有一个实例处理 GenerateRequest。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在高可用性的多副本场景下，Policy Controller 也启用了领导者选举。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/d71mXj8lhDAL43v.png" alt="img">&lt;/p>
&lt;p>如上图，Kyverno 策略是规则的集合。每个规则由一个 match 声明、一个可选 exclude 声明和一个 validate 、 mutate 、 generate 或 verifyImages 声明之一组成。&lt;/p>
&lt;p>每个规则只能包含一个 validate 、mutate 、generate 或 verifyImages 的子声明。&lt;/p>
&lt;ul>
&lt;li>namespace 策略（Policy）将仅适用于定义它们的 namespace 内的资源。&lt;/li>
&lt;li>集群范围的策略（ClusterPolicy）应用于匹配跨所有 namespace 的资源。&lt;/li>
&lt;/ul>
&lt;h3 id="kyverno-policy-reports">Kyverno policy reports&lt;/h3>
&lt;p>Kyverno policy reports 是 Kubernetes 的自定义资源。每个 namespace 、每个集群都有对应的 policy report ，提供有关 policy 结果的信息（也包含违规行为）。&lt;/p>
&lt;p>这里需要特别提下违规资源的问题（validationFailureAction=[audit, enforce]）。&lt;/p>
&lt;ul>
&lt;li>当处于 audit 模式下 ，每当创建违反适用规则集的一个或多个规则的资源时，就会将结果添加到报告中。（资源删除时，报告对应的 item 也会被删除）&lt;/li>
&lt;li>当处于 enforce 模式下 ，资源在创建时立即被阻止，报告中不会有。&lt;/li>
&lt;/ul>
&lt;p>Kyverno 创建和更新两种类型的报告（报告的内容取决于违规资源，而不是规则的存储位置）：&lt;/p>
&lt;ul>
&lt;li>ClusterPolicyReport - 集群范围的资源&lt;/li>
&lt;li>PolicyReport - namespace 级别的资源&lt;/li>
&lt;/ul>
&lt;p>使用 kubectl 来查看报告结果，在这里也给大家示例和标注出，请看下图：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/YfHjzRCGF2SiDWX.png" alt="img">&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/pv3UtCy7QL1TH5X.png" alt="img">&lt;/p>
&lt;h3 id="kyverno-监控">Kyverno 监控&lt;/h3>
&lt;p>生产环境中对于整个集群的可观测性和合规性有着一定的要求。Kyverno 的监控可以做到对应用的策略进行可视化和报警（Prometheus + Grafana）。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>监控内容&lt;/th>
&lt;th>指标名称&lt;/th>
&lt;th>指标值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>策略和规则计数&lt;/td>
&lt;td>kyverno_policy_rule_info_total&lt;/td>
&lt;td>0 - 如果规则不再存在于集群中（尽管它是在过去创建的）。1 - 如果规则当前活跃在集群中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>政策和规则执行结果追踪&lt;/td>
&lt;td>kyverno_policy_results_total&lt;/td>
&lt;td>Counter - 一个仅递增的整数，表示与对应于度量样本的规则相关联的结果/执行次数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>策略规则执行延迟&lt;/td>
&lt;td>kyverno_policy_execution_duration_seconds&lt;/td>
&lt;td>直方图 - 一个浮点值，表示规则执行的延迟（以秒为单位）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>准入审查延迟&lt;/td>
&lt;td>kyverno_admission_review_duration_seconds&lt;/td>
&lt;td>直方图 - 一个浮点值，以秒为单位表示准入审查的延迟。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>准入请求计数&lt;/td>
&lt;td>kyverno_admission_requests_total&lt;/td>
&lt;td>Counter - 一个唯一递增的整数，表示与样本相关联的准入请求计数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>策略更改跟踪&lt;/td>
&lt;td>kyverno_policy_changes_total&lt;/td>
&lt;td>Counter - 一个仅递增的整数，表示与度量样本相关的策略级别更改的总数。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在这里还是推荐大家一定要去官方文档看看。在官方文档中，详细的给出了各个监控内容的 Grafana 的表达式（查询语句）。&lt;/p>
&lt;h2 id="kyverno-vs-gatekeeper">Kyverno vs GateKeeper&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/XEhwsjl4oILYuD8.png" alt="img">&lt;/p>
&lt;p>关于 Kyverno ，经过上文的介绍，相信大家已经有了初步的了解。我们来看看 GateKeeper。&lt;/p>
&lt;h3 id="gatekeeperopa-简介">GateKeeper/OPA 简介&lt;/h3>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/BeXG2blTfKxCF9g.png" alt="img">&lt;/p>
&lt;p>styra 公司成立于 2016 年，紧接着搞了 OPA，发布了第一代 GateKeeper ，它通过 kube-mgmt sidecar 执行基于 configmap 的策略，提供验证和变异准入控制。&lt;/p>
&lt;p>2018年，第二代 GateKeeper 的主要贡献者为微软，使用 Kubernetes 策略控制器作为准入控制器，通过 OPA 和 kube-mgmt sidecars 执行基于 configmap 的策略。&lt;/p>
&lt;p>2019年，第三代 GateKeeper 是 Google、Microsoft、Red Hat 和 Styra 的合作项目，它与 OPA 约束框架集成，基于 CRD 的策略，允许以声明方式配置的策略可靠地共享。&lt;/p>
&lt;h4 id="open-policy-agent-opa">Open Policy Agent (OPA)&lt;/h4>
&lt;p>Open Policy Agent (OPA) 是一种开源的通用策略引擎，可在整个堆栈中实现统一、上下文感知的策略实施。它将策略决策与应用程序的业务逻辑分离（解耦）。OPA 策略以 Rego 这种高级声明性语言来表达。如果小伙伴们对这部分感兴趣的话，欢迎查阅我之前发布过的文章 &lt;a href="https://zhuanlan.zhihu.com/p/442190502">Open Policy Agent(OPA) 入门实践&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/S8JRpnoIw5uQgvq.png" alt="img">&lt;/p>
&lt;p>总得来讲，GateKeeper 是一个很好的将 OPA 与 Kubernetes 集成的实践。&lt;/p>
&lt;h3 id="kyverno-与-gatekeeper-对比">Kyverno 与 GateKeeper 对比&lt;/h3>
&lt;p>各有所长，关键在于生产环境中的人员资源及使用场景。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/TpFwn3OMWSx15f8.png" alt="img">&lt;/p>
&lt;h4 id="技术属性的特征能力">技术属性的特征/能力&lt;/h4>
&lt;p>&lt;img src="https://s2.loli.net/2022/03/03/TZK89YWrFde3q5X.png" alt="img">&lt;/p>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2022/png/10359851/1646232403013-75fbc754-1ea4-47a3-903a-6d5185d745a4.png" alt="img">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Kyverno 是一个云原生的策略引擎，上手简单，覆盖场景全面。&lt;/p>
&lt;p>如果大家对 Kyverno 感兴趣的话欢迎留言讨论，我会根据大家的反馈来考虑下是否安排实践篇。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">K8S 生态周报| containerd v1.6 正式发布，带来众多新特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/02/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.6-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2022/02/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.6-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/</id><updated>2022-02-21T09:27:39+08:00</updated><published>2022-02-20T20:55:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd v1.6.0 正式发布 containerd v1.6 在……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="containerd-v160-正式发布">containerd v1.6.0 正式发布&lt;/h1>
&lt;p>containerd v1.6 在本周也正式发布了，这是 containerd 的第 7 个大版本。距离上一个大的正式版 v1.5.0 已经过了将近 9 个月的时间（v1.5.0 是 2021 年 5 月发布的），关于 containerd v1.5.0 的主要变更，可参考我去年写的 &lt;a href="https://zhuanlan.zhihu.com/p/364074085">K8S 生态周报| containerd v1.5.0-rc.0 发布&lt;/a>。我们一起来看看 containerd v1.6.0 中有哪些值得关注的变更吧！&lt;/p>
&lt;h3 id="runtime">Runtime&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5744">#5744&lt;/a> 在 containerd 的 metrics 接口中增加了 &lt;code>runtime&lt;/code> 的 label;&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/6375">#6375&lt;/a> 将 runc 的依赖升级到了 v1.1.0 版本；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5817">#5871&lt;/a> 增加了 shim plugin 的支持，重构了 shim v2 来加载和注册 plugin;&lt;/li>
&lt;/ul>
&lt;h3 id="cri">CRI&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5619">#5619&lt;/a> 当前会同时支持 CRI v1 和 v1alpha2 ；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/6113">#6113&lt;/a> 实现了新的 Kubernetes CRI pod sandbox stats API，这其实是为了遵守 Kubernetes 中 CRI 的变更。其根本原因实际上是在 Kubernetes 中希望能够增强 CRI 的能力，减少对 cAdvisor 的依赖。更深层次的则是由于 cAdvisor 仅支持 Linux 容器，和一般的容器运行时，无法支持类似 Kata Containers 这类 VM 运行时，以及不支持 Windows 容器。由此其实我们也可以看出来 Kubernetes &amp;amp; containerd 的一些目标，做的更通用，更标准化；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/6111">#6111&lt;/a> 添加了 sandbox 和 container 延迟的 metrics，以便用户可以更简单的了解 containerd 内部的运行情况；&lt;/li>
&lt;/ul>
&lt;h3 id="其他">其他&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5778">#5778&lt;/a> 增加了 Windows 资源限制的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5131">#5131&lt;/a> 增加了 Windows HostProcess 容器的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5606">#5606&lt;/a> 在 gRPC 配置中增加了一个 &lt;code>tcp_tls_ca&lt;/code> 的配置；&lt;/li>
&lt;/ul>
&lt;p>毕竟是个大版本更新，还有很多其他的内容，具体的可参考其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.6.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="podman-v400-正式发布">Podman v4.0.0 正式发布&lt;/h1>
&lt;p>距离上一个完整的大版本 v3.0.0 已经过了整整一年了，我们来看看 Podman 这个大版本中比较值得关注的内容吧：&lt;/p>
&lt;ul>
&lt;li>&lt;code>podman run&lt;/code> 和 &lt;code>podman create&lt;/code> 等命令现在增加了一个 &lt;code>--ip6&lt;/code> 的选项用于支持 IPv6;&lt;/li>
&lt;li>如果是使用 CNI network 的话，现在可以增加了一个 &lt;code>ipvlan&lt;/code> 驱动；&lt;/li>
&lt;li>所有删除 container 的命令，现在都支持了 &lt;code>--time&lt;/code> 参数来控制超时时间。其实这个选项 Docker 很久之前就已经有了，我通常会加个 &lt;code>-t 1&lt;/code> ；&lt;/li>
&lt;li>有一些为了增加 Docker 兼容性的破坏性变更，可以通过在配置文件中增加 &lt;code>compat_api_enforce_docker_hub&lt;/code> 来进行控制；&lt;/li>
&lt;/ul>
&lt;p>此外，更多的就是一些功能增加和 bugfix 了，具体内容请参考其 &lt;a href="https://github.com/containers/podman/releases/tag/v4.0.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="kube-state-metrics-v240-发布">kube-state-metrics v2.4.0 发布&lt;/h1>
&lt;p>如果大家用过 &lt;code>kubectl top&lt;/code> 来查看 Node/Pod 的资源情况，或者有在用 HPA/VPA 等，应该都会比较熟悉 &lt;a href="https://github.com/kubernetes-sigs/metrics-server">Kubernetes Metrics Server&lt;/a>。
而 kube-state-metrics (KSM) 与它的定位以及做法是不一样的，KSM 会在内存中保存 Kubernetes 中各种资源/状态的完整快照，并根据这些数据生成完整的指标。
如果你使用 &lt;a href="https://github.com/prometheus-operator/kube-prometheus">Prometheus Operator/kube-prometheus&lt;/a> 来进行 Kubernetes 集群的监控，它会默认把 kube-state-metrics 作为一个组件进行安装。&lt;/p>
&lt;p>这个版本中新增了几个功能：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kube-state-metrics/pull/1652">#1652&lt;/a> 在 Ingress 的指标 &lt;code>kube_ingress_info&lt;/code> 中增加了 IngressClass 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kube-state-metrics/pull/1644">#1644&lt;/a> 扩展 KSM 来支持自定义资源的 metrics;&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kube-state-metrics/pull/1491">#1491&lt;/a> 将 &lt;code>PodDisruptionBudget&lt;/code> 和 &lt;code>CronJob&lt;/code> 资源的 API version 切换到了 v1;&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kube-state-metrics/pull/1676">#1676&lt;/a> 这个 PR 主要是优化 Slice 分配的性能；&lt;/li>
&lt;/ul>
&lt;p>不过当前这个版本标记的是预发布，需要注意下。&lt;/p>
&lt;h1 id="其他-1">其他&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://chaos-mesh.org/">Chaos Mesh&lt;/a> &lt;a href="https://www.cncf.io/blog/2022/02/16/chaos-mesh-moves-to-the-cncf-incubator/">正式进入 CNCF incubator 阶段&lt;/a> 算起来 Chaos Mesh 的孵化过程还算是比较顺利的，进度也比较快。恭喜！&lt;/li>
&lt;li>Kubernetes 项目中正在进行一些移除 dockershim 的后续操作，比如文档更新之类的。如果大家想要体验由 Mirantis 维护的 cri-dockerd ，将 Docker 继续用作 Kubernetes 的容器运行时的话，可以尝试下 minikube。启动时增加 &lt;code>--runtime=docker&lt;/code> 即可；&lt;/li>
&lt;li>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-23649">CVE-2022-23649&lt;/a> &lt;strong>Cosign 中包含了一个 CVE 漏洞&lt;/strong>。关于 Cosign 我在之前的文章中由介绍过，它是用于去校验镜像的，算作是供应链安全中的一个组件。这个事情说明，做供应链安全的时候，得把自己所用的工具也考虑在内。（思考：用不安全的工具是否可以保证最终的安全性？）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Istio 即将发布重大安全更新，多个版本受影响</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/02/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%8D%B3%E5%B0%86%E5%8F%91%E5%B8%83%E9%87%8D%E5%A4%A7%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%97%E5%BD%B1%E5%93%8D/"/><id>https://moelove.info/2022/02/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%8D%B3%E5%B0%86%E5%8F%91%E5%B8%83%E9%87%8D%E5%A4%A7%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%97%E5%BD%B1%E5%93%8D/</id><updated>2022-02-16T02:57:23+08:00</updated><published>2022-02-16T00:14:36+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Istio 即将发布重大安全……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="istio-即将发布重大安全更新多个版本受影响">Istio 即将发布重大安全更新，多个版本受影响&lt;/h1>
&lt;p>Istio 产品安全工作组近期发现 Istio 中存在一些安全漏洞，其中 &lt;strong>最高级别的漏洞被评级为高严重性。&lt;/strong>
鉴于当前 Istio 的漏洞披露政策，所以目前我们不会透露具体的漏洞细节。&lt;/p>
&lt;p>在一周后的 2 月 22 日，将会发布 Istio v1.11.7、v1.12.3 和 v1.13.1 版本修正这些安全漏洞。届时会再更新漏洞的详细内容。&lt;/p>
&lt;p>请参考&lt;a href="https://discuss.istio.io/t/upcoming-istio-v1-11-7-v1-12-4-and-v1-13-1-security-releases/12264">官方通告&lt;/a>&lt;/p>
&lt;p>此外，本周 Istio 也发布了 v1.13.0 正式版， &lt;strong>在 v1.13.1 版本发布前，我不建议大家将自己所用的 Istio 升级到 v1.13.0&lt;/strong> 。&lt;/p>
&lt;p>虽然不建议现在升级，但我们也可以关注下 v1.13.0 带来的一些值得关注的变更：&lt;/p>
&lt;p>v1.13.0 版本中为东西向流量提供了基于主机名的多网络网关支持。主机名可以在控制面中被解析，解析记录可被用作 endpoint。
如果你不需要这个行为，或者想要恢复到之前版本中的默认行为，可以为 istiod 添加 &lt;code>RESOLVE_HOSTNAME_GATEWAYS=false&lt;/code> 的配置。&lt;/p>
&lt;p>此外，它还支持重写 gRPC 探针，以及通过 &lt;code>proxyMetadata&lt;/code> 提供了在 Envoy 工作线程间的重平衡，并且通过学习 Kubernetes 的探测
行为，改善了 istio-agent 健康检查的探测，这样它就不会再重用连接了。请参考 &lt;a href="https://github.com/istio/istio/issues/36390">#36390&lt;/a> 。&lt;/p>
&lt;p>同时我们会发现在这个版本中它对 Telemetry API 的支持增加了不少，尤其是它为 access log 支持了
Common Expression Language (CEL) filter 。如果你觉得对 CEL 有些陌生，那么你可以看下我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/442534887">《K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览》&lt;/a> ，其中就介绍到了在 Kubernetes v1.23 中对 CEL 的支持。（这样看起来 CEL 的储备很正确）&lt;/p>
&lt;p>最后，就是 Istio 终于把 iptables 相关处理代码中对 22 端口硬编码的部分去掉了，可以通过 &lt;code>ISTIO_LOCAL_EXCLUDE_PORTS&lt;/code> 进行配置。这段代码其实存在很久了，这是 Istio 为了兼容在虚拟机 VM 上的用例专门加的。&lt;/p>
&lt;p>更多关于 Istio v1.13.0 版本的信息请参考其 &lt;a href="https://istio.io/latest/news/releases/1.13.x/announcing-1.13/change-notes/">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="kyverno-v160-正式发布">Kyverno v1.6.0 正式发布&lt;/h1>
&lt;p>Kyverno 是 Kubernetes 上原生的策略引擎，它主要的实现原理是利用 Kubernetes 提供的 Admission controller 机制。关于 Kubernetes Admission controller 机制可以参考我之前的文章：&lt;a href="https://zhuanlan.zhihu.com/p/439329022">《搞懂 Kubernetes 准入控制（Admission Controller)》&lt;/a> 。&lt;/p>
&lt;p>这个版本提供了很多有趣的功能，我挑几个特别值得关注的特性吧：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基于 sigstore Cosign 的镜像验证策略规则已进入到 beta 阶段。关于 Cosign 如何使用，可以参考我之前的文章 &lt;a href="https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/#sigstore-%E5%92%8C-cosign">云原生时代下的容器镜像安全（上）&lt;/a>。
在这个版本中其实增加了包括 keyless, annotation 等相关的很多增强，这个特性也非常的方便；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以在 Kyverno 策略中直接使用 OCI 容器镜像相关的元信息了，比如检查镜像的 label，挂载卷以及一些其他的配置。
比如，一种常见的使用场景是我们希望容器镜像不要过大，那么就可以使用如下的策略文件来限制集群内使用体积过大的容器镜像了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如下策略文件表示仅允许使用体积小于 2Gi 的容器镜像，如果镜像过大，则直接拒绝。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kyverno.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">images&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">validationFailureAction&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">enforce&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">only-allow-small-images&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">match&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kinds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">preconditions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">all&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{request.operation}}&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NotEquals&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DELETE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">validate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;images with size greater than 2Gi not allowed&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">foreach&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">list&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;request.object.spec.containers&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">context&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">imageSize&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imageRegistry&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">reference&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{ element.image }}&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Note that we need to use `to_string` here to allow kyverno to treat it like a resource quantity of type memory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># the total size of an image as calculated by docker is the total sum of its layer sizes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">jmesPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;to_string(sum(manifest.layers[*].size))&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">deny&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">conditions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">all&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2Gi&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">LessThan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;{{imageSize}}&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，这个版本中还增加了很多有用的函数，可用于进行数据处理。&lt;/p>
&lt;p>更多详细内容可参考其 &lt;a href="https://github.com/kyverno/kyverno/releases/tag/v1.6.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="trivy-v0230-正式发布">Trivy v0.23.0 正式发布&lt;/h1>
&lt;p>Trivy 是一款简单易用的漏洞扫描工具，关于 Trivy 我之前已经写过很多篇文章了，这里就不赘述了。近期它发布了 v0.23.0 版本，这个版本中有一些值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Trivy DB 原先是通过使用 &lt;a href="https://github.com/aquasecurity/trivy-db">https://github.com/aquasecurity/trivy-db&lt;/a> 项目的 GitHub Release 进行下载的，但是目前如果出现大量重复下载，会触发 GitHub 的限流策略。所以现在选择将 Trivy DB 切换为使用 GitHub Container Registry 进行托管了。这样一方面可以规避掉 GitHub 限流的问题，另一方面也可以可以利用 ghcr.io 提供的数据分析工具等。 &lt;strong>需要注意的是，这是一个破坏性变更。&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Trivy 现在可以直接从 Azure 的 ACR 下载镜像并进行扫描了，不再需要安装 az 工具，或者预先下载镜像了；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多详细内容可参考其 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.23.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/107695">#107695 · kubernetes/kubernetes&lt;/a> 这个 PR 实际上是对 Kubelet 管理的 Static Pod 生命周期部分的一个修正。我们都知道 Static Pod 的生命周期是不受 kube-apiserver 影响的，并且是由 Kubelet 管理的。但是之前几个相关的 issue 和 PR 都并没有覆盖到重启 Pod 时候需要名称完全相同。这个 PR 中对其逻辑进行了修正，增加了 Pod 的完整名称；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/107775">#107775 · kubernetes/kubernetes&lt;/a> 如果调度过程中，Pod 抢占失败，则在 event 中为其增加详细内容。这对于我们去调试问题来说是非常有帮助的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/107317">#107317 · kubernetes/kubernetes&lt;/a> 当前 Kubernetes 仓库中 in-tree 的 dockershim 组件的代码已经删除，其他相关组件比如 kubelet 中的清理也基本完成了。这个 PR 中完成了 kubeadm 对于移除 in-tree dockershim 的相关支持和逻辑，主要是变更默认的容器运行时的配置，访问地址等。关于 Kubernetes 移除 in-tree 的 dockershim 相关内容的详细内容可查看我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/334787180">《K8S 弃用 Docker 了？Docker 不能用了？别逗了！》&lt;/a>。我在本周五( 2 月 18 日)晚上，也会做一场直播，和 SUSE Rancher 的两位小伙伴一起聊聊关于 Kubernetes 移除 dockershim 后，企业用户如何处理的话题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="题外话">题外话&lt;/h1>
&lt;p>最近一段时间没有持续更新，感谢大家的关注。这段时间主要是两方面的原因，一方面是在进行个人的休整，另一方面也是事情较多。&lt;/p>
&lt;p>不过，从这篇开始，「K8S 生态周报」将会正常的恢复每周更新啦！希望不断更！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2021 回顾和 2022 展望</title><link rel="alternate" type="text/html" href="https://moelove.info/2022/01/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2021-%E5%9B%9E%E9%A1%BE%E5%92%8C-2022-%E5%B1%95%E6%9C%9B/"/><id>https://moelove.info/2022/01/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2021-%E5%9B%9E%E9%A1%BE%E5%92%8C-2022-%E5%B1%95%E6%9C%9B/</id><updated>2022-01-07T09:22:43+08:00</updated><published>2022-01-06T19:18:41+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 大家好，我是张晋涛……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>2021 年已经结束了，我们来对 Kubernetes 及相关生态做个回顾和总结。&lt;/p>
&lt;h2 id="kubernetes-的-2021">Kubernetes 的 2021&lt;/h2>
&lt;p>从 2021 年的 4 月份开始， Kubernetes 的发版节奏由原先的每 3 个月发布一个版本，修改成了每 4 个月发布一个版本。所以在 2021 年，Kubernetes 一共发布了 3 个大版本。包括 v1.21、v1.22 和 v1.23 。&lt;/p>
&lt;p>从整体的功能上而言，主要侧重在以下的几个方面。&lt;/p>
&lt;h3 id="资源利用">资源利用&lt;/h3>
&lt;h4 id="内存管理器kubelet">内存管理器（kubelet）&lt;/h4>
&lt;p>在 Kubernetes v1.21 中在 kubelet 组件生态中新增了一个 &lt;strong>内存管理器&lt;/strong> ，在 Linux 系统中，为需要保证 QoS 的 Pod 在多 NUMA 节点保障内存和大内存页分配。这个特性非常有用，尤其是当数据库类或者使用 DPDK 进行高性能数据包处理的应用要部署到 Kubernetes 中时，内存对其性能影响至关重要。&lt;/p>
&lt;p>这里稍微聊点和 NUMA 相关的内容。简单来说就是在多 NUMA 结构下，为了保证效率，所以会按内存和 CPU 的相对距离来按 node 定义是否为 local memory 或者说本地内存，同时由于实际位置不同，所以就可能会产生内存分配不均匀的情况了。比如，我们可以使用 numactl 管理工具查看下当前机器上的情况：&lt;/p>
&lt;pre>&lt;code>[tao@moelove ~]# numactl -H
available: 2 nodes (0-1)
node 0 cpus: 0 1 2 3 4 5 6 7 8 9 20 21 22 23 24 25 26 27 28 29
node 0 size: 65186 MB
node 0 free: 9769 MB
node 1 cpus: 10 11 12 13 14 15 16 17 18 19 30 31 32 33 34 35 36 37 38 39
node 1 size: 65536 MB
node 1 free: 15206 MB
node distances:
node 0 1
0: 10 21
1: 21 10
&lt;/code>&lt;/pre>&lt;p>可以看到在我当前的这台机器上就存在着比较明显的内存分配不均的情况。所以当某个进程达到了其 local memory 的上限，那自然就会影响到它的性能。&lt;/p>
&lt;p>这次在 kubelet 中增加的内存管理器便可以很好的解决这个问题，可以在启动 kubelet 的时候通过 &lt;code>--reserved-memory&lt;/code> 以及配合 &lt;code>--memory-manager-policy&lt;/code> 等参数来一起设置。例如：&lt;/p>
&lt;pre>&lt;code>--memory-manager-policy static --reserved-memory 0:memory=1Gi,hugepages-1M=2Gi --reserved-memory 1:memory=2Gi
&lt;/code>&lt;/pre>&lt;p>注意：&lt;code>memory-manager-policy&lt;/code> 必须设置为 static，如果不设置则默认为 none，即不采取任何行为。&lt;/p>
&lt;p>不过这个特性还在较早期的阶段，目前只为 &lt;code>Guaranteed&lt;/code> QoS 类的 Pod 提供支持。另外，如果正确启用了此特性，则在机器的 /var/lib/kubelet/memory_manager_state 可以看到其详细信息。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/01/07/8d1nKrtip9QoOmW.png" alt="img">&lt;/p>
&lt;p>最终将会影响到拓扑管理器。&lt;/p>
&lt;h4 id="内存资源的qos">内存资源的QoS&lt;/h4>
&lt;p>之前 Kubernetes 在使用 cgroups v1 ，对于 Pod 的 QoS 其实只适用于 CPU 资源。Kubernetes v1.22 中通过引入 cgroups v2 来提供了一个 alpha 特性，允许对内存资源也提供 QoS。（如果没记错，貌似是腾讯云团队提交的 KEP 吧）&lt;/p>
&lt;h4 id="replicaset-缩容算法调整">ReplicaSet 缩容算法调整&lt;/h4>
&lt;p>当前的缩容算法，主要是优先删除生命周期最短的 Pod，本次修改主要是为了避免某些场景：&lt;/p>
&lt;p>比如在缩容的时候，一次性把新扩容的所有的 Pod 给删掉了之类的。所以计划对他们进行对数计算，也可以简单的理解为想要相对随机的对 Pod 进行清理。&lt;/p>
&lt;p>这个调整确实能避免掉上述提到的那种场景，不过也可能会带来一些其他的关于服务可用性相关的问题，比如通常情况下运行时间越久的 Pod 可能当前服务的用户数就越多，连接销毁时，可能就会比新 Pod 带来的影响大一些了。（当然，这些也都是可以通过其他的方式来避免的）&lt;/p>
&lt;h4 id="node-swap-支持">Node swap 支持&lt;/h4>
&lt;p>此特性现在是 Alpha 阶段。&lt;/p>
&lt;p>虽然 swap 并不够快，但是现在有很多场景都是需要用到它的，尤其是一些 Java 和 Node 应用。&lt;/p>
&lt;p>在 Kubernetes 的 issue 列表中有一个存在了 5 年左右的讨论，就是针对于能否开启 swap 支持的。当前这个特性一旦开启就是针对于整个 Node 的，并不能精确到某个 Pod 中。&lt;/p>
&lt;p>你可以通过如下步骤启用此特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在 Node 中启用 swap；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开启 kubelet 的 &lt;code>NodeMemorySwap&lt;/code> 特性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置 &lt;code>--fail-on-swap=false&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可选在 Kubelet 的配置中增加 &lt;code>MemorySwap.SwapBehavior=UnlimitedSwap&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多内容可参考：&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkubernetes%2Fenhancements%2Ftree%2Fmaster%2Fkeps%2Fsig-node%2F2400-node-swap">github.com/kubernetes/…&lt;/a>&lt;/p>
&lt;h4 id="hpa-v2-api-达到-ga">HPA v2 API 达到 GA&lt;/h4>
&lt;p>HPA v2 大约是在 5 年前首次提出，经过这 5 年的发展，终于在现在它达到了 GA 级别。&lt;/p>
&lt;h3 id="安全性">安全性&lt;/h3>
&lt;h4 id="pod-security-policy-的替代品">Pod Security Policy 的替代品&lt;/h4>
&lt;p>&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkubernetes%2Fwebsite%2Fblob%2Fdev-1.22%2Fcontent%2Fen%2Fdocs%2Fconcepts%2Fsecurity%2Fpod-security-admission.md">PodSecurity admission controller&lt;/a> 是&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fsysdig.com%2Fblog%2Fkubernetes-1-21-whats-new%2F%235">在 Kubernets v1.21 中被废弃的 &lt;/a>&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fsysdig.com%2Fblog%2Fkubernetes-1-21-whats-new%2F%235">Pod&lt;/a>&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fsysdig.com%2Fblog%2Fkubernetes-1-21-whats-new%2F%235"> Security Policies &lt;/a>的替代品。&lt;/p>
&lt;p>这个 admission controller 可以按 namespace 级别启用 &lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fkubernetes.io%2Fdocs%2Fconcepts%2Fsecurity%2Fpod-security-standards%2F">Pod&lt;/a>&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fkubernetes.io%2Fdocs%2Fconcepts%2Fsecurity%2Fpod-security-standards%2F"> Security Standards&lt;/a> ，可以有以下三种模式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>enforce&lt;/strong>: 违反策略的 Pod 将被拒绝；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>audit&lt;/strong>：违反策略的 Pod 将会添加审计注释，但其他情况下都允许；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>warn&lt;/strong>：违反策略的 Pod 将会触发面向用户的警告；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可通过如下配置文件进行控制：&lt;/p>
&lt;pre>&lt;code>apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
configuration:
defaults: ## Defaults applied when a mode label is not set.
enforce: &amp;lt;default enforce policy level&amp;gt;
enforce-version: &amp;lt;default enforce policy version&amp;gt;
audit: &amp;lt;default audit policy level&amp;gt;
audit-version: &amp;lt;default audit policy version&amp;gt;
warn: &amp;lt;default warn policy level&amp;gt;
warn-version: &amp;lt;default warn policy version&amp;gt;
exemptions:
usernames: [ &amp;lt;array of authenticated usernames to exempt&amp;gt; ]
runtimeClassNames: [ &amp;lt;array of runtime class names to exempt&amp;gt; ]
namespaces: [ &amp;lt;array of namespaces to exempt&amp;gt; ]
&lt;/code>&lt;/pre>&lt;h3 id="可扩展性">可扩展性&lt;/h3>
&lt;h4 id="新增-openapi-v3">新增 OpenAPI V3&lt;/h4>
&lt;p>这个特性是 Alpha 级别，可通过 &lt;code>OpenApiv3&lt;/code> feature gate 进行开启。&lt;/p>
&lt;p>增加此特性主要是由于 CRD 目前可通过 OpenApi V3 进行定义，但是 api-server 目前还不支持。当从 OpenApi V3 转换为 V2 时，部分信息将会丢失。&lt;/p>
&lt;p>更多详细信息可参考 &lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkubernetes%2Fenhancements%2Fissues%2F2896">KEP #2896&lt;/a>&lt;/p>
&lt;h4 id="crd-validation-表达式语言">CRD Validation 表达式语言&lt;/h4>
&lt;p>这是一项 Alpha 级别的特性，默认是不开启的。可通过增加 &lt;code>CustomResourceValidationExpressions&lt;/code> feature gate 来进行开启。单独介绍此 Alpha 级别的特性是因为目前基于 Custom Resource Definitions (CRDs) 的方式对 Kubernetes 进行扩展已经成为主流，但是在 CRD 中目前能添加的校验规则有限，更多的场景都需要通过额外的 Admission 来完成。&lt;/p>
&lt;p>此功能使用一种叫做 Common Expression Language (CEL) 的语言进行规则定义，通过 &lt;code>x-kubernetes-validation-rules&lt;/code> 字段进行规则的添加。&lt;/p>
&lt;p>例如，某个 CRDs 的内容如下，其中定义了 &lt;code>minReplicas&lt;/code> 小于 &lt;code>replicas&lt;/code> 并且 &lt;code>replicas&lt;/code> 小于 &lt;code>maxReplicas&lt;/code> 。&lt;/p>
&lt;pre>&lt;code>...
openAPIV3Schema:
type: object
properties:
spec:
type: object
x-kubernetes-validation-rules:
- rule: &amp;quot;self.minReplicas &amp;lt;= self.replicas&amp;quot;
message: &amp;quot;replicas should be greater than or equal to minReplicas.&amp;quot;
- rule: &amp;quot;self.replicas &amp;lt;= self.maxReplicas&amp;quot;
message: &amp;quot;replicas should be smaller than or equal to maxReplicas.&amp;quot;
properties:
...
minReplicas:
type: integer
replicas:
type: integer
maxReplicas:
type: integer
required:
- minReplicas
- replicas
- maxReplicas
&lt;/code>&lt;/pre>&lt;p>那么，当有如下的自定义资源创建时，Kubernetes 将会拒绝其请求。&lt;/p>
&lt;pre>&lt;code>apiVersion: &amp;quot;stable.example.com/v1&amp;quot;
kind: CustomDeployment
metadata:
name: my-new-deploy-object
spec:
minReplicas: 0
replicas: 20
maxReplicas: 10
&lt;/code>&lt;/pre>&lt;p>并且返回如下错误：&lt;/p>
&lt;pre>&lt;code>The CustomDeployment &amp;quot;my-new-deploy-object&amp;quot; is invalid:
* spec: Invalid value: map[string]interface {}{&amp;quot;maxReplicas&amp;quot;:10, &amp;quot;minReplicas&amp;quot;:0, &amp;quot;replicas&amp;quot;:20}: replicas should be smaller than or equal to maxReplicas.
&lt;/code>&lt;/pre>&lt;p>这样相比原来我们通过 Admission 的方式来进行校验就会方便的多。&lt;/p>
&lt;h3 id="易用性">易用性&lt;/h3>
&lt;h4 id="增加-kubectl-alpha-events-命令">增加 &lt;code>kubectl alpha events&lt;/code> 命令&lt;/h4>
&lt;p>增加此命令主要是由于在不修改 &lt;code>kubectl get&lt;/code> 的前提下，查看 &lt;code>event&lt;/code> 有一些限制，所以直接增加 &lt;code>kubectl events&lt;/code> 命令可以更方便的去获取到需要的信息，尤其是 event 是在 Kubernetes 中经常需要查看的一个信息。&lt;code>kubectl get events&lt;/code> 比较典型的一些问题, 比如排序（虽然可以通过加参数解决）， watch，以及无法按照时间线方式去查看 events 等。&lt;/p>
&lt;h2 id="kubernetes-生态的-2021">Kubernetes 生态的 2021&lt;/h2>
&lt;h3 id="service-mesh">Service Mesh&lt;/h3>
&lt;p>在 Kubernetes 生态中，今年最主要的不同是在 Service Mesh 领域迎来了一个新的选手：Cilium Service Mesh。&lt;/p>
&lt;p>在之前，Service Mesh 的典型架构是以 Istio 和 Linkerd 等为代表的，基于 Sidecar 的架构模式。在应用程序的 Pod 中自动的注入一个 Sidecar 用于流量的管理等相关能力。&lt;/p>
&lt;p>但是 Cilium Service Mesh 提出了 Sidecarless 的模式，通过 eBPF 技术的加持，带来了更加安全，高性能，以及良好的可观测性。&lt;/p>
&lt;p>这也将引起了新一轮的变革。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2022/01/07/YUFjcMZsifuDxqw.png" alt="img">&lt;/p>
&lt;h3 id="serverless">Serverless&lt;/h3>
&lt;p>今年，Severless领域出现了一些新选手，比如国内青云团队开源出来的 OpenFunction 等项目。&lt;/p>
&lt;p>2012年，Severless概念正式提出，2014年Serverless开启商业化之路，2021年是Serverless规模化落地的关键一年，几乎所有的科技公司都有各种方式、形式的Serverless应用落地。&lt;/p>
&lt;h2 id="2022-展望">2022 展望&lt;/h2>
&lt;p>2022 年，Kubernetes的技术趋势可能将围绕安全性和eBPF展开。&lt;/p>
&lt;h3 id="安全性-1">安全性&lt;/h3>
&lt;p>随着云原生的普及，越来越多的公司已经越过了最初的探索阶段，迈入了实际使用或更大规模应用的阶段。&lt;/p>
&lt;p>安全性成为了另一个受大家关注的核心。其中包括供应链安全，DevSecOps 以及 Kubernetes 在使用时遇到的各种安全性问题。&lt;/p>
&lt;p>在 2022 年，这方面也会得到更多的重视。&lt;/p>
&lt;h3 id="ebpf">eBPF&lt;/h3>
&lt;p>eBPF 技术将会得到更多的普及，不仅是用于可观测性。也会被用于提升 Kubernetes 集群整体的网络性能，还有包括像 Cilium Service Mesh 等这样的架构层上的变革。&lt;/p>
&lt;p>这些都会提升 eBPF 技术在云原生时代的重要性。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">6 个月内做了 15 场公开技术分享，我的 2021 是这样过的</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/30/6-%E4%B8%AA%E6%9C%88%E5%86%85%E5%81%9A%E4%BA%86-15-%E5%9C%BA%E5%85%AC%E5%BC%80%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E6%88%91%E7%9A%84-2021-%E6%98%AF%E8%BF%99%E6%A0%B7%E8%BF%87%E7%9A%84/"/><id>https://moelove.info/2021/12/30/6-%E4%B8%AA%E6%9C%88%E5%86%85%E5%81%9A%E4%BA%86-15-%E5%9C%BA%E5%85%AC%E5%BC%80%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E6%88%91%E7%9A%84-2021-%E6%98%AF%E8%BF%99%E6%A0%B7%E8%BF%87%E7%9A%84/</id><updated>2021-12-31T09:17:46+08:00</updated><published>2021-12-30T21:39:12+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 一眨眼 2021 年就要结束了，我每年都会惯例的做个小回顾。2021 年也发生了很多的事情值得记录一下。 生活与换工作 这两……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>一眨眼 2021 年就要结束了，我每年都会惯例的做个小回顾。2021 年也发生了很多的事情值得记录一下。&lt;/p>
&lt;h2 id="生活与换工作">生活与换工作&lt;/h2>
&lt;p>这两年的疫情对每个人的生活都或多或少的产生了一定的影响，对我而言也是一样。更多的可能是一些想法和心态上的变化。&lt;/p>
&lt;p>我在 2020 年的回顾文章 &lt;a href="https://zhuanlan.zhihu.com/p/342464087">《新晋程序员奶爸的云原生之路》&lt;/a> 中有聊过，我和小可爱的宝宝在 2020 年出生了。&lt;/p>
&lt;p>相比于去年的各种手忙脚乱，以及学习和探索，今年整体来说已经轻松了很多。半夜已经基本上不需要再起来哄他或者冲奶了，也增加了很多互动，变得更加有趣了。&lt;/p>
&lt;p>我也更多的意识到对家人的陪伴是很关键的，之前总是在各种忙，在家人的陪伴方面是少了很多。&lt;/p>
&lt;p>得益于今年换了工作，现在在 API7.AI 是远程工作，全职做开源，工作之余也有了更多的时间陪伴家人。&lt;/p>
&lt;p>换工作期间有两个有趣的插曲跟大家一起分享下：&lt;/p>
&lt;h3 id="爆火的离职消息">爆火的离职消息&lt;/h3>
&lt;p>加了我微信或者关注了我其他社交媒体账号的小伙伴可能会发现，我更新还是比较频繁的。&lt;/p>
&lt;p>在我从前司离职当天，我惯例的发了条 &amp;quot;江湖再会&amp;quot; 的消息，然后我就跟小可爱约会去了。&lt;/p>
&lt;p>结果很意外的，这条消息得到了很多关注。&lt;/p>
&lt;p>朋友圈自不必说，还有很多小伙伴给我发消息询问情况的。&lt;/p>
&lt;p>在推上有 3w 的展示和 1w 多的互动。在脉脉上甚至给我送上了脉脉周榜的前 100 名，感谢大家的关注。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/31/iI9ZQRBWLuVNUh3.jpg" alt="">&lt;/p>
&lt;h3 id="无缝衔接">无缝衔接&lt;/h3>
&lt;p>其实我本来想要早点交接完在离职后休息一段时间的，不过老板让我多待了段时间，所以恰好周五是 last day。&lt;/p>
&lt;p>经过了两天和平时差不多一样的周末后，我就直接入职 API7.AI 飞去珠海跟团队小伙伴团建去了。&lt;/p>
&lt;p>基本上算是无缝衔接了，也就是正常的过了个周末罢了。这敬业程度，评个劳模不过分吧？（哈哈哈&lt;/p>
&lt;h2 id="远程工作的那些事">远程工作的那些事&lt;/h2>
&lt;p>再就是来聊聊我现在的工作，前面提到了，我现在是在 API7.AI 远程全职做开源。&lt;/p>
&lt;p>熟悉我的小伙伴可能知道，我一直都在参与开源项目和开源社区，只不过之前都是靠爱发电，现在全职做开源，还可以有一个公司给我支付薪水，还是很不错的。&lt;/p>
&lt;p>关于开源和职业规划等方面，我之前做过一次线下分享，感兴趣的小伙伴可以查看下分享内容的总结： &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296423&amp;amp;idx=1&amp;amp;sn=11d7dda8e5dc4569de5a5098a2834113&amp;amp;chksm=f2eb9ff8c59c16ee4f0e114fd523db85ea20446445f1a685de5abe7d60e95f3304e1208022a7&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229Yy2sWEYdoTgAzAc4SFwF&amp;amp;sharer_sharetime=1640852619547&amp;amp;sharer_shareid=ca2e51094588e06bf753d47ce6ce6894&amp;amp;exportkey=ARLdgzgH6nytXOL85guH5UM%3D&amp;amp;pass_ticket=qP4NeAQLR2lcADuYhEE8yUtney%2FiPQsWuwjri42D%2BPGtFyKUqAQElvw0Axv7%2Bs%2BQ&amp;amp;wx_header=0#rd">开源浪潮下程序员的职业规划和成长&lt;/a>&lt;/p>
&lt;p>作为一家 Global 的开源商业化公司 API7.AI 为我提供的是一份远程的工作，并不限制我的办工地点，所以刚入职后我选择了在家办公。&lt;/p>
&lt;p>不过那一周我发现一个很严重的问题，我下不了班。&lt;/p>
&lt;p>因为我工作时间在做开源，但是我下班时间其实还是在做开源（这是我的兴趣，也是一个习惯），而且由于在家办公，少了一些边界，就更加感觉是一直在工作。&lt;/p>
&lt;p>不过第二周我就调整好了，我在外面租了办公点，开始让工作和生活有了一定的边界，或者说有了点仪式感，这就有下班的感觉了。（虽然从结果上其实还是没有变化，仍然是工作时间在做开源，休息时间还在做开源 2333）&lt;/p>
&lt;p>再之后节奏就都调整好了，不再会有之前的那种感觉了，也不会再去在意那种所谓的&amp;quot;仪式感&amp;quot;了，也知道什么时候该休息一下了。&lt;/p>
&lt;p>有些小伙伴说远程工作可能会有孤独感，但我完全没有这种感觉。相反的，我觉得目前的状态特别好。&lt;/p>
&lt;p>之前在参与开源社区和活动的时候，大家基本也都是文字交流，甚至聊个几年都没有真的见过一次面的。写到这里我突然想起来了 Python Tornado 框架的作者 Ben Darnell，2016 年我把他邀请到了杭州在 PyCon China 2016 做分享，但我当时还在北京上班过不去。实话说，我俩聊了这么多年，还真的没有线下见过面，但也并不觉得有什么。(扯远了)&lt;/p>
&lt;p>至于工作内容的话，主要是在做基于 Apache APISIX 的 Kubernetes Ingress Controller 和 Service Mesh ，跟我个人的兴趣方向也是一致的，所以也比较开心。有朋友说我是把兴趣做成了工作，我觉得也基本上是的，毕竟即使没有这份工作，我也还是会持续的做开源。&lt;/p>
&lt;h2 id="个人学习和成长">个人学习和成长&lt;/h2>
&lt;p>今年的研究方向主要在 Kubernetes 和 Service Mesh 等云原生技术和方案上，另外就是对于 Apache APISIX 更加的熟悉。&lt;/p>
&lt;p>和去年一样，在 Kubernetes 上面的多数时间花在了理清某些功能的设计和演进过程方面，奇奇怪怪的知识增加了更多。成为了 Kubernetes ingress-nginx 项目的 reviewer ，维护这么活跃的开源项目还是很辛苦的。&lt;/p>
&lt;p>在 Docker 项目主仓库的贡献者排行榜上排名第 66 ，没有明显的进步。&lt;/p>
&lt;p>其他方面的话，在 Cilium 和 eBPF 上花了一些时间，后续可能会分享一些这方面的内容。&lt;/p>
&lt;h2 id="社区贡献">社区贡献&lt;/h2>
&lt;p>记得我去年的年终总结在思否社区得了个凡尔赛奖 (广告费记得结一下)，这次也例行的做个总结和回顾。&lt;/p>
&lt;h3 id="演讲">演讲&lt;/h3>
&lt;p>&lt;strong>我在 2021 年一共做了 19 场公开的技术分享&lt;/strong> 。&lt;/p>
&lt;p>主要集中在下半年， &lt;strong>我在 6 个月做了 15 场技术分享&lt;/strong> 。&lt;/p>
&lt;p>最忙碌的是在 7 月和 11 月，每月有 4 场。最轻松的是 8 月份，没有安排任何活动。(其实 8 月份本来也有安排的，由于疫情延期/取消了)。&lt;/p>
&lt;p>比较特殊的一个是在 7 月份海外 DoK 社区做了一场全英文的分享，由于时差的原因，那天是在 0 点做的分享，完事后已经凌晨 1 点了。打车回家的路上司机师傅问我是做什么工作的，然后说你们做程序员的就是加班太严重，哈哈哈。&lt;/p>
&lt;p>另一个也是 7 月份，在上海的 GOTC 大会，我当时分享中聊到了供应链攻击和 SBOM。实话说，在那之前我在国内会议中确实没发现有人提 SBOM 这个概念。但是从 8 月份开始，这个概念就好像多起来了。另外就是在这次也面基了很多小伙伴，特别开心。&lt;/p>
&lt;p>这些技术分享中可公开的 PPT 我全都上传到了 &lt;a href="https://github.com/tao12345666333/slides">https://github.com/tao12345666333/slides&lt;/a> 有兴趣的小伙伴可以自取。&lt;/p>
&lt;h3 id="专访">专访&lt;/h3>
&lt;p>没记错的话，今年有两次专访。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296303&amp;amp;idx=1&amp;amp;sn=e8d8267cf7cc79d7a4480b592e776253&amp;amp;chksm=f2eb9c70c59c1566c828313673c555d91086bd642508bd0b65da706b95231933e5f2085fc970&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">开源中国专访张晋涛：从Web开发者到中国首位K8s ingress-nginx reviewer&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649297017&amp;amp;idx=1&amp;amp;sn=082c0dc8073fbaf4661b442598ab72ea&amp;amp;chksm=f2eb81a6c59c08b0b0d1bee2fba47069f759bad19e6256bf102ecab5a8fce5aef9f8c4d56b7c&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">「对话GitOps之星」张晋涛：“肝帝”时不时也会拖更&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="文章">文章&lt;/h3>
&lt;p>今年我写了 40 篇文章，相比去年的 57 篇明显的要少了很多。其中 『K8s生态周报』也断更了几篇，明年要争取保持更新不断更！&lt;/p>
&lt;p>以下是一些反馈较好的文章：&lt;/p>
&lt;p>&lt;strong>『彻底搞懂』系列&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296734&amp;amp;idx=1&amp;amp;sn=ec98a1fdbd011c5610bd5aa3537d23fb&amp;amp;chksm=f2eb9e81c59c17978fd88244e41c69e2fd77653bd54c1d14eae997e1793e527fcb57735f7eed&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">彻底搞懂容器技术的基石： cgroup&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649297149&amp;amp;idx=2&amp;amp;sn=d522e6a1b5013288137c81318f8907d5&amp;amp;chksm=f2eb8122c59c083482976978e86c6ec99fbe9b52ae5fa343baef0de9842dd0b6538b8f491ba2&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">彻底搞懂容器技术的基石： namespace （上）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649297169&amp;amp;idx=1&amp;amp;sn=e2c175436ecc24da51361cf72a0f497a&amp;amp;chksm=f2eb80cec59c09d8715024b477b1cf9281b03e5aca9b6ea280081633620fa8279263f1b47425&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">彻底搞懂容器技术的基石：namespace（下）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649297426&amp;amp;idx=2&amp;amp;sn=215535b6044cae9a06e7239c1b6770f4&amp;amp;chksm=f2eb83cdc59c0adb3b9f20a748aad19b59e7828ce75aa7f616b94af1c9d0e0cda53854ea020b&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">彻底搞懂 Kubernetes 中的 Events&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>『K8s生态周报』系列&lt;/strong> 中大家比较关注的可能还是新版本的特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649297076&amp;amp;idx=1&amp;amp;sn=4d6a86220535a0aaa9fdbcbaf66625f4&amp;amp;chksm=f2eb816bc59c087db1ff984e94e449cb9bd6ee6efd18cf25cf946f3019532e56463629e2f1e0&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296413&amp;amp;idx=1&amp;amp;sn=18168eb2edde8f64be559c93b4b845de&amp;amp;chksm=f2eb9fc2c59c16d4a5790e1c46cc31c82b461be28b871e0fd790b45aa19f5ca09170a7f9dbb5&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">K8S 生态周报| Kubernetes v1.22.0 正式发布，新特性一览！&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其他一些:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296229&amp;amp;idx=1&amp;amp;sn=18584c5faef02109480ab539b84fd9af&amp;amp;chksm=f2eb9cbac59c15ac882d3c51206e033dbefd612f65a15abe098ae943e1973023ea3a8e7ee7d9&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">开源项目的 5 年长跑，runc v1.0 终于正式发布！&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296442&amp;amp;idx=1&amp;amp;sn=dbf9fe41dd461663d73b3cd3473ceb47&amp;amp;chksm=f2eb9fe5c59c16f3cd85e0c723e20446e5cde5e5bfdc5181ba9d30ca9003b495a3144f5626f0&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">Lima：Docker Desktop for Mac 的免费开源且自由的替代品&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296423&amp;amp;idx=1&amp;amp;sn=11d7dda8e5dc4569de5a5098a2834113&amp;amp;chksm=f2eb9ff8c59c16ee4f0e114fd523db85ea20446445f1a685de5abe7d60e95f3304e1208022a7&amp;amp;token=36152412&amp;amp;lang=zh_CN#rd">开源浪潮下程序员的职业规划和成长-分享总结&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后惯例的贴一张图：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/31/4yrdYS7Mg23bBxA.png" alt="">&lt;/p>
&lt;p>2022 年的小目标仍然不写了。愿：平安喜乐！&lt;/p>
&lt;p>还有文章前的你，感谢你的关注和支持，希望我们能各有收获！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">彻底搞懂 Kubernetes 中的 Events</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/28/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-Kubernetes-%E4%B8%AD%E7%9A%84-Events/"/><id>https://moelove.info/2021/12/28/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-Kubernetes-%E4%B8%AD%E7%9A%84-Events/</id><updated>2021-12-29T13:02:20+08:00</updated><published>2021-12-28T22:12:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 之前我写了一篇《更优雅的 Kubernetes 集群事件度量方案》，利用 Jaeger 利用 tracing 的方式来采集 Kubernetes 集群中的 events 并进行展示。最终效果如下：……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>之前我写了一篇&lt;a href="https://zhuanlan.zhihu.com/p/383795254">《更优雅的 Kubernetes 集群事件度量方案》&lt;/a>，利用 Jaeger 利用 tracing 的方式来采集 Kubernetes 集群中的 events 并进行展示。最终效果如下：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/25/cIyzN5Himdb6GEW.png" alt="">&lt;/p>
&lt;p>写那篇文章的时候，立了个 flag 要详细介绍下其中的原理，鸽了很久，现在年底了，也该发出来了。&lt;/p>
&lt;h2 id="eents-概览">Eents 概览&lt;/h2>
&lt;p>我们先来做个简单的示例，来看看 Kubernetes 集群中的 events 是什么。&lt;/p>
&lt;p>创建一个新的名叫 moelove 的 namespace ，然后在其中创建一个叫做 redis 的 deployment。接下来查看这个 namespace 中的所有 events。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl create ns moelove
namespace/moelove created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove create deployment redis --image&lt;span class="o">=&lt;/span>ghcr.io/moelove/redis:alpine
deployment.apps/redis created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get deploy
NAME READY UP-TO-DATE AVAILABLE AGE
redis 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 11s
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events
LAST SEEN TYPE REASON OBJECT MESSAGE
21s Normal Scheduled pod/redis-687967dbc5-27vmr Successfully assigned moelove/redis-687967dbc5-27vmr to kind-worker3
21s Normal Pulling pod/redis-687967dbc5-27vmr Pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span>
15s Normal Pulled pod/redis-687967dbc5-27vmr Successfully pulled image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span> in 6.814310968s
14s Normal Created pod/redis-687967dbc5-27vmr Created container redis
14s Normal Started pod/redis-687967dbc5-27vmr Started container redis
22s Normal SuccessfulCreate replicaset/redis-687967dbc5 Created pod: redis-687967dbc5-27vmr
22s Normal ScalingReplicaSet deployment/redis Scaled up replica &lt;span class="nb">set&lt;/span> redis-687967dbc5 to &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是我们会发现默认情况下 &lt;code>kubectl get events&lt;/code> 并没有按照 events 发生的顺序进行排列，所以我们往往需要为其增加 &lt;code>--sort-by='{.metadata.creationTimestamp}'&lt;/code> 参数来让其输出可以按时间进行排列。&lt;/p>
&lt;p>这也是为何 Kubernetes v1.23 版本中会新增 &lt;code>kubectl alpha events&lt;/code> 命令的原因。我在之前的&lt;a href="https://zhuanlan.zhihu.com/p/442534887">文章《K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览》&lt;/a>中已进行了详细的介绍，这里就不展开了。&lt;/p>
&lt;p>按时间排序后可以看到如下结果：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events --sort-by&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.metadata.creationTimestamp}&amp;#39;&lt;/span>
LAST SEEN TYPE REASON OBJECT MESSAGE
2m12s Normal Scheduled pod/redis-687967dbc5-27vmr Successfully assigned moelove/redis-687967dbc5-27vmr to kind-worker3
2m13s Normal SuccessfulCreate replicaset/redis-687967dbc5 Created pod: redis-687967dbc5-27vmr
2m13s Normal ScalingReplicaSet deployment/redis Scaled up replica &lt;span class="nb">set&lt;/span> redis-687967dbc5 to &lt;span class="m">1&lt;/span>
2m12s Normal Pulling pod/redis-687967dbc5-27vmr Pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span>
2m6s Normal Pulled pod/redis-687967dbc5-27vmr Successfully pulled image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span> in 6.814310968s
2m5s Normal Created pod/redis-687967dbc5-27vmr Created container redis
2m5s Normal Started pod/redis-687967dbc5-27vmr Started container redis
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过以上的操作，我们可以发现 &lt;strong>events 实际上是 Kubernetes 集群中的一种资源。当 Kubernetes 集群中资源状态发生变化时，可以产生新的 events&lt;/strong>。&lt;/p>
&lt;h2 id="深入-events">深入 Events&lt;/h2>
&lt;h3 id="单个-event-对象">单个 Event 对象&lt;/h3>
&lt;p>既然 events 是 Kubernetes 集群中的一种资源，正常情况下它的 metadata.name 中应该包含其名称，用于进行单独操作。所以我们可以使用如下命令输出其 name ：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events --sort-by&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.metadata.creationTimestamp}&amp;#39;&lt;/span> -o &lt;span class="nv">jsonpath&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>
redis-687967dbc5-27vmr.16c4fb7bde8c69d2
redis-687967dbc5.16c4fb7bde6b54c4
redis.16c4fb7bde1bf769
redis-687967dbc5-27vmr.16c4fb7bf8a0ab35
redis-687967dbc5-27vmr.16c4fb7d8ecaeff8
redis-687967dbc5-27vmr.16c4fb7d99709da9
redis-687967dbc5-27vmr.16c4fb7d9be30c06
&lt;/code>&lt;/pre>&lt;/div>&lt;p>选择其中的任意一条 event 记录，将其输出为 YAML 格式进行查看：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events redis-687967dbc5-27vmr.16c4fb7bde8c69d2 -o yaml
action: Binding
apiVersion: v1
eventTime: &lt;span class="s2">&amp;#34;2021-12-28T19:31:13.702987Z&amp;#34;&lt;/span>
firstTimestamp: null
involvedObject:
apiVersion: v1
kind: Pod
name: redis-687967dbc5-27vmr
namespace: moelove
resourceVersion: &lt;span class="s2">&amp;#34;330230&amp;#34;&lt;/span>
uid: 71b97182-5593-47b2-88cc-b3f59618c7aa
kind: Event
lastTimestamp: null
message: Successfully assigned moelove/redis-687967dbc5-27vmr to kind-worker3
metadata:
creationTimestamp: &lt;span class="s2">&amp;#34;2021-12-28T19:31:13Z&amp;#34;&lt;/span>
name: redis-687967dbc5-27vmr.16c4fb7bde8c69d2
namespace: moelove
resourceVersion: &lt;span class="s2">&amp;#34;330235&amp;#34;&lt;/span>
uid: e5c03126-33b9-4559-9585-5e82adcd96b0
reason: Scheduled
reportingComponent: default-scheduler
reportingInstance: default-scheduler-kind-control-plane
source: &lt;span class="o">{}&lt;/span>
type: Normal
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到其中包含了很多信息, 这里我们先不展开。我们看另一个例子。&lt;/p>
&lt;h3 id="kubectl-describe-中的-events">&lt;code>kubectl describe&lt;/code> 中的 Events&lt;/h3>
&lt;p>我们可以分别对 Deployment 对象和 Pod 对象执行 &lt;code>describe&lt;/code> 的操作，可以得到如下结果（省略掉了中间输出）：&lt;/p>
&lt;ul>
&lt;li>对 Deployment 操作&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove describe deploy/redis
Name: redis
Namespace: moelove
...
Events:
Type Reason Age From Message
---- ------ ---- ---- -------
Normal ScalingReplicaSet 15m deployment-controller Scaled up replica &lt;span class="nb">set&lt;/span> redis-687967dbc5 to &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>对 Pod 操作&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove describe pods redis-687967dbc5-27vmr
Name: redis-687967dbc5-27vmr
Namespace: moelove
Priority: &lt;span class="m">0&lt;/span>
Events:
Type Reason Age From Message
---- ------ ---- ---- -------
Normal Scheduled 18m default-scheduler Successfully assigned moelove/redis-687967dbc5-27vmr to kind-worker3
Normal Pulling 18m kubelet Pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span>
Normal Pulled 17m kubelet Successfully pulled image &lt;span class="s2">&amp;#34;ghcr.io/moelove/redis:alpine&amp;#34;&lt;/span> in 6.814310968s
Normal Created 17m kubelet Created container redis
Normal Started 17m kubelet Started container redis
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以发现 &lt;strong>对不同的资源对象进行 describe 的时候，能看到的 events 内容都是与自己有直接关联的&lt;/strong>。在 describe Deployment 的时候，看不到 Pod 相关的 Events 。&lt;/p>
&lt;p>这说明， &lt;strong>Event 对象中是包含它所描述的资源对象的信息的&lt;/strong>，它们是有直接联系的。&lt;/p>
&lt;p>结合前面我们看到的单个 Event 对象，我们发现 &lt;strong>&lt;code>involvedObject&lt;/code> 字段中内容就是与该 Event 相关联的资源对象的信息&lt;/strong>。&lt;/p>
&lt;h2 id="更进一步了解-events">更进一步了解 Events&lt;/h2>
&lt;p>我们来看看如下的示例，创建一个 Deployment ，但是使用一个不存在的镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove create deployment non-exist --image&lt;span class="o">=&lt;/span>ghcr.io/moelove/non-exist
deployment.apps/non-exist created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get pods
NAME READY STATUS RESTARTS AGE
non-exist-d9ddbdd84-tnrhd 0/1 ErrImagePull &lt;span class="m">0&lt;/span> 11s
redis-687967dbc5-27vmr 1/1 Running &lt;span class="m">0&lt;/span> 26m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到当前的 Pod 处于一个 &lt;code>ErrImagePull&lt;/code> 的状态。查看当前 namespace 中的 events (我省略掉了之前 deploy/redis 的记录)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events --sort-by&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.metadata.creationTimestamp}&amp;#39;&lt;/span>
LAST SEEN TYPE REASON OBJECT MESSAGE
35s Normal SuccessfulCreate replicaset/non-exist-d9ddbdd84 Created pod: non-exist-d9ddbdd84-tnrhd
35s Normal ScalingReplicaSet deployment/non-exist Scaled up replica &lt;span class="nb">set&lt;/span> non-exist-d9ddbdd84 to &lt;span class="m">1&lt;/span>
35s Normal Scheduled pod/non-exist-d9ddbdd84-tnrhd Successfully assigned moelove/non-exist-d9ddbdd84-tnrhd to kind-worker3
17s Warning Failed pod/non-exist-d9ddbdd84-tnrhd Error: ErrImagePull
17s Warning Failed pod/non-exist-d9ddbdd84-tnrhd Failed to pull image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>: rpc error: &lt;span class="nv">code&lt;/span> &lt;span class="o">=&lt;/span> Unknown &lt;span class="nv">desc&lt;/span> &lt;span class="o">=&lt;/span> failed to pull and unpack image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist:latest&amp;#34;&lt;/span>: failed to resolve reference &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist:latest&amp;#34;&lt;/span>: failed to authorize: failed to fetch anonymous token: unexpected status: &lt;span class="m">403&lt;/span> Forbidden
18s Normal Pulling pod/non-exist-d9ddbdd84-tnrhd Pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>
4s Warning Failed pod/non-exist-d9ddbdd84-tnrhd Error: ImagePullBackOff
4s Normal BackOff pod/non-exist-d9ddbdd84-tnrhd Back-off pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对这个 Pod 执行 &lt;code>describe&lt;/code> 操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove describe pods non-exist-d9ddbdd84-tnrhd
...
Events:
Type Reason Age From Message
---- ------ ---- ---- -------
Normal Scheduled 4m default-scheduler Successfully assigned moelove/non-exist-d9ddbdd84-tnrhd to kind-worker3
Normal Pulling 2m22s &lt;span class="o">(&lt;/span>x4 over 3m59s&lt;span class="o">)&lt;/span> kubelet Pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>
Warning Failed 2m21s &lt;span class="o">(&lt;/span>x4 over 3m59s&lt;span class="o">)&lt;/span> kubelet Failed to pull image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>: rpc error: &lt;span class="nv">code&lt;/span> &lt;span class="o">=&lt;/span> Unknown &lt;span class="nv">desc&lt;/span> &lt;span class="o">=&lt;/span> failed to pull and unpack image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist:latest&amp;#34;&lt;/span>: failed to resolve reference &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist:latest&amp;#34;&lt;/span>: failed to authorize: failed to fetch anonymous token: unexpected status: &lt;span class="m">403&lt;/span> Forbidden
Warning Failed 2m21s &lt;span class="o">(&lt;/span>x4 over 3m59s&lt;span class="o">)&lt;/span> kubelet Error: ErrImagePull
Warning Failed 2m9s &lt;span class="o">(&lt;/span>x6 over 3m58s&lt;span class="o">)&lt;/span> kubelet Error: ImagePullBackOff
Normal BackOff 115s &lt;span class="o">(&lt;/span>x7 over 3m58s&lt;span class="o">)&lt;/span> kubelet Back-off pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以发现，这里的输出和之前正确运行 Pod 的不一样。最主要的区别在与 &lt;code>Age&lt;/code> 列。这里我们看到了类似 &lt;code>115s (x7 over 3m58s)&lt;/code> 这样的输出。&lt;/p>
&lt;p>它的含义表示： &lt;strong>该类型的 event 在 3m58s 中已经发生了 7 次，最近的一次发生在 115s 之前&lt;/strong>&lt;/p>
&lt;p>但是当我们去直接 &lt;code>kubectl get events&lt;/code> 的时候，我们并没有看到有 7 次重复的 event 。这说明 &lt;strong>Kubernetes 会自动将重复的 events 进行合并&lt;/strong>。&lt;/p>
&lt;p>选择最后一条 Events (方法前面内容已经讲了) 并将其内容使用 YAML 格式进行输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n moelove get events non-exist-d9ddbdd84-tnrhd.16c4fce570cfba46 -o yaml
apiVersion: v1
count: &lt;span class="m">43&lt;/span>
eventTime: null
firstTimestamp: &lt;span class="s2">&amp;#34;2021-12-28T19:57:06Z&amp;#34;&lt;/span>
involvedObject:
apiVersion: v1
fieldPath: spec.containers&lt;span class="o">{&lt;/span>non-exist&lt;span class="o">}&lt;/span>
kind: Pod
name: non-exist-d9ddbdd84-tnrhd
namespace: moelove
resourceVersion: &lt;span class="s2">&amp;#34;333366&amp;#34;&lt;/span>
uid: 33045163-146e-4282-b559-fec19a189a10
kind: Event
lastTimestamp: &lt;span class="s2">&amp;#34;2021-12-28T18:07:14Z&amp;#34;&lt;/span>
message: Back-off pulling image &lt;span class="s2">&amp;#34;ghcr.io/moelove/non-exist&amp;#34;&lt;/span>
metadata:
creationTimestamp: &lt;span class="s2">&amp;#34;2021-12-28T19:57:06Z&amp;#34;&lt;/span>
name: non-exist-d9ddbdd84-tnrhd.16c4fce570cfba46
namespace: moelove
resourceVersion: &lt;span class="s2">&amp;#34;334638&amp;#34;&lt;/span>
uid: 60708be0-23b9-481b-a290-dd208fed6d47
reason: BackOff
reportingComponent: &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
reportingInstance: &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
source:
component: kubelet
host: kind-worker3
type: Normal
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们可以看到其字段中包括一个 &lt;code>count&lt;/code> 字段，表示同类 event 发生了多少次。以及 &lt;code>firstTimestamp&lt;/code> 和 &lt;code>lastTimestamp&lt;/code> 分别表示了这个 event 首次出现了最近一次出现的时间。这样也就解释了前面的输出中 events 持续的周期了。&lt;/p>
&lt;h2 id="彻底搞懂-events">彻底搞懂 Events&lt;/h2>
&lt;p>以下内容是从 Events 中随便选择的一条，我们可以看到它包含的一些字段信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">count&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">eventTime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">firstTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2021-12-28T19:31:13Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">involvedObject&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ReplicaSet&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">redis-687967dbc5&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">moelove&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;330227&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uid&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">11e98a9d-9062-4ccb-92cb-f51cc74d4c1d&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Event&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">lastTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2021-12-28T19:31:13Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">message: &amp;#39;Created pod&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">redis-687967dbc5-27vmr&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2021-12-28T19:31:13Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">redis-687967dbc5.16c4fb7bde6b54c4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">moelove&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;330231&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uid&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">8e37ec1e-b3a1-420c-96d4-3b3b2995c300&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">reason&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">SuccessfulCreate&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">reportingComponent&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">reportingInstance&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">source&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">component&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">replicaset-controller&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Normal&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中主要字段的含义如下：&lt;/p>
&lt;ul>
&lt;li>count: 表示当前同类的事件发生了多少次 （前面已经介绍）&lt;/li>
&lt;li>involvedObject: 与此 event 有直接关联的资源对象 （前面已经介绍） , 结构如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">ObjectReference&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Kind&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">Namespace&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">UID&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>
&lt;span class="nx">APIVersion&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">ResourceVersion&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">FieldPath&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>source: 直接关联的组件, 结构如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">EventSource&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Component&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">Host&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>reason: 简单的总结（或者一个固定的代码），比较适合用于做筛选条件，主要是为了让机器可读，当前有超过 50 种这样的代码；&lt;/li>
&lt;li>message: 给一个更易让人读懂的详细说明&lt;/li>
&lt;li>type: 当前只有 &lt;code>Normal&lt;/code> 和 &lt;code>Warning&lt;/code> 两种类型, 源码中也分别写了其含义：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// staging/src/k8s.io/api/core/v1/types.go
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">const&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="c1">// Information only and will not cause any problems
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">EventTypeNormal&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Normal&amp;#34;&lt;/span>
&lt;span class="c1">// These events are to warn that something might go wrong
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">EventTypeWarning&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Warning&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，当我们将这些 Events 都作为 tracing 的 span 采集回来后，就可以按照其 &lt;code>source&lt;/code> 进行分类，按 &lt;code>involvedObject&lt;/code> 进行关联，按时间进行排序了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在这篇文章中，我主要通过两个示例，一个正确部署的 Deploy，以及一个使用不存在镜像部署的 Deploy，深入的介绍了 Events 对象的实际的作用及其各个字段的含义。&lt;/p>
&lt;p>对于 Kubernetes 而言，Events 中包含了很多有用的信息，但是这些信息却并不会对 Kubernetes 造成什么影响，它们也并不是实际的 Kubernetes 的日志。默认情况下 Kubernetes 中的日志在 1 小时后就会被清理掉，以便释放对 etcd 的资源占用。&lt;/p>
&lt;p>所以为了能更好的让集群管理员知道发生了什么，在生产环境中，我们通常会把 Kubernetes 集群的 events 也给采集回来。我个人比较推荐的工具是： &lt;a href="https://github.com/opsgenie/kubernetes-event-exporter">https://github.com/opsgenie/kubernetes-event-exporter&lt;/a>&lt;/p>
&lt;p>当然你也可以按照我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/383795254">《更优雅的 Kubernetes 集群事件度量方案》&lt;/a>，利用 Jaeger 利用 tracing 的方式来采集 Kubernetes 集群中的 events 并进行展示。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm 新版本发布，解决了内存泄漏的问题</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E8%A7%A3%E5%86%B3%E4%BA%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/><id>https://moelove.info/2021/12/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E8%A7%A3%E5%86%B3%E4%BA%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id><updated>2021-12-27T14:47:52+08:00</updated><published>2021-12-26T23:57:25+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Trivy v0.22.0 正式发布 Trivy 是一……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="trivy-v0220-正式发布">Trivy v0.22.0 正式发布&lt;/h1>
&lt;p>Trivy 是一款轻量级的漏洞扫描工具，支持包括容器镜像，文件系统，IaC 配置文件等。在我之前的 『K8s生态周报』文章中已经介绍过多次，此处就不再展开了。我们一起来看看这个版本中有哪些值得关注的变更。&lt;/p>
&lt;ul>
&lt;li>新增了一个 &lt;code>--offline-scan&lt;/code> 的选项，在对 &lt;code>pom.xml&lt;/code> 和 &lt;code>JAR&lt;/code> 文件进行扫描的时候，可以通过同时指定 &lt;code>--skip-update&lt;/code> 和 &lt;code>--offline-scan&lt;/code> 参数来避免 Trivy 去发起更新漏洞库的请求。在离线环境或者网络不好的场景下会比较有用；&lt;/li>
&lt;li>&lt;strong>优化了内存的使用&lt;/strong>，在之前版本的逻辑中，如果对于大文件也会直接进行读取，有可能会造成 OOM 。本次修正了该问题，加入了一定的缓存。如果你正在使用 Trivy ，我建议你进行更新；&lt;/li>
&lt;li>再对 rpm 包扫描的时候， &lt;strong>支持了 NDB 格式&lt;/strong> ， 对此格式感兴趣的小伙伴可以去看看 rpm 项目的发版说明。&lt;/li>
&lt;/ul>
&lt;p>你可以直接去它的 Release 页面下载最新的二进制，也可以直接使用其容器镜像。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ docker pull aquasec/trivy:0.22.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于此版本的其他变更，可&lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.22.0">参考其 ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="helm-v372-发布">Helm v3.7.2 发布&lt;/h1>
&lt;p>Helm 最新一个大版本是 v3.7.0，但如果你去关注这个项目实际的变更，你会发现即使是大版本更新，也没有携带特别值得有价值的内容。反倒是这个小版本中还带来了一些值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>修复了一个 Helm upgrade 时，内存泄漏的问题&lt;/strong>，感兴趣的小伙伴可以去围观下 &lt;a href="https://github.com/helm/helm/issues/10439">https://github.com/helm/helm/issues/10439&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>至于之前版本中的变更，感兴趣的小伙伴可以自行去看看其 &lt;a href="https://github.com/helm/helm/releases">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="rook-发布-v18-版本">Rook 发布 v1.8 版本&lt;/h1>
&lt;p>Rook 是一个开源的，专用于 Kubernetes 平台上存储编排的组件。目前是 CNCF 毕业项目。在之前的 『K8s生态周报』中我也一直都有介绍，这里就不展开了，大家有兴趣的可以看看历史文章。现在我们一起来看它的新版本中有哪些值得关注的内容吧。&lt;/p>
&lt;p>首先是一些 Breaking Change：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Rook 可以与 Kubernetes v1.16 或更高版本兼容&lt;/strong>。这主要是由于其使用 CRD 的方式进行实现，而 Kubernetes 在 v1.22 版本中将旧的 API 已经移除，所以 Rook 将它使用的 API version 也已经升级到了 v1。在进 rook 升级操作的时候，如果当前的 Kubernetes 版本较低，则建议先升级 Kubernetes 集群再升级 Rook。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 v1.8 中对于 Ceph Nautilus 版本的支持已经移除，如果你之前有通过 Rook 部署的 Ceph Nautilus 版本的集群，那么建议先升级到 Octopus 或者 Pacific 版本，以便保证 Rook 可以正常的处理其版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现在已经完全使用 CSI 接口进行存储管理了，之前 Rook 支持的 Flex 驱动已经彻底废弃，如果想要进行迁移的小伙伴，可以参考 &lt;a href="https://rook.github.io/docs/rook/v1.7/flex-to-csi-migration.html">https://rook.github.io/docs/rook/v1.7/flex-to-csi-migration.html&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>此外还带来了很多新的功能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>支持使用 HashiCorp Vault 时进行 Kubernetes 身份验证；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了提供更好的安全性，当前的 Rook operator 和 toolbox 容器都运行在 &lt;code>rook&lt;/code> 用户下，而非原先的 &lt;code>root&lt;/code> 用户下；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rook 镜像中默认安装了 &lt;code>s5cmd&lt;/code> 工具，这是一个可以提供快速 S3 操作的工具，你可以在 &lt;a href="https://github.com/peak/s5cmd">https://github.com/peak/s5cmd&lt;/a> 找到它。默认提供的 &lt;code>s5cmd&lt;/code> 可以方便我们在 toolbox 中快速的验证 S3 gateway 的功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rook 当前添加了一个 &lt;code>ceph.rook.io/disaster-protection&lt;/code> finalizer 可用于阻止重要资源被意外删除，如果想要删除这些重要资源的话，需要如下步骤：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl -n rook-ceph patch configmap rook-ceph-mon-endpoints --type merge -p &lt;span class="s1">&amp;#39;{&amp;#34;metadata&amp;#34;:{&amp;#34;finalizers&amp;#34;: [null]}}&amp;#39;&lt;/span>
kubectl -n rook-ceph patch secrets rook-ceph-mon --type merge -p &lt;span class="s1">&amp;#39;{&amp;#34;metadata&amp;#34;:{&amp;#34;finalizers&amp;#34;: [null]}}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上就是关于 Rook v1.8 版本中值得关注的内容了，如果对其他变更感兴趣，可以查看其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.8.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/97252">Completely remove in-tree dockershim from kubelet by dims · #97252&lt;/a> 这个 PR 中彻底移除了 kubelet 中 in-tree 的 dockershim，关于这个内容可以参考我之前的文章；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/105164">Introduce new prune parameter into diff command by ardaguclu · #105164&lt;/a> 这个 PR 中为 &lt;code>kubectl diff&lt;/code> 增加了一个 &lt;code>--prune&lt;/code> 参数，其行为类似于 &lt;code>kubectl apply --prune&lt;/code>，会清理掉一些 managedFields 等内容，更容易观察到真正的变更；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/105566">Enable setting proxyurl in kubeconfig via kubectl config by ardaguclu · #105566&lt;/a> 可以通过 &lt;code>kubectl config&lt;/code> 设置 &lt;code>proxy-url&lt;/code>, 这样会比较方便一些部署在代理之后的集群；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="题外话">题外话&lt;/h1>
&lt;p>整体而言，近两周没有特别大的变更，一方面是由于已经到年底了，社区中大多数海外贡献者基本已经休假。另一方面是由于基本上今年的目标已经完成，接下来的迭代重点会放在年后。&lt;/p>
&lt;p>近期我会发布一篇内容，基于 2021 年 K8s 生态中值得关注的内容，以及整体的一些技术趋势，进行 2021 年 K8s 生态的总结，以及对 2022 年 K8s 生态发展的预测，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">倍受关注的 Cilium Service Mesh 到底怎么玩？ - 上手实践</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/21/%E5%80%8D%E5%8F%97%E5%85%B3%E6%B3%A8%E7%9A%84-Cilium-Service-Mesh-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%8E%A9-%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/"/><id>https://moelove.info/2021/12/21/%E5%80%8D%E5%8F%97%E5%85%B3%E6%B3%A8%E7%9A%84-Cilium-Service-Mesh-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%8E%A9-%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/</id><updated>2021-12-21T10:36:50+08:00</updated><published>2021-12-21T02:30:17+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 Cilium 是一个基于 eBPF 技术，用于为容器工作负载间提供安全且具备可观测性的网络连接的开源软件。 如果你对 Cilium 还不太了解，可……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>Cilium 是一个基于 eBPF 技术，用于为容器工作负载间提供安全且具备可观测性的网络连接的开源软件。&lt;/p>
&lt;p>如果你对 Cilium 还不太了解，可以参考我之前的两篇文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/195759300">K8S生态周报| Google 选择 Cilium 作为 GKE 下一代数据面&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/213745089">Cilium 上手实践&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>最近&lt;a href="https://github.com/cilium/cilium/releases/tag/v1.11.0"> Cilium v1.11.0 正式发布了&lt;/a>，增加 Open Telemetry 的支持以及其他一些增强特性。同时，也宣布了 Cilium Service Mesh 的计划。当前 Cilium Service Mesh 正处于测试阶段，预期在 2022 年会合并到 Cilium v1.12 版本中。&lt;/p>
&lt;p>Cilium Service Mesh 也带来了一个全新的模式。&lt;/p>
&lt;p>Cilium 直接通过 eBPF 技术实现的 Service Mesh 相比我们常规的 Istio/Linkerd 等方案，最显著的特点就是将 Sidecar proxy 模型替换成了 Kernel 模型， 如下图：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/21/IkKCZvgOA5priP2.png" alt="img">&lt;/p>
&lt;p>不再需要每个应用程序旁边都放置一个 Sidecar 了，直接在每台 Node 上提供支持。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/21/3gwSD2GXdcuBNKH.png" alt="img">&lt;/p>
&lt;p>我在几个月前就已经知道了这个消息并且进行了一些讨论，最近随着 isovalent 的一篇文章 &lt;a href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh">How eBPF will solve Service Mesh - Goodbye Sidecars&lt;/a> ，Cilium Service Mesh 也成为了大家关注的焦点。&lt;/p>
&lt;p>本篇我带你实际体验下 Cilium Service Mesh。&lt;/p>
&lt;h2 id="安装部署">安装部署&lt;/h2>
&lt;p>这里我使用 KIND 作为测试环境，我的内核版本是 5.15.8 。&lt;/p>
&lt;h3 id="准备-kind-集群">准备 KIND 集群&lt;/h3>
&lt;p>关于 KIND 命令行工具的安装这里就不再赘述了，感兴趣的小伙伴可以参考我之前的文章 《使用KIND搭建自己的本地 Kubernetes 测试环境》。&lt;/p>
&lt;p>以下是我创建集群使用的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kind.x-k8s.io/v1alpha4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">nodes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">networking&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">disableDefaultCNI&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建集群：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kind create cluster --config kind-config.yaml
Creating cluster &lt;span class="s2">&amp;#34;kind&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.22.4&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦 📦 📦 📦
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing StorageClass 💾
✓ Joining worker nodes 🚜
Set kubectl context to &lt;span class="s2">&amp;#34;kind-kind&amp;#34;&lt;/span>
You can now use your cluster with:
kubectl cluster-info --context kind-kind
Not sure what to &lt;span class="k">do&lt;/span> next? 😅 Check out https://kind.sigs.k8s.io/docs/user/quick-start/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装-cilium-cli">安装 Cilium CLI&lt;/h3>
&lt;p>这里我们使用 Cilium CLI 工具进行 Cilium 的部署。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz&lt;span class="se">\{&lt;/span>,.sha256sum&lt;span class="se">\}&lt;/span>
&lt;span class="o">[&lt;/span>1/2&lt;span class="o">]&lt;/span>: https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz --&amp;gt; cilium-linux-amd64.tar.gz
--_curl_--https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz
% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed
&lt;span class="m">100&lt;/span> &lt;span class="m">154&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">154&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">243&lt;/span> &lt;span class="m">0&lt;/span> --:--:-- --:--:-- --:--:-- &lt;span class="m">242&lt;/span>
&lt;span class="m">100&lt;/span> &lt;span class="m">664&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">664&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">579&lt;/span> &lt;span class="m">0&lt;/span> 0:00:01 0:00:01 --:--:-- &lt;span class="m">579&lt;/span>
&lt;span class="m">100&lt;/span> 14.6M &lt;span class="m">100&lt;/span> 14.6M &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 2928k &lt;span class="m">0&lt;/span> 0:00:05 0:00:05 --:--:-- 3910k
&lt;span class="o">[&lt;/span>2/2&lt;span class="o">]&lt;/span>: https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz.sha256sum --&amp;gt; cilium-linux-amd64.tar.gz.sha256sum
--_curl_--https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz.sha256sum
% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed
&lt;span class="m">100&lt;/span> &lt;span class="m">164&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">164&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">419&lt;/span> &lt;span class="m">0&lt;/span> --:--:-- --:--:-- --:--:-- &lt;span class="m">418&lt;/span>
&lt;span class="m">100&lt;/span> &lt;span class="m">674&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">674&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">861&lt;/span> &lt;span class="m">0&lt;/span> --:--:-- --:--:-- --:--:-- &lt;span class="m">861&lt;/span>
&lt;span class="m">100&lt;/span> &lt;span class="m">92&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">92&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">67&lt;/span> &lt;span class="m">0&lt;/span> 0:00:01 0:00:01 --:--:-- &lt;span class="m">0&lt;/span>
➜ cilium-mesh ls
cilium-linux-amd64.tar.gz cilium-linux-amd64.tar.gz.sha256sum kind-config.yaml
➜ cilium-mesh tar -zxvf cilium-linux-amd64.tar.gz
cilium
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加载镜像">加载镜像&lt;/h3>
&lt;p>在部署 Cilium 的过程中需要一些镜像，我们可以提前下载后加载到 KIND 的 Node 节点中。如果你的网络比较顺畅， 那这一步可以跳过。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh &lt;span class="nv">ciliumMeshImage&lt;/span>&lt;span class="o">=(&lt;/span>&lt;span class="s2">&amp;#34;quay.io/cilium/cilium-service-mesh:v1.11.0-beta.1&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;quay.io/cilium/operator-generic-service-mesh:v1.11.0-beta.1&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;quay.io/cilium/hubble-relay-service-mesh:v1.11.0-beta.1&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
➜ cilium-mesh &lt;span class="k">for&lt;/span> i in &lt;span class="si">${&lt;/span>&lt;span class="nv">ciliumMeshImage&lt;/span>&lt;span class="p">[@]&lt;/span>&lt;span class="si">}&lt;/span>
&lt;span class="k">do&lt;/span>
docker pull &lt;span class="nv">$i&lt;/span>
kind load docker-image &lt;span class="nv">$i&lt;/span>
&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-cilium">部署 cilium&lt;/h3>
&lt;p>接下来我们直接使用 Cilium CLI 完成部署。注意这里的参数。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium install --version -service-mesh:v1.11.0-beta.1 --config enable-envoy-config&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> --kube-proxy-replacement&lt;span class="o">=&lt;/span>probe --agent-image&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;quay.io/cilium/cilium-service-mesh:v1.11.0-beta.1&amp;#39;&lt;/span> --operator-image&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;quay.io/cilium/operator-generic-service-mesh:v1.11.0-beta.1&amp;#39;&lt;/span> --datapath-mode&lt;span class="o">=&lt;/span>vxlan
🔮 Auto-detected Kubernetes kind: kind
✨ Running &lt;span class="s2">&amp;#34;kind&amp;#34;&lt;/span> validation checks
✅ Detected kind version &lt;span class="s2">&amp;#34;0.12.0&amp;#34;&lt;/span>
ℹ️ using Cilium version &lt;span class="s2">&amp;#34;-service-mesh:v1.11.0-beta.1&amp;#34;&lt;/span>
🔮 Auto-detected cluster name: kind-kind
🔮 Auto-detected IPAM mode: kubernetes
🔮 Custom datapath mode: vxlan
🔑 Found CA in secret cilium-ca
🔑 Generating certificates &lt;span class="k">for&lt;/span> Hubble...
🚀 Creating Service accounts...
🚀 Creating Cluster roles...
🚀 Creating ConfigMap &lt;span class="k">for&lt;/span> Cilium version 1.11.0...
ℹ️ Manual overwrite in ConfigMap: enable-envoy-config&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
🚀 Creating Agent DaemonSet...
🚀 Creating Operator Deployment...
⌛ Waiting &lt;span class="k">for&lt;/span> Cilium to be installed and ready...
✅ Cilium was successfully installed! Run &lt;span class="s1">&amp;#39;cilium status&amp;#39;&lt;/span> to view installation health
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看状态">查看状态&lt;/h3>
&lt;p>在安装成功后， 可以通过 &lt;code>cilium status&lt;/code>命令来查看当前 Cilium 的部署情况。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium status
/¯¯&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> /¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Cilium: OK
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ Operator: OK
/¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Hubble: disabled
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ ClusterMesh: disabled
&lt;span class="se">\_&lt;/span>_/
Deployment cilium-operator Desired: 1, Ready: 1/1, Available: 1/1
DaemonSet cilium Desired: 4, Ready: 4/4, Available: 4/4
Containers: cilium Running: &lt;span class="m">4&lt;/span>
cilium-operator Running: &lt;span class="m">1&lt;/span>
Cluster Pods: 3/3 managed by Cilium
Image versions cilium quay.io/cilium/cilium-service-mesh:v1.11.0-beta.1: &lt;span class="m">4&lt;/span>
cilium-operator quay.io/cilium/operator-generic-service-mesh:v1.11.0-beta.1: &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>​&lt;/p>
&lt;h3 id="启用-hubble">启用 Hubble&lt;/h3>
&lt;p>Hubble 主要是用来提供可观测能力的。在启用它之前，需要先加载一个镜像，如果网络畅通可以跳过。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker.io/envoyproxy/envoy:v1.18.2@sha256:e8b37c1d75787dd1e712ff389b0d37337dc8a174a63bed9c34ba73359dc67da7
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用 Cilium CLI 开启 Hubble ：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium hubble &lt;span class="nb">enable&lt;/span> --relay-image&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;quay.io/cilium/hubble-relay-service-mesh:v1.11.0-beta.1&amp;#39;&lt;/span> --ui
🔑 Found CA in secret cilium-ca
✨ Patching ConfigMap cilium-config to &lt;span class="nb">enable&lt;/span> Hubble...
♻️ Restarted Cilium pods
⌛ Waiting &lt;span class="k">for&lt;/span> Cilium to become ready before deploying other Hubble component&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span>...
🔑 Generating certificates &lt;span class="k">for&lt;/span> Relay...
✨ Deploying Relay from quay.io/cilium/hubble-relay-service-mesh:v1.11.0-beta.1...
✨ Deploying Hubble UI from quay.io/cilium/hubble-ui:v0.8.3 and Hubble UI Backend from quay.io/cilium/hubble-ui-backend:v0.8.3...
⌛ Waiting &lt;span class="k">for&lt;/span> Hubble to be installed...
/¯¯&lt;span class="se">\ &lt;/span>
/¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Cilium: OK
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ Operator: OK
/¯¯&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\ &lt;/span> Hubble: OK
&lt;span class="se">\_&lt;/span>_/¯¯&lt;span class="se">\_&lt;/span>_/ ClusterMesh: disabled
&lt;span class="se">\_&lt;/span>_/
DaemonSet cilium Desired: 4, Ready: 4/4, Available: 4/4
Deployment cilium-operator Desired: 1, Ready: 1/1, Available: 1/1
Deployment hubble-relay Desired: 1, Ready: 1/1, Available: 1/1
Deployment hubble-ui Desired: 1, Unavailable: 1/1
Containers: cilium Running: &lt;span class="m">4&lt;/span>
cilium-operator Running: &lt;span class="m">1&lt;/span>
hubble-relay Running: &lt;span class="m">1&lt;/span>
hubble-ui Running: &lt;span class="m">1&lt;/span>
Cluster Pods: 5/5 managed by Cilium
Image versions cilium quay.io/cilium/cilium-service-mesh:v1.11.0-beta.1: &lt;span class="m">4&lt;/span>
cilium-operator quay.io/cilium/operator-generic-service-mesh:v1.11.0-beta.1: &lt;span class="m">1&lt;/span>
hubble-relay quay.io/cilium/hubble-relay-service-mesh:v1.11.0-beta.1: &lt;span class="m">1&lt;/span>
hubble-ui quay.io/cilium/hubble-ui:v0.8.3: &lt;span class="m">1&lt;/span>
hubble-ui quay.io/cilium/hubble-ui-backend:v0.8.3: &lt;span class="m">1&lt;/span>
hubble-ui docker.io/envoyproxy/envoy:v1.18.2@sha256:e8b37c1d75787dd1e712ff389b0d37337dc8a174a63bed9c34ba73359dc67da7: &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="测试-7-层-ingress-流量管理">测试 7 层 Ingress 流量管理&lt;/h2>
&lt;h3 id="安装lb">安装LB&lt;/h3>
&lt;p>这里我们可以给 KIND 集群中安装 MetaLB ，以便于我们可以使用 LoadBalancer 类型的 svc 资源（Cilium 会默认创建一个 LoadBalancer 类型的 svc）。如果不安装 MetaLB ，那也可以使用 NodePort 的方式来进行替代。&lt;/p>
&lt;p>具体过程就不一一介绍了，直接按下述操作步骤执行即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/master/manifests/namespace.yaml
namespace/metallb-system created
➜ cilium-mesh kubectl create secret generic -n metallb-system memberlist --from-literal&lt;span class="o">=&lt;/span>&lt;span class="nv">secretkey&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>openssl rand -base64 128&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
secret/memberlist created
➜ cilium-mesh kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/master/manifests/metallb.yaml
Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+
podsecuritypolicy.policy/controller created
podsecuritypolicy.policy/speaker created
serviceaccount/controller created
serviceaccount/speaker created
clusterrole.rbac.authorization.k8s.io/metallb-system:controller created
clusterrole.rbac.authorization.k8s.io/metallb-system:speaker created
role.rbac.authorization.k8s.io/config-watcher created
role.rbac.authorization.k8s.io/pod-lister created
role.rbac.authorization.k8s.io/controller created
clusterrolebinding.rbac.authorization.k8s.io/metallb-system:controller created
clusterrolebinding.rbac.authorization.k8s.io/metallb-system:speaker created
rolebinding.rbac.authorization.k8s.io/config-watcher created
rolebinding.rbac.authorization.k8s.io/pod-lister created
rolebinding.rbac.authorization.k8s.io/controller created
daemonset.apps/speaker created
deployment.apps/controller created
➜ cilium-mesh docker network inspect -f &lt;span class="s1">&amp;#39;{{.IPAM.Config}}&amp;#39;&lt;/span> kind
&lt;span class="o">[{&lt;/span>172.18.0.0/16 172.18.0.1 map&lt;span class="o">[]}&lt;/span> &lt;span class="o">{&lt;/span>fc00:f853:ccd:e793::/64 fc00:f853:ccd:e793::1 map&lt;span class="o">[]}]&lt;/span>
➜ cilium-mesh vim kind-lb-cm.yaml
➜ cilium-mesh cat kind-lb-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
namespace: metallb-system
name: config
data:
config: &lt;span class="p">|&lt;/span>
address-pools:
- name: default
protocol: layer2
addresses:
- 172.18.255.200-172.18.255.250
➜ cilium-mesh kubectl apply -f kind-lb-cm.yaml
configmap/config created
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加载镜像-1">加载镜像&lt;/h3>
&lt;p>这里我们使用 &lt;code>hashicorp/http-echo:0.2.3&lt;/code>作为示例程序，它们可以按照启动参数的不同响应不同的内容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh docker pull hashicorp/http-echo:0.2.3
0.2.3: Pulling from hashicorp/http-echo
86399148984b: Pull &lt;span class="nb">complete&lt;/span>
Digest: sha256:ba27d460cd1f22a1a4331bdf74f4fccbc025552357e8a3249c40ae216275de96
Status: Downloaded newer image &lt;span class="k">for&lt;/span> hashicorp/http-echo:0.2.3
docker.io/hashicorp/http-echo:0.2.3
➜ cilium-mesh kind load docker-image hashicorp/http-echo:0.2.3
Image: &lt;span class="s2">&amp;#34;hashicorp/http-echo:0.2.3&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:a6838e9a6ff6ab3624720a7bd36152dda540ce3987714398003e14780e61478a&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;hashicorp/http-echo:0.2.3&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:a6838e9a6ff6ab3624720a7bd36152dda540ce3987714398003e14780e61478a&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker2&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;hashicorp/http-echo:0.2.3&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:a6838e9a6ff6ab3624720a7bd36152dda540ce3987714398003e14780e61478a&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-control-plane&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;hashicorp/http-echo:0.2.3&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:a6838e9a6ff6ab3624720a7bd36152dda540ce3987714398003e14780e61478a&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker3&amp;#34;&lt;/span>, loading...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署测试服务">部署测试服务&lt;/h3>
&lt;p>&lt;strong>本文中的所有配置文件均可在 &lt;a href="https://github.com/tao12345666333/practical-kubernetes/tree/main/cilium-mesh">https://github.com/tao12345666333/practical-kubernetes/tree/main/cilium-mesh&lt;/a> 代码仓库中获取。&lt;/strong>&lt;/p>
&lt;p>我们使用如下配置进行测试服务的部署：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hashicorp/http-echo:0.2.3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;-text=foo&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hashicorp/http-echo:0.2.3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;-text=bar&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新建如下的 Ingress 资源文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium-ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ingressClassName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">foo-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/foo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pathType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Prefix&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bar-app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5678&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/bar&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pathType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Prefix&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建 Ingress 资源，然后可以看到产生了一个新的 LoadBalancer 类型的 svc 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl apply -f cilium-ingress.yaml
ingress.networking.k8s.io/cilium-ingress created
➜ cilium-mesh kubectl get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
bar-app ClusterIP 10.96.229.141 &amp;lt;none&amp;gt; 5678/TCP 106s
cilium-ingress-cilium-ingress LoadBalancer 10.96.161.128 172.18.255.200 80:31643/TCP 4s
foo-app ClusterIP 10.96.166.212 &amp;lt;none&amp;gt; 5678/TCP 106s
kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 81m
➜ cilium-mesh kubectl get ing
NAME CLASS HOSTS ADDRESS PORTS AGE
cilium-ingress cilium * 172.18.255.200 &lt;span class="m">80&lt;/span> 1m
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>使用 curl 命令进行测试访问，发现可以按照 Ingress 资源中的配置得到正确的响应。查看响应头，我们会发现这里的代理实际上还是使用的 Envoy 来完成的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh curl 172.18.255.200
➜ cilium-mesh curl 172.18.255.200/foo
foo
➜ cilium-mesh curl 172.18.255.200/bar
bar
➜ cilium-mesh curl -I 172.18.255.200/bar
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Content-Length: &lt;span class="m">4&lt;/span>
Connection: keep-alive
Content-Type: text/plain&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>utf-8
Date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 06:02:56 GMT
Keep-Alive: &lt;span class="nv">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
Proxy-Connection: keep-alive
Server: envoy
X-App-Name: http-echo
X-App-Version: 0.2.3
X-Envoy-Upstream-Service-Time: &lt;span class="m">0&lt;/span>
➜ cilium-mesh curl -I 172.18.255.200/foo
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
Content-Length: &lt;span class="m">4&lt;/span>
Connection: keep-alive
Content-Type: text/plain&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>utf-8
Date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 06:03:01 GMT
Keep-Alive: &lt;span class="nv">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">4&lt;/span>
Proxy-Connection: keep-alive
Server: envoy
X-App-Name: http-echo
X-App-Version: 0.2.3
X-Envoy-Upstream-Service-Time: &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="测试-ciliumenvoyconfig">测试 CiliumEnvoyConfig&lt;/h2>
&lt;p>在使用上述方式部署 CIlium 后， 它其实还安装了一些 CRD 资源。其中有一个是 &lt;code>CiliumEnvoyConfig&lt;/code>用于配置服务之间代理的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl api-resources &lt;span class="p">|&lt;/span>grep cilium.io
ciliumclusterwidenetworkpolicies ccnp cilium.io/v2 &lt;span class="nb">false&lt;/span> CiliumClusterwideNetworkPolicy
ciliumendpoints cep,ciliumep cilium.io/v2 &lt;span class="nb">true&lt;/span> CiliumEndpoint
ciliumenvoyconfigs cec cilium.io/v2alpha1 &lt;span class="nb">false&lt;/span> CiliumEnvoyConfig
ciliumexternalworkloads cew cilium.io/v2 &lt;span class="nb">false&lt;/span> CiliumExternalWorkload
ciliumidentities ciliumid cilium.io/v2 &lt;span class="nb">false&lt;/span> CiliumIdentity
ciliumnetworkpolicies cnp,ciliumnp cilium.io/v2 &lt;span class="nb">true&lt;/span> CiliumNetworkPolicy
ciliumnodes cn,ciliumn cilium.io/v2 &lt;span class="nb">false&lt;/span> CiliumNode
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署测试服务-1">部署测试服务&lt;/h3>
&lt;p>可以先进行 Hubble 的 port-forward&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium hubble port-forward
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认会监听到 4245 端口上，如果不提前执行此操作就会出现下述内容&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">🔭 Enabling Hubble telescope...
⚠️ Unable to contact Hubble Relay, disabling Hubble telescope and flow validation: rpc error: &lt;span class="nv">code&lt;/span> &lt;span class="o">=&lt;/span> Unavailable &lt;span class="nv">desc&lt;/span> &lt;span class="o">=&lt;/span> connection error: &lt;span class="nv">desc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;transport: Error while dialing dial tcp [::1]:4245: connect: connection refused&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果已经开启 Hubble 的 port-forward ，正常情况下会得到如下输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium connectivity &lt;span class="nb">test&lt;/span> --test egress-l7
ℹ️ Monitor aggregation detected, will skip some flow validation steps
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> deployments &lt;span class="o">[&lt;/span>client client2 echo-same-node&lt;span class="o">]&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> deployments &lt;span class="o">[&lt;/span>echo-other-node&lt;span class="o">]&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> CiliumEndpoint &lt;span class="k">for&lt;/span> pod cilium-test/client-6488dcf5d4-pk6w9 to appear...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> CiliumEndpoint &lt;span class="k">for&lt;/span> pod cilium-test/client2-5998d566b4-hrhrb to appear...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> CiliumEndpoint &lt;span class="k">for&lt;/span> pod cilium-test/echo-other-node-f4d46f75b-bqpcb to appear...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> CiliumEndpoint &lt;span class="k">for&lt;/span> pod cilium-test/echo-same-node-745bd5c77-zpzdn to appear...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> Service cilium-test/echo-other-node to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> Service cilium-test/echo-same-node to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.5:32751 &lt;span class="o">(&lt;/span>cilium-test/echo-other-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.5:32133 &lt;span class="o">(&lt;/span>cilium-test/echo-same-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.3:32133 &lt;span class="o">(&lt;/span>cilium-test/echo-same-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.3:32751 &lt;span class="o">(&lt;/span>cilium-test/echo-other-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.2:32751 &lt;span class="o">(&lt;/span>cilium-test/echo-other-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.2:32133 &lt;span class="o">(&lt;/span>cilium-test/echo-same-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.4:32751 &lt;span class="o">(&lt;/span>cilium-test/echo-other-node&lt;span class="o">)&lt;/span> to become ready...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> NodePort 172.18.0.4:32133 &lt;span class="o">(&lt;/span>cilium-test/echo-same-node&lt;span class="o">)&lt;/span> to become ready...
ℹ️ Skipping IPCache check
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> pod cilium-test/client-6488dcf5d4-pk6w9 to reach default/kubernetes service...
⌛ &lt;span class="o">[&lt;/span>kind-kind&lt;span class="o">]&lt;/span> Waiting &lt;span class="k">for&lt;/span> pod cilium-test/client2-5998d566b4-hrhrb to reach default/kubernetes service...
🔭 Enabling Hubble telescope...
ℹ️ Hubble is OK, flows: 16380/16380
🏃 Running tests...
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>no-policies&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>allow-all&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>client-ingress&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>echo-ingress&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>client-egress&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>to-entities-world&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>to-cidr-1111&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>echo-ingress-l7&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Test &lt;span class="o">[&lt;/span>client-egress-l7&lt;span class="o">]&lt;/span>
..........
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>dns-only&lt;span class="o">]&lt;/span>
&lt;span class="o">[=]&lt;/span> Skipping Test &lt;span class="o">[&lt;/span>to-fqdns&lt;span class="o">]&lt;/span>
✅ All &lt;span class="m">1&lt;/span> tests &lt;span class="o">(&lt;/span>&lt;span class="m">10&lt;/span> actions&lt;span class="o">)&lt;/span> successful, &lt;span class="m">10&lt;/span> tests skipped, &lt;span class="m">0&lt;/span> scenarios skipped.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以同时打开UI看看：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh cilium hubble ui
ℹ️ Opening &lt;span class="s2">&amp;#34;http://localhost:12000&amp;#34;&lt;/span> in your browser...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果图如下：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/21/OcJRdFrhsWVG76w.png" alt="img">&lt;/p>
&lt;p>这个操作实际上会进行如下部署：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl -n cilium-test get all
NAME READY STATUS RESTARTS AGE
pod/client-6488dcf5d4-pk6w9 1/1 Running &lt;span class="m">0&lt;/span> 66m
pod/client2-5998d566b4-hrhrb 1/1 Running &lt;span class="m">0&lt;/span> 66m
pod/echo-other-node-f4d46f75b-bqpcb 1/1 Running &lt;span class="m">0&lt;/span> 66m
pod/echo-same-node-745bd5c77-zpzdn 1/1 Running &lt;span class="m">0&lt;/span> 66m
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
service/echo-other-node NodePort 10.96.124.211 &amp;lt;none&amp;gt; 8080:32751/TCP 66m
service/echo-same-node NodePort 10.96.136.252 &amp;lt;none&amp;gt; 8080:32133/TCP 66m
NAME READY UP-TO-DATE AVAILABLE AGE
deployment.apps/client 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
deployment.apps/client2 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
deployment.apps/echo-other-node 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
deployment.apps/echo-same-node 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
NAME DESIRED CURRENT READY AGE
replicaset.apps/client-6488dcf5d4 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
replicaset.apps/client2-5998d566b4 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
replicaset.apps/echo-other-node-f4d46f75b &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
replicaset.apps/echo-same-node-745bd5c77 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 66m
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以看看它的 label：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl get pods -n cilium-test --show-labels -o wide
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES LABELS
client-6488dcf5d4-pk6w9 1/1 Running &lt;span class="m">0&lt;/span> 67m 10.244.3.7 kind-worker3 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; &lt;span class="nv">kind&lt;/span>&lt;span class="o">=&lt;/span>client,name&lt;span class="o">=&lt;/span>client,pod-template-hash&lt;span class="o">=&lt;/span>6488dcf5d4
client2-5998d566b4-hrhrb 1/1 Running &lt;span class="m">0&lt;/span> 67m 10.244.3.18 kind-worker3 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; &lt;span class="nv">kind&lt;/span>&lt;span class="o">=&lt;/span>client,name&lt;span class="o">=&lt;/span>client2,other&lt;span class="o">=&lt;/span>client,pod-template-hash&lt;span class="o">=&lt;/span>5998d566b4
echo-other-node-f4d46f75b-bqpcb 1/1 Running &lt;span class="m">0&lt;/span> 67m 10.244.1.146 kind-worker2 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; &lt;span class="nv">kind&lt;/span>&lt;span class="o">=&lt;/span>echo,name&lt;span class="o">=&lt;/span>echo-other-node,pod-template-hash&lt;span class="o">=&lt;/span>f4d46f75b
echo-same-node-745bd5c77-zpzdn 1/1 Running &lt;span class="m">0&lt;/span> 67m 10.244.3.164 kind-worker3 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; &lt;span class="nv">kind&lt;/span>&lt;span class="o">=&lt;/span>echo,name&lt;span class="o">=&lt;/span>echo-same-node,other&lt;span class="o">=&lt;/span>echo,pod-template-hash&lt;span class="o">=&lt;/span>745bd5c77
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试-1">测试&lt;/h3>
&lt;p>这里我们在主机上进行操作下， 先拿到 client2 的 Pod 名称，然后通过 Hubble 命令观察所有访问此 Pod 的流量。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh &lt;span class="nb">export&lt;/span> &lt;span class="nv">CLIENT2&lt;/span>&lt;span class="o">=&lt;/span>client2-5998d566b4-hrhrb
➜ cilium-mesh hubble observe --from-pod cilium-test/&lt;span class="nv">$CLIENT2&lt;/span> -f
Dec &lt;span class="m">18&lt;/span> 14:07:37.200: cilium-test/client2-5998d566b4-hrhrb:44805 &amp;lt;&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-overlay FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.200: cilium-test/client2-5998d566b4-hrhrb:44805 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.200: cilium-test/client2-5998d566b4-hrhrb:44805 &amp;lt;&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-overlay FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.200: cilium-test/client2-5998d566b4-hrhrb:44805 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.200: cilium-test/client2-5998d566b4-hrhrb:42260 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.201: cilium-test/client2-5998d566b4-hrhrb:42260 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.201: cilium-test/client2-5998d566b4-hrhrb:42260 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.202: cilium-test/client2-5998d566b4-hrhrb:42260 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:37.203: cilium-test/client2-5998d566b4-hrhrb:42260 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.769: cilium-test/client2-5998d566b4-hrhrb:36768 &amp;lt;&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-overlay FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.769: cilium-test/client2-5998d566b4-hrhrb:36768 &amp;lt;&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-overlay FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.769: cilium-test/client2-5998d566b4-hrhrb:36768 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.769: cilium-test/client2-5998d566b4-hrhrb:36768 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 &amp;lt;&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-overlay FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 &amp;lt;&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-overlay FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 &amp;lt;&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-overlay FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.770: cilium-test/client2-5998d566b4-hrhrb:42068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.771: cilium-test/client2-5998d566b4-hrhrb:42068 &amp;lt;&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-overlay FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.771: cilium-test/client2-5998d566b4-hrhrb:42068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.772: cilium-test/client2-5998d566b4-hrhrb:42068 &amp;lt;&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-overlay FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:07:50.772: cilium-test/client2-5998d566b4-hrhrb:42068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-endpoint FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上输出是由于我们执行了下面的操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -v echo-same-node:8080/
kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -v echo-other-node:8080/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>日志中基本上都是 &lt;code>to-endpoint&lt;/code> 或者 &lt;code>to-overlay&lt;/code>的。&lt;/p>
&lt;h3 id="测试使用-proxy">测试使用 proxy&lt;/h3>
&lt;p>需要先安装 networkpolicy ， 我们可以直接从 Cilium CLI 的仓库中拿到。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f https://raw.githubusercontent.com/cilium/cilium-cli/master/connectivity/manifests/client-egress-l7-http.yaml
kubectl apply -f https://raw.githubusercontent.com/cilium/cilium-cli/master/connectivity/manifests/client-egress-only-dns.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后重复上面的请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Dec &lt;span class="m">18&lt;/span> 14:33:40.570: cilium-test/client2-5998d566b4-hrhrb:44344 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.570: cilium-test/client2-5998d566b4-hrhrb:44344 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.570: cilium-test/client2-5998d566b4-hrhrb:44344 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.570: cilium-test/client2-5998d566b4-hrhrb:44344 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-other-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.570: cilium-test/client2-5998d566b4-hrhrb:44344 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-other-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.571: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.571: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.571: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.571: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.572: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 http-request FORWARDED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-other-node:8080/&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.573: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:33:40.573: cilium-test/client2-5998d566b4-hrhrb:42074 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行另一个请求：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -v echo-same-node:8080/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以看到如下输出，其中有 &lt;code>to-proxy&lt;/code>的字样。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Dec &lt;span class="m">18&lt;/span> 14:45:18.857: cilium-test/client2-5998d566b4-hrhrb:58895 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.857: cilium-test/client2-5998d566b4-hrhrb:58895 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.857: cilium-test/client2-5998d566b4-hrhrb:58895 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.857: cilium-test/client2-5998d566b4-hrhrb:58895 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.857: cilium-test/client2-5998d566b4-hrhrb:58895 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.858: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.858: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.858: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.858: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.858: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 http-request FORWARDED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-same-node:8080/&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.859: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:45:18.859: cilium-test/client2-5998d566b4-hrhrb:42266 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实看请求头更加方便：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -I echo-same-node:8080/
HTTP/1.1 &lt;span class="m">403&lt;/span> Forbidden
content-length: &lt;span class="m">15&lt;/span>
content-type: text/plain
date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 14:47:39 GMT
server: envoy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之前都是如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1">## 没有 proxy&lt;/span>
➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -v echo-same-node:8080/
* Trying 10.96.136.252:8080...
* Connected to echo-same-node &lt;span class="o">(&lt;/span>10.96.136.252&lt;span class="o">)&lt;/span> port &lt;span class="m">8080&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="c1">#0) &lt;/span>
&amp;gt; GET / HTTP/1.1
&amp;gt; Host: echo-same-node:8080
&amp;gt; User-Agent: curl/7.78.0
&amp;gt; Accept: */*
&amp;gt;
* Mark bundle as not supporting multiuse
&amp;lt; HTTP/1.1 &lt;span class="m">200&lt;/span> OK
&amp;lt; X-Powered-By: Express
&amp;lt; Vary: Origin, Accept-Encoding
&amp;lt; Access-Control-Allow-Credentials: &lt;span class="nb">true&lt;/span>
&amp;lt; Accept-Ranges: bytes
&amp;lt; Cache-Control: public, max-age&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&amp;lt; Last-Modified: Sat, &lt;span class="m">26&lt;/span> Oct &lt;span class="m">1985&lt;/span> 08:15:00 GMT
&amp;lt; ETag: W/&lt;span class="s2">&amp;#34;809-7438674ba0&amp;#34;&lt;/span>
&amp;lt; Content-Type: text/html&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
&amp;lt; Content-Length: &lt;span class="m">2057&lt;/span>
&amp;lt; Date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 14:07:37 GMT
&amp;lt; Connection: keep-alive
&amp;lt; Keep-Alive: &lt;span class="nv">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="请求一个不存在的地址">请求一个不存在的地址：&lt;/h3>
&lt;p>以前请求响应是 404 ，现在是 403 ,并得到如下内容&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -v echo-same-node:8080/foo
* Trying 10.96.136.252:8080...
* Connected to echo-same-node &lt;span class="o">(&lt;/span>10.96.136.252&lt;span class="o">)&lt;/span> port &lt;span class="m">8080&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="c1">#0)&lt;/span>
&amp;gt; GET /foo HTTP/1.1
&amp;gt; Host: echo-same-node:8080
&amp;gt; User-Agent: curl/7.78.0
&amp;gt; Accept: */*
&amp;gt;
* Mark bundle as not supporting multiuse
&amp;lt; HTTP/1.1 &lt;span class="m">403&lt;/span> Forbidden
&amp;lt; content-length: &lt;span class="m">15&lt;/span>
&amp;lt; content-type: text/plain
&amp;lt; date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 14:50:38 GMT
&amp;lt; server: envoy
&amp;lt;
Access denied
* Connection &lt;span class="c1">#0 to host echo-same-node left intact&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>日志中也都是 &lt;code>to-proxy&lt;/code>的字样。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Dec &lt;span class="m">18&lt;/span> 14:50:39.185: cilium-test/client2-5998d566b4-hrhrb:37683 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.185: cilium-test/client2-5998d566b4-hrhrb:37683 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.185: cilium-test/client2-5998d566b4-hrhrb:37683 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.185: cilium-test/client2-5998d566b4-hrhrb:37683 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.185: cilium-test/client2-5998d566b4-hrhrb:37683 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 http-request DROPPED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-same-node:8080/foo&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.186: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 14:50:39.187: cilium-test/client2-5998d566b4-hrhrb:42274 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们使用如下内容作为 Envoy 的配置文件，其中包含 rewrite 策略。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium.io/v2alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumEnvoyConfig&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">envoy-lb-listener&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-other-node&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-same-node&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;@type&amp;#34;: &lt;/span>&lt;span class="l">type.googleapis.com/envoy.config.listener.v3.Listener&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">envoy-lb-listener&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">filter_chains&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">filters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">envoy.filters.network.http_connection_manager&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">typed_config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">&amp;#34;@type&amp;#34;: &lt;/span>&lt;span class="l">type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stat_prefix&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">envoy-lb-listener&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">route_config_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">lb_route&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http_filters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">envoy.filters.http.router&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;@type&amp;#34;: &lt;/span>&lt;span class="l">type.googleapis.com/envoy.config.route.v3.RouteConfiguration&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">lb_route&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">virtual_hosts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;lb_route&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">domains&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">routes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">match&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">prefix&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">route&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">weighted_clusters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">clusters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium-test/echo-same-node&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">weight&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">50&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium-test/echo-other-node&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">weight&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">50&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">retry_policy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">retry_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">5xx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">num_retries&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">per_try_timeout&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">1s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">regex_rewrite&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pattern&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">google_re2&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;^/foo.*$&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">substitution&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;@type&amp;#34;: &lt;/span>&lt;span class="l">type.googleapis.com/envoy.config.cluster.v3.Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium-test/echo-same-node&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">connect_timeout&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">5s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">lb_policy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ROUND_ROBIN&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">EDS&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">outlier_detection&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">split_external_local_origin_errors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">consecutive_local_origin_failure&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;@type&amp;#34;: &lt;/span>&lt;span class="l">type.googleapis.com/envoy.config.cluster.v3.Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium-test/echo-other-node&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">connect_timeout&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">3s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">lb_policy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ROUND_ROBIN&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">EDS&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">outlier_detection&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">split_external_local_origin_errors&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">consecutive_local_origin_failure&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试请求时，发现可以正确的得到响应了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -X GET -I echo-same-node:8080/
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
x-powered-by: Express
vary: Origin, Accept-Encoding
access-control-allow-credentials: &lt;span class="nb">true&lt;/span>
accept-ranges: bytes
cache-control: public, max-age&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
last-modified: Sat, &lt;span class="m">26&lt;/span> Oct &lt;span class="m">1985&lt;/span> 08:15:00 GMT
etag: W/&lt;span class="s2">&amp;#34;809-7438674ba0&amp;#34;&lt;/span>
content-type: text/html&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
content-length: &lt;span class="m">2057&lt;/span>
date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 15:00:01 GMT
x-envoy-upstream-service-time: &lt;span class="m">1&lt;/span>
server: envoy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且请求 &lt;code>/foo&lt;/code>地址时，也可以正确的得到响应了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ cilium-mesh kubectl &lt;span class="nb">exec&lt;/span> -it -n cilium-test &lt;span class="nv">$CLIENT2&lt;/span> -- curl -X GET -I echo-same-node:8080/foo
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
x-powered-by: Express
vary: Origin, Accept-Encoding
access-control-allow-credentials: &lt;span class="nb">true&lt;/span>
accept-ranges: bytes
cache-control: public, max-age&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
last-modified: Sat, &lt;span class="m">26&lt;/span> Oct &lt;span class="m">1985&lt;/span> 08:15:00 GMT
etag: W/&lt;span class="s2">&amp;#34;809-7438674ba0&amp;#34;&lt;/span>
content-type: text/html&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
content-length: &lt;span class="m">2057&lt;/span>
date: Sat, &lt;span class="m">18&lt;/span> Dec &lt;span class="m">2021&lt;/span> 15:01:40 GMT
x-envoy-upstream-service-time: &lt;span class="m">2&lt;/span>
server: envoy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时：请求 &lt;code>/foo&lt;/code> 的时候，流量如下: 直接转换成功了对/的访问&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Dec &lt;span class="m">18&lt;/span> 15:02:22.541: cilium-test/client2-5998d566b4-hrhrb:38860 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.541: cilium-test/client2-5998d566b4-hrhrb:38860 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.541: cilium-test/client2-5998d566b4-hrhrb:38860 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.541: cilium-test/client2-5998d566b4-hrhrb:38860 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.541: cilium-test/client2-5998d566b4-hrhrb:38860 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 none REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53048 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.542: cilium-test/client2-5998d566b4-hrhrb:53048 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 http-request FORWARDED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-same-node:8080/&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.543: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:02:22.544: cilium-test/client2-5998d566b4-hrhrb:53062 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多次请求看日志：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Dec &lt;span class="m">18&lt;/span> 15:07:20.883: cilium-test/client2-5998d566b4-hrhrb:49656 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.883: cilium-test/client2-5998d566b4-hrhrb:49656 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.883: cilium-test/client2-5998d566b4-hrhrb:49656 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.883: cilium-test/client2-5998d566b4-hrhrb:49656 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.884: cilium-test/client2-5998d566b4-hrhrb:49656 -&amp;gt; kube-system/coredns-78fcd69978-2ww28:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 none REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53064 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.885: cilium-test/client2-5998d566b4-hrhrb:53064 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 http-request FORWARDED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-same-node:8080/&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.886: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:20.886: cilium-test/client2-5998d566b4-hrhrb:53070 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:26.086: cilium-test/client2-5998d566b4-hrhrb:53048 -&amp;gt; cilium-test/echo-same-node-745bd5c77-zpzdn:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.739: cilium-test/client2-5998d566b4-hrhrb:39057 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 L3-L4 REDIRECTED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.739: cilium-test/client2-5998d566b4-hrhrb:39057 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.740: cilium-test/client2-5998d566b4-hrhrb:39057 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 to-proxy FORWARDED &lt;span class="o">(&lt;/span>UDP&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.740: cilium-test/client2-5998d566b4-hrhrb:39057 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. AAAA&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.740: cilium-test/client2-5998d566b4-hrhrb:39057 -&amp;gt; kube-system/coredns-78fcd69978-7lbwh:53 dns-request FORWARDED &lt;span class="o">(&lt;/span>DNS Query echo-same-node.cilium-test.svc.cluster.local. A&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.741: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 none REDIRECTED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.741: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: SYN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.741: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.741: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.742: cilium-test/client2-5998d566b4-hrhrb:53068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, PSH&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.742: cilium-test/client2-5998d566b4-hrhrb:53068 -&amp;gt; cilium-test/echo-other-node-f4d46f75b-bqpcb:8080 http-request FORWARDED &lt;span class="o">(&lt;/span>HTTP/1.1 GET http://echo-same-node:8080/&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.744: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK, FIN&lt;span class="o">)&lt;/span>
Dec &lt;span class="m">18&lt;/span> 15:07:44.744: cilium-test/client2-5998d566b4-hrhrb:53072 -&amp;gt; cilium-test/echo-same-node:8080 to-proxy FORWARDED &lt;span class="o">(&lt;/span>TCP Flags: ACK&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到它真的成功的进行了负载均衡。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文我带你部署了 Cilium Service Mesh，并通过两个示例，带你体验了 Cilium Service Mesh 的工作情况。&lt;/p>
&lt;p>整体而言， 这种方式能带来一定的便利性，但它的服务间流量配置主要依靠于 CiliumEnvoyConfig ，不算太方便。&lt;/p>
&lt;p>一起来期待它后续的演进！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/cilium/" term="cilium" label="cilium"/></entry><entry><title type="text">GitOps 应用实践系列 - Flux CD 及其核心组件</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/18/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-Flux-CD-%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/><id>https://moelove.info/2021/12/18/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-Flux-CD-%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id><updated>2021-12-19T15:03:42+08:00</updated><published>2021-12-18T20:56:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 经过前面三篇文章，不仅为大家介绍了什么是 GitOps 也介绍了如何利用 Argo CD 来实施 GitOps。本篇我来为你介绍另一个可用……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>经过前面三篇文章，不仅为大家介绍了什么是 GitOps 也介绍了如何利用 Argo CD 来实施 GitOps。本篇我来为你介绍另一个可用于实施 GitOps 的工具：Flux CD 。&lt;/p>
&lt;h2 id="flux-cd">Flux CD&lt;/h2>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/zFRTjgr18Z7XIfM.png" alt="img">&lt;/p>
&lt;p>Flux 是一组可支持实现 GitOps 的工具，用于使 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a> 集群与配置源（如 Git 仓库）保持同步，并在有代码更新后自动同步配置，面向 Kubernetes 的&lt;strong>持续渐进式交付解决方案&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/EPI7DHZQkWxySvp.png" alt="img">&lt;/p>
&lt;h2 id="flux-cd-的发展历史">Flux CD 的发展历史&lt;/h2>
&lt;ul>
&lt;li>2016 年 10 月 28 日，&lt;a href="https://github.com/fluxcd/flux/releases/tag/pre-split">Flux single-user service&lt;/a> 版本发布。&lt;/li>
&lt;/ul>
&lt;p>它奠定了 flux 的两个基调：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>集中式运行的服务&lt;/li>
&lt;li>以守护进程的方式，在自动模式下运行在 k8s 集群中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>2016 年 12 月 15 日，发布《使用 Weave Flux 持续交付》，构建了将 CI 与持续部署 (CD) 联系起来的 Flux。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/jAcoFS2ulXNH5ia.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>2017 年 8 月 22 日，v1.0.0 版本正式发布。&lt;/li>
&lt;/ul>
&lt;p>自 v1.0.0 开始，Flux 致力于将集群与存储在 Git 中的配置同步，并在新版本准备好部署时自动升级镜像。（提出了：Configuration as code）&lt;/p>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/cvXCry2oRlkmUZI.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>2018 年 5 月 1 日，发布的 alpha 版本中，集成了 Helm Operator 。这是 Flux Helm Operator 的第一个 alpha 标签的版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2019 年 8 月 15 日，Flux 宣布加入 CNCF Sandbox。随着各开发者及企业开始落地 GitOps ，Flux 的用户数量不断增长。 彼时已超过 2500 个 GitHub star，也在不断地集成：Helm Operator 、 Kustomize 、 Weave Flagger 、 OpenFaaS 、 Fluxcloud 、 Flux Web UI 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2019 年 10 月 2 日发布的版本，正式支持 kustomize 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2019 年 11 月 14 日，《Argo Flux 简介 - Weaveworks-Intuit-AWS 协作》中，Weaveworks 宣布与 Intuit 合作创建了 Argo Flux。该项目被称为 &lt;a href="https://github.com/argoproj/gitops-engine">GitOps-Engine&lt;/a> ，现在位于 Argo 项目组织中，由 Intuit、Red Hat 和 GitLab 驱动。（具体可参考：https://www.weave.works/blog/argo-flux-join-forces）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2020 年 10 月 5 日，Flux v1（和 Helm Operator v1）宣布处于维护模式（仅提供 6 个月支持），并宣布将致力于 Flux v2 的开发。&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>Flux v1 is in maintenance mode #3320 &lt;a href="https://github.com/fluxcd/flux/issues/3320">https://github.com/fluxcd/flux/issues/3320&lt;/a>&lt;/li>
&lt;li>Helm Operator (v1) is in maintenance mode #546 &lt;a href="https://github.com/fluxcd/helm-operator/issues/546">https://github.com/fluxcd/helm-operator/issues/546&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>V1 in maintenance #25 &lt;a href="https://github.com/fluxcd/website/pull/25">https://github.com/fluxcd/website/pull/25&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>2021 年 2 月 17日新版本发布，正式将 issue、PR 指向 v2。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2021 年 3 月 11 日，CNCF 技术监督委员会（TOC） 投票将 Flux 从 Sandbox 提升为孵化项目（Incubation）。自加入 CNCF Sandbox 以来，Flux 的最终用户群增加了 2.75 倍，并将其社区扩大了 2 至 4 倍，包括 Slack 用户、邮件列表订阅者和贡献者。 80 多个组织在生产中使用它，包括 Babylon Health、Fidelity Investments、MyFitnessPal、Starbucks 等等。 CNCF End User Community 将 Flux 纳入持续交付的 Technology Radar。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/ThMWO3VmNrIb7Q4.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>2021 年 8 月 13 日，正式发布了《Flux v2 助力 GitOps 变得更好》，宣告了从 Flux 到 Flux v2 的交替。Flux v2 在 Flux 已有功能的基础上，更适于 Kubernetes 的操作和&lt;strong>可观测性&lt;/strong>，并且功能更强大。Flux v2 的基础是 GitOps Toolkit，这是一组用于构建基于 GitOps 的交付和自动化组件。（也实现了重要组件的解耦，具体可参考：https://www.weave.works/blog/gitops-with-flux-v2）&lt;/li>
&lt;/ul>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/rzXIFQh9UcNKlTv.png" alt="img">&lt;/p>
&lt;p>​ 注：Flux 团队决定在不使用 GitOps Engine 的情况下继续前进，并构建了&lt;a href="https://fluxcd.io/docs/">GitOps Toolkit&lt;/a>。Flux v2 参考了 GitOps Engine ，但它不使用 GitOps Engine。&lt;/p>
&lt;ul>
&lt;li>自 2018 年 10 月开始的 Flagger 项目也于 2021 年集成入 Flux v2。&lt;/li>
&lt;/ul>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/ePZqo5dO7LCJzvX.png" alt="img">&lt;/p>
&lt;p>​ &lt;img src="https://i.loli.net/2021/10/31/davhq8DzFbyGj16.png" alt="img">&lt;/p>
&lt;h2 id="flux-cd-v2-和-gitops-toolkit">Flux CD v2 和 GitOps Toolkit&lt;/h2>
&lt;h3 id="gitops-toolkit">GitOps Toolkit&lt;/h3>
&lt;p>GitOps Toolkit 是构成 Flux 运行时的一组 APIs 和 controllers 。可以通过 GitOps Toolkit 来扩展 Flux，并构建所需 CD 系统。&lt;/p>
&lt;h3 id="source-controller">Source Controller&lt;/h3>
&lt;p>Source Controller 主要作用是为工件获取提供通用接口。Source API 定义了一组 Kubernetes 对象，cluster admin 和各种自动化 operator 可以与之交互，以将 Source（如 Git 和 Helm repo）注册、身份验证、验证和资源获取卸载到专用的 controller 。&lt;/p>
&lt;p>每个 Flux 和 Helm 的 operator 都以相同的方式使用 Git repositories 中的代码（镜像），但是其他组件可能需要访问到不同的镜像。Flux 和 Helm operator 就可以使用标准的 Kubernetes 机制来构建 Source （通常是 Git repo，但也有 Helm chart 等） 作为 Kubernetes 资源，独立于使用它们的组件进行管理。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/7JR9PlXLhqUatfT.png" alt="img">&lt;/p>
&lt;h4 id="git-repository">Git Repository&lt;/h4>
&lt;p>它为来自 Git 的 artifact 定义了一个源，将来自 Git 的最新状态作为 artifact 公开为 gzip 压缩的 TAR 文件 ( &lt;commit hash>.tar.gz) 。&lt;/p>
&lt;p>默认情况会排除，Git 文件 ( .git/ ,.gitignore, .gitmodules, .gitattributes)；文件扩展名 ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip)；CI 配置 ( .github/, .circleci/, .travis.yml, .gitlab-ci.yml, appveyor.yml, .drone.yml, cloudbuild.yaml, codeship-services.yml, codeship-steps.yml)；CLI 配置 ( .goreleaser.yml, .sops.yaml)；Flux v1 配置 ( .flux.yaml)。&lt;/p>
&lt;p>如果想要自定义排除可以考虑以下两种办法：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>.sourceignore&lt;/code> 在 repository 的根目录中添加文件 。（遵循 .gitignore 格式，详见 &lt;a href="https://git-scm.com/docs/gitignore#_pattern_format">https://git-scm.com/docs/gitignore#_pattern_format&lt;/a> ）&lt;/li>
&lt;li>使用 spec.ignore 字段。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">source.toolkit.fluxcd.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">GitRepository&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">podinfo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">5m&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com/stefanprodan/podinfo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ignore&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> ## exclude all
&lt;/span>&lt;span class="sd"> /*
&lt;/span>&lt;span class="sd"> ## include deploy dir
&lt;/span>&lt;span class="sd"> !/deploy
&lt;/span>&lt;span class="sd"> ## exclude file extensions from deploy dir
&lt;/span>&lt;span class="sd"> /deploy/**/*.md
&lt;/span>&lt;span class="sd"> /deploy/**/*.txt &lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="helm-charts">Helm Charts&lt;/h4>
&lt;p>它为来自 Helm 源 的 Helm chart artifacts 定义了一个源，将作为 artifact 的最新拉取或打包的 chart 公开。&lt;/p>
&lt;h4 id="helm-repositories">Helm Repositories&lt;/h4>
&lt;p>它为 Helm repositories 定义了一个源，将作为 artifact 的最新同步的 repository 索引公开。&lt;/p>
&lt;h4 id="object-storage-buckets">Object storage buckets&lt;/h4>
&lt;p>它为来自 S3 兼容的存储（Minio, Amazon S3, Google Cloud Storage, Alibaba Cloud OSS 等等）定义了一个源，将来自 S3 的最新同步状态作为 artifact 公开为 gzip 压缩的 TAR 文件 ( &lt;bucket checksum>.tar.gz) 。&lt;/p>
&lt;p>默认及自定义排除文件，可参考 Git Repositories 中的排除文件相关内容。&lt;/p>
&lt;h3 id="kustomize-controller">Kustomize Controller&lt;/h3>
&lt;p>kustomize-controller 是一个专门用于运行通过使用 Kustomize 组装 Kubernetes 清单和工作负载定义的持续交付pipeline 的 Kubernetes operator。它提供一个自动化的 operator ，可以引导并持续协调来自多个 sources（例如基础设施和应用程序 repositories ）的集群状态。&lt;/p>
&lt;p>配置新集群时，可以按照特定顺序安装工作负载。当多个团队同时操作集群时，集群管理员可以为每个团队分配角色和服务帐户。团队拥有的 manifests 将使用团队帐户应用于集群，从而确保团队之间的隔离。&lt;/p>
&lt;p>处理事件时，可以选择不停止协调器影响整个集群，采用暂停某些工作负载的协调并将其他工作负载的协调固定到指定的 Git 版本的方式进行。&lt;/p>
&lt;p>操作集群时，不同的团队可以收到与之相关的 CD pipeline 状态通知。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/ZMfAKIuLxH9BE4S.png" alt="img">&lt;/p>
&lt;p>Kustomization API 定义了一个可以获取，解密，构建，验证和应用 Kubernetes manifests 的 pipeline 。&lt;/p>
&lt;p>&lt;code>spec.sourceRef&lt;/code> 是对 Source Controller 管理的对象的引用 。当 Source （支持类型：GitRepository、Bucket）版本变更时，它会生成一个 Kubernetes 事件，触发 kustomize 的构建和应用。&lt;/p>
&lt;p>如果 repository 包含原始的 Kubernetes manifest，会为 &lt;code>spec.path&lt;/code> 和子目录中的所有 Kubernetes manifest 自动生成 &lt;code>kustomization.yaml&lt;/code>。（建议 kustomization.yaml 自行生成并存储在 Git 仓库中）&lt;/p>
&lt;p>&lt;code>spec.interval&lt;/code> 告诉 Controller 在哪个时间间隔为 Source 获取 Kubernetes manifest，构建 Kustomization 并将其应用于集群。间隔时间单位是 s（最小值应超过 60 秒，interval: 60s）。&lt;/p>
&lt;p>&lt;code>spec.healthChecks&lt;/code> 、&lt;code>spec.wait&lt;/code> 和 &lt;code>spec.timeout&lt;/code> 可以设置一系列运行状况检查。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Kubernetes 内置（Deployment、DaemonSet、StatefulSet、PersistentVolumeClaim、Pod、PodDisruptionBudget、Job、CronJob、Service、Secret、ConfigMap、CustomResourceDefinition）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Toolkit （HelmRelease、HelmRepository、GitRepository等）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与 kstatus 兼容的自定义资源 （https://github.com/kubernetes-sigs/cli-utils/tree/master/pkg/kstatus）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>spec.dependsOn&lt;/code> 可以自定义依赖。多个 Kustomizations 的情况下，可以指定先后顺序及依赖。这就引入了两个必须注意的地方：&lt;/p>
&lt;ul>
&lt;li>避免循环。&lt;/li>
&lt;li>与健康检查结合使用时，将在其所有依赖项健康检查通过后运行 Kustomization。&lt;/li>
&lt;/ul>
&lt;p>Kustomization 在覆盖自定义配置、变量替换、加解密等也有这很多灵活的设置，感兴趣的小伙伴可以自行阅读官方文档了解。&lt;/p>
&lt;h3 id="helm-controller">Helm Controller&lt;/h3>
&lt;p>Helm Controller 是一个 Kubernetes operator，允许使用 Kubernetes manifests 以声明方式管理 Helm chart Release。它提供一个自动化的 operator ，可以执行 Helm 操作（例如安装、升级、卸载、回滚、测试）并持续协调 Helm Release的状态。&lt;/p>
&lt;p>配置新集群时，可以指定顺序安装 Helm Release。处理事件时，可以不必停止协调器影响整个集群，采用暂停一些 Helm Release 的协调即可。操作集群时，不同的团队可以收到与其有关的 Helm Release 状态的通知。
&lt;img src="https://i.loli.net/2021/10/31/rLByzJExwYhHkj1.png" alt="img">&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/TLDrP41nQtigNkv.png" alt="img">&lt;/p>
&lt;p>HelmRelease 对象定义了一个控制器资源通过 Helm 操作（例如安装、升级、测试、卸载和回滚）驱动的 Helm Release 协调。包括发布位置（namespace/name）、发布内容（chart/values overrides）、操作触发器配置、个别操作配置和状态。&lt;/p>
&lt;p>可以分别通过 &lt;code>spec.targetNamespace&lt;/code>、&lt;code>spec.storageNamespace&lt;/code> 和 &lt;code>spec.releaseName&lt;/code> 覆盖默认部署和存储 Helm Release 的namespace/name。&lt;/p>
&lt;p>&lt;code>spec.chart.spec&lt;/code> 是创建具有指定 spec 的新 HelmChart 资源的模板。&lt;code>spec.chart.spec.sourceRef&lt;/code> 是对 Source Controller 管理的对象的引用。 当 source（支持类型：HelmRepository、GitRepository、Bucket） 版本变更时，会生成触发新版本的 Kubernetes 事件。&lt;/p>
&lt;p>如果没有找到具有匹配 namespace/name 的 Helm Release，将安装配置中的 Helm Release 。&lt;/p>
&lt;p>当出现以下状态更新时，Helm Release 将升级：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>spec （以及 metadata.generation ）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最新的 HelmChart 修订版可用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ConfigMap 和 Secret 值覆盖（为了避免在更新多个资源时发生大量升级，不会立即进行，会在spec.interval 间隔后进行）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Helm 支持安装 CRD，由于存在数据丢失的风险，目前暂不支持使用 Helm 升级或删除 CRD。&lt;/p>
&lt;p>更多 Helm Controller 的详细内容欢迎参考官方文档。&lt;/p>
&lt;h3 id="notification-controller">Notification Controller&lt;/h3>
&lt;p>Notification Controller 是一个 Kubernetes operator，专门处理出入口事件。&lt;/p>
&lt;p>它提供一个通知服务，可以通过 HTTP 接收事件并根据事件严重性和涉及的对象将它们分派到外部系统（Slack、Microsoft Teams、Discord、Rocker）。&lt;/p>
&lt;p>GitOps Controller 本质上是基于拉取的，为了通知 Controllers 有关 Git 或 Helm 库中的变更，可以支持设置 webhooks 在每次源更改时触发集群协调。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/LAOYlxyZBibmgdj.png" alt="img">&lt;/p>
&lt;h3 id="image-reflector-and-automation-controllers">Image reflector and automation controllers&lt;/h3>
&lt;p>image-reflector-controller 和 image-automation-controller 协同工作，在新的容器镜像可用时更新 Git repository。&lt;/p>
&lt;ul>
&lt;li>image-reflector-controller 扫描镜像仓库，并与 K8S 资源中的元数据进行对比。&lt;/li>
&lt;li>image-automation-controller 根据扫描到的最新镜像，更新 YAML 文件 并且提交变更到指定的 Git repository。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/Z1klTnrbuKH6Dae.png" alt="img">&lt;/p>
&lt;h2 id="flux-cd-使用要求">Flux CD 使用要求&lt;/h2>
&lt;h3 id="kubernetes-版本">Kubernetes 版本&lt;/h3>
&lt;p>使用 Flux CD，最好 Kubernetes 集群版本在 v&lt;strong>1.19&lt;/strong> 或更高版本。旧版本也支持，但官方不建议在生产中运行 EOL Kubernetes 版本。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/10/31/BJhqdksWc5Mue6K.png" alt="img">&lt;/p>
&lt;p>注：如果你正在使用 APIService（例如 &lt;a href="https://github.com/kubernetes-sigs/metrics-server">metrics-server&lt;/a>），Kubernetes 集群版本至少需要 v1.18.18，v1.19.10，v1.20.6 或 v1.21.0 。&lt;/p>
&lt;h3 id="git-repo-权限">Git Repo 权限&lt;/h3>
&lt;p>通过设置 SSH 部署密钥或使用基于令牌的身份验证，将目标集群配置为与 Git 库进行同步。&lt;/p>
&lt;ul>
&lt;li>GitLab 使用示例&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">//将 GitLab personal access token 导出为环境变量：
export GITLAB_TOKEN=&amp;lt;your-token&amp;gt;
//在 GitLab 账号上运行 git 库的引导程序：
flux bootstrap gitlab \
--owner=my-gitlab-username \
--repository=my-repository \
--branch=master \
--path=clusters/my-cluster \
--token-auth \
--personal
//使用部署密钥进行身份验证运行 git 库的引导程序，必须指定 SSH hostname：
flux bootstrap gitlab \
--ssh-hostname=gitlab.com \
--owner=my-gitlab-username \
--repository=my-repository \
--branch=master \
--path=clusters/my-cluster
//为 GitLab 团队的 git 库运行引导程序：
flux bootstrap gitlab \
--owner=my-gitlab-group/my-gitlab-subgroup \
--repository=my-repository \
--branch=master \
--path=clusters/my-cluster
//为托管在本地或企业 GitLab 上的 git 库运行引导程序，必须指定 GitLab hostname：
flux bootstrap gitlab \
--hostname=my-gitlab.com \
--token-auth \
--owner=my-gitlab-group \
--repository=my-repository \
--branch=master \
--path=clusters/my-cluster
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>GitHub 使用示例&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">//将 GitHub personal access token 导出为环境变量：
export GITHUB_TOKEN=&amp;lt;your-token&amp;gt;
//flux bootstrap 命令会创建一个 SSH 密钥，并存储在 Kubernetes 集群中。
//该密钥还用于在 GitHub 库中创建部署密钥。
//在 GitHub 账号上运行 git 库的引导程序：
flux bootstrap github \
--owner=my-github-username \
--repository=my-repository \
--path=clusters/my-cluster \
--personal
//当指定团队列表时，这些团队将被授予对 git 库的维护者访问权限。
//为 GitHub 中团队拥有的 git 库运行引导程序：
flux bootstrap github \
--owner=my-github-organization \
--repository=my-repository \
--team=team1-slug \
--team=team2-slug \
--path=clusters/my-cluster
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇主要介绍了 Flux CD 的发展历史和其核心组件及其功能，后续文章中将陆续介绍如何使用 Flux CD 来实践 GitOps，敬请期待。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/GitOps/" term="GitOps" label="GitOps"/></entry><entry><title type="text">Grafana k6 的上手实践</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/17/Grafana-k6-%E7%9A%84%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/"/><id>https://moelove.info/2021/12/17/Grafana-k6-%E7%9A%84%E4%B8%8A%E6%89%8B%E5%AE%9E%E8%B7%B5/</id><updated>2021-12-19T22:19:54+08:00</updated><published>2021-12-17T03:50:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 本篇我将为你介绍一个工具 - k6 ，它和 K8s 并没有什么直接的关系，它是一款开源的性能压测工具。 k6 背后的故事 2016 年 8 月，……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本篇我将为你介绍一个工具 - k6 ，它和 K8s 并没有什么直接的关系，它是一款开源的性能压测工具。&lt;/p>
&lt;h2 id="k6-背后的故事">k6 背后的故事&lt;/h2>
&lt;p>2016 年 8 月，k6 在 GitHub 上发布了第一个版本，至此，一个出色的开源负载压测工具进入了人们的视野。&lt;/p>
&lt;p>2021 年的 6 月，对于 Grafana 和 k6 来讲是个大日子，Grafana Labs 收购了 k6 。&lt;/p>
&lt;p>而事实上， Grafana 与 k6 的缘分还要追溯到更早的 2 年前。&lt;/p>
&lt;p>2019 年，在进行 Grafana 6.0 的短期令牌刷新行为的压测时，Grafana Labs 进行了一系列的技术选型。&lt;/p>
&lt;p>由于 Grafana Labs 的大部分后端软件是使用 Go 来实现的，恰巧 k6 满足 OSS 和 Go 需求，并且负载测试是使用 JS 编写（Grafana 前端框架及 UI 都在使用）。这使得 k6 自 Grafana 6.0 版本开始，不断地为 Grafana 开发者及测试者完成追踪 bug 的使命。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/FkHjMApXsSuZcwe.png" alt="img">&lt;/p>
&lt;p>图 1 ，k6 加入 Grafana Labs&lt;/p>
&lt;h3 id="多样的压测工具">多样的压测工具&lt;/h3>
&lt;p>一个称心应手的自动化负载压测工具会极大的提升程序开发人员的代码质量及效率。&lt;/p>
&lt;p>下图中是一些比较常见的用于负载压测的工具，我们可以在 GitHub 上看到，目前，更新比较频繁、活跃的项目主要有：Gatling, Jmeter 和 k6 。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/C1tJIe7BEGRKgV6.png" alt="img">&lt;/p>
&lt;p>图 2 ，压测工具们&lt;/p>
&lt;p>如何从中选择，简单的讲就是工具效率的比拼。主要从以下两个方面来考量：&lt;/p>
&lt;ul>
&lt;li>工具性能&lt;/li>
&lt;li>工具使用体验&lt;/li>
&lt;/ul>
&lt;p>下图对以上工具进行了一些简单的对比。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/TxGyYpRtMKza4fE.png" alt="img">&lt;/p>
&lt;p>这里我主要对比下其中较为活跃的 3 个项目。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>JMeter - 熟悉 Java 的小伙伴可能比较了解这个工具。由于存在时间久，JMeter 的功能是这之中最全面的，并且集成、附加组件做的较好。基于它构建的 SaaS 服务 Blazemeter，相信大家也都熟识。这也导致了一个极大的问题，使用的复杂性高及不够轻量级；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Gatling - Gatling 也有着 SaaS 产品 Gatling Frontline。就使用门槛来讲，JS 要比 Scala 要低很多；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>k6 - k6 最初是由 SaaS 服务 Load Impact 的几名员工开发维护。使用门槛低（JS），参数化更简单，并且 “负载测试即代码” 的理念也让他的维护成本更低。未来可期。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/IYNDA5FEQLWZz4b.png" alt="img">&lt;/p>
&lt;p>图 3 ，3 种热门工具比一比&lt;/p>
&lt;h2 id="执行效果">执行效果&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/YLoJZqdn5QrTeB6.png" alt="img">&lt;/p>
&lt;p>或者这样：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/CNA91tqRhGwTYcm.png" alt="img">&lt;/p>
&lt;h2 id="安装-k6">安装 k6&lt;/h2>
&lt;p>k6 是用 Go 语言开发的，要安装 k6 步骤很简单，只要直接在其 GitHub 的 Release 页面下载二进制文件即可。比如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ wget -q https://github.com/grafana/k6/releases/download/v0.35.0/k6-v0.35.0-linux-amd64.tar.gz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ tar -xzf k6-v0.35.0-linux-amd64.tar.gz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls
k6-v0.35.0-linux-amd64 k6-v0.35.0-linux-amd64.tar.gz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ mv ./k6-v0.35.0-linux-amd64/k6 ~/bin/k6
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ k6 version
k6 v0.35.0 &lt;span class="o">(&lt;/span>2021-11-17T09:53:18+0000/1c44b2d, go1.17.3, linux/amd64&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者也可以直接使用它的 Docker 镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ docker run --rm loadimpact/k6 version
k6 v0.35.0 &lt;span class="o">(&lt;/span>2021-11-17T09:53:03+0000/1c44b2d, go1.17.3, linux/amd64&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="核心概念">核心概念&lt;/h2>
&lt;p>在 k6 中并没有太多的概念。其中最主要的就是用来执行测试的 &lt;strong>virtual users (VUs)&lt;/strong> ，它的本质就是并发执行任务的次数。&lt;/p>
&lt;p>在使用 k6 执行测试的时候，可以通过 &lt;code>--vus&lt;/code>或者 &lt;code>-u&lt;/code>进行指定，默认是 1 。&lt;/p>
&lt;h2 id="上手实践">上手实践&lt;/h2>
&lt;p>我个人感觉 k6 在目前的这些主流压测工具中算用户体验比较好的一个。它使用 JS（ES6）作为配置语言，还是比较方便的，我们来做一些示例。&lt;/p>
&lt;h3 id="简单请求">简单请求&lt;/h3>
&lt;p>如果对于进行 HTTP 请求的时候，我们只需要从 &lt;code>k6/http&lt;/code> 导入 &lt;code>http&lt;/code>即可。&lt;/p>
&lt;p>注意在 k6 中，默认情况下必须得有个作为入口的 &lt;code>default&lt;/code>函数，这类似我们常用的 &lt;code>main&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">import&lt;/span> &lt;span class="nx">http&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6/http&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;https://test-api.k6.io/public/crocodiles/&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行后效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ k6 run simple_http_get.js
/&lt;span class="se">\ &lt;/span> &lt;span class="p">|&lt;/span>‾‾&lt;span class="p">|&lt;/span> /‾‾/ /‾‾/
/&lt;span class="se">\ &lt;/span> / &lt;span class="se">\ &lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>/ / / /
/ &lt;span class="se">\/&lt;/span> &lt;span class="se">\ &lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="o">(&lt;/span> / ‾‾&lt;span class="se">\ &lt;/span>
/ &lt;span class="se">\ &lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span>&lt;span class="se">\ &lt;/span> &lt;span class="se">\ &lt;/span>&lt;span class="p">|&lt;/span> &lt;span class="o">(&lt;/span>‾&lt;span class="o">)&lt;/span> &lt;span class="p">|&lt;/span>
/ __________ &lt;span class="se">\ &lt;/span> &lt;span class="p">|&lt;/span>__&lt;span class="p">|&lt;/span> &lt;span class="se">\_&lt;/span>_&lt;span class="se">\ \_&lt;/span>____/ .io
execution: &lt;span class="nb">local&lt;/span>
script: simple_http_get.js
output: -
scenarios: &lt;span class="o">(&lt;/span>100.00%&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span> scenario, &lt;span class="m">1&lt;/span> max VUs, 10m30s max duration &lt;span class="o">(&lt;/span>incl. graceful stop&lt;span class="o">)&lt;/span>:
* default: &lt;span class="m">1&lt;/span> iterations &lt;span class="k">for&lt;/span> each of &lt;span class="m">1&lt;/span> VUs &lt;span class="o">(&lt;/span>maxDuration: 10m0s, gracefulStop: 30s&lt;span class="o">)&lt;/span>
running &lt;span class="o">(&lt;/span>00m01.1s&lt;span class="o">)&lt;/span>, 0/1 VUs, &lt;span class="m">1&lt;/span> &lt;span class="nb">complete&lt;/span> and &lt;span class="m">0&lt;/span> interrupted iterations
default ✓ &lt;span class="o">[======================================]&lt;/span> &lt;span class="m">1&lt;/span> VUs 00m01.1s/10m0s 1/1 iters, &lt;span class="m">1&lt;/span> per VU
data_received..................: 6.3 kB 5.7 kB/s
data_sent......................: &lt;span class="m">634&lt;/span> B &lt;span class="m">578&lt;/span> B/s
http_req_blocked...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>848.34ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>848.34ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>848.34ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>848.34ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>848.34ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>848.34ms
http_req_connecting............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>75.59µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>75.59µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>75.59µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>75.59µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>75.59µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>75.59µs
http_req_duration..............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>247.46ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>247.46ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>247.46ms
&lt;span class="o">{&lt;/span> expected_response:true &lt;span class="o">}&lt;/span>...: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>247.46ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>247.46ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>247.46ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>247.46ms
http_req_failed................: 0.00% ✓ &lt;span class="m">0&lt;/span> ✗ &lt;span class="m">1&lt;/span>
http_req_receiving.............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>455.24µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>455.24µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>455.24µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>455.24µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>455.24µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>455.24µs
http_req_sending...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>103.77µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>103.77µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>103.77µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>103.77µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>103.77µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>103.77µs
http_req_tls_handshaking.......: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>848.07ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>848.07ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>848.07ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>848.07ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>848.07ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>848.07ms
http_req_waiting...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>246.9ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>246.9ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>246.9ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>246.9ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>246.9ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>246.9ms
http_reqs......................: &lt;span class="m">1&lt;/span> 0.911502/s
iteration_duration.............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>1.09s &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>1.09s &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>1.09s &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>1.09s p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>1.09s p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>1.09s
iterations.....................: &lt;span class="m">1&lt;/span> 0.911502/s
vus............................: &lt;span class="m">1&lt;/span> &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
vus_max........................: &lt;span class="m">1&lt;/span> &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>k6 默认会将执行后的结果输出到终端。同时它自带了一些指标会同时输出。&lt;/p>
&lt;p>这些指标基本上都是语义化的，看名字就可以理解其含义，这里就不一一介绍了。&lt;/p>
&lt;h3 id="带检查的请求">带检查的请求&lt;/h3>
&lt;p>我们可以在请求中同时增加一些测试，判断接口的响应值是否符合我们的预期。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">import&lt;/span> &lt;span class="nx">http&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6/http&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">check&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">group&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">group&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;http://httpbin.org/get?verb=get&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">check&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">res&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;status is 200&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;is verb correct&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">json&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">verb&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过引入了 &lt;code>check&lt;/code>函数，来执行一些判断的逻辑，当然上述的 &lt;code>==&amp;gt;&lt;/code> 其实是 ES6 中的一种简写，将其展开为正常的函数也可以。比如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">import&lt;/span> &lt;span class="nx">http&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6/http&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">check&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">group&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">group&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;http://httpbin.org/get?verb=get&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">check&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">res&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;status is 200&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">){&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">200&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="s2">&amp;#34;is verb correct&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">json&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">verb&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 k6 执行此脚本后，得到的输出相比之前的多了如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash"> █ GET
✓ status is &lt;span class="m">200&lt;/span>
✓ is verb correct
checks.........................: 100.00% ✓ &lt;span class="m">2&lt;/span> ✗ &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从这里可以看到我们当前请求接口的测试是否通过（也可以用来判断当前接口是否能正常提供服务）。&lt;/p>
&lt;h3 id="自定义指标输出">自定义指标输出&lt;/h3>
&lt;p>接下来我们尝试下在压测过程中定义一些自己定的指标。只需要从 &lt;code>k6/metrics&lt;/code>中导入一些不同类型的指标即可。这和在 Prometheus 中的类型基本一致。&lt;/p>
&lt;p>这里我增加了两个 metric。一个 &lt;code>testCounter&lt;/code>用于统计一共执行了多少次测试， &lt;code>passedRate&lt;/code>计算通过率。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">import&lt;/span> &lt;span class="nx">http&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6/http&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">Counter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Rate&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6/metrics&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">check&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">group&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s2">&amp;#34;k6&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">testCounter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Counter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;test_counter&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">passedRate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nx">Rate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;passed_rate&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kr">export&lt;/span> &lt;span class="k">default&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">group&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;http://httpbin.org/get?verb=get&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kd">let&lt;/span> &lt;span class="nx">passed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">check&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">res&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;status is 200&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;is verb correct&amp;#34;&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">json&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">verb&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="nx">testCounter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">passedRate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">passed&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们设置了 2 个 VU， 以及设置了执行过程为 &lt;code>10s&lt;/code> 执行后的输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ k6 run -u &lt;span class="m">2&lt;/span> -d 10s simple_custom_metrics.js
...
execution: &lt;span class="nb">local&lt;/span>
script: simple_custom_metrics.js
output: -
scenarios: &lt;span class="o">(&lt;/span>100.00%&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span> scenario, &lt;span class="m">2&lt;/span> max VUs, 40s max duration &lt;span class="o">(&lt;/span>incl. graceful stop&lt;span class="o">)&lt;/span>:
* default: &lt;span class="m">2&lt;/span> looping VUs &lt;span class="k">for&lt;/span> 10s &lt;span class="o">(&lt;/span>gracefulStop: 30s&lt;span class="o">)&lt;/span>
running &lt;span class="o">(&lt;/span>10.4s&lt;span class="o">)&lt;/span>, 0/2 VUs, &lt;span class="m">36&lt;/span> &lt;span class="nb">complete&lt;/span> and &lt;span class="m">0&lt;/span> interrupted iterations
default ✓ &lt;span class="o">[======================================]&lt;/span> &lt;span class="m">2&lt;/span> VUs 10s
█ GET
✓ status is &lt;span class="m">200&lt;/span>
✓ is verb correct
checks.........................: 100.00% ✓ &lt;span class="m">72&lt;/span> ✗ &lt;span class="m">0&lt;/span>
data_received..................: &lt;span class="m">18&lt;/span> kB 1.7 kB/s
data_sent......................: 3.9 kB &lt;span class="m">372&lt;/span> B/s
group_duration.................: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>567.35ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>440.56ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>600.52ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>738.73ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>620.88ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>655.17ms
http_req_blocked...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>266.72µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>72.33µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>135.14µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>776.66µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>644.4µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>719.96µs
http_req_connecting............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>170.04µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>45.51µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>79.9µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>520.69µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>399.41µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>463.55µs
http_req_duration..............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>566.82ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>439.69ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>600.31ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>738.16ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>620.52ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>654.61ms
&lt;span class="o">{&lt;/span> expected_response:true &lt;span class="o">}&lt;/span>...: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>566.82ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>439.69ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>600.31ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>738.16ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>620.52ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>654.61ms
http_req_failed................: 0.00% ✓ &lt;span class="m">0&lt;/span> ✗ &lt;span class="m">36&lt;/span>
http_req_receiving.............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>309.13µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>122.4µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>231.72µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>755.3µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>597.95µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>641.92µs
http_req_sending...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>80.69µs &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>20.47µs &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>38.91µs &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>235.1µs p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>197.87µs p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>214.79µs
http_req_tls_handshaking.......: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>0s &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>0s &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>0s &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>0s p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>0s p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>0s
http_req_waiting...............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>566.43ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>439.31ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>600.16ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>737.8ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>620.19ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>654.18ms
http_reqs......................: &lt;span class="m">36&lt;/span> 3.472534/s
iteration_duration.............: &lt;span class="nv">avg&lt;/span>&lt;span class="o">=&lt;/span>567.38ms &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>440.62ms &lt;span class="nv">med&lt;/span>&lt;span class="o">=&lt;/span>600.53ms &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>738.75ms p&lt;span class="o">(&lt;/span>90&lt;span class="o">)=&lt;/span>620.89ms p&lt;span class="o">(&lt;/span>95&lt;span class="o">)=&lt;/span>655.2ms
iterations.....................: &lt;span class="m">36&lt;/span> 3.472534/s
passed_rate....................: 100.00% ✓ &lt;span class="m">36&lt;/span> ✗ &lt;span class="m">0&lt;/span>
test_counter...................: &lt;span class="m">36&lt;/span> 3.472534/s
vus............................: &lt;span class="m">2&lt;/span> &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span> &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
vus_max........................: &lt;span class="m">2&lt;/span> &lt;span class="nv">min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span> &lt;span class="nv">max&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到在输出中多了两行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash"> passed_rate....................: 100.00% ✓ &lt;span class="m">36&lt;/span> ✗ &lt;span class="m">0&lt;/span>
test_counter...................: &lt;span class="m">36&lt;/span> 3.472534/s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>与我们的预期相符。&lt;/p>
&lt;p>不过这样看起来不够直观，我们可以尝试使用 k6 Cloud 来展示结果。登陆后，只要在执行 k6 时，通过 &lt;code>-o cloud&lt;/code>的方式将输出指定到 cloud 就可以在 cloud 上看到所有的指标了&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/17/YkoIXDai59Crbct.png" alt="img">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇主要是在介绍一个现代化的用户体验相对较好的压测工具 k6 。我目前正在计划将其引入到我们项目的 CI 中，以便了解每次核心部分的变更对项目性能的影响。&lt;/p>
&lt;p>后续推进顺利的话，会再分享 k6 如何应用到 CI 环境中，敬请期待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Grafana/" term="Grafana" label="Grafana"/></entry><entry><title type="text">搞懂容器技术的基石： namespace （下）</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/13/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8B/"/><id>https://moelove.info/2021/12/13/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8B/</id><updated>2021-12-14T11:57:53+08:00</updated><published>2021-12-13T03:50:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。 对于容……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。&lt;/p>
&lt;p>对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。&lt;/p>
&lt;p>我们先对这两项技术的作用做个概括：&lt;/p>
&lt;ul>
&lt;li>cgroup 的主要作用：管理资源的分配、限制；&lt;/li>
&lt;li>namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；&lt;/li>
&lt;/ul>
&lt;p>这是一个系列文章，对此系列感兴趣的小伙伴可以查看：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/434731896">彻底搞懂容器技术的基石：cgroup&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/443605569">彻底搞懂容器技术的基石：namespace（上）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>本篇我们将继续聊 namespace。&lt;/p>
&lt;h2 id="namespace-类型">Namespace 类型&lt;/h2>
&lt;p>我们先来总览一下 namespace 的类型，上篇中已经为大家介绍过 &lt;code>Cgroup&lt;/code> , &lt;code>IPC&lt;/code>, &lt;code>Network&lt;/code> 和 &lt;code>Mount&lt;/code> 等 4 种类型的 namespace。我们继续聊剩余的部分。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>namespace名称&lt;/th>
&lt;th>使用的标识 - Flag&lt;/th>
&lt;th>控制内容&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Cgroup&lt;/td>
&lt;td>CLONE_NEWCGROUP&lt;/td>
&lt;td>Cgroup root directory cgroup 根目录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IPC&lt;/td>
&lt;td>CLONE_NEWIPC&lt;/td>
&lt;td>System V IPC, POSIX message queues信号量，消息队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Network&lt;/td>
&lt;td>CLONE_NEWNET&lt;/td>
&lt;td>Network devices, stacks, ports, etc.网络设备，协议栈，端口等等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mount&lt;/td>
&lt;td>CLONE_NEWNS&lt;/td>
&lt;td>Mount points挂载点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PID&lt;/td>
&lt;td>CLONE_NEWPID&lt;/td>
&lt;td>Process IDs进程号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Time&lt;/td>
&lt;td>CLONE_NEWTIME&lt;/td>
&lt;td>Boot and monotonic clocks启动和单调时钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User&lt;/td>
&lt;td>CLONE_NEWUSER&lt;/td>
&lt;td>User and group IDs用户和用户组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTS&lt;/td>
&lt;td>CLONE_NEWUTS&lt;/td>
&lt;td>Hostname and NIS domain name主机名与 NIS 域名&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="pid-namespaces">PID namespaces&lt;/h3>
&lt;p>我们知道在 Linux 系统中，每个进程都会有自己的独立的 PID，而 PID namespace 主要是用于隔离进程号。即，在不同的 PID namespace 中可以包含相同的进程号。&lt;/p>
&lt;p>每个 PID namespace 中进程号都是从 1 开始的，在此 PID namespace 中可通过调用 &lt;code>fork(2)&lt;/code>, &lt;code>vfork(2)&lt;/code>和 &lt;code>clone(2)&lt;/code> 等系统调用来创建其他拥有独立 PID 的进程。&lt;/p>
&lt;p>要使用 PID namespace 需要内核支持 &lt;code>CONFIG_PID_NS&lt;/code> 选项。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ grep CONFIG_PID_NS /boot/config-&lt;span class="k">$(&lt;/span>uname -r&lt;span class="k">)&lt;/span>
&lt;span class="nv">CONFIG_PID_NS&lt;/span>&lt;span class="o">=&lt;/span>y
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="init-进程">init 进程&lt;/h4>
&lt;p>我们都知道在 Linux 系统中有一个进程比较特殊，所谓的 init 进程，也就是 PID 为 1 的进程。&lt;/p>
&lt;p>前面我们已经说了每个 PID namespace 中进程号都是从 1 开始的，那么它有什么特点呢？&lt;/p>
&lt;p>首先，PID namespace 中的 1 号进程是所有孤立进程的父进程。&lt;/p>
&lt;p>其次，如果这个进程被终止，内核将调用 &lt;code>SIGKILL&lt;/code> 发出终止此 namespace 中的所有进程的信号。 &lt;strong>这部分内容与 Kubernetes 中应用的优雅关闭/平滑升级等都有一定的联系。&lt;/strong>（对此部分感兴趣的小伙伴可以留言交流，如果对这些内容感兴趣的话，我可以专门写一篇展开来聊）&lt;/p>
&lt;p>最后，从 Linux v3.4 内核版本开始，如果在一个 PID namespace 中发生 &lt;code>reboot()&lt;/code> 的系统调用，则 PID namespace 中的 init 进程会立即退出。&lt;strong>这算是一个比较特殊的技巧，可用于处理高负载机器上容器退出的问题。&lt;/strong>&lt;/p>
&lt;h4 id="pid-namespace-的层次结构">PID namespace 的层次结构&lt;/h4>
&lt;p>PID namespace 支持嵌套，除了初始的 PID namespace外，其余的 PID namespace 都拥有其父节点的 PID namespace。&lt;/p>
&lt;p>也就是说 PID namespace 也是树形结构的，此结构内的所有 PID namespace 我们都可以追踪到祖先 PID namespace。当然，这个深度也不是无限的，从 Linux v3.7 内核版本开始，树的最大深度被限制成 32 。&lt;/p>
&lt;p>如果达到此最大深度，将会抛出 &lt;code>No space left on device&lt;/code>的错误。&lt;em>（我之前尝试嵌套容器的时候遇到过）&lt;/em>&lt;/p>
&lt;p>&lt;strong>在同一个（且同级） PID namespace 中，进程间彼此可见。&lt;/strong>&lt;/p>
&lt;p>但如果某个进程位于子 PID namespace 的话，那么该进程是看不到上一层（即，父 PID namespace）中的进程的。&lt;/p>
&lt;p>进程间是否可见，决定了进程间能否存在一定的关联和调用关系，小伙伴们对这个应该比较熟悉，这里我就不赘述了。&lt;/p>
&lt;p>那么，进程是否可以调度到不同层级的 PID namespace 呢？&lt;/p>
&lt;p>我们先来说结论，&lt;strong>进程在 PID namespace 中的调度只能是单向调度（从高 -&amp;gt; 低）&lt;/strong>。即：&lt;/p>
&lt;ul>
&lt;li>进程只能从父 PID namespace 调度到 子 PID namespace 中；&lt;/li>
&lt;li>进程不能从子 PID namespace 调度到 父 PID namespace 中；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/14/aoe3DC2TLA47xBZ.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 1 ，通过 setns(2) 调度进程说明&lt;/strong>&lt;/p>
&lt;p>PID namespace 的层级关系其实是由 &lt;code>ioctl_ns(2)&lt;/code> 系统调用进行发现和维护的（NS_GET_PARENT），这里先不展开。那么，上述内容中的调度是如何实现的呢？&lt;/p>
&lt;p>要解答这个问题，就必须先意识到在 PID namespace 创建之初，哪些进程具备该 namespace 的权限就已经确定了。至于调度，我们可以简单地将其理解成关系映射或者符号链接。&lt;/p>
&lt;p>线程必须在同一个PID namespace 中，以便保证进程中的线程间可以彼此互传信号。这就导致了&lt;code>CLONE_NEWPID&lt;/code> 不能与 &lt;code>CLONE_THREAD&lt;/code> 同时使用。但如果分布在不同 PID namespace 的多个进程互相有信号传递的需求要怎么办呢？ 用共享的信号队列即可解决。&lt;/p>
&lt;p>此外，我们常接触到的 &lt;code>/proc&lt;/code> 目录下有很多 &lt;code>/proc/${PID}&lt;/code>的目录，在其中可看到 PID namespace 中的进程情况。 同时此目录也是可直接通过挂载方式进行操作的。比如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">(MoeLove) ➜ mount |grep proc
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>有没有办法知道当前最大的 PID 数呢？&lt;/p>
&lt;p>这也是可以的，自从 Linux v3.3 版本的内核开始新增了一个 &lt;code>/proc/sys/kernel/ns_last_pid&lt;/code>的文件，用于记录最后一个进程的 ID 。&lt;/p>
&lt;p>当需要分配下一个进程 ID 的时候，内核会去搜索最大的未使用 ID 进行分配，随后会更新此文件中 PID 的信息。&lt;/p>
&lt;h3 id="time-namespaces">Time namespaces&lt;/h3>
&lt;p>在聊 time namespace 之前，我们需要先聊下&lt;strong>单调时间&lt;/strong>。首先，我们通常提到的系统时间，指的是 clock realtime，即，机器对当前时间的展示。它可以向前或者向后调整（结合 NTP 服务来理解）。而 clock monotonic 表示在某一时刻之后的时间记录，它是单向向后的绝对时间，不受系统时间的变化所影响。&lt;/p>
&lt;p>使用 time namespace 需要内核支持 &lt;code>CONFIG_TIME_NS&lt;/code> 选项。如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ grep CONFIG_TIME_NS /boot/config-&lt;span class="k">$(&lt;/span>uname -r&lt;span class="k">)&lt;/span>
&lt;span class="nv">CONFIG_TIME_NS&lt;/span>&lt;span class="o">=&lt;/span>y
&lt;/code>&lt;/pre>&lt;/div>&lt;p>time namespace 不会虚拟化 CLOCK_REALTIME 时钟。你可能会好奇，为什么内核支持 time namespace 呢？主要是为了一些特殊的场景。&lt;/p>
&lt;p>time namespace 中的所有进程共享由 time namespace 提供的以下两个参数：&lt;/p>
&lt;ul>
&lt;li>CLOCK_MONOTONIC - 单调时间，一个不可设置的时钟；&lt;/li>
&lt;li>CLOCK_BOOTTIME（可参考 CLOCK_BOOTTIME_ALARM 内核参数）- 不可设置的时钟，包括系统暂停的时间。&lt;/li>
&lt;/ul>
&lt;p>time namespace 目前只能使用 CLONE_NEWTIME 标识，通过调用 &lt;code>unshare(2)&lt;/code> 系统调用进行创建。创建 time namespace 的进程是独立于新建的 time namespace 之外的，而该进程后续的子进程将会被放置到新建的 time namespace 之内。同一个 time namespace 中的进程们会共享 CLOCK_MONOTONIC 和 CLOCK_BOOTTIME。&lt;/p>
&lt;p>当父进程创建子进程时，子进程的 time namespace 归属将在文件 /proc/[pid]/ns/time_for_children 中显示。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls -al /proc/self/ns/time_for_children
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> 12月 &lt;span class="m">14&lt;/span> 02:06 /proc/self/ns/time_for_children -&amp;gt; &lt;span class="s1">&amp;#39;time:[4026531834]&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>文件 /proc/PID/timens_offsets 定义了初始 time namespace 的单调时钟和启动时钟，并记录了偏移量。（如果一个新的 time namespace 还没有进程入驻时，是可以进行修改的。这里暂不展开，感兴趣的小伙伴可讨论区留言交流讨论。）&lt;/p>
&lt;p>需要注意的是：在初始的 time namespace 中，/proc/self/timens_offsets 显示的偏移量都为 0。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ cat /proc/self/timens_offsets
monotonic &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
boottime &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中第二列和第三列的含义如下：&lt;/p>
&lt;ul>
&lt;li>&lt;offset-secs> 可以为负值，单位 ：秒（s）&lt;/li>
&lt;li>&lt;offset-nanosecs> 是个无符号值，单位 ：纳秒（ns）&lt;/li>
&lt;/ul>
&lt;p>以下的时钟接口都与此 namespace 有所关联：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>clock_gettime(2)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>clock_nanosleep(2)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nanosleep(2)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>timer_settime(2)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>timerfd_settime(2)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>整体而言， time namespace 在一些特殊场景下还是很有用的。&lt;/p>
&lt;h3 id="user-namespaces">User namespaces&lt;/h3>
&lt;p>User namespaces 顾名思义是隔离了用户 id、组 id 等。&lt;/p>
&lt;p>使用 user namespaces 需要内核支持 CONFIG_USER_NS 选项。如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ local_time grep CONFIG_USER_NS /boot/config-&lt;span class="k">$(&lt;/span>uname -r&lt;span class="k">)&lt;/span>
&lt;span class="nv">CONFIG_USER_NS&lt;/span>&lt;span class="o">=&lt;/span>y
&lt;/code>&lt;/pre>&lt;/div>&lt;p>进程的用户 id 和组 id 在一个 user namespace 内和外有可能是不同的。&lt;/p>
&lt;p>比如，一个进程在 user namespace 中的用户和组可以是特权用户（root），但在该 user namespace 之外，可能只是一个普通的非特权用户。这就涉及到用户、组映射（uid_map 、gid_map）等相关的内容了。&lt;/p>
&lt;p>自 Linux v3.5 版本的内核开始，在 &lt;code>/proc/[pid]/uid_map&lt;/code> 和 &lt;code>/proc/[pid]/gid_map&lt;/code> 文件中，我们可以查看到映射内容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ cat /proc/self/uid_map
&lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">4294967295&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ cat /proc/self/gid_map
&lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">4294967295&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>user namespace 也支持嵌套，使用 CLONE_NEWUSER 标识，使用 unshare(2) 或者 clone(2) 等系统调用来创建，最大的嵌套层级深度也是 32。&lt;/p>
&lt;p>如果是通过 fork(2) 或者 clone(2) 创建的子进程没带有 CLONE_NEWUSER 标识，也是一样的，子进程跟父进程同在一个 user namespace 中。树状的关联关系同样通过 ioctl(2) 系统调用接口维护。&lt;/p>
&lt;p>一个单线程进程可以通过 setns(2) 系统调用来调整其归属的 user namespace。&lt;/p>
&lt;p>此外， user namespace 还有个很重要的规则，那就是关于 Linux capability 的继承关系。关于 Linux capability 我就不展开了，这里简单记录一下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当进程所在的 user namespace 拥有 effective capability set 中的 capability 时，该进程具有该 capability。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当进程在该 user namespace 中拥有 capability 时，该进程在此 user namespace 的所有子 user namespace 中都拥有该 capability。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建该 user namespace 的用户会被内核记录为 owner ，即，拥有该 user namespace 中的全部 capabilities。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于 Docker 而言，它可以原生的支持此能力，进而达到对容器环境的一种保护。&lt;/p>
&lt;h3 id="uts-namespaces">UTS namespaces&lt;/h3>
&lt;p>UTS namespaces 隔离了主机名和 NIS 域名。&lt;/p>
&lt;p>使用 UTS namespaces 需要内核支持 CONFIG_UTS_NS 选项。如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ grep CONFIG_UTS_NS /boot/config-&lt;span class="k">$(&lt;/span>uname -r&lt;span class="k">)&lt;/span>
&lt;span class="nv">CONFIG_UTS_NS&lt;/span>&lt;span class="o">=&lt;/span>y
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在同一个 UTS namespace 中，通过 sethostname(2) 和 and setdomainname(2) 系统调用进行的设置和修改是所有进程共享查看的，但是对于不同 UTS namespaces 而言，则彼此隔离不可见。&lt;/p>
&lt;h2 id="namespaces-主要的-api">Namespaces 主要的 API&lt;/h2>
&lt;p>前面内容中提到了很多的系统调用，这里我们来挑几个重要的介绍一下。&lt;/p>
&lt;h3 id="clone2">clone(2)&lt;/h3>
&lt;p>系统调用 clone(2) 创建一个新的进程，它会根据参数中的 CLONE_NEW* 设置，逐个实现对应的配置功能。当然这个系统调用也实现了一些与 namespace 无关的功能。对低于 Linux 3.8 版本内核的系统而言，大多数情况下， 需要具备 CAP_SYS_ADMIN 的 capability。&lt;/p>
&lt;h3 id="unshare2">unshare(2)&lt;/h3>
&lt;p>系统调用 unshare(2) 将进程分配至新的 namespace ，同样，它也会根据参数中的 CLONE_NEW* 设置来调整实现对应的配置功能。对低于 Linux 3.8 的系统而言，大多数情况，需要具备 CAP_SYS_ADMIN 的 capability。&lt;/p>
&lt;h3 id="setns2">setns(2)&lt;/h3>
&lt;p>系统调用 setns(2) 将进程移动到某一已存在的 namespace，这会导致 /proc/[pid]/ns 对应的目录中内容的变更。进程创建的子进程可以通过调用 unshare(2) 和 setns(2) 来调整所属的 namespace。这通常是需要具备 CAP_SYS_ADMIN 的 capability 的。&lt;/p>
&lt;h2 id="一些关键目录说明">一些关键目录说明&lt;/h2>
&lt;h3 id="procpidns-目录">/proc/[pid]/ns/ 目录&lt;/h3>
&lt;p>每个进程都有一个 /proc/[pid]/ns/ 子目录，目录中的内容会受到 setns(2) 系统调用的影响。只要目录中的文件被打开，对应的 namespace 就不能被销毁。系统可以通过调用 setns(2) 来变更这些文件内容。&lt;/p>
&lt;ul>
&lt;li>Linux 3.7 及更早期的版本 - 文件是以硬链接方式存在的；&lt;/li>
&lt;li>Linux 3.8 开始 - 文件以软连接的方式存在；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ls -l --time-style&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;+&amp;#39;&lt;/span> /proc/&lt;span class="nv">$$&lt;/span>/ns
总用量 &lt;span class="m">0&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> cgroup -&amp;gt; &lt;span class="s1">&amp;#39;cgroup:[4026531835]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> ipc -&amp;gt; &lt;span class="s1">&amp;#39;ipc:[4026531839]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> mnt -&amp;gt; &lt;span class="s1">&amp;#39;mnt:[4026531840]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> net -&amp;gt; &lt;span class="s1">&amp;#39;net:[4026532008]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> pid -&amp;gt; &lt;span class="s1">&amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> pid_for_children -&amp;gt; &lt;span class="s1">&amp;#39;pid:[4026531836]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> &lt;span class="nb">time&lt;/span> -&amp;gt; &lt;span class="s1">&amp;#39;time:[4026531834]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> time_for_children -&amp;gt; &lt;span class="s1">&amp;#39;time:[4026531834]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> user -&amp;gt; &lt;span class="s1">&amp;#39;user:[4026531837]&amp;#39;&lt;/span>
lrwxrwxrwx. &lt;span class="m">1&lt;/span> tao tao &lt;span class="m">0&lt;/span> uts -&amp;gt; &lt;span class="s1">&amp;#39;uts:[4026531838]&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果两个进程的 namespace 相同，那么它们这个目录内的内容应该是一样的。&lt;/p>
&lt;p>以下是该目录下文件的详细说明：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>文件名称&lt;/th>
&lt;th>起始版本&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>/proc/[pid]/ns/cgroup&lt;/td>
&lt;td>Linux 4.6&lt;/td>
&lt;td>进程的 cgroup namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/ipc&lt;/td>
&lt;td>Linux 3.0&lt;/td>
&lt;td>进程的 IPC namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/mnt&lt;/td>
&lt;td>Linux 3.8&lt;/td>
&lt;td>进程的 mount namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/net&lt;/td>
&lt;td>Linux 3.0&lt;/td>
&lt;td>进程的 network namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/pid&lt;/td>
&lt;td>Linux 3.8&lt;/td>
&lt;td>进程的 PID namespace在进程的整个生命周期里是不变的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/pid_for_children&lt;/td>
&lt;td>Linux 4.12&lt;/td>
&lt;td>进程创建子进程的 PID namespace这个文件与 /proc/[pid]/ns/pid 不一定一致。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/time&lt;/td>
&lt;td>Linux 5.6&lt;/td>
&lt;td>进程的 time namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/time_for_children&lt;/td>
&lt;td>Linux 5.6&lt;/td>
&lt;td>进程创建子进程的 time namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/user&lt;/td>
&lt;td>Linux 3.8&lt;/td>
&lt;td>进程的 user namespace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>/proc/[pid]/ns/uts&lt;/td>
&lt;td>Linux 3.0&lt;/td>
&lt;td>进程的 UTS namespace&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="procsysuser-目录">/proc/sys/user 目录&lt;/h3>
&lt;p>/proc/sys/user 目录下的文件记录了各 namespace 的相关限制。当达到限制，相关调用会报错 error ENOSPC 。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>文件名称&lt;/th>
&lt;th>限制内容说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>max_cgroup_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 cgroup namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_ipc_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 ipc namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_mnt_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 mount namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_net_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 network namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_pid_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 PID namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_time_namespaces&lt;/td>
&lt;td>Linux 5.7在 user namespace 中的每个用户可以创建的最大 time namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_user_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 user namespaces 数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>max_uts_namespaces&lt;/td>
&lt;td>在 user namespace 中的每个用户可以创建的最大 uts namespaces 数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="namespace-的生命周期">Namespace 的生命周期&lt;/h2>
&lt;p>正常的 namespace 的生命周期与最后一个进程的终止和离开相关。&lt;/p>
&lt;p>但有一些情况，即使最后一个进程已经退出了，namespace 仍不能被销毁。这里来稍微聊下这些特殊的情况：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/proc/[pid]/ns/*&lt;/code> 中的文件被打开或者 mount ，即使最后一个进程退出，也不能被销毁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>namespace 存在分层，子 namespace 仍存在 ，即使最后一个进程退出，也不能被销毁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个 user namespace 拥有一些非 user namespace （比如拥有 PID namespace 等其他的 namespace 存在），即使最后一个进程退出，也不能被销毁；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 PID namespace 而言，如果与 &lt;code>/proc/[pid]/ns/pid_for_children&lt;/code> 存在关联关系时，即使最后一个进程退出，也不能被销毁;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当然还有一些其他的情况，有空再补充。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>通过之前的一篇，和本篇，主要为大家介绍了 Linux namespace 的发展历程，基本类型，主要 API 以及一些使用场景和用途。&lt;/p>
&lt;p>namespace 对于容器技术而言，是非常核心的部分。后续本系列中还将继续为大家分享关于容器和 Kubernetes 等技术的内容，敬请期待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">搞懂容器技术的基石： namespace （上）</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/"/><id>https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/</id><updated>2021-12-10T12:05:32+08:00</updated><published>2021-12-10T03:50:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。 对于容……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。&lt;/p>
&lt;p>对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。&lt;/p>
&lt;p>我们先对这两项技术的作用做个概括：&lt;/p>
&lt;ul>
&lt;li>cgroup 的主要作用：管理资源的分配、限制；&lt;/li>
&lt;li>namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/434731896">在上一篇文章中，我们重点聊了 cgroup &lt;/a>。本篇，我们重点来聊 namespace 。&lt;/p>
&lt;h2 id="namespace-是什么">Namespace 是什么？&lt;/h2>
&lt;p>我们引用 &lt;a href="https://en.wikipedia.org/wiki/Linux_namespaces">wiki&lt;/a> 上对 namespace 的定义：&lt;/p>
&lt;blockquote>
&lt;p>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources.&lt;/p>
&lt;/blockquote>
&lt;p>namespace 是 Linux 内核的一项特性，它可以对内核资源进行分区，使得一组进程可以看到一组资源；而另一组进程可以看到另一组不同的资源。该功能的原理是为一组资源和进程使用相同的 namespace，但是这些 namespace 实际上引用的是不同的资源。&lt;/p>
&lt;p>这样的说法未免太绕了些，简单来说 namespace 是由 Linux 内核提供的，用于进程间资源隔离的一种技术。将全局的系统资源包装在一个抽象里，让进程（看起来）拥有独立的全局资源实例。同时 Linux 也默认提供了多种 namespace，用于对多种不同资源进行隔离。&lt;/p>
&lt;p>在之前，我们单独使用 namespace 的场景比较有限，但 namespace 却是容器化技术的基石。&lt;/p>
&lt;p>我们先来看看它的发展历程。&lt;/p>
&lt;h2 id="namespace-的发展历程">Namespace 的发展历程&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/10/rRA1dQx69butYTZ.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>图 1 ，namespace 的历史过程&lt;/strong>&lt;/p>
&lt;h3 id="最早期---plan-9">最早期 - Plan 9&lt;/h3>
&lt;p>namespace 的早期提出及使用要追溯到 Plan 9 from Bell Labs ，贝尔实验室的 Plan 9。这是一个分布式操作系统，由贝尔实验室的计算科学研究中心在八几年至02年开发的（02年发布了稳定的第四版，距离92年发布的第一个公开版本已10年打磨），现在仍然被操作系统的研究者和爱好者开发使用。在 Plan 9 的设计与实现中，我们着重提以下3点内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>文件系统：所有系统资源都列在文件系统中，以 Node 标识。所有的接口也作为文件系统的一部分呈现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Namespace：能更好的应用及展示文件系统的层次结构，它实现了所谓的 “分离”和“独立”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准通信协议：9P协议（Styx/9P2000）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/10/ye5wSuNMnJoc6TU.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>图 2 ，Plan 9 from Bell Labs 图标&lt;/strong>&lt;/p>
&lt;h3 id="开始加入-linux-kernel">开始加入 Linux Kernel&lt;/h3>
&lt;p>Namespace 开始进入 Linux Kernel 的版本是在 2.4.X，最初始于 2.4.19 版本。但是，自 2.4.2 版本才开始实现每个进程的 namespace。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/10/KeakXfEFsMjoLPz.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>图 3 ，Linux Kernel Note&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/10/YlNU6uBeWdEJhgG.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 4 ，Linux Kernel 对应的各操作系统版本&lt;/strong>&lt;/p>
&lt;h3 id="linux-38-基本实现">Linux 3.8 基本实现&lt;/h3>
&lt;p>Linux 3.8 中终于完全实现了 &lt;code>User&lt;/code> Namespace 的相关功能集成到内核。这样 Docker 及其他容器技术所用到的 namespace 相关的能力就基本都实现了。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/10/5HBV3ylXepPijvD.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 5 ，Linux Kernel 从 2001 到2013 逐步演变，完成了 namespace 的实现&lt;/strong>&lt;/p>
&lt;h2 id="namespace-类型">Namespace 类型&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>namespace名称&lt;/th>
&lt;th>使用的标识 - Flag&lt;/th>
&lt;th>控制内容&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Cgroup&lt;/td>
&lt;td>CLONE_NEWCGROUP&lt;/td>
&lt;td>Cgroup root directory cgroup 根目录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IPC&lt;/td>
&lt;td>CLONE_NEWIPC&lt;/td>
&lt;td>System V IPC, POSIX message queues信号量，消息队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Network&lt;/td>
&lt;td>CLONE_NEWNET&lt;/td>
&lt;td>Network devices, stacks, ports, etc.网络设备，协议栈，端口等等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mount&lt;/td>
&lt;td>CLONE_NEWNS&lt;/td>
&lt;td>Mount points挂载点&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PID&lt;/td>
&lt;td>CLONE_NEWPID&lt;/td>
&lt;td>Process IDs进程号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Time&lt;/td>
&lt;td>CLONE_NEWTIME&lt;/td>
&lt;td>时钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User&lt;/td>
&lt;td>CLONE_NEWUSER&lt;/td>
&lt;td>用户和组 ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTS&lt;/td>
&lt;td>CLONE_NEWUTS&lt;/td>
&lt;td>系统主机名和 NIS(Network Information Service) 主机名（有时称为域名）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cgroup-namespaces">Cgroup namespaces&lt;/h3>
&lt;p>Cgroup namespace 是进程的 cgroups 的虚拟化视图，通过 &lt;code>/proc/[pid]/cgroup&lt;/code> 和 &lt;code>/proc/[pid]/mountinfo&lt;/code> 展示。&lt;/p>
&lt;p>使用 cgroup namespace 需要内核开启 &lt;code>CONFIG_CGROUPS&lt;/code> 选项。可通过以下方式验证：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="p">(&lt;/span>&lt;span class="nx">MoeLove&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">➜&lt;/span> &lt;span class="nx">grep&lt;/span> &lt;span class="nx">CONFIG_CGROUPS&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="nx">boot&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uname&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">CONFIG_CGROUPS&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">y&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>cgroup namespace 提供的了一系列的隔离支持：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>防止信息泄漏（容器不应该看到容器外的任何信息）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>简化了容器迁移。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>限制容器进程资源，因为它会把 cgroup 文件系统进行挂载，使得容器进程无法获取上层的访问权限。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>每个 cgroup namespace 都有自己的一组 cgroup 根目录。这些 cgroup 的根目录是在 &lt;code>/proc/[pid]/cgroup&lt;/code> 文件中对应记录的相对位置的基点。当一个进程用 &lt;code>CLONE_NEWCGROUP&lt;/code>（clone(2) 或者 unshare(2)） 创建一个新的 cgroup namespace时，它当前的 cgroups 的目录就变成了新 namespace 的 cgroup 根目录。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ cat /proc/self/cgroup
0::/user.slice/user-1000.slice/session-2.scope
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当一个目标进程从 &lt;code>/proc/[pid]/cgroup&lt;/code> 中读取 cgroup 关系时，每个记录的路径名会在第三字段中展示，会关联到正在读取的进程的相关 cgroup 分层结构的根目录。如果目标进程的 cgroup 目录位于正在读取的进程的 cgroup namespace 根目录之外时，那么，路径名称将会对每个 cgroup 层次中的上层节点显示 &lt;code>../&lt;/code> 。&lt;/p>
&lt;p>我们来看看下面的示例（这里以 cgroup v1 为例，如果你想看 v2 版本的示例，请在留言中告诉我）：&lt;/p>
&lt;ol>
&lt;li>在初始的 cgroup namespace 中，我们使用 root （或者有 root 权限的用户），在 freezer 层下创建一个子 cgroup 名为 &lt;code>moelove-sub&lt;/code>，同时，将进程放入该 cgroup 进行限制。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">(MoeLove) ➜ mkdir -p /sys/fs/cgroup/freezer/moelove-sub
(MoeLove) ➜ sleep 6666666 &amp;amp;
[1] 1489125
(MoeLove) ➜ echo 1489125 &amp;gt; /sys/fs/cgroup/freezer/moelove-sub/cgroup.procs
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>我们在 freezer 层下创建另外一个子 cgroup，名为 &lt;code>moelove-sub2&lt;/code>， 并且再放入执行进程号。可以看到当前的进程已经纳入到 &lt;code>moelove-sub2&lt;/code>的 cgroup 下管理了。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">(MoeLove) ➜ mkdir -p /sys/fs/cgroup/freezer/moelove-sub2
(MoeLove) ➜ echo $$
1488899
(MoeLove) ➜ echo 1488899 &amp;gt; /sys/fs/cgroup/freezer/moelove-sub2/cgroup.procs
(MoeLove) ➜ cat /proc/self/cgroup |grep freezer
7:freezer:/moelove-sub2
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>我们使用 &lt;code>unshare(1)&lt;/code> 创建一个进程，这里使用了 &lt;code>-C&lt;/code>参数表示是新的 cgroup namespace， 使用了 &lt;code>-m&lt;/code>参数表示是新的 mount namespace。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">(MoeLove) ➜ unshare -Cm bash
root@moelove:~#
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>从用 unshare(1) 启动的新 shell 中，我们可以在 &lt;code>/proc/[pid]/cgroup&lt;/code> 文件中看到，新 shell 和以上示例中的进程：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">root@moelove:~# cat /proc/self/cgroup | grep freezer
7:freezer:/
root@moelove:~# cat /proc/1/cgroup | grep freezer
7:freezer:/..
# 第一个示例进程
root@moelove:~# cat /proc/1489125/cgroup | grep freezer
7:freezer:/../moelove-sub
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>从上面的示例中，我们可以看到新 shell 的 freezer cgroup 关系中，当新的 cgroup namespace 创建时，freezer cgroup 的根目录与它的关系也就建立了。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">root@moelove:~# cat /proc/self/mountinfo | grep freezer
1238 1230 0:37 /.. /sys/fs/cgroup/freezer rw,nosuid,nodev,noexec,relatime - cgroup cgroup rw,freezer
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>第四个字段 ( &lt;code>/..&lt;/code>) 显示了在 cgroup 文件系统中的挂载目录。从 cgroup namespaces 的定义中，我们可以知道，进程当前的 freezer cgroup 目录变成了它的根目录，所以这个字段显示 &lt;code>/..&lt;/code> 。我们可以重新挂载来处理它。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">root@moelove:~# mount --make-rslave /
root@moelove:~# umount /sys/fs/cgroup/freezer
root@moelove:~# mount -t cgroup -o freezer freezer /sys/fs/cgroup/freezer
root@moelove:~# cat /proc/self/mountinfo | grep freezer
1238 1230 0:37 / /sys/fs/cgroup/freezer rw,relatime - cgroup freezer rw,freezer
root@moelove:~# mount |grep freezer
freezer on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ipc-namespaces">IPC namespaces&lt;/h3>
&lt;p>IPC namespaces 隔离了 IPC 资源，如 System V IPC objects、 POSIX message queues。每个 IPC namespace 都有着自己的一组 System V IPC 标识符，以及 POSIX 消息队列系统。在一个 IPC namespace 中创建的对象，对所有该 namespace 下的成员均可见（对其他 namespace 下的成员均不可见）。&lt;/p>
&lt;p>使用 IPC namespace 需要内核支持 CONFIG_IPC_NS 选项。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="p">(&lt;/span>&lt;span class="nx">MoeLove&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">➜&lt;/span> &lt;span class="nx">grep&lt;/span> &lt;span class="nx">CONFIG_IPC_NS&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="nx">boot&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">config&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">uname&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">CONFIG_IPC_NS&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">y&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以在 IPC namespace 中设置以下 &lt;code>/proc&lt;/code> 接口：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/proc/sys/fs/mqueue&lt;/code> - POSIX 消息队列接口&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/proc/sys/kernel&lt;/code> - System V IPC 接口 （msgmax, msgmnb, msgmni, sem, shmall, shmmax, shmmni, shm_rmid_forced）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/proc/sysvipc&lt;/code> - System V IPC 接口&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当 IPC namespace 被销毁时（空间里的最后一个进程都被停止删除时），在 IPC namespace 中创建的 object 也会被销毁。&lt;/p>
&lt;h3 id="network-namepaces">Network namepaces&lt;/h3>
&lt;p>Network namespaces 隔离了与网络相关的系统资源（这里罗列一些）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>network devices - 网络设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPv4 and IPv6 protocol stacks - IPv4、IPv6 的协议栈&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IP routing tables - IP 路由表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>firewall rules - 防火墙规则&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/proc/net （即 /proc/PID/net）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/sys/class/net&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/proc/sys/net 目录下的文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>端口、socket&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UNIX domain abstract socket namespace&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>使用 Network namespaces 需要内核支持 CONFIG_NET_NS 选项。如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ grep CONFIG_NET_NS /boot/config-&lt;span class="k">$(&lt;/span>uname -r&lt;span class="k">)&lt;/span>
&lt;span class="nv">CONFIG_NET_NS&lt;/span>&lt;span class="o">=&lt;/span>y
&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个物理网络设备只能存在于一个 Network namespace 中。当一个 Network namespace 被释放时（空间里的最后一个进程都被停止删除时），物理网络设备将被移动到初始的 Network namespace 而不是上层的 Network namespace。&lt;/p>
&lt;p>一个虚拟的网络设备(veth(4)) ，在 Network namespace 间通过一个类似管道的方式进行连接。这使得它能存在于多个 Network namespace，但是，当 Network namespace 被摧毁时，该空间下包含的 veth(4) 设备可能被破坏。&lt;/p>
&lt;h3 id="mount-namespaces">Mount namespaces&lt;/h3>
&lt;p>Mount namespaces 最早出现在 Linux 2.4.19 版本。Mount namespaces 隔离了各空间中挂载的进程实例。每个 mount namespace 的实例下的进程会看到不同的目录层次结构。&lt;/p>
&lt;p>每个进程在 mount namespace 中的描述可以在下面的文件视图中看到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/proc/[pid]/mounts&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/proc/[pid]/mountinfo&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/proc/[pid]/mountstats&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一个新的 Mount namespace 的创建标识是 CLONE_NEWNS ，使用了 clone(2) 或者 unshare(2) 。&lt;/p>
&lt;ul>
&lt;li>如果 Mount namespace 用 clone(2) 创建，子 namespace 的挂载列表是从父进程的 mount namespace 拷贝的。&lt;/li>
&lt;li>如果 Mount namespace 用 unshare(2) 创建，新 namespace 的挂载列表是从调用者之前的 moun namespace 拷贝的。&lt;/li>
&lt;/ul>
&lt;p>如果 mount namespace 发生了修改，会引起什么样的连锁反应？下面，我们就在 &lt;strong>共享子树&lt;/strong>中谈谈。&lt;/p>
&lt;p>每个 mount 都被可以有如下标记 ：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MS_SHARED - 与组内每个成员分享 events 。也就是说相同的 mount 或者 unmount 将自动发生在组内其他的 mounts 中。反之，mount 或者 unmount 事件 也会影响这次的 event 动作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MS_PRIVATE - 这个 mount 是私有的。mount 或者 unmount events 都不会影响这次的 event 动作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MS_SLAVE - mount 或者 unmount events 会从 master 节点传入影响该节点。但是这个节点下的 mount 或者 unmount events 不会影响组内的其他节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MS_UNBINDABLE - 这也是个私有的 mount 。任何尝试绑定的 mount 在这个设置下都将失败。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在文件 &lt;code>/proc/[pid]/mountinfo&lt;/code> 中可以看到 &lt;code>propagation&lt;/code> 类型的字段。每个对等组都会由内核生成唯一的 ID ，同一对等组的 mount 都是这个 ID（即，下文中的 X ）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ cat /proc/self/mountinfo &lt;span class="p">|&lt;/span>grep root
&lt;span class="m">65&lt;/span> &lt;span class="m">1&lt;/span> 0:33 /root / rw,relatime shared:1 - btrfs /dev/nvme0n1p6 rw,seclabel,compress&lt;span class="o">=&lt;/span>zstd:1,ssd,space_cache,subvolid&lt;span class="o">=&lt;/span>256,subvol&lt;span class="o">=&lt;/span>/root
&lt;span class="m">1210&lt;/span> &lt;span class="m">65&lt;/span> 0:33 /root/var/lib/docker/btrfs /var/lib/docker/btrfs rw,relatime shared:1 - btrfs /dev/nvme0n1p6 rw,seclabel,compress&lt;span class="o">=&lt;/span>zstd:1,ssd,space_cache,subvolid&lt;span class="o">=&lt;/span>256,subvol&lt;span class="o">=&lt;/span>/root
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>shared:X - 在组 X 中共享。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master:X - 对于组 X 而言是 slave，即，从属于 ID 为 X 的主。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>propagate_from:X - 接收从组 X 发出的共享 mount。这个标签总是个 master:X 一同出现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>unbindable - 表示不能被绑定，即，不与其他关联从属。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>新 mount namespace 的传播类型取决于它的父节点。如果父节点的传播类型是 MS_SHARED ，那么新 mount namespace 的传播类型是 MS_SHARED ，不然会默认为 MS_PRIVATE。&lt;/p>
&lt;p>关于 mount namespaces 我们还需要注意以下几点：&lt;/p>
&lt;p>（1）每个 mount namespace 都有一个 owner user namespace。如果新的 mount namespace 和拷贝的 mount namespace 分属于不同的 user namespace ，那么，新的 mount namespace 优先级低。&lt;/p>
&lt;p>（2）当创建的 mount namespace 优先级低时，那么，slave 的 mount events 会优先于 shared 的 mount events。&lt;/p>
&lt;p>（3）高优先级和低优先级的 mount namespace 有关联被锁定在一起时，他们都不能被单独卸载。&lt;/p>
&lt;p>（4）mount(2) 标识和 atime 标识会被锁定，即，不能被传播影响而修改。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>以上就是关于 Linux 内核中 namespace 的一些介绍了，篇幅原因，剩余部分以及 namespace 在容器中的应用我们放在下一篇中介绍，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.23.0 正式发布，新特性一览</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.23.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/><id>https://moelove.info/2021/12/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.23.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</id><updated>2021-12-08T08:26:16+08:00</updated><published>2021-12-08T03:50:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.23 即将发布，这是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes v1.23 即将发布，这是 2021 年发布的第三个版本，也是今年最后一个正式发布的版本。&lt;/p>
&lt;p>此版本中主要包括 47 项增强更新，其中 11 项达到 stable, 17 项达到 beta 还有 19 项达到 alpha 。 当然，也有 1 项被标记为废弃。相比于 v1.22 从数量上来说是少了一点（v1.22 有 53 项增强更新），但这并不影响这是一个很棒的版本！&lt;/p>
&lt;p>在 Kubernetes 的发布周期变更为 &lt;strong>每4个月一个版本&lt;/strong> 后，很明显的感觉就是不用在升级上面花费太多时间了，毕竟 Kubernetes 的升级操作是个体力活，大家觉得呢？&lt;/p>
&lt;p>我们一起来看看这个版本中有哪些值得关注的变更吧！&lt;/p>
&lt;h1 id="新增-kubectl-alpha-events-命令">新增 kubectl alpha events 命令&lt;/h1>
&lt;p>在之前的 《K8S 生态周报| Helm 新版本发布增强对 OCI 的支持》 文章的上游进展中我曾为大家介绍了该功能。它是按照 &lt;a href="https://github.com/kubernetes/enhancements/issues/1440">KEP #1440&lt;/a> 实施的。&lt;/p>
&lt;blockquote>
&lt;p>增加此命令主要是由于在不修改 &lt;code>kubectl get&lt;/code> 的前提下，查看 &lt;code>event&lt;/code> 有一些限制，所以直接增加 &lt;code>kubectl events&lt;/code> 命令可以更方便的去获取到需要的信息，尤其是 event 是在 Kubernetes 中经常需要查看的一个信息。&lt;code>kubectl get events&lt;/code> 比较典型的一些问题, 比如排序（虽然可以通过加参数解决）， watch，以及无法按照时间线方式去查看 events 等。&lt;/p>
&lt;/blockquote>
&lt;p>我们来看看这个命令具体如何使用。&lt;/p>
&lt;p>我们先来创建两个 Pod，分别叫 &lt;code>redis&lt;/code> 和 &lt;code>redis2&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl run redis --image&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span>
pod/redis created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl run redis2 --image&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span>
pod/redis2 created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl get pods
NAME READY STATUS RESTARTS AGE
redis 1/1 Running &lt;span class="m">0&lt;/span> 12m
redis2 1/1 Running &lt;span class="m">0&lt;/span> 2m23s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行 &lt;code>kubectl alpha events&lt;/code> 可以看到当前 namespace 下的所有 events 。如果增加 &lt;code>--for&lt;/code> 条件可以用来筛选只展示特定资源相关的 events 。同时 &lt;strong>默认情况下就是按时间排序的&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl alpha events
LAST SEEN TYPE REASON OBJECT MESSAGE
12m Normal Scheduled Pod/redis Successfully assigned default/redis to kind-control-plane
12m Normal Pulling Pod/redis Pulling image &lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span>
12m Normal Pulled Pod/redis Successfully pulled image &lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span> in 4.028873745s
12m Normal Created Pod/redis Created container redis
12m Normal Started Pod/redis Started container redis
3m5s Normal Scheduled Pod/redis2 Successfully assigned default/redis2 to kind-control-plane
3m5s Normal Pulled Pod/redis2 Container image &lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span> already present on machine
3m4s Normal Created Pod/redis2 Created container redis2
3m4s Normal Started Pod/redis2 Started container redis2
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl alpha events --for pod/redis2
LAST SEEN TYPE REASON OBJECT MESSAGE
3m23s Normal Scheduled Pod/redis2 Successfully assigned default/redis2 to kind-control-plane
3m23s Normal Pulled Pod/redis2 Container image &lt;span class="s2">&amp;#34;ghcr.io/tao12345666333/redis:alpine&amp;#34;&lt;/span> already present on machine
3m22s Normal Created Pod/redis2 Created container redis2
3m22s Normal Started Pod/redis2 Started container redis2
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="ipv4ipv6-双栈支持达到-ga">IPv4/IPv6 双栈支持达到 GA&lt;/h1>
&lt;p>在配置双栈网络的 Kubernetes 时，需要同时指定 &lt;code>--node-cidr-mask-size-ipv4&lt;/code> 和 &lt;code>--node-cidr-mask-size-ipv6&lt;/code> 以便于设置每个 Node 上的子网大小。在此之前我们都是直接使用 &lt;code> --node-cidr-mask-size&lt;/code> 进行设置即可。&lt;/p>
&lt;p>如果我们仍然使用单栈 Kubernetes 集群的话，正常来说不需要做什么调整，当然我们也可以使用上面提到的选项，来单独设置集群的 IPv4/IPv6 子网。&lt;/p>
&lt;h1 id="podsecurity-admission-达到-beta">PodSecurity Admission 达到 Beta&lt;/h1>
&lt;p>PodSecurity Admission 是之前的 PSP 的代替，关于 Kubernetes Admission 可以参考我之前的文章 《理清 Kubernetes 中 Admission 机制》，这里就不展开了。&lt;/p>
&lt;h1 id="ingressclass-支持-namespace-级别的参数">IngressClass 支持 namespace 级别的参数&lt;/h1>
&lt;p>&lt;code>IngressClass.Spec.Parameters.Namespace&lt;/code> 字段当前达到 GA ，这样我们就可以为 IngressClass 设置参数为 namespace 级别了。比如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IngressClass&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">external-lb&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">controller&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">example.com/ingress-controller&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">parameters&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IngressParameters&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">external-lb&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">external-configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scope&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Namespace&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="probe-中增加-grpc-协议的支持">Probe 中增加 gRPC 协议的支持&lt;/h1>
&lt;p>通过 KEP #2727 ，在此版本中为 Pod.Spec.Container.{Liveness,Readiness,Startup} 的 Probe 添加了 gRPC 协议的支持。 例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">grpc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">9090&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">moelove-service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">initialDelaySeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">periodSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可通过 &lt;code>GRPCContainerProbe&lt;/code> feature gate 开启此特性。具体细节可参考 &lt;a href="https://github.com/kubernetes/kubernetes/pull/106463">#106463&lt;/a>&lt;/p>
&lt;h1 id="新增-openapi-v3">新增 OpenAPI V3&lt;/h1>
&lt;p>这个特性是 Alpha 级别，可通过 &lt;code>OpenApiv3&lt;/code> feature gate 进行开启。&lt;/p>
&lt;p>增加此特性主要是由于 CRD 目前可通过 OpenApi V3 进行定义，但是 api-server 目前还不支持。当从 OpenApi V3 转换为 V2 时，部分信息将会丢失。&lt;/p>
&lt;p>更多详细信息可参考 &lt;a href="https://github.com/kubernetes/enhancements/issues/2896">KEP #2896&lt;/a>&lt;/p>
&lt;h1 id="crd-validation-表达式语言">CRD Validation 表达式语言&lt;/h1>
&lt;p>这是一项 Alpha 级别的特性，默认是不开启的。可通过增加 &lt;code>CustomResourceValidationExpressions&lt;/code> feature gate 来进行开启。单独介绍此 Alpha 级别的特性是因为目前基于 Custom Resource Definitions (CRDs) 的方式对 Kubernetes 进行扩展已经成为主流，但是在 CRD 中目前能添加的校验规则有限，更多的场景都需要通过额外的 Admission 来完成。&lt;/p>
&lt;p>此功能使用一种叫做 Common Expression Language (CEL) 的语言进行规则定义，通过 &lt;code>x-kubernetes-validation-rules&lt;/code> 字段进行规则的添加。&lt;/p>
&lt;p>例如，某个 CRDs 的内容如下，其中定义了 &lt;code>minReplicas&lt;/code> 小于 &lt;code>replicas&lt;/code> 并且 &lt;code>replicas&lt;/code> 小于 &lt;code>maxReplicas&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">openAPIV3Schema&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">object&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">properties&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">object&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">x-kubernetes-validation-rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;self.minReplicas &amp;lt;= self.replicas&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;replicas should be greater than or equal to minReplicas.&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;self.replicas &amp;lt;= self.maxReplicas&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;replicas should be smaller than or equal to maxReplicas.&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">properties&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">minReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">integer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">integer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">maxReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">integer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">required&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">minReplicas&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">replicas&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">maxReplicas &lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，当有如下的自定义资源创建时，Kubernetes 将会拒绝其请求。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;stable.example.com/v1&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CustomDeployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-new-deploy-object&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">minReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">20&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">maxReplicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且返回如下错误：&lt;/p>
&lt;pre>&lt;code>The CustomDeployment &amp;quot;my-new-deploy-object&amp;quot; is invalid:
* spec: Invalid value: map[string]interface {}{&amp;quot;maxReplicas&amp;quot;:10, &amp;quot;minReplicas&amp;quot;:0, &amp;quot;replicas&amp;quot;:20}: replicas should be smaller than or equal to maxReplicas.
&lt;/code>&lt;/pre>&lt;p>这样相比原来我们通过 Admission 的方式来进行校验就会方便的多。关于 Kubernetes Admission 可以参考我之前的文章 《理清 Kubernetes 中 Admission 机制》。&lt;/p>
&lt;h1 id="hpa-v2-api-达到-ga">HPA v2 API 达到 GA&lt;/h1>
&lt;p>HPA v2 大约是在 5 年前首次提出，经过这 5 年的发展，终于在现在它达到了 GA 级别。&lt;/p>
&lt;p>以上就是关于 Kubernetes v1.23 中我认为值得关注的一些主要特性，更多信息可参阅其 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Open Policy Agent (OPA) 入门实践</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/12/06/Open-Policy-Agent-OPA-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"/><id>https://moelove.info/2021/12/06/Open-Policy-Agent-OPA-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</id><updated>2021-12-19T15:01:20+08:00</updated><published>2021-12-06T19:50:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 本篇我来为你介绍一个我个人很喜欢的，通用策略引擎，名叫 OPA，全称是 Open Policy Agent。 在具体聊 OPA 之前，我们先来……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>本篇我来为你介绍一个我个人很喜欢的，通用策略引擎，名叫 OPA，全称是 Open Policy Agent。&lt;/p>
&lt;p>在具体聊 OPA 之前，我们先来聊一下为什么需要一个通用策略引擎，以及 OPA 解决了什么问题。&lt;/p>
&lt;h2 id="opa-解决了什么问题">OPA 解决了什么问题&lt;/h2>
&lt;p>在实际的生产环境中很多场景中都需要策略控制，比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>需要策略控制用户是否可登陆服务器或者做一些操作；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要策略控制哪些项目/哪些组件可进行部署；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要策略控制如何访问数据库；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要策略控制哪些资源可部署到 Kubernetes 中；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/paN9tjO46QM3RbT.png" alt="img">&lt;/p>
&lt;p>但是对于这些场景或者软件来说，配置它们的策略是需要与该软件进行耦合的，彼此是不统一，不通用的。管理起来也会比较混乱，带来了不小的维护成本。&lt;/p>
&lt;p>OPA 的出现可以将各处配置的策略进行统一，极大的&lt;strong>降低了维护成本&lt;/strong>。以及将策略与对应的软件/服务进行解耦，方便进行移植/复用。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/dPrM4sqaeXIT1Q8.png" alt="img">&lt;/p>
&lt;h2 id="opa-的发展过程">OPA 的发展过程&lt;/h2>
&lt;p>OPA 最初是由 Styra 公司在 2016 年创建并开源的项目，目前该公司的主要产品就是提供可视化策略控制及策略执行的可视化 Dashboard 服务的。&lt;/p>
&lt;p>OPA 首次进入 CNCF 并成为 sandbox 级别的项目是在 2018 年， 在 2021 年的 2 月份便已经从 CNCF 毕业，这个过程相对来说还是比较快的，由此也可以看出 OPA 是一个比较活跃且应用广泛的项目。&lt;/p>
&lt;h2 id="opa-是什么">OPA 是什么&lt;/h2>
&lt;p>前面我们已经介绍过 Open Policy Agent (OPA) 是一种开源的通用策略引擎，可在整个堆栈中实现统一、上下文感知的策略控制。&lt;/p>
&lt;p>OPA 可将策略决策与应用程序的业务逻辑分离（解耦），&lt;strong>透过现象看本质，策略就是一组规则，请求发送到引擎，引擎根据规则来进行决策。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/6bqX3GINMmUVg2k.png" alt="img">&lt;/p>
&lt;p>图 3 ，OPA 的策略解耦示例&lt;/p>
&lt;p>&lt;strong>OPA 并不负责具体任务的执行，它仅负责决策&lt;/strong>，需要决策的请求通过 JSON 的方式传递给 OPA ，在 OPA 决策后，也会将结果以 JSON 的形式返回。&lt;/p>
&lt;h2 id="rego">Rego&lt;/h2>
&lt;p>OPA 中的策略是以 Rego 这种 DSL(Domain Specific Language) 来表示的。&lt;/p>
&lt;p>Rego 受 Datalog（https://en.wikipedia.org/wiki/Datalog） 的启发，并且扩展了 Datalog 对于结构化文档模型的支持，方便以 JSON 的方式对数据进行处理。&lt;/p>
&lt;p>Rego 允许策略制定者可以专注于返回内容的查询而不是如何执行查询。同时 OPA 中也内置了执行规则时的优化，用户可以默认使用。&lt;/p>
&lt;p>Rego 允许我们使用规则（if-then）封装和重用逻辑，规则可以是完整的或者是部分的。&lt;/p>
&lt;p>每个规则都是由头部和主体组成。在 Rego 中，如果规则主体对于某些变量赋值为真，那么我们说规则头为真。可以通过绝对路径引用任何加载到 OPA 中的规则来查询它的值。规则的路径总是： data.&lt;package-path>.&lt;rule-name> （规则生成的所有值都可以通过全局 data 变量进行查询。 例如，下方示例中的 &lt;code>data.example.rules.any_public_networks&lt;/code>&lt;/p>
&lt;ul>
&lt;li>完整规则是将单个值分配给变量的 if-then 语句。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/bQDisFJrBPAyk6h.png" alt="img">&lt;/p>
&lt;p>图 4 ，Rego 完整规则示例&lt;/p>
&lt;ul>
&lt;li>部分规则是生成一组值并将该组分配给变量的 if-then 语句。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/hKIamVtH5AzMbYr.png" alt="img">&lt;/p>
&lt;p>图 5 ，Rego 部分规则示例&lt;/p>
&lt;ul>
&lt;li>逻辑或是要在 Rego 中定义多个具有相同名称的规则。（查询中将多个表达式连接在一起时，表示的是逻辑 AND）&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/PJjwpmZtBNk4yHh.png" alt="img">&lt;/p>
&lt;p>图 6 ，Rego 规则或的完全规则和部分规则示例图&lt;/p>
&lt;h2 id="opa-的使用">OPA 的使用&lt;/h2>
&lt;p>OPA 的使用还是比较简单的，我们来看一下。&lt;/p>
&lt;h3 id="安装-opa">安装 OPA&lt;/h3>
&lt;h4 id="二进制方式">二进制方式&lt;/h4>
&lt;p>我们可以直接从 OPA 的 release 页面下载其二进制进行使用&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ wget -q -O ~/bin/opa https://github.com/open-policy-agent/opa/releases/download/v0.35.0/opa_linux_amd64_static
➜ ~ chmod +x ~/bin/opa
➜ ~ opa version
Version: 0.35.0
Build Commit: a54537a
Build Timestamp: 2021-12-01T02:11:47Z
Build Hostname: 9e4cf671a460
Go Version: go1.17.3
WebAssembly: unavailable
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="容器">容器&lt;/h4>
&lt;p>我们可以使用其官方镜像&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ docker run --rm openpolicyagent/opa:0.35.0 version
Version: 0.35.0
Build Commit: a54537a
Build Timestamp: 2021-12-01T02:10:31Z
Build Hostname: 4ee9b086e5de
Go Version: go1.17.3
WebAssembly: available
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="opa-交互">OPA 交互&lt;/h3>
&lt;h4 id="opa-eval">opa eval&lt;/h4>
&lt;p>最简单的命令是 &lt;code>opa eval&lt;/code> ，当然我们除了能使用它进行策略的执行外，还可以用来做表达式计算。&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/Ql5Lhwt1Knr7O3D.png" alt="img">&lt;/p>
&lt;p>图 7 ， opa eval 的使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ opa eval &amp;#34;6+6&amp;#34;
{
&amp;#34;result&amp;#34;: [
{
&amp;#34;expressions&amp;#34;: [
{
&amp;#34;value&amp;#34;: 12,
&amp;#34;text&amp;#34;: &amp;#34;6+6&amp;#34;,
&amp;#34;location&amp;#34;: {
&amp;#34;row&amp;#34;: 1,
&amp;#34;col&amp;#34;: 1
}
}
]
}
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="opa-run">opa run&lt;/h4>
&lt;p>&lt;code>opa run&lt;/code> 会启动一个交互式 shell （ REPL） 。我们可以使用 REPL 来试验策略并构建新的原型。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ opa run
OPA 0.35.0 &lt;span class="o">(&lt;/span>commit a54537a, built at 2021-12-01T02:11:47Z&lt;span class="o">)&lt;/span>
Run &lt;span class="s1">&amp;#39;help&amp;#39;&lt;/span> to see a list of commands and check &lt;span class="k">for&lt;/span> updates.
&amp;gt; &lt;span class="nb">true&lt;/span>
&lt;span class="nb">true&lt;/span>
&amp;gt; &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;OPA&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;OPA&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>
&amp;gt; pi :&lt;span class="o">=&lt;/span> 3.14
Rule &lt;span class="s1">&amp;#39;pi&amp;#39;&lt;/span> defined in package repl. Type &lt;span class="s1">&amp;#39;show&amp;#39;&lt;/span> to see rules.
&amp;gt; show
package repl
pi :&lt;span class="o">=&lt;/span> 3.14
&amp;gt; pi &amp;gt; &lt;span class="m">1&lt;/span>
&lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以将策略直接加载进去，或者 将 OPA 作为一个服务运行并通过 HTTP 执行查询。默认情况下，OPA 监会监听在 8181 端口。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ opa run --server
{&amp;#34;addrs&amp;#34;:[&amp;#34;:8181&amp;#34;],&amp;#34;diagnostic-addrs&amp;#34;:[],&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;msg&amp;#34;:&amp;#34;Initializing server.&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2021-12-07T01:12:47+08:00&amp;#34;}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>打开浏览器也可以看到一个简单的查询窗口&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/07/nbe45kwZFJWgiKL.png" alt="img">&lt;/p>
&lt;h4 id="opa-作为-go-的库使用">opa 作为 go 的库使用&lt;/h4>
&lt;p>OPA 可以作为库嵌入到 Go 程序中。将 OPA 嵌入为库的最简单方法是导入 &lt;code>github.com/open-policy-agent/opa/rego&lt;/code> 包。通过 &lt;code>rego.New&lt;/code> 函数用来创建一个可以准备或评估的对象, &lt;code>PrepareForEval()&lt;/code> 以获取可执行查询。&lt;/p>
&lt;p>以下是一个简单的示例：&lt;/p>
&lt;ul>
&lt;li>目录结构&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ opa tree
.
├── data
├── go.mod
├── go.sum
├── input.json
├── k8s-label.rego
└── main.go
&lt;span class="m">1&lt;/span> directory, &lt;span class="m">5&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>策略文件&lt;/li>
&lt;/ul>
&lt;p>这里的策略文件是来校验 INPUT 中是否包含名为 domain 的 label ， 以及该 label 是否以 &lt;code>moelove-&lt;/code>开头。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">kubernetes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">validating&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">existence&lt;/span>
&lt;span class="nx">deny&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">not&lt;/span> &lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">metadata&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">labels&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">domain&lt;/span>
&lt;span class="nx">msg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">&amp;#34;Every resource must have a domain label&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">deny&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">value&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">metadata&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">labels&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">domain&lt;/span>
&lt;span class="nx">not&lt;/span> &lt;span class="nf">startswith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;moelove-&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">msg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;domain label must start with `moelove-`; found `%v`&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>INPUT 文件， 以 Kubernetes 的 AdmissionReview 为例&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;AdmissionReview&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;request&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;kind&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Pod&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;version&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;v1&amp;#34;&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nt">&amp;#34;object&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;metadata&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;myapp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;labels&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;domain&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;opa&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nt">&amp;#34;spec&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;containers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;image&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;alpine&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;alpine&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>main.go 文件&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;context&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;encoding/json&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;os&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/open-policy-agent/opa/rego&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">ctx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// Construct a Rego object that can be prepared or evaluated.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">rego&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">rego&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Args&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]),&lt;/span>
&lt;span class="nx">rego&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Args&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]},&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="c1">// Create a prepared query that can be evaluated.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">PrepareForEval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Load the input document from stdin.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">input&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">dec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDecoder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdin&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">dec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">UseNumber&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">input&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">rs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">rego&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EvalInput&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">input&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行结果如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ opa go run main.go k8s-label.rego &lt;span class="s2">&amp;#34;data&amp;#34;&lt;/span> &amp;lt; input.json
&lt;span class="o">[{[&lt;/span>map&lt;span class="o">[&lt;/span>kubernetes:map&lt;span class="o">[&lt;/span>validating:map&lt;span class="o">[&lt;/span>existence:map&lt;span class="o">[&lt;/span>deny:&lt;span class="o">[&lt;/span>domain label must start with &lt;span class="sb">`&lt;/span>moelove-&lt;span class="sb">`&lt;/span>&lt;span class="p">;&lt;/span> found &lt;span class="sb">`&lt;/span>opa&lt;span class="sb">`&lt;/span>&lt;span class="o">]]]]]]&lt;/span> map&lt;span class="o">[]}]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上便是对于 OPA 的一个大致介绍，OPA 的应用场景有很多，后续文章中将为大家分享 OPA 在 Kubernetes 中的应用，和将 OPA 应用与 CI/CD pipeline 的场景。敬请期待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/OPA/" term="OPA" label="OPA"/></entry><entry><title type="text">理清 Kubernetes 中的准入控制（Admission Controller)</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/"/><id>https://moelove.info/2021/11/30/%E7%90%86%E6%B8%85-Kubernetes-%E4%B8%AD%E7%9A%84%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6Admission-Controller/</id><updated>2021-11-30T12:48:00+08:00</updated><published>2021-11-30T03:04:22+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 在我之前发布的文章 《云原生时代下的容器镜像安全》（系列）中，我提到过 Kubernetes 集群的核心组件 -- kube-apiser……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在我之前发布的文章 《云原生时代下的容器镜像安全》（系列）中，我提到过 Kubernetes 集群的核心组件 -- kube-apiserver，它允许来自终端用户或集群的各组件与之进行通信（例如，查询、创建、修改或删除 Kubernetes 资源）。&lt;/p>
&lt;p>本篇我们将聚焦于 kube-apiserver 请求处理过程中一个很重要的部分 -- 准入控制器（Admission Controller）&lt;/p>
&lt;h2 id="k8s-的准入控制器是什么">K8s 的准入控制器是什么&lt;/h2>
&lt;h3 id="k8s-中的请求处理流程">K8s 中的请求处理流程&lt;/h3>
&lt;p>在聊 K8s 准入控制器是什么之前，让我们先来回顾一下 Kubernetes API 的处理具体请求的过程。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/30/PrlCtD3dvUAoRni.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 1 ，Kubernetes API 处理请求的过程 （从 API Handler 到 etcd 持久化的过程）&lt;/strong>&lt;/p>
&lt;p>如上图所示，每个 API 的请求从开始被 kube-apiserver 接收到最终持久化到 ETCD 的过程，即为 Kubernetes API 的请求处理流程。&lt;/p>
&lt;p>它主要包含了以下几个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>API Handler&lt;/strong> -- 主要负责提供服务，接收请求。&lt;/li>
&lt;/ul>
&lt;p>对于其内部实现而言，请求会先到 &lt;code>FullHandlerChain&lt;/code> （它是由 &lt;code>DefaultBuildHandlerChain&lt;/code> 构建出来的）是一个 &lt;code>director&lt;/code> 对象&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">director&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">name&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">goRestfulContainer&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">restful&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Container&lt;/span>
&lt;span class="nx">nonGoRestfulMux&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PathRecorderMux&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>director&lt;/code>根据配置进行初始化，如果 &lt;code>goRestfulContainer&lt;/code>的 WebServices 的 RootPath 是 &lt;code>/apis&lt;/code>，或者请求前缀与 RootPath 匹配，则进入 Restful 处理链路。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Authentication&lt;/strong> -- 认证的流程。&lt;/li>
&lt;/ul>
&lt;p>在TLS 连接建立后，会进行认证处理，如果请求认证失败，会拒绝该请求并返回 401 错误码；如果认证成功，将进行到鉴权的部分。目前支持的客户端认证方式有很多，例如：x509 客户端证书、Bearer Token、基于用户名密码的认证、OpenID 认证等。由于这些内容不是本篇的重点我们暂且跳过，感兴趣的小伙伴可以在评论区留言讨论。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Authorization&lt;/strong> -- 鉴权的流程。&lt;/li>
&lt;/ul>
&lt;p>对于 Kubernetes 而言，支持多种的鉴权模式，例如，ABAC 模式，RBAC 模式和 Webhook 模式等。我们在创建集群时，可以直接为 kube-apiserver 传递参数进行配置，这里也不赘述了。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Mutating Admission&lt;/strong> -- 指执行可用于变更操作的准入控制器，下文中会详细介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Object Schema Validation&lt;/strong> -- 对资源对象的 schema 校验。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Validating Admission&lt;/strong> -- 指执行可用于验证操作的准入控制器，下文中会详细介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ETCD&lt;/strong> -- ETCD 实现资源的持久化存储。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>上面便是一个请求的处理流程，其中 Mutating Admission 和 Validating Admission 便是我们今天的主角。我们来详细的看一看。&lt;/p>
&lt;h3 id="什么是准入控制器admission-controller">什么是准入控制器（Admission Controller）&lt;/h3>
&lt;p>准入控制器是指在&lt;strong>请求通过认证和授权之后&lt;/strong>，可用于对其进行变更操作或验证操作的一些代码或功能。&lt;/p>
&lt;p>准入控制的过程分为两个阶段：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一阶段，运行变更准入控制器（Mutating Admission）。它可以修改被它接受的对象，这就引出了它的另一个作用，将相关资源作为请求处理的一部分进行变更；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二阶段，运行验证准入控制器（Validating Admission）。它只能进行验证，不能进行任何资源数据的修改操作；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>需要注意的是，某些控制器可以既是变更准入控制器又是验证准入控制器。如果任一个阶段的准入控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回错误。&lt;/p>
&lt;h2 id="为什么需要准入控制器-admission-controller">为什么需要准入控制器 Admission Controller&lt;/h2>
&lt;p>我们主要从两个角度来理解为什么我们需要准入控制器：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从安全的角度&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>我们需要明确在 Kubernetes 集群中部署的镜像来源是否可信，以免遭受攻击；&lt;/li>
&lt;li>一般情况下，在 Pod 内尽量不使用 root 用户，或者尽量不开启特权容器等；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>从治理的角度&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>比如通过 label 对业务/服务进行区分，那么可以通过 admission controller 校验服务是否已经有对应的 label 存在之类的；&lt;/li>
&lt;li>比如添加资源配额限制 ，以免出现资源超卖之类的情况；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="准入控制器">准入控制器&lt;/h2>
&lt;p>考虑到这些需求比较有用 &amp;amp; 确实也比较需要，所以 Kubernetes 目前已经实现了很多内置的 Admission Controller 。 可以参考官方文档来获取详细列表： &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do&lt;/a>&lt;/p>
&lt;p>这些内置的 Admission Controller 都是以插件的方式与 kube-apiserver 构建到一起的，你可以对其进行启用和关停。比如用如下参数进行控制：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ bin ./kube-apiserver --help &lt;span class="p">|&lt;/span>grep admission-plugins
--admission-control strings Admission is divided into two phases. In the first phase, only mutating admission plugins run. In the second phase, only validating admission plugins run. The names in the below list may represent a validating plugin, a mutating plugin, or both. The order of plugins in which they are passed to this flag does not matter. Comma-delimited list of: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurity, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. &lt;span class="o">(&lt;/span>DEPRECATED: Use --enable-admission-plugins or --disable-admission-plugins instead. Will be removed in a future version.&lt;span class="o">)&lt;/span>
--disable-admission-plugins strings admission plugins that should be disabled although they are in the default enabled plugins list &lt;span class="o">(&lt;/span>NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, PodSecurity, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota&lt;span class="o">)&lt;/span>. Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurity, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.
--enable-admission-plugins strings admission plugins that should be enabled in addition to default enabled ones &lt;span class="o">(&lt;/span>NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, PodSecurity, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota&lt;span class="o">)&lt;/span>. Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurity, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这么多的准入控制器中有两个比较特别，分别是 &lt;code>MutatingAdmissionWebhook&lt;/code> 和 &lt;code>ValidatingAdmissionWebhook&lt;/code>。它们并没有真正执行相应的策略，而是为 kube-apiserver 提供了一种可扩展的方式， 用户可以通过配置 &lt;code>MutatingAdmissionWebhook&lt;/code> 和 &lt;code>ValidatingAdmissionWebhook&lt;/code> 来使用自构建的服务， 而且这种方式是无需对 kube-spiserver 执行编译或者重启，完全是动态的，非常的方便。&lt;/p>
&lt;p>我们来具体看一下。&lt;/p>
&lt;h2 id="动态准入控制器">动态准入控制器&lt;/h2>
&lt;p>利用上文中提到的 &lt;code>MutatingAdmissionWebhook&lt;/code> 和 &lt;code>ValidatingAdmissionWebhook&lt;/code> 进行运行时配置的，以 Webhook 形式调用的 Admission Controller 即为动态准入控制器。&lt;/p>
&lt;p>它是一种用于接收准入请求并对其进行处理的 HTTP 回调机制，就是一个 Web 服务。当前的两种类型的准入 webhook：&lt;/p>
&lt;ul>
&lt;li>validating admission webhook&lt;/li>
&lt;li>mutating admission webhook&lt;/li>
&lt;/ul>
&lt;p>mutating admission webhook 会优先被调用，这个过程中可以对资源进行修改。&lt;/p>
&lt;p>如果我们需要确保对象的最终状态以执行某些操作应该考虑使用 validating admission webhook *，*因为到达这个阶段的请求不会再被修改。&lt;/p>
&lt;h3 id="使用条件">使用条件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>确保 Kubernetes 集群版本至少为 v1.16（以便使用 &lt;code>admissionregistration.k8s.io/v1&lt;/code> API） 或者 v1.9 （以便使用 &lt;code>admissionregistration.k8s.io/v1beta1&lt;/code> API）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确保已经启用 &lt;code>MutatingAdmissionWebhook&lt;/code> 和 &lt;code>ValidatingAdmissionWebhook&lt;/code> 准入控制器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确保启用了 &lt;code>admissionregistration.k8s.io/v1beta1&lt;/code> 或者 &lt;code>admissionregistration.k8s.io/v1&lt;/code> API;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="admission-webhook-是什么">Admission Webhook 是什么&lt;/h3>
&lt;p>它其实就是一个普通的 HTTP Server，需要处理的就是 &lt;code>AdmissionReview&lt;/code> 类型的资源，我们来看个示例，比如说要对 &lt;code>Ingress&lt;/code>资源进行准入校验：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">ia&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">IngressAdmission&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">HandleAdmission&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">obj&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">review&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">isV1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">admissionv1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AdmissionReview&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">isV1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;request is not of type AdmissionReview v1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">apiequality&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Semantic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">DeepEqual&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kind&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ingressResource&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;rejecting admission review because the request does not contain an Ingress resource but %s with name %s in namespace %s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kind&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">String&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">status&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">admissionv1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AdmissionResponse&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UID&lt;/span>
&lt;span class="nx">ingress&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Ingress&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">codec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSerializerWithOptions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DefaultMetaFactory&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">scheme&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">scheme&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SerializerOptions&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Pretty&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="nx">codec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Raw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">codec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Raw&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ingress&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ErrorS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to decode ingress&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Allowed&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Status&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Status&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusFailure&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Code&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusBadRequest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Reason&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusReasonBadRequest&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Error&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Response&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">status&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ia&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Checker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CheckIngress&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ingress&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ErrorS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;invalid ingress configuration&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ingress&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%v/%v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Allowed&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Status&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Status&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusFailure&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Code&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusBadRequest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">Reason&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StatusReasonBadRequest&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Error&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Response&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">status&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">klog&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">InfoS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;successfully validated configuration, accepting&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ingress&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%v/%v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Request&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Allowed&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="nx">review&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Response&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">status&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">review&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>核心处理逻辑其实就是处理请求 Webhook 时候发送的 &lt;code>AdmissionReview&lt;/code> ，它会包含着我们待校验的资源对象。然后我们就按照实际的需要对资源对象进行校验或者修改了。&lt;/p>
&lt;p>这里需要注意几个点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Mutating Webhook 的处理是串行的，而 Validating Webhook 是并行处理的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mutating Webhook 虽然处理是串行的，但是并不保证顺序；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意对 Mutating Webhook 的处理做到幂等性，以免结果不符合预期；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>请求处理时，注意要处理资源对象的所有 API 版本；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="如何部署-admission-webhook">如何部署 Admission Webhook&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admissionregistration.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ValidatingWebhookConfiguration&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">app.kubernetes.io/name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingress-nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingress-nginx-admission&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">webhooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">validate.nginx.ingress.kubernetes.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Equivalent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">apiGroups&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">networking.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">operations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">CREATE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">UPDATE&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ingresses&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">failurePolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Fail&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">sideEffects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">None&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">admissionReviewVersions&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">clientConfig&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingress-nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingress-nginx-controller-admission&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/networking/v1/ingresses&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;code>webhooks&lt;/code> 中配置 webhook 的具体连接信息，以及触发规则。&lt;code>rules&lt;/code>中可指定对哪些资源的具体行为生效。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇主要介绍了 Kubernetes 中的 Admission Controller ，默认情况下有一些已经以插件形式与 kube-apiserver 编译到了一起，另外我们也可以通过自己编写动态准入控制器来完成相关的需求。&lt;/p>
&lt;p>当然，目前在 K8s 生态中已经有很多现成的工具可以帮我们完成对应的这些事情了，很多情况下不需要再自行开发对应的服务了。后续我来为大家分享当前一些比较主流的，可用于进行 Mutating 和 Validating 准入控制的工具， 欢迎关注。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">新功能：Prometheus Agent 模式上手体验</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/><id>https://moelove.info/2021/11/28/%E6%96%B0%E5%8A%9F%E8%83%BDPrometheus-Agent-%E6%A8%A1%E5%BC%8F%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/</id><updated>2021-11-29T10:22:24+08:00</updated><published>2021-11-28T00:26:44+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 Prometheus 几乎已经成为了云原生时代下监控选型的事实标准，它也是第二个从 CNCF 毕业的项目。 当前，Prometheus 几乎可……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>Prometheus 几乎已经成为了云原生时代下监控选型的事实标准，它也是第二个从 CNCF 毕业的项目。&lt;/p>
&lt;p>当前，Prometheus 几乎可以满足各种场景/服务的监控需求。我之前有写过一些文章介绍过 Prometheus 及其生态，本篇我们将聚焦于 Prometheus 最新版本中发布的 Agent 模式，对于与此主题无关的一些概念或者用法，我会粗略带过。&lt;/p>
&lt;h2 id="拉模式pull和-推模式push">拉模式（Pull）和 推模式（Push）&lt;/h2>
&lt;p>众所周知，Prometheus 是一种拉模式（Pull）的监控系统，这不同于传统的基于推模式（Push）的监控系统。&lt;/p>
&lt;p>什么是拉模式（Pull）呢？&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/yAYWuiLRdks7BgZ.png" alt="Prometheus Pull model">&lt;/p>
&lt;p>待监控的服务自身或者通过一些 exporter 暴露出来一些 metrics 指标的接口，由 Prometheus 去主动的定时进行抓取/采集，这就是拉模式（Pull）。即由监控系统主动的去拉（Pull）目标的 metrics。&lt;/p>
&lt;p>与之相对应的就是推模式（Push）了。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/Vki54At9fCXrm6Z.png" alt="Monitor Push model">&lt;/p>
&lt;p>由应用程序主动将自身的一些 metrics 指标进行上报，监控系统再进行相对应的处理。如果对于某些应用程序的监控想要使用推模式（Push），比如：不易实现 metrics 接口等原因，可以考虑使用 Pushgateway 来完成。&lt;/p>
&lt;p>对于拉模式（Pull）和推模式（Push）到底哪种更好的讨论一直都在继续，有兴趣的小伙伴可以自行搜索下。&lt;/p>
&lt;p>这里主要是聚焦于单个 Prometheus 和应用服务之间交互的手方式。本篇我们从更上层的角度或者全局角度来看看当前 Prometheus 是如何做 HA、 持久化和集群的。&lt;/p>
&lt;h2 id="prometheus-ha持久化集群的方案">Prometheus HA/持久化/集群的方案&lt;/h2>
&lt;p>在大规模生产环境中使用时，很少有系统中仅有一个单实例 Prometheus 存在的情况出现。无论从高可用、数据持久化还是从为用户提供更易用的全局视图来考虑，运行多个 Prometheus 实例的情况就很常见了。&lt;/p>
&lt;p>目前 Prometheus 主要有三种办法来将多个 Prometheus 实例的数据进行聚合，并给用户提供一个统一的全局视图。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/Vu61jXHeR2i5zsp.png" alt="">&lt;/p>
&lt;ul>
&lt;li>联邦（Federation）：是最早期的 Prometheus 内置的数据聚合方案。这种方案下，可以使用某个中心 Prometheus 实例从叶子 Prometheus 实例上进行指标的抓取。这种方案下可以保留 metrics 原本的时间戳，整体也比较简单；&lt;/li>
&lt;li>Prometheus Remote Read（远程读）：可以支持从远程的存储中读取原始 metrics，注意：这里的远程存储可以有多种选择。当读取完数据后，便可对它们进行聚合，并展现给用户了；&lt;/li>
&lt;li>Prometheus Remote Write（远程写）：可以支持将 Prometheus 采集到 metrics 等写到远程存储中。用户在使用的时候，直接从远端存储中读取数据，并提供全局视图等；&lt;/li>
&lt;/ul>
&lt;h2 id="prometheus-agent-模式">Prometheus Agent 模式&lt;/h2>
&lt;p>Prometheus Agent 是自 Prometheus v2.32.0 开始将会提供的一项功能，它主要是采用上文中提到的 &lt;strong>Prometheus Remote Write&lt;/strong> 的方式，将启用了 Agent 模式的 Prometheus 实例的数据写入到远程存储中。并借助远程存储来提供一个全局视图。&lt;/p>
&lt;h3 id="前置依赖">前置依赖&lt;/h3>
&lt;p>由于它使用了 &lt;strong>Prometheus Remote Write&lt;/strong> 的方式，所以我们需要先准备一个 &amp;quot;远程存储&amp;quot; 用于 metrcis 的中心化存储。这里我们使用 &lt;a href="https://github.com/thanos-io/thanos">Thanos&lt;/a> 来提供此能力。当然，如果你想要使用其他的方案，比如： Cortex、influxDB 等也都是可以的。&lt;/p>
&lt;h4 id="准备远程存储">准备远程存储&lt;/h4>
&lt;p>这里我们直接使用 Thanos 最新版本的容器镜像来进行部署。这里我们使用了 &lt;code>host&lt;/code> 网络比较方便进行测试。&lt;/p>
&lt;p>执行完这些命令后，Thanos receive 将会监听在 &lt;code>http://127.0.0.1:10908/api/v1/receive&lt;/code> 用于接收&amp;quot;远程写入&amp;quot;。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ &lt;span class="nb">cd&lt;/span> prometheus
➜ prometheus docker run -d --rm &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -v &lt;span class="k">$(&lt;/span>&lt;span class="nb">pwd&lt;/span>&lt;span class="k">)&lt;/span>/receive-data:/receive/data &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --net&lt;span class="o">=&lt;/span>host &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --name receive &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> quay.io/thanos/thanos:v0.23.1 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> receive &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --tsdb.path &lt;span class="s2">&amp;#34;/receive/data&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --grpc-address 127.0.0.1:10907 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --http-address 127.0.0.1:10909 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --label &lt;span class="s2">&amp;#34;receive_replica=\&amp;#34;0\&amp;#34;&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --label &lt;span class="s2">&amp;#34;receive_cluster=\&amp;#34;moelove\&amp;#34;&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --remote-write.address 127.0.0.1:10908
59498d43291b705709b3f360d28af81d5a8daba11f5629bb11d6e07532feb8b6
➜ prometheus docker ps -l
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
59498d43291b quay.io/thanos/thanos:v0.23.1 &lt;span class="s2">&amp;#34;/bin/thanos receive…&amp;#34;&lt;/span> &lt;span class="m">21&lt;/span> seconds ago Up &lt;span class="m">20&lt;/span> seconds receive
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="准备查询组件">准备查询组件&lt;/h4>
&lt;p>接下来我们启动一个 Thanos 的 query 组件，跟 receive 组件连接，用于查询写入的数据。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ prometheus docker run -d --rm &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--net&lt;span class="o">=&lt;/span>host &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--name query &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>quay.io/thanos/thanos:v0.23.1 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>query &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--http-address &lt;span class="s2">&amp;#34;0.0.0.0:39090&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>--store &lt;span class="s2">&amp;#34;127.0.0.1:10907&amp;#34;&lt;/span>
10c2b1bf2375837dbda16d09cee43d95787243f6dcbee73f4159a21b12d36019
➜ prometheus docker ps -l
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
10c2b1bf2375 quay.io/thanos/thanos:v0.23.1 &lt;span class="s2">&amp;#34;/bin/thanos query -…&amp;#34;&lt;/span> &lt;span class="m">4&lt;/span> seconds ago Up &lt;span class="m">3&lt;/span> seconds query
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：这里我们配置了 &lt;code>--store&lt;/code> 字段，指向了前面的 receive 组件。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/Iq15lebL8UHFvWY.png" alt="">&lt;/p>
&lt;p>打开浏览器访问 http://127.0.0.1:39090/stores ，如果一起顺利，你应该可以看到 receive 已经注册到了 store 中。&lt;/p>
&lt;h3 id="部署-prometheus-agent-模式">部署 Prometheus Agent 模式&lt;/h3>
&lt;p>这里我直接从 Prometheus 的 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.32.0-beta.0">Release 页面&lt;/a> 下载了它最新版本 v2.32.0 的二进制文件。解压后，你会发现目录中的内容和之前版本中是一致的。&lt;/p>
&lt;p>这是因为 &lt;strong>Prometheus Agent 模式现在是内置在 Prometheus 二进制文件中的，增加 &lt;code>--enable-feature=agent&lt;/code> 选项即可启用。&lt;/strong>&lt;/p>
&lt;h4 id="准备配置文件">准备配置文件&lt;/h4>
&lt;p>我们需要为它准备一份配置文件，注意， &lt;strong>需要配置 remote_write ，且不能有 alerting 之类的配置&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">global&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scrape_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">15s&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">external_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cluster&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">moelove&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replica&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">scrape_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;prometheus&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;localhost:9090&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">remote_write&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;http://127.0.0.1:10908/api/v1/receive&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置文件另存为 &lt;code>prometheus.yml&lt;/code>&lt;/p>
&lt;h4 id="启动">启动&lt;/h4>
&lt;p>我们将它的日志级别设置成 debug 方便查看它的一些细节&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ./prometheus --enable-feature&lt;span class="o">=&lt;/span>agent --log.level&lt;span class="o">=&lt;/span>debug --config.file&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;prometheus.yml&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:195 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Experimental agent mode enabled.&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:515 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Starting Prometheus&amp;#34;&lt;/span> &lt;span class="nv">version&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;(version=2.32.0-beta.0, branch=HEAD, revision=c32725ba7873dbaa39c223410043430ffa5a26c0)&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:520 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">build_context&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;(go=go1.17.3, user=root@da630543d231, date=20211116-11:23:14)&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:521 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">host_details&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;(Linux 5.14.18-200.fc34.x86_64 #1 SMP Fri Nov 12 16:48:10 UTC 2021 x86_64 moelove (none))&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:522 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">fd_limits&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;(soft=1024, hard=524288)&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.861Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:523 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">vm_limits&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;(soft=unlimited, hard=unlimited)&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.862Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>web.go:546 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>web &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Start listening for connections&amp;#34;&lt;/span> &lt;span class="nv">address&lt;/span>&lt;span class="o">=&lt;/span>0.0.0.0:9090
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.862Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:980 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Starting WAL storage ...&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.863Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>tls_config.go:195 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>web &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;TLS is disabled.&amp;#34;&lt;/span> &lt;span class="nv">http2&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>db.go:306 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;replaying WAL, this may take a while&amp;#34;&lt;/span> &lt;span class="nv">dir&lt;/span>&lt;span class="o">=&lt;/span>data-agent/wal
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>db.go:357 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;WAL segment loaded&amp;#34;&lt;/span> &lt;span class="nv">segment&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">maxSegment&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:1001 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">fs_type&lt;/span>&lt;span class="o">=&lt;/span>9123683e
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:1004 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Agent WAL storage started&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:1005 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Agent WAL storage options&amp;#34;&lt;/span> &lt;span class="nv">WALSegmentSize&lt;/span>&lt;span class="o">=&lt;/span>0B &lt;span class="nv">WALCompression&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="nv">StripeSize&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">TruncateFrequency&lt;/span>&lt;span class="o">=&lt;/span>0s &lt;span class="nv">MinWALTime&lt;/span>&lt;span class="o">=&lt;/span>0s &lt;span class="nv">MaxWALTime&lt;/span>&lt;span class="o">=&lt;/span>0s
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.864Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:1129 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Loading configuration file&amp;#34;&lt;/span> &lt;span class="nv">filename&lt;/span>&lt;span class="o">=&lt;/span>prometheus.yml
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Starting WAL watcher&amp;#34;&lt;/span> &lt;span class="nv">queue&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Starting scraped metadata watcher&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Replaying WAL&amp;#34;&lt;/span> &lt;span class="nv">queue&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Tailing WAL&amp;#34;&lt;/span> &lt;span class="nv">lastCheckpoint&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="nv">checkpointIndex&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">currentSegment&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">lastSegment&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Processing segment&amp;#34;&lt;/span> &lt;span class="nv">currentSegment&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.877Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>manager.go:196 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;discovery manager scrape&amp;#34;&lt;/span> &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Starting provider&amp;#34;&lt;/span> &lt;span class="nv">provider&lt;/span>&lt;span class="o">=&lt;/span>static/0 &lt;span class="nv">subs&lt;/span>&lt;span class="o">=[&lt;/span>prometheus&lt;span class="o">]&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.877Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:1166 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Completed loading of configuration file&amp;#34;&lt;/span> &lt;span class="nv">filename&lt;/span>&lt;span class="o">=&lt;/span>prometheus.yml &lt;span class="nv">totalDuration&lt;/span>&lt;span class="o">=&lt;/span>12.433099ms &lt;span class="nv">db_storage&lt;/span>&lt;span class="o">=&lt;/span>361ns &lt;span class="nv">remote_storage&lt;/span>&lt;span class="o">=&lt;/span>323.413µs &lt;span class="nv">web_handler&lt;/span>&lt;span class="o">=&lt;/span>247ns &lt;span class="nv">query_engine&lt;/span>&lt;span class="o">=&lt;/span>157ns &lt;span class="nv">scrape&lt;/span>&lt;span class="o">=&lt;/span>11.609215ms &lt;span class="nv">scrape_sd&lt;/span>&lt;span class="o">=&lt;/span>248.024µs &lt;span class="nv">notify&lt;/span>&lt;span class="o">=&lt;/span>3.216µs &lt;span class="nv">notify_sd&lt;/span>&lt;span class="o">=&lt;/span>6.338µs &lt;span class="nv">rules&lt;/span>&lt;span class="o">=&lt;/span>914ns
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.877Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>main.go:897 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Server is ready to receive web requests.&amp;#34;&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:15.877Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>manager.go:214 &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;discovery manager scrape&amp;#34;&lt;/span> &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Discoverer channel closed&amp;#34;&lt;/span> &lt;span class="nv">provider&lt;/span>&lt;span class="o">=&lt;/span>static/0
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:28.196Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>info &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Done replaying WAL&amp;#34;&lt;/span> &lt;span class="nv">duration&lt;/span>&lt;span class="o">=&lt;/span>12.331255772s
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:30.867Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;runShard timer ticked, sending buffered data&amp;#34;&lt;/span> &lt;span class="nv">samples&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">230&lt;/span> &lt;span class="nv">exemplars&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">shard&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:35.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>QueueManager.calculateDesiredShards &lt;span class="nv">dataInRate&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">23&lt;/span> &lt;span class="nv">dataOutRate&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">23&lt;/span> &lt;span class="nv">dataKeptRatio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="nv">dataPendingRate&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">dataPending&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">dataOutDuration&lt;/span>&lt;span class="o">=&lt;/span>0.0003201718 &lt;span class="nv">timePerSample&lt;/span>&lt;span class="o">=&lt;/span>1.3920513043478261e-05 &lt;span class="nv">desiredShards&lt;/span>&lt;span class="o">=&lt;/span>0.0003201718 &lt;span class="nv">highestSent&lt;/span>&lt;span class="o">=&lt;/span>1.638039808e+09 &lt;span class="nv">highestRecv&lt;/span>&lt;span class="o">=&lt;/span>1.638039808e+09
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:35.865Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>QueueManager.updateShardsLoop &lt;span class="nv">lowerBound&lt;/span>&lt;span class="o">=&lt;/span>0.7 &lt;span class="nv">desiredShards&lt;/span>&lt;span class="o">=&lt;/span>0.0003201718 &lt;span class="nv">upperBound&lt;/span>&lt;span class="o">=&lt;/span>1.3
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:45.866Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>QueueManager.calculateDesiredShards &lt;span class="nv">dataInRate&lt;/span>&lt;span class="o">=&lt;/span>23.7 &lt;span class="nv">dataOutRate&lt;/span>&lt;span class="o">=&lt;/span>18.4 &lt;span class="nv">dataKeptRatio&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> &lt;span class="nv">dataPendingRate&lt;/span>&lt;span class="o">=&lt;/span>5.300000000000001 &lt;span class="nv">dataPending&lt;/span>&lt;span class="o">=&lt;/span>355.5 &lt;span class="nv">dataOutDuration&lt;/span>&lt;span class="o">=&lt;/span>0.00025613744 &lt;span class="nv">timePerSample&lt;/span>&lt;span class="o">=&lt;/span>1.3920513043478263e-05 &lt;span class="nv">desiredShards&lt;/span>&lt;span class="o">=&lt;/span>0.00037940358300000006 &lt;span class="nv">highestSent&lt;/span>&lt;span class="o">=&lt;/span>1.638039808e+09 &lt;span class="nv">highestRecv&lt;/span>&lt;span class="o">=&lt;/span>1.638039823e+09
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:45.866Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>QueueManager.updateShardsLoop &lt;span class="nv">lowerBound&lt;/span>&lt;span class="o">=&lt;/span>0.7 &lt;span class="nv">desiredShards&lt;/span>&lt;span class="o">=&lt;/span>0.00037940358300000006 &lt;span class="nv">upperBound&lt;/span>&lt;span class="o">=&lt;/span>1.3
&lt;span class="nv">ts&lt;/span>&lt;span class="o">=&lt;/span>2021-11-27T19:03:45.871Z &lt;span class="nv">caller&lt;/span>&lt;span class="o">=&lt;/span>dedupe.go:112 &lt;span class="nv">component&lt;/span>&lt;span class="o">=&lt;/span>remote &lt;span class="nv">level&lt;/span>&lt;span class="o">=&lt;/span>debug &lt;span class="nv">remote_name&lt;/span>&lt;span class="o">=&lt;/span>e6fa2a &lt;span class="nv">url&lt;/span>&lt;span class="o">=&lt;/span>http://127.0.0.1:10908/api/v1/receive &lt;span class="nv">msg&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;runShard timer ticked, sending buffered data&amp;#34;&lt;/span> &lt;span class="nv">samples&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">265&lt;/span> &lt;span class="nv">exemplars&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span> &lt;span class="nv">shard&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从日志中可以看到，它会去向 &lt;code>http://127.0.0.1:10908/api/v1/receive&lt;/code> 也就是我们一开始部署的 Thanos receive 发送数据。&lt;/p>
&lt;h4 id="查询数据">查询数据&lt;/h4>
&lt;p>打开我们一开始部署好的 Thanos query， 输入任意 metrics 进行查询，可以查询到预期的结果。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/Sa1pjykYWIA8lQE.png" alt="">&lt;/p>
&lt;p>但是如果我们直接访问开启了 Agent 模式的 Prometheus 的 UI 地址的时候，会直接报错，无法进行查询。这是由于 &lt;strong>如果已开启 Agent 模式的 Prometheus 将会默认关闭其 UI 查询能力，报警以及本地存储等能力&lt;/strong>。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇主要进行了 Prometheus Agent 的上手实践，通过 Thanos receive 接收来自 Prometheus Agent 的 metrics 上报，然后通过 Thanos query 进行结果的查询。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/28/pYPXM5KC3VF8yTr.png" alt="">&lt;/p>
&lt;p>Prometheus Agent 并没有本质上改变 Prometheus 指标采集的方式，仍然还是继续使用拉模式（Pull）。&lt;/p>
&lt;p>它的使用场景主要是进行 Prometheus 的 HA/数据持久化或集群。与现有的一些方案在架构上会略有重合，
但是有一些优势：&lt;/p>
&lt;ul>
&lt;li>Agent 模式是 Prometheus 内置的功能；&lt;/li>
&lt;li>开启 Agent 模式的 Prometheus 实例，资源消耗更少，功能也会更单一，对于扩展一些边缘场景更有利；&lt;/li>
&lt;li>启用 Agent 模式后，Prometheus 实例几乎可以当作是一个无状态的应用，比较方便进行扩展使用；&lt;/li>
&lt;/ul>
&lt;p>过段时间就会发布正式版本了，你是否会尝试使用呢？&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Prometheus/" term="Prometheus" label="Prometheus"/></entry><entry><title type="text">用 Go 调用 Rust</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/"/><id>https://moelove.info/2021/11/26/%E7%94%A8-Go-%E8%B0%83%E7%94%A8-Rust/</id><updated>2021-11-26T11:33:52+08:00</updated><published>2021-11-26T03:04:22+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 近期 Rust 社区/团队有些变动，所以再一次将 Rust 拉到大多数人眼前。 我最近看到很多小伙伴说的话： Rust 还值得学吗？社区是不……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>近期 Rust 社区/团队有些变动，所以再一次将 Rust 拉到大多数人眼前。&lt;/p>
&lt;p>我最近看到很多小伙伴说的话：&lt;/p>
&lt;blockquote>
&lt;p>Rust 还值得学吗？社区是不是不稳定呀&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Rust 和 Go 哪个好？&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Rust 还值得学吗？&lt;/p>
&lt;/blockquote>
&lt;p>这些问题如果有人来问我，那我的回答是：&lt;/p>
&lt;p>&lt;strong>小孩子才做选择，我都要！&lt;/strong>&lt;/p>
&lt;p>当然，关于 Rust 和 Go 的问题也不算新，比如之前的一条推文：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/26/JsdQwfOImrvek2K.png" alt="">&lt;/p>
&lt;p>我在本篇中就来介绍下如何用 Go 调用 Rust。&lt;/p>
&lt;p>&lt;strong>当然，这篇中我基本上不会去比较 Go 和 Rust 的功能，或者这种方式的性能之类的，Just for Fun&lt;/strong>&lt;/p>
&lt;h1 id="ffi-和-binding">FFI 和 Binding&lt;/h1>
&lt;p>FFI (Foreign Function Interface) 翻译过来叫做外部函数接口（为了比较简单，下文中都将使用 FFI 指代）。最早来自于 Common Lisp 的规范，这是在 wiki 上写的，我并没有去考证。
不过我所使用过的绝大多数语言中都有 FFI 的概念/术语存在，比如：Python、Ruby, Haskell、Go、Rust、LuaJIT 等。&lt;/p>
&lt;p>FFI 的作用简单来说就是允许一种语言去调用另一种语言，有时候我们也会用 Binding 来表示类似的能力。&lt;/p>
&lt;p>在不同的语言中会有不同的实现，比如在 Go 中的 cgo , Python 中的 ctypes ， Haskell 中的 CAPI （之前还有一个 ccall）等。
我个人感觉 Haskell 中用 FFI 相比其他语言要更简单&amp;amp;方便的多，不过这不是本篇的重点就不展开了。&lt;/p>
&lt;p>在本文中，对于 Go 和 Rust 而言，它们的 FFI 需要与 C 语言对象进行通信，而这部分其实是由操作系统根据 API 中的调用约定来完成的。&lt;/p>
&lt;p>我们来进入正题。&lt;/p>
&lt;h1 id="准备-rust-示例程序">准备 Rust 示例程序&lt;/h1>
&lt;p>Rust 的安装和 Cargo 工具的基本使用，这里就不介绍了。大家可以去 Rust 的官网进行了解。&lt;/p>
&lt;h2 id="用-cargo-创建项目">用 Cargo 创建项目&lt;/h2>
&lt;p>我们先准备一个目录用来放本次示例的代码。（我创建的目录叫做 &lt;code>go-rust&lt;/code> ）&lt;/p>
&lt;p>然后使用 Rust 的 Cargo 工具创建一个名叫 &lt;code>rustdemo&lt;/code> 的项目，这里由于我增加了 &lt;code>--lib&lt;/code> 的选项，使用其内置的 library 模板。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ mkdir lib &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">cd&lt;/span> lib
➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ cargo new --lib rustdemo
Created library &lt;span class="sb">`&lt;/span>rustdemo&lt;span class="sb">`&lt;/span> package
➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ tree rustdemo
rustdemo
├── Cargo.toml
└── src
└── lib.rs
&lt;span class="m">1&lt;/span> directory, &lt;span class="m">2&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="准备-rust-代码">准备 Rust 代码&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="k">extern&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">crate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">libc&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="n">ffi&lt;/span>::&lt;span class="p">{&lt;/span>&lt;span class="n">CStr&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CString&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="cp">#[no_mangle]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">pub&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">extern&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">rustdemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>: &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">libc&lt;/span>::&lt;span class="n">c_char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">libc&lt;/span>::&lt;span class="n">c_char&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cstr_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">unsafe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CStr&lt;/span>::&lt;span class="n">from_ptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cstr_name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to_str&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">to_string&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Rust get Input: \&amp;#34;{}\&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str_name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">r_string&lt;/span>: &lt;span class="kp">&amp;amp;&lt;/span>&lt;span class="kt">str&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34; Rust say: Hello Go &amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str_name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r_string&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CString&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str_name&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">into_raw&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码比较简单，Rust 暴露出来的函数名叫做 &lt;code>rustdemo&lt;/code> ，接收一个外部的参数，并将其打印出来。之后从 Rust 这边再设置一个字符串。&lt;/p>
&lt;p>&lt;code>CString::new(str_name).unwrap().into_raw()&lt;/code> 被转换为原始指针，以便之后由 C 语言处理。&lt;/p>
&lt;h2 id="编译-rust-代码">编译 Rust 代码&lt;/h2>
&lt;p>我们需要修改下 &lt;code>Cargo.toml&lt;/code> 文件以便进行编译。注意，这里我们增加了 &lt;code>crate-type = [&amp;quot;cdylib&amp;quot;]&lt;/code> 和 &lt;code>libc&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">package&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;rustdemo&amp;#34;&lt;/span>
&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.1.0&amp;#34;&lt;/span>
&lt;span class="nx">edition&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;2021&amp;#34;&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">lib&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">crate&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">type&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;cdylib&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">libc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.2&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后进行编译&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ rustdemo git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ cargo build --release
Compiling rustdemo v0.1.0 &lt;span class="o">(&lt;/span>/home/tao/go/src/github.com/tao12345666333/go-rust/lib/rustdemo&lt;span class="o">)&lt;/span>
Finished release &lt;span class="o">[&lt;/span>optimized&lt;span class="o">]&lt;/span> target&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span> in 0.22s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看生成的文件，这是一个 &lt;code>.so&lt;/code> 文件（这是因为我在 Linux 环境下，你如果在其他系统环境下会不同)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ rustdemo git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ ls target/release/librustdemo.so
target/release/librustdemo.so
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="准备-go-代码">准备 Go 代码&lt;/h1>
&lt;p>Go 环境的安装之类的这里也不再赘述了，继续在我们的 go-rust 目录操作即可。&lt;/p>
&lt;h2 id="编写-maingo">编写 main.go&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="cm">/*
&lt;/span>&lt;span class="cm">#cgo LDFLAGS: -L./lib -lrustdemo
&lt;/span>&lt;span class="cm">#include &amp;lt;stdlib.h&amp;gt;
&lt;/span>&lt;span class="cm">#include &amp;#34;./lib/rustdemo.h&amp;#34;
&lt;/span>&lt;span class="cm">*/&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;C&amp;#34;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;unsafe&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">&amp;#34;Go say: Hello Rust&amp;#34;&lt;/span>
&lt;span class="nx">input&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">C&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">CString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">C&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">input&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">o&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">C&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">rustdemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">input&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">output&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">C&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GoString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">o&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">output&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里我们使用了 cgo ，在 &lt;code>import &amp;quot;C&amp;quot;&lt;/code> 之前的注释内容是一种特殊的语法，这里是正常的 C 代码，其中需要声明使用到的头文件之类的。&lt;/p>
&lt;p>下面的代码很简单，定义了一个字符串，传递给 rustdemo 函数，然后打印 C 处理后的字符串。&lt;/p>
&lt;p>同时，为了能够让 Go 程序能正常调用 Rust 函数，这里我们还需要声明其头文件，在 &lt;code>lib/rustdemo.h&lt;/code> 中写入如下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">rustdemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="编译代码">编译代码&lt;/h2>
&lt;p>在 Go 编译的时候，我们需要开启 CGO （默认都是开启的），同时需要链接到 Rust 构建出来的 &lt;code>rustdemo.so&lt;/code> 文件，所以我们将该文件和它的头文件放到 &lt;code>lib&lt;/code> 目录下。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ cp lib/rustdemo/target/release/librustdemo.so lib
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以完整的目录结构就是：&lt;/p>
&lt;pre>&lt;code>➜ go-rust git:(master) ✗ tree -L 2 .
.
├── go.mod
├── lib
│   ├── librustdemo.so
│   ├── rustdemo
│   └── rustdemo.h
└── main.go
2 directories, 5 files
&lt;/code>&lt;/pre>&lt;p>编译：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ go build -o go-rust -ldflags&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;-r ./lib&amp;#34;&lt;/span> main.go
➜ go-rust git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ ./go-rust
Rust get Input: &lt;span class="s2">&amp;#34;Go say: Hello Rust&amp;#34;&lt;/span>
Go say: Hello Rust Rust say: Hello Go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，第一行的输出是由 Go 传入了 Rust ， 第二行中则是从 Rust 再传回 Go 的了。符合我们的预期。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本篇介绍了如何使用 Go 与 Rust 进行结合，介绍了其前置关于 FFI 相关的知识，后续通过一个小的实践演示了其完整过程。
感兴趣的小伙伴可以自行实践下。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Go/" term="Go" label="Go"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Rust/" term="Rust" label="Rust"/></entry><entry><title type="text">云原生时代下的容器镜像安全（上）</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/"/><id>https://moelove.info/2021/11/23/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E4%B8%8A/</id><updated>2021-11-24T16:25:33+08:00</updated><published>2021-11-23T23:16:42+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 Kubernetes 作为云原生的基石，为我们带来了极大的便利性，越来越多的公司也都将 Kubernetes 应用到了生产环境中。然而，在享受其带来的……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>Kubernetes 作为云原生的基石，为我们带来了极大的便利性，越来越多的公司也都将 Kubernetes 应用到了生产环境中。然而，在享受其带来的便利性的同时，我们也需要关注其中的一些安全隐患。&lt;/p>
&lt;p>本篇，我将为你重点介绍&lt;strong>容器镜像安全&lt;/strong>相关的内容。&lt;/p>
&lt;p>通常情况下，我们提到&lt;strong>容器镜像安全&lt;/strong>，主要是指以下两个方面：&lt;/p>
&lt;ul>
&lt;li>镜像自身内容的安全；&lt;/li>
&lt;li>镜像分发过程的安全；&lt;/li>
&lt;/ul>
&lt;h2 id="镜像自身内容的安全">镜像自身内容的安全&lt;/h2>
&lt;p>要聊镜像自身内容的安全，那我们就需要知道镜像到底是什么，以及它其中的内容是什么。&lt;/p>
&lt;h3 id="镜像是什么">镜像是什么&lt;/h3>
&lt;p>我们以 &lt;code>debian&lt;/code>镜像为例，pull 最新的镜像，并将其保存为 tar 文件，之后进行解压：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ mkdir -p debian-image
➜ ~ docker pull debian
Using default tag: latest
latest: Pulling from library/debian
647acf3d48c2: Pull &lt;span class="nb">complete&lt;/span>
Digest: sha256:e8c184b56a94db0947a9d51ec68f42ef5584442f20547fa3bd8cbd00203b2e7a
Status: Downloaded newer image &lt;span class="k">for&lt;/span> debian:latest
docker.io/library/debian:latest
➜ ~ docker image save -o debian-image/debian.tar debian
➜ ~ ls debian-image
debian.tar
➜ ~ tar -C debian-image -xf debian-image/debian.tar
➜ ~ tree -I debian.tar debian-image
debian-image
├── 827e5611389abf13dad1057e92f163b771febc0bcdb19fa2d634a7eb0641e0cc.json
├── b331057b5d32f835ac4b051f6a08af6e9beedb99ec9aba5c029105abe360bbda
│ ├── json
│ ├── layer.tar
│ └── VERSION
├── manifest.json
└── repositories
&lt;span class="m">1&lt;/span> directory, &lt;span class="m">6&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;p>解压完成后，我们看到它是一堆 json 文件和 &lt;code>layer.tar&lt;/code>文件的组合，我们再次对其中的 &lt;code>layer.tar&lt;/code>进行解压：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ tar -C debian-image/b331057b5d32f835ac4b051f6a08af6e9beedb99ec9aba5c029105abe360bbda -xf debian-image/b331057b5d32f835ac4b051f6a08af6e9beedb99ec9aba5c029105abe360bbda/layer.tar
➜ ~ tree -I &lt;span class="s1">&amp;#39;layer.tar|json|VERSION&amp;#39;&lt;/span> -L &lt;span class="m">1&lt;/span> debian-image/b331057b5d32f835ac4b051f6a08af6e9beedb99ec9aba5c029105abe360bbda
debian-image/b331057b5d32f835ac4b051f6a08af6e9beedb99ec9aba5c029105abe360bbda
├── bin
├── boot
├── dev
├── etc
├── home
├── lib
├── lib64
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
&lt;span class="m">19&lt;/span> directories, &lt;span class="m">0&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;p>解压后的目录结构想必你已经很熟悉了，是的，这是 &lt;code>rootfs&lt;/code>的目录结构。&lt;/p>
&lt;p>如果我们使用的是自己构建的一些应用镜像的话，经过几次解压，你也会在其中找到应用程序相对应的文件。&lt;/p>
&lt;h3 id="镜像自身内容安全如何保证">镜像自身内容安全如何保证&lt;/h3>
&lt;p>前面我们已经看到了容器镜像就是 &lt;code>rootfs&lt;/code>和应用程序，以及一些配置文件的组合。所以要保证它自身内容的安全性，主要从以下几个方面来考虑：&lt;/p>
&lt;h4 id="rootfs安全">&lt;code>rootfs&lt;/code>安全&lt;/h4>
&lt;p>对应到我们的实际情况，&lt;code>rootfs&lt;/code>通常是由我们使用的基础（系统）镜像提供的，或者也可以认为是我们构建镜像时，&lt;code>Dockerfile&lt;/code>的 &lt;code>FROM&lt;/code>字段所配置的镜像提供的。&lt;/p>
&lt;p>在这个方面想要做到安全性就需要我们：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用可信来源的镜像，比如 Docker 官方维护的镜像；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对基础镜像持续的进行漏洞扫描和升级；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>也可以考虑使用 &lt;code>Distroless&lt;/code>镜像，这样也可以一定程度上免受攻击；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="应用程序">应用程序&lt;/h4>
&lt;p>应用程序其实是我们自己提供的，在这方面想要做到安全性，那么就需要我们：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>持续的进行软件的漏洞扫描；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对依赖及时的进行更新；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以考虑从 SDL（Security Development Lifecycle）过渡到 DevSecOps ；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="配置文件">配置文件&lt;/h4>
&lt;p>镜像中所包含的那些配置文件是由镜像构建工具所提供的，一般情况下，只要我们保证使用的镜像构建工具未被篡改或者留下什么漏洞，那么这里基本上不会有什么大的问题。&lt;/p>
&lt;p>综合来看，我们可以直接使用类似 &lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> 或者 &lt;a href="https://github.com/anchore/anchore-engine">Anchore Engine&lt;/a> 等镜像漏洞扫描工具来帮助我们保障镜像内容的安全。此外，一些镜像仓库，比如 Harbor 等都已经内置了镜像安全的扫描工具，或者可以使用 &lt;code>docker scan&lt;/code>命令进行镜像的安全扫描。&lt;/p>
&lt;h2 id="镜像分发安全">镜像分发安全&lt;/h2>
&lt;h3 id="镜像如何分发">镜像如何分发&lt;/h3>
&lt;p>我们首先来看看，容器镜像是怎么样从构建到部署到我们的 Kubernetes 环境中的。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/KnehEd4PD6H5YB3.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 1 ，容器镜像自创建到发布部署的简要过程示意图&lt;/strong>&lt;/p>
&lt;p>开发者在编写完代码后，推送代码到代码仓库。由此来触发 CI 进行构建，在此过程中会进行镜像的构建，以及将镜像推送至镜像仓库中。&lt;/p>
&lt;p>在 CD 的环节中，则会使用镜像仓库中的镜像，部署至目标 Kubernetes 集群中。&lt;/p>
&lt;p>那么在此过程中，攻击者如何进行攻击呢？&lt;/p>
&lt;h3 id="镜像分发中的安全问题">镜像分发中的安全问题&lt;/h3>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/ZjrvqNodKxU9AXY.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 2 ，镜像分发部署安全示例&lt;/strong>&lt;/p>
&lt;p>如图，在镜像分发部署的环节中其上游是镜像仓库，下游是 Kubernetes 集群。对于镜像仓库而言，即使是内网的自建环境，由于我们的观念已从基于边界的安全转变为零信任安全，所以，我们统一以公共仓库为例来讲解。&lt;/p>
&lt;p>攻击者可以通过一些手段进行劫持、替换成恶意的镜像，包括直接攻击镜像仓库等。&lt;/p>
&lt;p>要保证部署到 Kubernetes 集群中镜像的安全性来源以及完整性，其实是需要在两个主要的环节上进行：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>构建镜像时进行镜像的签名；&lt;/strong>&lt;/li>
&lt;li>&lt;strong>镜像分发部署时进行签名的校验；（下一篇内容继续）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们来分别看一下。&lt;/p>
&lt;h3 id="镜像的标签和摘要">镜像的标签和摘要&lt;/h3>
&lt;p>我们通常在使用容器镜像时有两种选择：&lt;/p>
&lt;ul>
&lt;li>标签，比如 &lt;code>alpine:3.14.3&lt;/code>&lt;/li>
&lt;li>摘要，比如 &lt;code>alpine@sha256:635f0aa53d99017b38d1a0aa5b2082f7812b03e3cdb299103fe77b5c8a07f1d2&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>大多数场景下，我们会直接使用标签，因为它的可读性更好。但是镜像内容可能会随着时间的推移而变化，因为我们可能会为不同内容的镜像使用相同的标签，最常见的就是 &lt;code>:latest&lt;/code>标签，每次新版本发布的时候，新版本的镜像都会继续沿用 &lt;code>:latest&lt;/code>标签，但其中的应用程序版本已经升级到了最新。&lt;/p>
&lt;p>使用摘要的主要弊端是它的可读性不好，但是，每个镜像的摘要都是唯一的，摘要是镜像内容的 SHA256 的哈希值。所以我们可以通过摘要来保证镜像的唯一性。&lt;/p>
&lt;p>通过以下示例可以直接看到标签和摘要信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ docker pull alpine:3.14.3
3.14.3: Pulling from library/alpine
Digest: sha256:635f0aa53d99017b38d1a0aa5b2082f7812b03e3cdb299103fe77b5c8a07f1d2
Status: Image is up to date for alpine:3.14.3
docker.io/library/alpine:3.14.3
➜ ~ docker image inspect alpine:3.14.3 | jq -r &amp;#39;.[] | {RepoTags: .RepoTags, RepoDigests: .RepoDigests}&amp;#39;
{
&amp;#34;RepoTags&amp;#34;: [
&amp;#34;alpine:3.14.3&amp;#34;
],
&amp;#34;RepoDigests&amp;#34;: [
&amp;#34;alpine@sha256:635f0aa53d99017b38d1a0aa5b2082f7812b03e3cdb299103fe77b5c8a07f1d2&amp;#34;
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么如何来保证镜像的正确性/安全性呢？这就是镜像签名解决的主要问题了。&lt;/p>
&lt;h3 id="镜像签名解决方案">镜像签名解决方案&lt;/h3>
&lt;p>数字签名是一种众所周知的方法，用于维护在网络上传输的任何数据的完整性。对于容器镜像签名，我们有几种比较通用的方案。&lt;/p>
&lt;h4 id="docker-content-trust-dct">Docker Content Trust (DCT)&lt;/h4>
&lt;p>在传输一般文件时，可能有过类似的经历，比如因为网络原因导致下载的文件不完整；或是遭遇中间人的攻击导致文件被篡改、替换等。&lt;/p>
&lt;p>镜像在分发过程中其实也可能会遇到类似的问题，这就是此处我们要讨论的重点，也就是 Docker Content Trust（DCT）主要解决的问题。&lt;/p>
&lt;p>Docker Content Trust 使用数字签名，并且允许客户端或运行时验证特定镜像标签的完整性和发布者。对于使用而言也就是 &lt;code>docker trust&lt;/code> 命令所提供的相关功能。注意：这需要 Docker CE 17.12 及以上版本。&lt;/p>
&lt;p>前面我们提到了，镜像记录可以有一些标签，格式如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以标签为例，DCT 会与标签的一部分相关联。每个镜像仓库都有一组密钥，镜像发布者使用这些密钥对镜像标签进行签名。（镜像发布者可以自行决定要签署哪些标签）镜像仓库可以同时包含多个带有已签名标签和未签名标签的镜像。&lt;/p>
&lt;p>这里需要说明下，如果镜像发布者先推送签名的 latest 镜像，再推送未签名的 latest 镜像，那么后一个镜像不会影响前一个镜像的内容（区别于上文中标签覆盖的地方）。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/m94jihT7XgCftod.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 4 ，DCT 镜像签名示例（图中简略了登录镜像仓库的认证过程）&lt;/strong>&lt;/p>
&lt;p>在生产中，我们可以启用 DCT 确保使用的镜像都已签名。如果启用了 DCT，那么只能对受信任的镜像（已签名并可验证的镜像）进行拉取、运行或构建。&lt;/p>
&lt;p>启用 DCT 有点像对镜像仓库应用“过滤器”，即，只能看到已签名的镜像标签，看不到未签名的镜像标签。如果客户端没有启用 DCT ，那么它可以看到所有的镜像。&lt;/p>
&lt;p>&lt;strong>这里我们来快速的看一下 DCT 的工作过程&lt;/strong>&lt;/p>
&lt;p>它对镜像标签的信任是通过使用签名密钥来管理的。在我们首次开启 DCT 并使用的时候会创建密钥集。一个密钥集由以下几类密钥组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个离线密钥 offline key ，它是镜像标签 DCT 的根 （&lt;strong>丢失根密钥很难恢复&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对标签进行签名的存储库或标记密钥 tag key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务器管理的密钥，例如时间戳密钥&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/r6TeNFBLQOu9Unm.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 5 ， 镜像签名密钥示例&lt;/strong>&lt;/p>
&lt;p>刚从我们提到客户端使用 DCT 也就是我们的 &lt;code>docker trust&lt;/code>命令，它是建立在 Notary v1 上的。默认情况下，Docker 客户端中禁用 DCT 。要启用需要设置 &lt;code>DOCKER_CONTENT_TRUST=1&lt;/code> 环境变量 。&lt;/p>
&lt;p>效果如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ ~ DOCKER_CONTENT_TRUST=1 docker pull alpine:3.12
Pull (1 of 1): alpine:3.12@sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a
docker.io/library/alpine@sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a: Pulling from library/alpine
188c0c94c7c5: Already exists
Digest: sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a
Status: Downloaded newer image for alpine@sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a
Tagging alpine@sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a as alpine:3.12
docker.io/library/alpine:3.12
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="notary-v1">Notary v1&lt;/h4>
&lt;p>前面我们提到 DCT 是基于 Notary v1 实现的，不过这不是我们本篇的重点，所以这里仅对 Notary v1 做个简单的介绍。Notary 项目地址： &lt;a href="https://github.com/notaryproject/notary">https://github.com/notaryproject/notary&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/rLne1joJQNXhRkp.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 6 ，Notary 客户端、服务器和签名相关的交互流程&lt;/strong>&lt;/p>
&lt;p>过程1 - 身份认证，任何没有令牌的连接将被重定向到授权服务器（Docker Registry v2 身份认证）；&lt;/p>
&lt;p>过程2 - 客户端将通过 HTTPS 上的身份验证登录到授权服务器，获取令牌；&lt;/p>
&lt;p>过程3 - 当客户端上传新的元数据文件时，服务器会根据以前的版本检查它们是否存在冲突，并验证上传的元数据的签名、校验和和有效性；&lt;/p>
&lt;p>过程4 - 一旦所有上传的元数据都经过验证，服务器会生成时间戳（可能还有快照），然后将它们发送给 sign 进行签名；&lt;/p>
&lt;p>过程5 - sign 从其数据库中检索加密私钥，解密密钥，并使用它们进行签名，并发送回服务器；&lt;/p>
&lt;p>过程6 - 服务器将客户端上传和服务器生成的元数据存储在 TUF 库中。生成的时间戳和快照元数据证明客户端上传的元数据是该可信集合的最新版本。之后，服务器会通知客户端--上传成功；&lt;/p>
&lt;p>过程7 - 客户端现在可以立即从服务器下载最新的元数据了。在时间戳过期的情况下，服务器将遍历整个序列，生成新的时间戳，请求 sign 签名，将新签名的时间戳存储在数据库中。然后，它将这个新的时间戳连同其他存储的元数据一起发送给请求客户端；&lt;/p>
&lt;p>这个项目由于是一个安全项目，虽然用途很大，但整体并不活跃。现在正在进行 v2 版本的开发，有兴趣的小伙伴欢迎加入。&lt;/p>
&lt;h4 id="sigstore-和-cosign">sigstore 和 Cosign&lt;/h4>
&lt;p>这里介绍另一个来自 Linux 基金会的项目，叫做 sigstore 它主要是为了提供一些标准的库/工具，便于更好的进行签名和校验。当然，目前 sigstore 已经汇聚了包括 Cosign，Fulcio 和 Rekor 等开源项目，涉及到镜像镜像签名校验和供应链等方面。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/24/RIQ7Vvbd2aJ4BAh.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 7 ，sigstore 简介&lt;/strong>&lt;/p>
&lt;p>Cosign 是 sigstore 的工具之一，用于 OCI registry 中创建、存储和验证容器镜像签名。Cosign v1.0 已于今年下半年发布，是否能稳定用于生产环境，还有待考验。 截止目前，Cosign 已经发布了 v1.3.1 版本，详细变更请参考其 ReleaseNote： &lt;a href="https://github.com/sigstore/cosign/releases/tag/v1.3.1">https://github.com/sigstore/cosign/releases/tag/v1.3.1&lt;/a>&lt;/p>
&lt;p>我们这里看下它如何进行镜像的签名&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">➜ cosign cosign generate-key-pair
Enter password for private key:
Enter password for private key again:
Private key written to cosign.key
Public key written to cosign.pub
➜ cosign cosign sign --key cosign.key ghcr.io/tao12345666333/argo-cd-demo/argo-cd-demo:fa5714f419b3d11dee6ac795e38356e9c3c439cb
Enter password for private key: %
➜ cosign cosign verify --key cosign.pub ghcr.io/tao12345666333/argo-cd-demo/argo-cd-demo:fa5714f419b3d11dee6ac795e38356e9c3c439cb
Verification for ghcr.io/tao12345666333/argo-cd-demo/argo-cd-demo:fa5714f419b3d11dee6ac795e38356e9c3c439cb --
The following checks were performed on each of these signatures:
- The cosign claims were validated
- The signatures were verified against the specified public key
- Any certificates were verified against the Fulcio roots.
[{&amp;#34;critical&amp;#34;:{&amp;#34;identity&amp;#34;:{&amp;#34;docker-reference&amp;#34;:&amp;#34;ghcr.io/tao12345666333/argo-cd-demo/argo-cd-demo&amp;#34;},&amp;#34;image&amp;#34;:{&amp;#34;docker-manifest-digest&amp;#34;:&amp;#34;sha256:768845efa2a32bc5c5d83a6f7ec668b98f5db46585dd1918afc9695a9e653d2d&amp;#34;},&amp;#34;type&amp;#34;:&amp;#34;cosign container image signature&amp;#34;},&amp;#34;optional&amp;#34;:null}]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来还是比较简单的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上就是关于镜像自身内容安全，以及镜像分发安全中的镜像签名校验部分的内容。&lt;/p>
&lt;p>下一篇我将为大家介绍如何在镜像分发及部署时进行签名的校验，以及如何保护 Kubernetes 集群免受未签名或不可信来源镜像的攻击，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Shell 脚本避坑指南（一）</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/"/><id>https://moelove.info/2021/11/21/Shell-%E8%84%9A%E6%9C%AC%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%E4%B8%80/</id><updated>2021-11-22T22:55:22+08:00</updated><published>2021-11-21T22:41:02+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 提到 Shell 大家想必不会太陌生，我们通常认为 Shell 是我们和系统交互的接口，执行命令返回输出，比如 bash 、zsh 等。偶尔也会……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>提到 Shell 大家想必不会太陌生，我们通常认为 Shell 是我们和系统交互的接口，执行命令返回输出，比如 bash 、zsh 等。偶尔也会有人把 Shell 和 Terminal（终端）混淆，但这和本文关系不大，暂且略过。&lt;/p>
&lt;p>作为一名程序员，我们可能天天都会用到 Shell ，偶尔也会把一些命令组织到一起，写个 Shell 脚本之类的，以便提升我们的工作效率。&lt;/p>
&lt;p>然而在看似简单的 Shell 脚本中，可能隐藏着很深的坑。这里我先给出两段简单且相似的 Shell 脚本，大家不妨来看看这两段代码的输出是什么：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e -u
i=0
while [ $i -lt 6 ]; do
echo $i
((i++))
done
&lt;/code>&lt;/pre>&lt;p>&lt;strong>答案是只会输出一个 0 。&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
set -e -u
let i=0
while [ $i -lt 6 ]; do
echo $i
((i++))
done
&lt;/code>&lt;/pre>&lt;p>&lt;strong>答案是没有任何输出，直接退出。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>如果你能解释清楚上面两段代码输出结果的话， 那大概你可以跳过这篇文章后续的内容了。&lt;/strong>&lt;/p>
&lt;p>我先来分解下这段代码中涉及到的主要知识点。&lt;/p>
&lt;h2 id="变量声明">变量声明&lt;/h2>
&lt;p>变量声明有很多种办法， 但是其行为却各有不同。&lt;/p>
&lt;p>我们必须先有个基础认识： &lt;strong>Bash 没有类型系统，所有变量都是 string 。&lt;/strong> 基于这个原因，如果是让变量进行算术运算时，不能像在其他的编程语言中那样直接写算术运算符。这会让 bash 解释为对 string 的操作，而不是对数字的操作。&lt;/p>
&lt;h3 id="直接声明">直接声明&lt;/h3>
&lt;pre>&lt;code>(MoeLove)➜ ~ foo=1+1
(MoeLove)➜ ~ echo $foo
1+1
&lt;/code>&lt;/pre>&lt;p>直接声明最简单，但正如前面提到的，直接声明会默认当作 string 进行处理，不能在声明时进行算术运算。&lt;/p>
&lt;h3 id="declare-声明">declare 声明&lt;/h3>
&lt;pre>&lt;code>(MoeLove)➜ ~ declare foo=1+1
(MoeLove)➜ ~ echo $foo
1+1
&lt;/code>&lt;/pre>&lt;p>除去直接声明变量外，比较常用的方法是用 &lt;code>declare&lt;/code> 来声明变量，但默认情况下，其声明的变量都是按 string 处理的，无法进行正常的算术运算。&lt;/p>
&lt;p>&lt;strong>declare 整数属性&lt;/strong>&lt;/p>
&lt;p>declare 在声明变量的时候，可以通过 &lt;code>-i&lt;/code> 参数增加整数属性，当变量被赋值时，将进行算术运算。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ declare -i bar=1+1
(MoeLove)➜ ~ echo $bar
2
&lt;/code>&lt;/pre>&lt;p>但要注意的是，增加整数属性后，如果将字符串赋值给它，则会出现解析失败的情况，即：将值设置为 0：&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ bar=test
(MoeLove)➜ ~ echo $bar
0
&lt;/code>&lt;/pre>&lt;h3 id="let-声明">let 声明&lt;/h3>
&lt;p>另一种办法，我们可以通过 &lt;code>let&lt;/code> 命令进行变量的声明，这种方式允许在声明时进行算术运算，同时也支持将其他值赋值给此变量。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ let baz=1+1
(MoeLove)➜ ~ echo $baz
2
(MoeLove)➜ ~ baz=moelove.info
(MoeLove)➜ ~ echo $baz
moelove.info
&lt;/code>&lt;/pre>&lt;h2 id="while-循环">while 循环&lt;/h2>
&lt;pre>&lt;code>while list-1; do list-2; done
&lt;/code>&lt;/pre>&lt;p>Bash 中 while 语法就是这样，在 while 关键字后是一个序列（list），可以是一个或多个表达式/语句，&lt;/p>
&lt;p>需要注意的是，当 list-1 返回值为 0 时， list-2 总是会被执行，并且 while 语句最后的返回值是 list-2 最后一次执行的返回值，或者，如果没执行任何语句的话，则返回 0 。&lt;/p>
&lt;h2 id="bash-中的算数计算">bash 中的算数计算&lt;/h2>
&lt;p>这部分的内容大家想必常会用到。我来介绍几种常用的方法：&lt;/p>
&lt;h3 id="算术扩展">算术扩展&lt;/h3>
&lt;p>Bash 中的扩展一共有 7 种，算术扩展只是其中之一。具体而言就是通过类似 &lt;code>$((expression))&lt;/code> 这样的形式，来计算表达式的值。例如：&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ echo $((3+7))
10
(MoeLove)➜ ~ x=3;y=7
(MoeLove)➜ ~ echo $((x+y))
10
&lt;/code>&lt;/pre>&lt;h3 id="expr-命令">expr 命令&lt;/h3>
&lt;p>expr 是 coreutils 软件包提供的一个命令，可对表达式进行计算，或者比较大小之类的。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ x=3;y=7
(MoeLove)➜ ~ expr $x + $y
10
## 比较大小
(MoeLove)➜ ~ expr 2 \&amp;lt; 3
1
(MoeLove)➜ ~ expr 2 \&amp;lt; 1
0
&lt;/code>&lt;/pre>&lt;h3 id="bc-命令">bc 命令&lt;/h3>
&lt;p>按定义来说，bc 其实是一种支持任意精度和可交互执行的计算语言。它比上述提到的 &lt;code>expr&lt;/code> 要强大的多，尤其是它还支持浮点数运算。例如：&lt;/p>
&lt;h4 id="一般浮点数计算">一般浮点数计算&lt;/h4>
&lt;pre>&lt;code>(MoeLove)➜ ~ echo &amp;quot;scale=2;7/3&amp;quot;|bc
2.33
(MoeLove)➜ ~ echo &amp;quot;7/3&amp;quot;|bc
2
&lt;/code>&lt;/pre>&lt;p>注意： &lt;code>scale&lt;/code> 需要手动指定，它表示小数点后的位数。默认情况下 &lt;code>scale&lt;/code> 的值为 0 。&lt;/p>
&lt;h4 id="内置函数">内置函数&lt;/h4>
&lt;p>bc 还有一些内置函数，可以方便我们进行一些快速的计算，比如可以利用 &lt;code>sqrt()&lt;/code> 快速的计算平方根。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ echo &amp;quot;scale=2;sqrt(9)&amp;quot; |bc
3.00
(MoeLove)➜ ~ echo &amp;quot;scale=2;sqrt(6)&amp;quot; |bc
2.44
&lt;/code>&lt;/pre>&lt;h4 id="脚本">脚本&lt;/h4>
&lt;p>此外， bc 还支持一种简单的语法，可以支持声明变量，编写循环和判断语句等。例如：我们可以打印20 以内可以被 3 整除的数：&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ echo &amp;quot;for(i=1; i&amp;lt;=20; i++) {if (i % 3 == 0) i;}&amp;quot; |bc
3
6
9
12
15
18
&lt;/code>&lt;/pre>&lt;h2 id="bash-的调试">bash 的调试&lt;/h2>
&lt;p>其实 bash shell 中并没有内置调试器。很多情况下，都是采用重复运行加打印来进行调试。但这种方式不够高效。&lt;/p>
&lt;p>这里介绍一种比较直观的，也比较方便的用来调试 shell 代码的办法。以下是一段示例 shell 代码。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ cat compare.sh
#!/bin/bash
read -p &amp;quot;请输入任意数字: &amp;quot; val
real_val=66
if [ &amp;quot;$val&amp;quot; -gt &amp;quot;$real_val&amp;quot; ]
then
echo &amp;quot;输入值大于等于预设值&amp;quot;
else
echo &amp;quot;输入值比预设值小&amp;quot;
fi
&lt;/code>&lt;/pre>&lt;p>为其增加执行权限，或者使用 bash 执行：&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash compare.sh
请输入任意数字: 33
输入值比预设值小
&lt;/code>&lt;/pre>&lt;h3 id="详细模式">详细模式&lt;/h3>
&lt;p>通过增加 &lt;code>-v&lt;/code> 选项，即可开启详细模式，用于查看所执行的命令。当然，我们也可以通过在 shebang 上直接增加 &lt;code>-v&lt;/code> 选项， 或者增加 &lt;code>set -v&lt;/code> 来开启此模式&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash -v compare.sh
which () { ( alias;
eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot &amp;quot;$@&amp;quot;
}
#!/bin/bash
read -p &amp;quot;请输入任意数字: &amp;quot; val
请输入任意数字: 33
real_val=66
if [ &amp;quot;$val&amp;quot; -gt &amp;quot;$real_val&amp;quot; ]
then
echo &amp;quot;输入值大于等于预设值&amp;quot;
else
echo &amp;quot;输入值比预设值小&amp;quot;
fi
输入值比预设值小
&lt;/code>&lt;/pre>&lt;h3 id="使用-xtrace-模式">使用 xtrace 模式&lt;/h3>
&lt;p>我们可以通过增加 &lt;code>-x&lt;/code> 参数来进入 xtrace 模式，用于调试执行阶段的变量值。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash -x compare.sh
+ read -p '请输入任意数字: ' val
请输入任意数字: 33
+ real_val=66
+ '[' 33 -gt 66 ']'
+ echo 输入值比预设值小
输入值比预设值小
&lt;/code>&lt;/pre>&lt;h3 id="识别未定义变量">识别未定义变量&lt;/h3>
&lt;p>以下示例中，我故意写错一个字符。执行脚本后，你会发现没有任何报错，但结果并不是我们预期的。这类可能是手误居多，所以我们需要检查是否存在未绑定的变量。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ cat add.sh
#!/bin/bash
five=5
ten=10
total=$((five+tne))
echo $total
(MoeLove)➜ ~ bash add.sh
5
(MoeLove)➜ ~ bash -u add.sh
add.sh: line 4: tne: unbound variable
&lt;/code>&lt;/pre>&lt;p>增加 &lt;code>-u&lt;/code> 选项， 可以检查变量是否未定义/绑定。&lt;/p>
&lt;h3 id="组合使用">组合使用&lt;/h3>
&lt;p>以上是几种比较常见的使用方式，当然，也可以把它进行组合使用。比如上面的变量未定义的问题， 组合使用 &lt;code>-vu&lt;/code> 就可以直接看到具体出现问题的代码是什么内容了。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash -vu add.sh
which () { ( alias;
eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot &amp;quot;$@&amp;quot;
}
#!/bin/bash
five=5
ten=10
total=$((five+tne))
add.sh: line 4: tne: unbound variable
&lt;/code>&lt;/pre>&lt;h3 id="将调试信息输出到指定文件">将调试信息输出到指定文件&lt;/h3>
&lt;p>这里我打开了一个特定 FD 上的 &lt;code>debug.log&lt;/code> 文件，注意这个 FD 需要与 &lt;code>BASH_XTRACEFD&lt;/code> 配置的一致，另外我修改了 &lt;code>PS4&lt;/code> 的变量内容，它的默认值是 &lt;code>+&lt;/code> 看起来会比较乱，而且没有有效信息，我通过设置 &lt;code>PS4='$LINENO: ' &lt;/code> 让它显示行号。&lt;/p>
&lt;p>然后在需要调试的位置设置 &lt;code>set -x&lt;/code> ，在结束的位置设置 &lt;code>set +x&lt;/code> ，这样调试日志中就只会记录我需要调试部分的日志了。&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ cat compare.sh
#!/bin/bash
exec 6&amp;gt; debug.log
PS4='$LINENO: '
BASH_XTRACEFD=&amp;quot;6&amp;quot;
read -p &amp;quot;请输入任意数字: &amp;quot; val
real_val=66
set -x
if [ &amp;quot;$val&amp;quot; -gt &amp;quot;$real_val&amp;quot; ]
then
echo &amp;quot;输入值大于等于预设值&amp;quot;
else
echo &amp;quot;输入值比预设值小&amp;quot;
fi
set +x
echo &amp;quot;End&amp;quot;
(MoeLove)➜ ~ bash compare.sh
请输入任意数字: 88
输入值大于等于预设值
End
(MoeLove)➜ ~ cat debug.log
8: '[' 88 -gt 66 ']'
10: echo $'\350\276\223\345\205\245\345\200\274\345\244\247\344\272\216\347\255\211\344\272\216\351\242\204\350\256\276\345\200\274'
14: set +x
&lt;/code>&lt;/pre>&lt;p>这里介绍了&lt;strong>通过 set 设置选项&lt;/strong> 的方式较简单，其他的比如使用 trap 加调试的方式也推荐大家去尝试下，这里就不展开了。&lt;/p>
&lt;h2 id="回到开始的问题">回到开始的问题&lt;/h2>
&lt;p>那我们用刚才介绍的调试方法来执行下开头的两个脚本，并且进行问题的解答。&lt;/p>
&lt;h3 id="第一个">第一个&lt;/h3>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash -xv demo1.sh
#!/bin/bash
set -e -u
+ set -e -u
i=0
+ i=0
while [ $i -lt 6 ]; do
echo $i
((i++))
done
+ '[' 0 -lt 6 ']'
+ echo 0
0
+ (( i++ ))
&lt;/code>&lt;/pre>&lt;p>从上述调试结果可以看到，这个脚本在输出 &lt;code>0&lt;/code> 然后执行完 &lt;code>((i++))&lt;/code> 后退出。为什么呢？ 主要是由于在脚本顶部增加的 &lt;code>set -e&lt;/code> 选项。&lt;/p>
&lt;p>&lt;strong>该选项在遇到首个非 0 值的时候会直接退出。&lt;/strong> 我们来解释下：&lt;/p>
&lt;pre>&lt;code>(MoeLove)➜ ~ i=0
(MoeLove)➜ ~ ((i++))
(MoeLove)➜ ~ echo $?
1
&lt;/code>&lt;/pre>&lt;p>可以看到，执行 &lt;code>((i++))&lt;/code> 后，返回值其实是 1 ，所以触发了 &lt;code>set -e&lt;/code> 的退出条件，脚本便退出了。&lt;/p>
&lt;h3 id="第二个">第二个&lt;/h3>
&lt;pre>&lt;code>(MoeLove)➜ ~ bash -xv demo2.sh
#!/bin/bash
set -e -u
+ set -e -u
let i=0
+ let i=0
&lt;/code>&lt;/pre>&lt;p>第二个和第一个的最主要区别在于变量的赋值上， &lt;code>let i=0&lt;/code> 的返回值是 1 ，所以也就会触发 &lt;code>set -e&lt;/code> 的退出条件了。我们尝试将第二个脚本修改下，再次执行：&lt;/p>
&lt;pre>&lt;code>[tao@moelove ~]$ cat demo2-1.sh
#!/bin/bash
set -e -u
let i=1
while [ $i -lt 6 ]; do
echo $i
((i++))
done
[tao@moelove ~]$ bash demo2-1.sh
1
2
3
4
5
&lt;/code>&lt;/pre>&lt;p>将 &lt;code>let i=0&lt;/code> 修改成 &lt;code>let i=1&lt;/code> 即可按预期执行成功。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇中，我们主要聊了 bash shell 中的变量声明，循环，数学运算以及 bash shell 的调试。是否对你有所启发呢？ 欢迎留言进行交流。&lt;/p>
&lt;ul>
&lt;li>注：本文仅讨论 Bash Shell&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Shell/" term="Shell" label="Shell"/></entry><entry><title type="text">一篇搞懂容器技术的基石： cgroup</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/"/><id>https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/</id><updated>2021-11-18T12:35:51+08:00</updated><published>2021-11-17T23:16:42+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。 对于容……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>目前我们所提到的容器技术、虚拟化技术（不论何种抽象层次下的虚拟化技术）都能做到资源层面上的隔离和限制。&lt;/p>
&lt;p>对于容器技术而言，它实现资源层面上的限制和隔离，依赖于 Linux 内核所提供的 cgroup 和 namespace 技术。&lt;/p>
&lt;p>我们先对这两项技术的作用做个概括：&lt;/p>
&lt;ul>
&lt;li>cgroup 的主要作用：管理资源的分配、限制；&lt;/li>
&lt;li>namespace 的主要作用：封装抽象，限制，隔离，使命名空间内的进程看起来拥有他们自己的全局资源；&lt;/li>
&lt;/ul>
&lt;p>本篇，我们重点来聊 cgroup 。&lt;/p>
&lt;h2 id="为什么要关注-cgroup--namespace">为什么要关注 cgroup &amp;amp; namespace&lt;/h2>
&lt;h3 id="云原生容器技术的井喷式增长">云原生/容器技术的井喷式增长&lt;/h3>
&lt;p>自 1979年，&lt;strong>Unix 版本7&lt;/strong> 在开发过程中引入 &lt;strong>Chroot Jail&lt;/strong> 以及 &lt;strong>Chroot&lt;/strong> 系统调用开始，直到 2013 年开源出的 Docker，2014 年开源出来的 Kubernetes，直到现在的云原生生态的火热。 容器技术已经逐步成为主流的基础技术之一。&lt;/p>
&lt;p>在越来越多的公司、个人选择了云服务/容器技术后，资源的分配和隔离，以及安全性变成了人们关注及讨论的热点话题。&lt;/p>
&lt;p>&lt;strong>其实容器技术使用起来并不难，但要真正把它用好，大规模的在生产环境中使用， 那我们还是需要掌握其核心的。&lt;/strong>&lt;/p>
&lt;p>以下是容器技术&amp;amp;云原生生态的大致发展历程：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/tnwBPg6JofNKh5F.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 1 ，容器技术发展历程&lt;/strong>&lt;/p>
&lt;p>从图中，我们可以看到容器技术、云原生生态的发展轨迹。容器技术其实很早就出现了，但为何在 Docker 出现后才开始有了较为显著的发展？早期的 chroot 、 Linux VServer 又有哪些问题呢？&lt;/p>
&lt;h3 id="chroot-带来的安全性问题">Chroot 带来的安全性问题&lt;/h3>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/7CfsBmyolDGPJZL.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 2 ，chroot 示例&lt;/strong>&lt;/p>
&lt;p>Chroot 可以将进程及其子进程与操作系统的其余部分隔离开来。但是，&lt;strong>对于 root process&lt;/strong> ，却&lt;strong>可以任意退出 chroot&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;log&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;os&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;syscall&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">getWd&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">path&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Getwd&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">RealRoot&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">RealRoot&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[ Error ] - /: %v\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">path&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getWd&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chroot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[ Error ] - chroot: %v\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">getWd&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">RealRoot&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chdir&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[ Error ] - chdir(): %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">getWd&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Chroot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;[ Error ] - chroot back: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">getWd&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别以普通用户和 sudo 的方式运行：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ chroot go run main.go
2021/11/18 00:46:21 /tmp/chroot
2021/11/18 00:46:21 &lt;span class="o">[&lt;/span> Error &lt;span class="o">]&lt;/span> - chroot: operation not permitted
&lt;span class="nb">exit&lt;/span> status &lt;span class="m">1&lt;/span>
➜ chroot sudo go run main.go
2021/11/18 00:46:25 /tmp/chroot
2021/11/18 00:46:25 /
2021/11/18 00:46:25 &lt;span class="o">(&lt;/span>unreachable&lt;span class="o">)&lt;/span>/
2021/11/18 00:46:25 /
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到如果是使用 &lt;code>sudo&lt;/code>来运行的时候，程序在当前目录和系统原本的根目录下进行了切换。而普通用户则无权限操作。&lt;/p>
&lt;h3 id="linux-vserver-的安全漏洞">Linux VServer 的安全漏洞&lt;/h3>
&lt;p>Linux-VServer 是一种基于 &lt;em>Security Contexts&lt;/em> 的软分区技术，可以做到虚拟服务器隔离，共享相同的硬件资源。主要问题是 VServer 应用程序针对 &amp;quot;chroot-again&amp;quot; 类型的攻击没有很好的进行安全保护，攻击者可以利用这个漏洞脱离限制环境，访问限制目录之外的任意文件。（自 2004年开始，国家信息安全漏洞库就登出了相关漏洞问题）&lt;/p>
&lt;h3 id="现代化容器技术带来的优势">现代化容器技术带来的优势&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>轻量级，基于 Linux 内核所提供的 cgroup 和 namespace 能力，创建容器的成本很低；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一定的隔离性；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准化，通过使用容器镜像的方式进行应用程序的打包和分发，可以屏蔽掉因为环境不一致带来的诸多问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DevOps 支撑（可以在不同环境，如开发、测试和生产等环境之间轻松迁移应用，同时还可保留应用的全部功能）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为基础架构增添防护，提升可靠性、可扩展性和信赖度；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DevOps/GitOps 支撑 （可以做到快速有效地持续性发布，管理版本及配置）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>团队成员间可以有效简化、加速和编排应用的开发与部署；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在了解了为什么要关注 cgroup 和 namespace 等技术之后，那我们就进入到本篇的重点吧，来一起学习下 cgroup 。&lt;/p>
&lt;h2 id="什么是-cgroup">什么是 cgroup&lt;/h2>
&lt;p>cgroup 是 Linux 内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。它是由 Google 的两位工程师进行开发的，自 2018 年 1 月正式发布的 Linux 内核 v2.6.24 开始提供此能力。&lt;/p>
&lt;p>cgroup 到目前为止，有两个大版本， cgroup v1 和 v2 。以下内容以 cgroup v2 版本为主，涉及两个版本差别的地方会在下文详细介绍。&lt;/p>
&lt;p>cgroup 主要限制的资源是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CPU&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络&lt;/p>
&lt;/li>
&lt;li>
&lt;p>磁盘 I/O&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>当我们将可用系统资源按特定百分比分配给 cgroup 时，剩余的资源可供系统上的其他 cgroup 或其他进程使用。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/1KqfLoNisJkQgtd.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 4 ，cgroup 资源分配及剩余可用资源示例&lt;/strong>&lt;/p>
&lt;h3 id="cgroup-的组成">cgroup 的组成&lt;/h3>
&lt;p>cgroup 代表“控制组”，并且不会使用大写。cgroup 是一种分层组织进程的机制， 沿层次结构以受控的方式分配系统资源。我们通常使用单数形式用于指定整个特征，也用作限定符如 “cgroup controller” 。&lt;/p>
&lt;p>cgroup 主要有两个组成部分：&lt;/p>
&lt;ul>
&lt;li>core - 负责分层组织过程；&lt;/li>
&lt;li>controller - 通常负责沿层次结构分配特定类型的系统资源。每个 cgroup 都有一个 &lt;code>cgroup.controllers&lt;/code> 文件，其中列出了所有可供 cgroup 启用的控制器。当在 &lt;code>cgroup.subtree_control&lt;/code> 中指定多个控制器时，要么全部成功，要么全部失败。在同一个控制器上指定多项操作，那么只有最后一个生效。每个 cgroup 的控制器销毁是异步的，在引用时同样也有着延迟引用的问题；&lt;/li>
&lt;/ul>
&lt;p>所有 cgroup 核心接口文件都以 &lt;code>cgroup&lt;/code> 为前缀。每个控制器的接口文件都以控制器名称和一个点为前缀。控制器的名称由小写字母和“&lt;em>”组成，但永远不会以“&lt;/em>”开头。&lt;/p>
&lt;h3 id="cgroup-的核心文件">cgroup 的核心文件&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>cgroup.type - （单值）存在于非根 cgroup 上的可读写文件。通过将“threaded”写入该文件，可以将 cgroup 转换为线程 cgroup，可选择 4 种取值，如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>domain - 一个正常的有效域 cgroup&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>domain threaded - 线程子树根的线程域 cgroup&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>domain invalid - 无效的 cgroup&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="4">
&lt;li>threaded - 线程 cgroup，线程子树&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cgroup.procs - （换行分隔）所有 cgroup 都有的可读写文件。每行列出属于 cgroup 的进程的 PID。PID 不是有序的，如果进程移动到另一个 cgroup ，相同的 PID 可能会出现不止一次；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.controllers - （空格分隔）所有 cgroup 都有的只读文件。显示 cgroup 可用的所有控制器；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.subtree_control - （空格分隔）所有 cgroup 都有的可读写文件，初始为空。如果一个控制器在列表中出现不止一次，最后一个有效。当指定多个启用和禁用操作时，要么全部成功，要么全部失败。&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>以“+”为前缀的控制器名称表示启用控制器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>以“-”为前缀的控制器名称表示禁用控制器&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cgroup.events - 存在于非根 cgroup 上的只读文件。&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>populated - cgroup 及其子节点中包含活动进程，值为1；无活动进程，值为0.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>frozen - cgroup 是否被冻结，冻结值为1；未冻结值为0.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cgroup.threads - （换行分隔）所有 cgroup 都有的可读写文件。每行列出属于 cgroup 的线程的 TID。TID 不是有序的，如果线程移动到另一个 cgroup ，相同的 TID 可能会出现不止一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.max.descendants - （单值）可读写文件。最大允许的 cgroup 数量子节点数量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.max.depth - （单值）可读写文件。低于当前节点最大允许的树深度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.stat - 只读文件。&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>nr_descendants - 可见后代的 cgroup 数量。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>nr_dying_descendants - 被用户删除即将被系统销毁的 cgroup 数量。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cgroup.freeze - （单值）存在于非根 cgroup 上的可读写文件。默认值为0。当值为1时，会冻结 cgroup 及其所有子节点 cgroup，会将相关的进程关停并且不再运行。冻结 cgroup 需要一定的时间，当动作完成后， cgroup.events 控制文件中的 “frozen” 值会更新为“1”，并发出相应的通知。cgroup 的冻结状态不会影响任何 cgroup 树操作（删除、创建等）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cgroup.kill - （单值）存在于非根 cgroup 上的可读写文件。唯一允许值为1，当值为1时，会将 cgroup 及其所有子节点中的 cgroup 杀死（进程会被 SIGKILL 杀掉）。一般用于将一个 cgroup 树杀掉，防止叶子节点迁移；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="cgroup-的归属和迁移">cgroup 的归属和迁移&lt;/h3>
&lt;p>系统中的每个进程都属于一个 cgroup，一个进程的所有线程都属于同一个 cgroup。一个进程可以从一个 cgroup 迁移到另一个 cgroup 。进程的迁移不会影响现有的后代进程所属的 cgroup。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/wHkb1QLV6KjMd3B.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 5 ，进程及其子进程的 cgroup 分配；跨 cgroup 迁移示例&lt;/strong>&lt;/p>
&lt;p>跨 cgroup 迁移进程是一项代价昂贵的操作并且有状态的资源限制（例如，内存）不会动态的应用于迁移。因此，经常跨 cgroup 迁移进程只是作为一种手段。不鼓励直接应用不同的资源限制。&lt;/p>
&lt;h4 id="如何实现跨-cgroup-迁移">如何实现跨 cgroup 迁移&lt;/h4>
&lt;p>每个cgroup都有一个可读写的接口文件 “cgroup.procs” 。每行一个 PID 记录 cgroup 限制管理的所有进程。一个进程可以通过将其 PID 写入另一 cgroup 的 “cgroup.procs” 文件来实现迁移。&lt;/p>
&lt;p>但是这种方式，只能迁移一个进程在单个 write(2) 上的调用（如果一个进程有多个线程，则会同时迁移所有线程，但也要参考线程子树，是否有将进程的线程放入不同的 cgroup 的记录）。&lt;/p>
&lt;p>当一个进程 fork 出一个子进程时，该进程就诞生在其父亲进程所属的 cgroup 中。&lt;/p>
&lt;p>一个没有任何子进程或活动进程的 cgroup 是可以通过删除目录进行销毁的（即使存在关联的僵尸进程，也被认为是可以被删除的）。&lt;/p>
&lt;h2 id="什么是-cgroups">什么是 cgroups&lt;/h2>
&lt;p>当明确提到多个单独的控制组时，才使用复数形式 “cgroups” 。&lt;/p>
&lt;p>cgroups 形成了树状结构。（一个给定的 cgroup 可能有多个子 cgroup 形成一棵树结构体）每个非根 cgroup 都有一个 &lt;code>cgroup.events&lt;/code> 文件，其中包含 &lt;code>populated&lt;/code> 字段指示 cgroup 的子层次结构是否具有实时进程。所有非根的 &lt;code>cgroup.subtree_control&lt;/code> 文件，只能包含在父级中启用的控制器。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/YfPRAelm92GnSEq.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 6 ，cgroups 示例&lt;/strong>&lt;/p>
&lt;p>如图所示，cgroup1 中限制了使用 cpu 及 内存资源，它将控制子节点的 CPU 周期和内存分配（即，限制 cgroup2、cgroup3、cgroup4 中的cpu及内存资源分配）。cgroup2 中启用了内存限制，但是没有启用cpu的资源限制，这就导致了 cgroup3 和 cgroup4 的内存资源受 cgroup2中的 mem 设置内容的限制；cgroup3 和 cgroup4 会自由竞争在 cgroup1 的 cpu 资源限制范围内的 cpu 资源。&lt;/p>
&lt;p>由此，也可以明显的看出 cgroup 资源是自上而下分布约束的。只有当资源已经从上游 cgroup 节点分发给下游时，下游的 cgroup 才能进一步分发约束资源。所有非根的 &lt;code>cgroup.subtree_control&lt;/code> 文件只能包含在父节点的 &lt;code>cgroup.subtree_control&lt;/code> 文件中启用的控制器内容。&lt;/p>
&lt;p>那么，&lt;strong>子节点 cgroup 与父节点 cgroup 是否会存在内部进程竞争的情况呢&lt;/strong>？&lt;/p>
&lt;p>当然不会。cgroup v2 中，设定了非根 cgroup 只能在没有任何进程时才能将域资源分发给子节点的 cgroup。简而言之，只有不包含任何进程的 cgroup 才能在其 &lt;code>cgroup.subtree_control&lt;/code> 文件中启用域控制器，这就保证了，进程总在叶子节点上。&lt;/p>
&lt;h3 id="挂载和委派">挂载和委派&lt;/h3>
&lt;h4 id="cgroup-的挂载方式">cgroup 的挂载方式&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>memory_recursiveprot - 递归地将 memory.min 和 memory.low 保护应用于整个子树，无需显式向下传播到叶节点的 cgroup 中，子树内叶子节点可以自由竞争；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>memory_localevents - 只能挂载时设置或者通过从 init 命名空间重新挂载来修改，这是系统范围的选项。只用当前 cgroup 的数据填充 memory.events，如果没有这个选项，默认会计数所有子树；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nsdelegate - 只能挂载时设置或者通过从 init 命名空间重新挂载来修改，这也是系统范围的选项。它将 cgroup 命名空间视为委托边界，这是两种委派 cgroup 的方式之一；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="cgroup-的委派方式">cgroup 的委派方式&lt;/h4>
&lt;ul>
&lt;li>设置挂载选项 nsdelegate ；&lt;/li>
&lt;li>授权用户对目录及其 &lt;code>cgroup.procs&lt;/code>、&lt;code>cgroup.threads&lt;/code> 和 &lt;code>cgroup.subtree_control&lt;/code> 文件的写访问权限&lt;/li>
&lt;/ul>
&lt;p>两种方式的结果相同。一旦被委派，用户就可以在目录下建立子层次结构，所有的资源分配都受父节点的制约。目前，cgroup 对委托子层次结构中的 cgroup 数量或嵌套深度没有任何限制（之后可能会受到明确限制）。&lt;/p>
&lt;p>前面提到了跨 cgroup 迁移，从委派中，我们可以很明确的得知跨 cgroup 迁移对于普通用户来讲，是有限制条件的。即，是否对目前 cgroup 的 “cgroup.procs” 文件具有写访问权限以及是否对源 cgroup 和目标 cgroup 的共同祖先的 “cgroup.procs” 文件具有写访问权限。&lt;/p>
&lt;h4 id="委派和迁移">委派和迁移&lt;/h4>
&lt;p>&lt;img src="https://i.loli.net/2021/11/18/JCmExjwOUcTBvrL.png" alt="img">&lt;/p>
&lt;p>&lt;strong>图 7 ，委派权限示例&lt;/strong>&lt;/p>
&lt;p>如图，普通用户 User0 具有 cgroup[1-5] 的委派权限。&lt;/p>
&lt;p>为什么 User0 想将进程 从 cgroup3 迁移至 cgroup5会失败呢？&lt;/p>
&lt;p>这是由于 User0 的权限只到 cgroup1 和 cgroup2 层，并不具备 cgroup0 的权限。而委派中的授权用户明确指出&lt;strong>需要共同祖先的&lt;/strong> &lt;strong>“cgroup.procs” 文件具有写访问权限！&lt;/strong>（即，需要图中 cgroup0 的权限，才可以实现）&lt;/p>
&lt;h3 id="资源分配模型及功能">资源分配模型及功能&lt;/h3>
&lt;p>以下是 cgroups 的资源分配模型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>权重 - (例如，cpu.weight) 所有权重都在 [1, 10000] 范围内，默认值为 100。按照权重比率来分配资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>限制 - [0, max] 范围内，默认为“max”，即 noop（例如，io.max）。限制可以被过度使用（子节点限制的总和可能超过父节点可用的资源量）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保护 - [0, max] 范围内，默认为 0，即 noop（例如，io.low）。保护可以是硬保证或尽力而为的软边界，保护也可能被过度使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分配 - [0, max] 范围内，默认为 0，即没有资源。分配不能被过度使用（子节点分配的总和不能超过父节点可用的资源量）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>cgroups 提供了如下功能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>资源限制 - 上面 cgroup 部分已经示例，cgroups 可以以树状结构来嵌套式限制资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先级 - 发生资源争用时，优先保障哪些进程的资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>审计 - 监控及报告资源限制及使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>控制 - 控制进程的状态（起、停、挂起）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="cgroup-v1-与-cgroup-v2">cgroup v1 与 cgroup v2&lt;/h2>
&lt;h3 id="被弃用的核心功能">被弃用的核心功能&lt;/h3>
&lt;p>cgroup v2 和 cgroup v1 有很大的不同，我们一起来看看在 cgroup v2 中弃用了哪些 cgroup v1 的功能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不支持包括命名层次在内的多个层次结构；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持所有 v1 安装选项；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“tasks” 文件被删除，“cgroup.procs” 没有排序&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>在 cgroup v1 中线程组 ID 的列表。不保证此列表已排序或没有重复的 TGID，如果需要此属性，用户空间应排序/统一列表。将线程组 ID 写入此文件会将该组中的所有线程移动到此 cgroup 中；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>cgroup.clone_children&lt;/code> 被删除。clone_children 仅影响 cpuset controller。如果在 cgroup 中启用了 clone_children （设置：1），新的 cpuset cgroup 将在初始化期间从父节点的 cgroup 复制配置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/proc/cgroups 对于 v2 没有意义。改用根目录下的“cgroup.controllers”文件；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="cgroup-v1-的问题">cgroup v1 的问题&lt;/h3>
&lt;p>cgroup v2 和 v1 中最显著的不同就是 cgroup v1 允许任意数量的层次结构, 但这会带来一些问题的。我们来详细聊聊。&lt;/p>
&lt;p>挂载 cgroup 层次结构时，你可以指定要挂载的子系统的逗号分隔列表作为文件系统挂载选项。默认情况下，挂载 cgroup 文件系统会尝试挂载包含所有已注册子系统的层次结构。&lt;/p>
&lt;p>如果已经存在具有完全相同子系统集的活动层次结构，它将被重新用于新安装。&lt;/p>
&lt;p>如果现有层次结构不匹配，并且任何请求的子系统正在现有层次结构中使用，则挂载将失败并显示 -EBUSY。否则，将激活与请求的子系统相关联的新层次结构。&lt;/p>
&lt;p>当前无法将新子系统绑定到活动 cgroup 层次结构，或从活动 cgroup 层次结构中取消绑定子系统。当 cgroup 文件系统被卸载时，如果在顶级 cgroup 之下创建了任何子 cgroup，即使卸载，该层次结构仍将保持活动状态；如果没有子 cgroup，则层次结构将被停用。&lt;/p>
&lt;p>这就是 cgroup v1 中的问题，在 cgroup v2 中就很好的进行了解决。&lt;/p>
&lt;h2 id="cgroup-和容器的联系">cgroup 和容器的联系&lt;/h2>
&lt;p>这里我们以 Docker 为例。 创建一个容器，并对其可使用的 CPU 和内存进行限制：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ docker run --rm -d --cpus&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span> --memory&lt;span class="o">=&lt;/span>2g --name&lt;span class="o">=&lt;/span>2c2g redis:alpine
e420a97835d9692df5b90b47e7951bc3fad48269eb2c8b1fa782527e0ae91c8e
➜ ~ cat /sys/fs/cgroup/system.slice/docker-&lt;span class="sb">`&lt;/span>docker ps -lq --no-trunc&lt;span class="sb">`&lt;/span>.scope/cpu.max
&lt;span class="m">200000&lt;/span> &lt;span class="m">100000&lt;/span>
➜ ~ cat /sys/fs/cgroup/system.slice/docker-&lt;span class="sb">`&lt;/span>docker ps -lq --no-trunc&lt;span class="sb">`&lt;/span>.scope/memory.max
&lt;span class="m">2147483648&lt;/span>
➜ ~
➜ ~ docker run --rm -d --cpus&lt;span class="o">=&lt;/span>0.5 --memory&lt;span class="o">=&lt;/span>0.5g --name&lt;span class="o">=&lt;/span>0.5c0.5g redis:alpine
8b82790fe0da9d00ab07aac7d6e4ef2f5871d5f3d7d06a5cdb56daaf9f5bc48e
➜ ~ cat /sys/fs/cgroup/system.slice/docker-&lt;span class="sb">`&lt;/span>docker ps -lq --no-trunc&lt;span class="sb">`&lt;/span>.scope/cpu.max
&lt;span class="m">50000&lt;/span> &lt;span class="m">100000&lt;/span>
➜ ~ cat /sys/fs/cgroup/system.slice/docker-&lt;span class="sb">`&lt;/span>docker ps -lq --no-trunc&lt;span class="sb">`&lt;/span>.scope/memory.max
&lt;span class="m">536870912&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的示例可以看到，当我们使用 Docker 创建出新的容器并且为他指定 CPU 和 内存限制后，其对应的 cgroup 配置文件的 &lt;code>cpu.max&lt;/code> 和 &lt;code>memory.max&lt;/code>都设置成了相应的值。&lt;/p>
&lt;p>如果你想要对一些已经在运行的容器进行资源配额的检查的话，也可以直接去查看其对应的配置文件中的内容。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上就是关于容器技术的基石之一的 cgroup 的详细介绍了。接下来我还会写关于 namespace 以及其他容器技术相关的内容，敬请关注！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">OCI 与下一代镜像构建工具</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/11/03/OCI-%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/><id>https://moelove.info/2021/11/03/OCI-%E4%B8%8E%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</id><updated>2021-11-04T18:58:41+08:00</updated><published>2021-11-03T23:16:42+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 这篇文章中我将介绍 OCI 及 Docker 镜像相关的内容，欢迎留言讨论。 OCI 的前世今生 2013 年 3 月 dotCloud 公司在 PyCon 上进行了 Docker 的首次展示，随……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>这篇文章中我将介绍 OCI 及 Docker 镜像相关的内容，欢迎留言讨论。&lt;/p>
&lt;h2 id="oci-的前世今生">OCI 的前世今生&lt;/h2>
&lt;p>2013 年 3 月 dotCloud 公司在 PyCon 上进行了 Docker 的首次展示，随后宣布开源。自此 Docker 开始被众人知晓，随后掀起了一股容器化的热潮。&lt;/p>
&lt;p>在 2014 年 6 月 Docker 1.0 正式发布，有近 460 位贡献者和超过 8700 次提交，这也标志着 Docker 达到了生产可用的状态。&lt;/p>
&lt;p>在当时，提到容器化第一想法就是用 Docker 。而当时 Docker 的实现或者说发展方向主要是由 Docker Inc. 公司控制的，并没有一个统一的工业标准。这对于一些头部公司而言，显然是不能接受的，没有统一的工业标准意味着如果选择了使用 Docker 的容器化技术，便会被 Docker Inc. 公司所绑定；加上随着 Docker 软件的升级，某些功能或者特性必然会进行变动，没人能保证不发生破坏性变更。&lt;/p>
&lt;p>所以，为了推进容器化技术的工业标准化，2015 年 6 月在 DockerCon 上 Linux 基金会与 Google，华为，惠普，IBM，Docker，Red Hat，VMware 等公司共同宣布成立开放容器项目(OCP)，后更名为 OCI。它的主要目标便是 &lt;strong>建立容器格式和运行时的工业开放通用标准&lt;/strong>。&lt;/p>
&lt;p>发展至今， OCI 制定的主要标准有三个分别是 &lt;code>runtime-spec&lt;/code> 、&lt;code>image-spec&lt;/code> 和 &lt;code>distribution-spec&lt;/code> 这三个标准分别定义了容器运行时，容器镜像还有分发的规范，后面会展开介绍。&lt;/p>
&lt;p>为了支持 OCI 容器运行时标准的推进，Docker 公司起草了镜像格式和运行时规范的草案，并将 Docker 项目的相关实现捐献给了 OCI 作为容器运行时的基础实现，现在项目名为 &lt;a href="https://github.com/opencontainers/runc">&lt;code>runc&lt;/code>&lt;/a> 。&lt;/p>
&lt;p>后来 Docker 将其容器运行时独立成了一个项目，名为 &lt;code>containerd&lt;/code> 并将此项目捐献给了 CNCF ，现在已经是 CNCF 毕业项目了。&lt;/p>
&lt;h2 id="oci-image-vs-docker-image">OCI image vs Docker image&lt;/h2>
&lt;p>OCI 的建立推动了容器技术的工业标准化，但是否此标准就是唯一呢？其实不然。在成立 OCI 并制定 &lt;code>image-spec&lt;/code> 标准的时候 Docker 已经空前繁荣，并得到了广泛的应用。&lt;/p>
&lt;p>由于标准只定义了最基本的内容，想要将 Docker 的实现全部按照标准进行改造的话，会对 Docker 造成破坏性变更，也不利于 Docker 功能的迭代。&lt;/p>
&lt;p>所以，Docker 为了支持 OCI 标准的普及，已经推进了 registry 对 OCI 镜像的支持，现在也正在给 Docker 自身增加适配中，目标是让 Docker 支持两种镜像格式，分别是符合 Docker 标准的镜像和符合 OCI 标准的镜像。&lt;/p>
&lt;p>那这两者有什么异同呢？ 我们来逐步看下。&lt;/p>
&lt;h3 id="docker-image-和-oci-image-的区别和联系">Docker Image 和 OCI Image 的区别和联系&lt;/h3>
&lt;p>在我以前的文章中我们已经详细的从根本上介绍了 Docker image 是什么，这里我们就快速的介绍下。&lt;/p>
&lt;p>每个 Docker 镜像都是由一系列的配置清单和相应的层进行组织的。每个层一般都是 tar 格式的归档，配置清单中描述了对应的层应该按何种顺序进行组织，以及镜像的一些元属性。比如镜像所支持的架构，例如 &lt;code>amd64&lt;/code> 之类的，还有 ENV 等提前配置好的一些参数等。&lt;/p>
&lt;p>当然，在 Docker Image 中也包含着构建镜像时候所用的 Docker 版本 &lt;code>docker_version&lt;/code> 以及构建镜像的历史记录 &lt;code>history&lt;/code> 等信息。所以你在 &lt;code>DockerHub&lt;/code> 或者其他的镜像仓库上可以看到构建镜像所用的 Docker 版本， 或者可通过 &lt;code>docker history &amp;lt;IMAGE&amp;gt;&lt;/code> 的方式来查看构建历史。&lt;/p>
&lt;p>那么 OCI Image 是什么呢？ 首先我们需要有一个 OCI Image 才好探究它到底是什么。&lt;/p>
&lt;p>这里介绍一个工具 &lt;a href="https://github.com/projectatomic/skopeo">skopeo&lt;/a> 可以很方便的从镜像仓库或者本地 Docker daemon 甚至是通过 &lt;code>docker save&lt;/code> 保存的 Docker Image tar 文件转换为 OCI Image 。&lt;/p>
&lt;p>关于 &lt;a href="https://github.com/projectatomic/skopeo">skopeo&lt;/a> 的安装过程就不再赘述了，参考项目主页的文档说明即可。这里直接开始使用。&lt;/p>
&lt;p>我们使用 &lt;code>debian&lt;/code> 的镜像为例。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ skopeo copy docker://debian:stretch oci:debian:stretch
Getting image source signatures
Copying blob a4d8138d0f6b done
Copying config 45f82268e3 done
Writing manifest to image destination
Storing signatures
&lt;/code>&lt;/pre>&lt;p>通过上面的命令便会得到一个 OCI Image 了， 我们看下它的目录结构。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ tree debian
debian
├── blobs
│   └── sha256
│   ├── 0043cd2a654fe86258f43f5b1dbbb4e6c582cc4bb6e505e9c5171c124150d155
│   ├── 45f82268e32180cb1839f90467d9b8a8258953d68b7221199976653308d92ef5
│   └── a4d8138d0f6b5a441aaa533faf5fe0c3996a6ca42643c46f4402c7e8bda53742
├── index.json
└── oci-layout
2 directories, 5 files
&lt;/code>&lt;/pre>&lt;p>是不是有种似曾相识的感觉？没错 OCI Image 的规范是在 Docker Image 的基础上建立的，所以大致看起来差异不是特别大。我们看看其中具体的内容。&lt;/p>
&lt;h4 id="oci-layout">&lt;code>oci-layout&lt;/code>&lt;/h4>
&lt;p>这个文件是 OCI Image 的布局文件，也是用于说明它所使用或者遵循的镜像规范。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ debian cat oci-layout| jq
{
&amp;quot;imageLayoutVersion&amp;quot;: &amp;quot;1.0.0&amp;quot;
}
&lt;/code>&lt;/pre>&lt;p>可以看到此处的内容写的是 &lt;code>1.0.0&lt;/code> 这便说明该镜像遵循 OCI 1.0.0 版本的布局规范。&lt;/p>
&lt;h4 id="indexjson">&lt;code>index.json&lt;/code>&lt;/h4>
&lt;p>&lt;code>index.json&lt;/code> 文件中的 &lt;code>manifest&lt;/code> 字段类似于 Docker Image 中的 &lt;code>manifest.json&lt;/code> 作为 OCI Image 的顶级配置, 也是镜像的一个入口配置。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ debian cat index.json | jq
{
&amp;quot;schemaVersion&amp;quot;: 2,
&amp;quot;manifests&amp;quot;: [
{
&amp;quot;mediaType&amp;quot;: &amp;quot;application/vnd.oci.image.manifest.v1+json&amp;quot;,
&amp;quot;digest&amp;quot;: &amp;quot;sha256:0043cd2a654fe86258f43f5b1dbbb4e6c582cc4bb6e505e9c5171c124150d155&amp;quot;,
&amp;quot;size&amp;quot;: 349,
&amp;quot;annotations&amp;quot;: {
&amp;quot;org.opencontainers.image.ref.name&amp;quot;: &amp;quot;stretch&amp;quot;
},
&amp;quot;platform&amp;quot;: {
&amp;quot;architecture&amp;quot;: &amp;quot;amd64&amp;quot;,
&amp;quot;os&amp;quot;: &amp;quot;linux&amp;quot;
}
}
]
}
&lt;/code>&lt;/pre>&lt;p>从它的内容可以看到它其中的 &lt;code>mediaType&lt;/code> 字段与 Docker Image 中的类型形式相同，但是将 &lt;code>docker&lt;/code> 都换成了 &lt;code>oci&lt;/code>。从这个配置文件，我们可以找到第一个 blob 是 &lt;code>sha256:0043cd2a654fe86258f43f5b1dbbb4e6c582cc4bb6e505e9c5171c124150d155&lt;/code> 我们看看它的内容。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ debian cat blobs/sha256/0043cd2a654fe86258f43f5b1dbbb4e6c582cc4bb6e505e9c5171c124150d155 | jq
{
&amp;quot;schemaVersion&amp;quot;: 2,
&amp;quot;config&amp;quot;: {
&amp;quot;mediaType&amp;quot;: &amp;quot;application/vnd.oci.image.config.v1+json&amp;quot;,
&amp;quot;digest&amp;quot;: &amp;quot;sha256:45f82268e32180cb1839f90467d9b8a8258953d68b7221199976653308d92ef5&amp;quot;,
&amp;quot;size&amp;quot;: 579
},
&amp;quot;layers&amp;quot;: [
{
&amp;quot;mediaType&amp;quot;: &amp;quot;application/vnd.oci.image.layer.v1.tar+gzip&amp;quot;,
&amp;quot;digest&amp;quot;: &amp;quot;sha256:a4d8138d0f6b5a441aaa533faf5fe0c3996a6ca42643c46f4402c7e8bda53742&amp;quot;,
&amp;quot;size&amp;quot;: 45337510
}
]
}
&lt;/code>&lt;/pre>&lt;p>这个入口文件描述了 OCI 镜像的实际配置和其中的 Layer 配置。如果有多层那 &lt;code>layers&lt;/code> 也会相应增加。&lt;/p>
&lt;p>&lt;strong>注意：layers 中 &lt;code>mediaType&lt;/code> 使用了 &lt;code>application/vnd.oci.image.layer.v1.tar+gzip&lt;/code> 说明数据内容是经过 gzip 压缩的&lt;/strong> 如果有兴趣你可以将它用 tar 解压一下，你会发现很有趣的内容。&lt;/p>
&lt;blockquote>
&lt;p>这里先将结果说出来，解压后你会得到一个 &lt;code>rootfs&lt;/code> 这与 Docker Image 是类似的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>我们通过 &lt;a href="https://github.com/projectatomic/skopeo">skopeo&lt;/a> 工具，从本地的 Docker daemon 中由 debian 的 Docker Image 得到了 OCI Image，并分析了它其中的内容。&lt;/p>
&lt;p>最主要的区别在于它们的目录结构不完全相同，配置信息尤其是 &lt;code>mediaType&lt;/code> 的规范是不相同的。&lt;/p>
&lt;p>而它们的联系也在于此，OCI Image 的规范是由 Docker Image 的规范修改而来的，所以类似它们的 blob 的组织形式大致是相同的，配置文件中很多的参数也相似。&lt;/p>
&lt;p>另外，我们也可以很容易的得到另一个结论，那便是我们可以很方便的将 Docker Image 转换为 OCI Image 。&lt;/p>
&lt;h3 id="oci-image-和-docker-image-的转换">OCI image 和 Docker image 的转换&lt;/h3>
&lt;p>上面我们已经看到，使用 &lt;a href="https://github.com/projectatomic/skopeo">skopeo&lt;/a> 工具，可以将 Docker Image 转换为 OCI Image ，当然它也可以将 OCI Image 转换为 Docker Image 。下面给出了方法：&lt;/p>
&lt;pre>&lt;code># 从 DockerHub 将 debian 的 Docker Image 拉取并转换为 OCI Image
(MoeLove) ➜ skopeo copy docker://debian:stretch oci:debian:stretch
Getting image source signatures
Copying blob a4d8138d0f6b done
Copying config 45f82268e3 done
Writing manifest to image destination
Storing signatures
# 将当前目录下的 debian 的 OCI Image 转换为 Docker Image 并存储到本地 docker daemon 中
(MoeLove) ➜ skopeo copy oci:debian:stretch docker-daemon:local/debian:oci
Getting image source signatures
Copying blob 0e350e141713 done
Copying config aae58a37cf done
Writing manifest to image destination
Storing signatures
# 验证
(MoeLove) ➜ oci docker images local/debian
REPOSITORY TAG IMAGE ID CREATED SIZE
local/debian oci ac6bcf605d82 6 months ago 101MB
&lt;/code>&lt;/pre>&lt;h3 id="镜像构建工具">镜像构建工具&lt;/h3>
&lt;p>在 CI/CD 环境中，虽然我们可以使用 DinD (Docker in Docker) 的方式启动一个 docker daemon 或者使用挂载的方式，将外部的 &lt;code>/var/run/docker.sock&lt;/code> 挂载进容器内部，亦或者将 Docker API 使用 HTTP 的方式暴露出来，直接使用该地址进行构建。&lt;/p>
&lt;p>但这些方式你是否会觉得比较重？是否有考虑安全问题，或者压力及负载的问题？&lt;/p>
&lt;p>这里的压力及负载主要是指当所有的任务都共用同一个 docker daemon 提供服务的话，对该 docker daemon 造成的压力。&lt;/p>
&lt;p>这里我们来介绍一些其他的镜像构建工具，使用这些工具可以让你在无 Docker 的环境下构建出镜像并上传至 Docker 镜像仓库中。&lt;/p>
&lt;p>到目前为止，我们可以有很多种选择：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/moby/buildkit">BuildKit&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/genuinetools/img">img&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/cyphar/orca-build">orca-build&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/openSUSE/umoci">umoci&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/containers/buildah">buildah&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/kaniko">kaniko&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleCloudPlatform/runtimes-common/tree/master/ftl">FTL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/bazelbuild/rules_docker">Bazel rules_docker&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这些工具侧重点各有不同，当然也不仅有上面列到的这些工具，只是这些工具比较典型罢了。&lt;/p>
&lt;p>通常情况下，在网络上比较容易见到宣传为下一代镜像构建工具的是 &lt;code>buildah&lt;/code> ，最主要原因是因为它可以直接构建 OCI 标准的镜像或 Docker 镜像，也可以直接使用 &lt;code>Dockerfile&lt;/code> 。并且它还可以 &lt;code>pull&lt;/code>/&lt;code>push&lt;/code> 镜像，可以说在镜像构建方面与 Docker 是完全兼容，甚至可以说它在构建镜像方面可以作为 Docker 的替代品了。&lt;/p>
&lt;p>并且 &lt;code>buildah&lt;/code> 构建镜像的时候不需要任何 &lt;code>root&lt;/code> 权限，也不依赖 Docker， 它使用了简单的 &lt;code>fork-exec&lt;/code> 模型，同时它也可以作为一个库包含在其他的工具中。它的最终目标便是提供一个更低层次的核心工具集，来完成构建镜像相关的事情。&lt;/p>
&lt;p>说完这个典型的替代品，我们再来说下 &lt;code>BuildKit&lt;/code> 和 &lt;code>img&lt;/code> , &lt;code>img&lt;/code> 这个工具是构建在 &lt;code>BuildKit&lt;/code> 之上的，所以有很多相似性。它们使用非 root 用户来构建镜像。当然 &lt;code>BuildKit&lt;/code> 我在之前的文章中详细介绍过了，它是 Docker 内置的下一代构建工具，独立使用也是可以的。称它为“下一代镜像构建工具” 也并不为过。&lt;/p>
&lt;p>&lt;code>kaniko&lt;/code> 是 Google 推出的，它主要的宣传语为 “在 Kubernetes 中构建容器镜像” 实际上无论是在 K8S 集群中或者在容器中它都是可以工作的。它也可以使用 &lt;code>Dockerfile&lt;/code> 构建镜像。当然还有很重要的一点，它所有的构建命令都是运行在用户态的，并且也可以很好的与 Kubernetes 结合，在云原生时代下，它也占据了一定的优势。&lt;/p>
&lt;p>以上工具都只是大致介绍了下，如果对它们感兴趣，可直接进入项目主页查看 &lt;code>README.md&lt;/code> 基础使用都有比较详细的说明，这里不再进行赘述了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本篇为大家介绍了 OCI 的前世今生，以及 OCI Image 的规范和特点，另外也介绍了一个可用于在 OCI Image 和 Docker Image 之间镜像转换的工具 &lt;code>skopeo&lt;/code> 。另外介绍了一些可用于在 CI 环境或其他有特定场景环境下替代 Docker build 的工具，请大家按实际需求进行选择。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/></entry><entry><title type="text">K8S 生态周报| Helm 新版本发布增强对 OCI 的支持</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%A2%9E%E5%BC%BA%E5%AF%B9-OCI-%E7%9A%84%E6%94%AF%E6%8C%81/"/><id>https://moelove.info/2021/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%A2%9E%E5%BC%BA%E5%AF%B9-OCI-%E7%9A%84%E6%94%AF%E6%8C%81/</id><updated>2021-11-03T02:34:22+08:00</updated><published>2021-10-31T01:15:34+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v20.10.10 发布 这个版本是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h1 id="docker-v201010-发布">Docker v20.10.10 发布&lt;/h1>
&lt;p>这个版本是 Docker v20.10 的第 10 个小版本，这个版本中没有什么太特别的共性问题，但是由于&lt;a href="https://go-review.googlesource.com/c/net/+/249440/" title="Go 116 对 http_proxy 的处理行为"> Go 1.16 中 &lt;code>net/http&lt;/code> 包对 &lt;code>$HTTP_PROXY&lt;/code> 行为的变化&lt;/a>，所以当你为 Docker daemon 设置代理的时候，请确认你已经正确的设置了 &lt;code>$HTTP_PROXY&lt;/code> 和 &lt;code>$HTTPS_PROXY&lt;/code> 等。&lt;/p>
&lt;p>此版本的其他变更，可参考其 &lt;a href="https://github.com/moby/moby/releases/tag/v20.10.10">ReleaseNote&lt;/a> 。至于 Docker v21.x 短时间内还不会发布，不过里面确实增加了一些值得一提的特性，后续新版本快发布前再跟大家分享。&lt;/p>
&lt;h1 id="helm-v37-正式发布">Helm v3.7 正式发布&lt;/h1>
&lt;p>Helm v3.7 是一个特性版本，我们一起来看看有哪些值得关注的变更吧。&lt;/p>
&lt;h2 id="对-oci-chart-的支持相关的变更">对 OCI Chart 的支持相关的变更&lt;/h2>
&lt;ul>
&lt;li>&lt;code>helm chart export&lt;/code> 已删除&lt;/li>
&lt;li>&lt;code>helm chart list&lt;/code> 已删除&lt;/li>
&lt;li>&lt;code>helm chart pull&lt;/code> 由 &lt;code>helm pull&lt;/code> 代替&lt;/li>
&lt;li>&lt;code>helm chart push&lt;/code> 由 &lt;code>helm push&lt;/code> 代替&lt;/li>
&lt;li>&lt;code>helm chart remove&lt;/code> 已删除&lt;/li>
&lt;li>&lt;code>helm chart save&lt;/code> 由 &lt;code>helm package&lt;/code> 代替&lt;/li>
&lt;/ul>
&lt;p>另外， &lt;strong>如果是通过旧版本创建的 OCI chart 需要使用 Helm v3.7 进行重新打包和上传才能使用。&lt;/strong>&lt;/p>
&lt;h2 id="一些新特性">一些新特性&lt;/h2>
&lt;ul>
&lt;li>新增 &lt;code>helm uninstall --wait&lt;/code>&lt;/li>
&lt;li>新增 &lt;code>helm show crds&lt;/code>&lt;/li>
&lt;li>&lt;code>helm dependency list&lt;/code> 新增 &lt;code>--max-col-width&lt;/code> 用于设置列宽&lt;/li>
&lt;li>&lt;code>helm repo add&lt;/code> 新增 &lt;code>--password-stdin&lt;/code> 用于从 stdin 输入密码&lt;/li>
&lt;li>&lt;code>helm repo update&lt;/code> 可以指定 repo 名称进行更新了&lt;/li>
&lt;li>Helm 模板引擎中新增 &lt;code>{{ .Chart.IsRoot }}&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更可以参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.7.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="notary-v2-alpha1-发布">Notary v2 alpha1 发布&lt;/h1>
&lt;p>Notary v1，也称为 Docker Content Trust(DCT)，主要是为当时的 Docker Hub 发布的。从那以后发生了很多变化，围绕首次使用信任 (TOFU)、密钥管理以及在注册中心内和跨注册中心缺乏内容推广的一些设计选择已成为 Docker Content Trust 和 Notary v1 的限制因素。&lt;/p>
&lt;p>对 Notary 不了解的小伙伴，可以看下我两年前写的一篇 《K8S 生态周报| TUF 正式从 CNCF 毕业》在这篇文章中介绍了 TUF 还有 Notary 等内容。这里就不展开了。&lt;/p>
&lt;p>Notary v2 支持对存储在基于 OCI 分发的注册表中的所有工件（容器镜像、软件材料清单、扫描结果）进行签名，并增强了 ORAS 工件规范。Notary v2 的一个关键原则是它支持在注册中心内和跨注册中心推广已签名的工件，包括私有网络环境。&lt;/p>
&lt;p>它的工作过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/03/ETIVuP7jK6U9pcH.png" alt="Notary v2">&lt;/p>
&lt;p>在 Notary v2 中最显著的变化就是易用性的提升，包括它发布了名为 &lt;code>notation&lt;/code> 的 CLI 工具。可以创建证书，签名，校验等。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ notation
NAME:
notation - Notation - Notary V2
USAGE:
notation &lt;span class="o">[&lt;/span>global options&lt;span class="o">]&lt;/span> &lt;span class="nb">command&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="nb">command&lt;/span> options&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>arguments...&lt;span class="o">]&lt;/span>
VERSION:
0.7.0-alpha.1
AUTHOR:
CNCF Notary Project
COMMANDS:
sign Signs artifacts
verify Verifies OCI Artifacts
push Push signature to remote
pull Pull signatures from remote
list, ls List signatures from remote
certificate, cert Manage certificates used &lt;span class="k">for&lt;/span> verification
key Manage keys used &lt;span class="k">for&lt;/span> signing
cache Manage signature cache
help, h Shows a list of commands or &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> one &lt;span class="nb">command&lt;/span>
GLOBAL OPTIONS:
--help, -h show &lt;span class="nb">help&lt;/span> &lt;span class="o">(&lt;/span>default: &lt;span class="nb">false&lt;/span>&lt;span class="o">)&lt;/span>
--version, -v print the version &lt;span class="o">(&lt;/span>default: &lt;span class="nb">false&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此版本中最显著的特性就是离线签名创建，以及对 OCI 分发规范的支持。后续的版本中将支持证书吊销，策略支持等能力。感兴趣的小伙伴可以参考其 &lt;a href="https://github.com/notaryproject/notaryproject/releases/tag/v1.0.0-draft.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="docker-hub-registry-公布对-ipv6-的支持">Docker Hub Registry 公布对 IPv6 的支持&lt;/h1>
&lt;p>随着 IPv6 的逐步普及，世界范围内越来越多的用户开始在使用 IPv6 网络了，但是 Docker Hub 此前并不支持 IPv6 网络。在听取社区反馈意见后，正式加入了对 Docker Hub 的 IPv6 网络的支持。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/03/C48k9VZ2xUSmohe.png" alt="Google IPv6 statistic">&lt;/p>
&lt;p>目前公布的测试版本的 IPv6 地址为 &lt;code>registry.ipv6.docker.com&lt;/code>， 如果是纯 IPv6 或者双栈用户，可以使用如下命令进行登陆。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker login registry.ipv6.docker.com
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以使用如下的命令进行镜像的拉取：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker pull registry.ipv6.docker.com/library/debian:latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在后续对 IPv6 的支持达到稳定后，默认的 Docker Hub Registry 的地址也将支持 IPv6。这件事情对于 Docker Inc. 公司而言，比较大的挑战在与它需要处理它的限流限速相关的逻辑，不过目前也已经基本处理好了。&lt;/p>
&lt;h1 id="上游进展">上游进展&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99557">#99557 · kubernetes/kubernetes&lt;/a> 新增了一个实验性的 &lt;code>kubectl events&lt;/code> 命令，这个 PR 中仅包含了最基本的实现，后续版本中将会按照 &lt;a href="https://github.com/kubernetes/enhancements/issues/1440">KEP #1440&lt;/a> 继续实施。&lt;/p>
&lt;p>增加此命令主要是由于在不修改 &lt;code>kubectl get&lt;/code> 的前提下，查看 &lt;code>event&lt;/code> 有一些限制，所以直接增加 &lt;code>kubectl events&lt;/code> 命令可以更方便的去获取到需要的信息，尤其是 event 是在 Kubernetes 中经常需要查看的一个信息。&lt;code>kubectl get events&lt;/code> 比较典型的一些问题, 比如排序（虽然可以通过加参数解决）， watch，以及无法按照时间线方式去查看 events 等。&lt;/p>
&lt;p>当然以上的这些问题也可以参考我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/383795254">《更优雅的 Kubernetes 集群事件度量方案》&lt;/a> 来解决。&lt;/p>
&lt;p>现在主要是增加了 &lt;code>--for&lt;/code> 选项，可以直接按照对象进行过滤，在下个版本 v1.23 中就将正式和大家见面了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/105908">#105908 · kubernetes/kubernetes&lt;/a> 作为在 v1.21 中被废弃的 PSP（Pod Security Policy）的替代品，Pod Security Admission Control 在此版本中实现了很多内容。此 PR 中为被免于 Pod Security 的 Pod 添加了 annotation 用于解释如何/为什么。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/104909">#104909 · kubernetes/kubernetes&lt;/a> 修正了获取 Pod QoS 时的逻辑。原先的逻辑中仅包含了 &lt;code>pod.Spec.Containers&lt;/code> 的部分，而没有处理 &lt;code>pod.Spec.InitContainers&lt;/code> 这些 InitContainer 的部分，此次修改将它们都加上了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/104693">#104693 · kubernetes/kubernetes&lt;/a> 在 &lt;code>PodSpec&lt;/code> 中根据 KEP-2808 增加 &lt;code>OS&lt;/code> 字段，以及一些校验，主要是为了区分是否为 Windows 节点等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">GitOps 应用实践系列 - Argo CD 的基本介绍</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/10/21/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-Argo-CD-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/><id>https://moelove.info/2021/10/21/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-Argo-CD-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</id><updated>2021-12-19T15:11:11+08:00</updated><published>2021-10-21T20:56:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 在上一篇『GitOps 应用实践系列 - 综述（一）』中，我介绍了 GitOps 的概念、如何工作以及基于 Pull 和 Push 的模型等内容。本……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在上一篇&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2ODAwMzUwNA==&amp;amp;mid=2649296484&amp;amp;idx=1&amp;amp;sn=03e9d37f5919bf6702f3463644b3291c&amp;amp;chksm=f2eb9fbbc59c16ad41151faeacdccf5d9e9d52bde12e77d48234c87a837e07b90240153f4701&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1021yuHEEAO2EHfV21mv0iU4&amp;amp;sharer_sharetime=1634745866724&amp;amp;sharer_shareid=ca2e51094588e06bf753d47ce6ce6894&amp;amp;exportkey=AV3eqjRIBjJyEyLC5rFwQiA%3D&amp;amp;pass_ticket=dKcOVN1krZPAqOSsYDQNdfDP5pZPyajrfnBNwCPn53J8GD0ry7ubzn6xT7tDLhOz&amp;amp;wx_header=0#rd">『GitOps 应用实践系列 - 综述（一）』&lt;/a>中，我介绍了 GitOps 的概念、如何工作以及基于 Pull 和 Push 的模型等内容。本篇，我们重点介绍用于实施 GitOps 的工具 &lt;a href="https://argoproj.github.io/argo-cd/">ArgoCD&lt;/a> 。&lt;/p>
&lt;h2 id="argo-cd-概览">Argo CD 概览&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/19/XLMzJdCmGK12sWg.png" alt="img">&lt;/p>
&lt;p>2020 年 4 月 7 日，CNCF Technical Oversight Committee (TOC) 投票通过 Argo 项目进入 CNCF 孵化。&lt;/p>
&lt;p>其实 Argo 是在 2017 年由 &lt;a href="https://www.applatix.com/">Applatix&lt;/a> 公司创建的（这家公司的主要产品和服务目前主要与 AWS 进行深度融合，当然也包括一些多云的服务），2018 年初被 Intuit 收购。 之后，BlackRock 为 Argo 项目贡献了 Argo Events 子项目。两家公司都积极参与项目和社区的开发和培育中。&lt;/p>
&lt;p>Argo 及其子项目提供了一种简单的方法管理 Workflow，事件和应用程序。所有 Argo 工具都通过 CRD 的方式实现。他们可以使用或集成其他 CNCF 项目，如 gRPC、Prometheus、NATS、Helm 和 CloudEvents。&lt;/p>
&lt;p>Argo 生态目前主要由四个子项目组成，包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Argo Workflows&lt;/strong> -- 第一个 Argo 项目，是 Kubernetes 的原生&lt;strong>工作流引擎&lt;/strong>，支持 DAG 和 step-based 的工作流；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Argo Events&lt;/strong> -- Kubernetes 上的基于事件的依赖管理器，用于触发 Kubernetes 中的 Argo 工作流和其他操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Argo CD&lt;/strong> -- 是 Argo 社区和 Intuit 带来的开源项目，支持基于 GitOps 的声明性部署 Kubernetes 资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Argo Rollouts&lt;/strong> -- 支持声明式渐进式交付策略，例如 canary 、blue-green 和更多形式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Argo CD 旨在提供一个&lt;strong>声明式持续交付 (CD) 工具。&lt;strong>Argo CD 支持多种配置管理工具，包括 ksonnet /jsonnet，kustomize 和 &lt;a href="https://github.com/helm/helm">Helm&lt;/a> 等&lt;/strong>。&lt;strong>Argo CD 扩展了声明式和基于 Git 的配置管理的优势，以在&lt;/strong>不影响安全性和合规性的情况下加速应用程序的部署和生命周期管理。&lt;/strong>&lt;/p>
&lt;h2 id="argo-cd-的适用场景">Argo CD 的适用场景&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>应用程序及其部署环境的配置是声明性的，并且是版本可控的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序部署和生命周期管理简单、可自动和可审计（企业友好）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序部署快速、可靠和幂等；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要检测并纠正与版本控制配置的任何偏差；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>回滚简单；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="argo-cd-的主要功能">Argo CD 的主要功能&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>可搭配使用各种配置管理工具（如 ksonnet/jsonnet、Helm 和 kustomize）使应用程序与 Git 中定义的保持一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将应用程序自动部署到指定的目标环境；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>持续监控已部署的应用程序；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于 Web 和 CLI 的操作，以及应用程序可视化；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署或回滚到 Git 仓库中提交的应用程序的任何状态（这也是使用 Git 进行版本管理的一大好处）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PreSync、Sync、PostSync hooks 以支持复杂的应用程序部署策略（例如：blue/green 、canary upgrades）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SSO 集成（OIDC、LDAP、SAML 2.0、GitLab、Microsoft、LinkedIn），这些是企业比较需要的功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Webhook 集成（GitHub、BitBucket、GitLab）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以独立使用，也可以作为现有 Pipeline 的一部分使用，例如与 Argo Workflow、Jenkins 以及 GitLab CI 等配合使用；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="argo-cd-架构">Argo CD 架构&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2021/12/19/jql6DZiAV92XWGT.png" alt="img">&lt;/p>
&lt;p>从整体上看，Argo CD 有三个主要的组成部分：API Server 、Repository Server 、Application Controller。&lt;/p>
&lt;h3 id="api-server">API Server&lt;/h3>
&lt;p>Argo CD 的 API Server 是一个 gRPC/REST server，它公开 Web UI、CLI 以及一些其他场景需要用到的 API。&lt;/p>
&lt;p>它主要进行以下几个内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>应用程序管理和状态报告；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用应用程序操作（例如：同步、回滚、用户定义的操作）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>repository 和集群 credential 管理（存 K8s secrets）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>身份验证和授权委托给外部身份认证组件；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RBAC（&lt;strong>Role-based access control&lt;/strong> 基于角色的访问控制）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Git webhook 事件的 listener/forwarder；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="repository-server">Repository Server&lt;/h3>
&lt;p>Repository Server 是一个内部服务，它负责保存应用程序 Git 仓库的本地缓存，并负责生成和返回可供 Kubernetes 使用的 manifests，它接受的输入信息主要有以下内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>仓库地址（URL）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>revision（commit, tag, branch）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用程序路径&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模板的特定设置：比如 helm values.yaml 等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="application-controller">Application Controller&lt;/h3>
&lt;p>Application Controller 是一个 Kubernetes controller，它持续监听正在运行的应用程序并将当前的实时状态与所需的目标状态（如 repo 中指定的）进行比较。它检测 OutOfSync 应用程序状态并有选择地采取纠正措施。它负责为生命周期事件（PreSync、Sync、PostSync）调用任何用户定义的 hooks。&lt;/p>
&lt;h2 id="argo-cd-的主要特性">Argo CD 的主要特性&lt;/h2>
&lt;p>自2019年3月17号发布了 &lt;a href="https://github.com/argoproj/argo-cd/releases/tag/v1.0.0">v1.0.0&lt;/a> 版本开始，到现在，Argo CD已经全面进入了 v2.x 时代，当前最新的版本是 v2.1.5。&lt;/p>
&lt;p>在 2.0 中引入了Pods View功能、重写了日志可视化、新增了通知横幅功能、还有很多后台操作及自定义操作，并且致力于打造 Argo CD Core （轻量级 Argo CD 发行版，仅打包核心 GitOps 功能，依赖Kubernetes API/RBAC 为 UI 和 CLI 提供支持）。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Pods View ：对于拥有数百个 Pod 的应用程序特别有用。它没有可视化应用程序的所有 Kubernetes 资源，而是仅显示 Kubernetes pod 和密切相关的资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新日志可视化：支持分页、过滤、禁用/启用日志流的能力，甚至为终端爱好者提供暗模式。支持查看多个部署 Pod 的聚合日志，Argo CD CLI 也支持日志流。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UI通知横幅功能：使用ConfigMap 中的ui.bannercontent和ui.bannerurl属性指定通知消息和可选 URL argocd-cm。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后台操作：资源的deletion/pruning、仅同步更改的资源、Prune Last、引入了对 &lt;a href="https://github.com/external-secrets/kubernetes-external-secrets">Sealed-&lt;/a>&lt;a href="https://github.com/bitnami-labs/sealed-secrets">secrets&lt;/a>、&lt;a href="https://github.com/external-secrets/kubernetes-external-secrets">kubernetes-external-secrets&lt;/a> 和 &lt;a href="https://github.com/strimzi">strimzi&lt;/a> CRD 的健康检查。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="部署-argo-cd">部署 Argo CD&lt;/h2>
&lt;p>Argo CD 有四种安装方式：多租户（multi-tenant）、 core 、自定义 、Helm。&lt;/p>
&lt;h3 id="多租户multi-tenant">多租户（multi-tenant）&lt;/h3>
&lt;p>多租户是 Argo CD 使用最多的部署方式。用户可以使用 Web UI 或 argocd CLI 通过 API Server访问 Argo CD 。&lt;/p>
&lt;p>该 argocd CLI 必须先执行 &lt;code>argocd login &amp;lt;server-host&amp;gt;&lt;/code>命令。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">argocd login SERVER [flags]
## Login to Argo CD using a username and password
argocd login cd.argoproj.io
## Login to Argo CD using SSO
argocd login cd.argoproj.io --sso
## Configure direct access using Kubernetes API server
argocd login cd.argoproj.io --core
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在项目的 GitHub 仓库中默认提供了两种部署方式（manifests）：&lt;/p>
&lt;h4 id="非高可用">非高可用&lt;/h4>
&lt;p>这种类型的安装通常用于演示和测试。（不推荐用于生产）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml">install.yaml&lt;/a> - 具有集群管理员权限的标准 Argo CD 安装。可使用 Argo CD 在其运行的同一集群中部署应用程序，当然也可以使用输入的 credentials 部署到外部集群。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/namespace-install.yaml">namespace-install.yaml&lt;/a> - 只需要命名空间级别的权限（不需要集群管理员权限）。但这种安装的话 Argo CD 不能在其所运行的同一集群中部署应用程序，并且将仅依赖于输入的外部集群 credentials 。&lt;/p>
&lt;p>注意：Argo CD CRD 不包含在 &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/namespace-install.yaml">namespace-install.yaml 中&lt;/a> 必须单独安装。CRD manifests 位于&lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/crds">manifests/crds&lt;/a>目录中。使用以下命令安装它们：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -k https://github.com/argoproj/argo-cd/manifests/crds&lt;span class="se">\?&lt;/span>ref&lt;span class="se">\=&lt;/span>stable
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="高可用">高可用&lt;/h4>
&lt;p>强烈建议生产环境使用高可用方式安装。&lt;/p>
&lt;p>bundle 包含相同的组件，但针对高可用性和弹性进行了调整。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/install.yaml">ha/install.yaml&lt;/a> - 与上文中提到的 install.yaml 相同，但配置了相关组件的多个副本；&lt;/li>
&lt;li>&lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/namespace-install.yaml">ha/namespace-install.yaml&lt;/a> - 与上文提到的 namespace-install.yaml 相同，但配置了相关组件的多个副本；&lt;/li>
&lt;/ul>
&lt;h3 id="core">core&lt;/h3>
&lt;p>core 安装最适合独立使用 Argo CD 且不需要多租户功能的集群管理员。&lt;/p>
&lt;p>此安装包括较少的组件，并且更易于设置。bundle 不包括 API Server或 UI，并只安装每个组件的轻量级（非 HA）版本。&lt;/p>
&lt;p>用户需要 Kubernetes 访问权限来管理 Argo CD。该 argocd CLI 必须使用下面的命令进行配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">kubectl config set-context --current --namespace=argocd
argocd login --core
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Web UI 也可以使用，可以使用以下命令启动。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">argocd admin dashboard
&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体的 manifests 对应于仓库中的 &lt;a href="https://github.com/argoproj/argo-cd/blob/master/manifests/core-install.yaml">core-install.yaml&lt;/a> 。&lt;/p>
&lt;h3 id="自定义安装">自定义安装&lt;/h3>
&lt;p>Argo CD manifests 也可以使用自定义安装。建议将 manifests 作为远程资源包含在内，并使用 Kustomize 补丁应用其他自定义。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-plain" data-lang="plain">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: argocd
resources:
- https://raw.githubusercontent.com/argoproj/argo-cd/v2.0.4/manifests/ha/install.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="helm">Helm&lt;/h3>
&lt;p>Argo CD 可以使用&lt;a href="https://helm.sh/">Helm&lt;/a>安装。Helm chart 目前由社区维护，访问 &lt;a href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd">https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd&lt;/a> 获取即可，此处不再添加示例。&lt;/p>
&lt;h2 id="argo-cd-的-secret-管理">Argo CD 的 Secret 管理&lt;/h2>
&lt;p>Argo CD 没有明确限制 Secret 管理的方式。这里罗列些 GitOps 的管理 Secret 的方式，对其他场景也适用：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.vaultproject.io/">Hashicorp Vault&lt;/a> 推荐，这是一种比较通用的方案，并且应用场景很广泛。（https://www.vaultproject.io/）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/bitnami-labs/sealed-secrets">Bitnami Sealed Secrets&lt;/a> 将 Secret 加密为可安全存储的 SealedSecret，甚至可以存储到公共库中；SealedSecret 只能由运行在目标集群中的控制器解密，其他人（甚至原作者）都无法从 SealedSecret 中获取原始 Secret。（https://github.com/bitnami-labs/sealed-secrets）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/banzaicloud/bank-vaults">Banzai Cloud Bank-Vaults&lt;/a> 为 Vault 提供各种工具，使 Hashicorp Vault 的使用和操作更容易。它是官方 Vault 客户端的封装，具有自动令牌更新和内置 Kubernetes 支持、基于Golang 的客户端的动态数据库凭据提供程序。它有一个 CLI 工具来自动初始化、解封和配置 Vault。它还提供了一个用于配置的 Kubernetes operator，以及一个用于注入机密的 mutating webhook。（https://github.com/banzaicloud/bank-vaults）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/jkroepke/helm-secrets">Helm Secrets&lt;/a> 与Argo CD的集成是从 helm-secrets v3.9.0 开始可用;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/IBM/argocd-vault-plugin">argocd-vault-plugin&lt;/a> 从各种 secrets 管理工具（HashiCorp Vault、IBM Cloud Secrets Manager、AWS Secrets Manager 等）中检索 secrets 并将它们注入到 Kubernetes 资源中（https://github.com/IBM/argocd-vault-plugin）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kustomize/blob/fd7a353df6cece4629b8e8ad56b71e30636f38fc/examples/kvSourceGoPlugin.md#secret-values-from-anywhere">Kustomize secret generator plugins&lt;/a> Kubernetes &lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#configmap-v1-core">ConfigMaps&lt;/a>和&lt;a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#secret-v1-core">Secrets&lt;/a>都是 key:value (KV) 映射。kustomize 有三种不同的方法来从本地文件生成 secrets，详细可查看链接 。（https://github.com/kubernetes-sigs/kustomize/blob/fd7a353df6cece4629b8e8ad56b71e30636f38fc/examples/kvSourceGoPlugin.md#secret-values-from-anywhere）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/mumoshu/aws-secret-operator">aws-secret-operator&lt;/a> 一个 Kubernetes operator，可根据 AWS Secrets Manager 中存储的内容自动创建和更新 Kubernetes secrets。aws-secret-operator 自定义资源将 AWS secrets映射到 Kubernetes 。（https://github.com/mumoshu/aws-secret-operator）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver">secrets-store-csi-driver&lt;/a> 是一个利用 CSI 接口，将密钥信息挂载进 Pod 的工具。支持多种密钥存储方式，比如 Vault，GCP，AWS，Azure 等；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="资源健康评估">资源健康评估&lt;/h2>
&lt;p>Argo CD 为几种标准的 Kubernetes 资源提供了内置的健康评估，然后将这些评估作为一个整体呈现在整体应用程序健康状态中。&lt;/p>
&lt;p>对以下几种类型的 Kubernetes 资源进行检查：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Deployment，ReplicaSet，StatefulSet，DaemonSet&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Service&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ingress&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PersistentVolumeClaim&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Argocd App&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>也可以添加自定义的健康检查，Argo CD 支持用 &lt;a href="https://www.lua.org/">Lua&lt;/a> 编写自定义健康检查，支持两种配置方式：&lt;/p>
&lt;p>1） 在argocd-cm 这个 ConfigMap 中定义自定义健康检查&lt;/p>
&lt;p>可以在 &lt;code>argocd-cm&lt;/code> 的 &lt;code>resource.customizations.health.&amp;lt;group_kind&amp;gt;&lt;/code>字段中定义自定义健康检查。&lt;/p>
&lt;p>2） 捆绑到 Argo CD 中。自定义健康检查脚本位于 &lt;a href="https://github.com/argoproj/argo-cd/tree/master/resource_customizations">https://github.com/argoproj/argo-cd/tree/master/resource_customizations&lt;/a> 目录中。&lt;/p>
&lt;p>以上就是关于 Argo CD 的核心内容了，下一篇我们将进行 Argo CD 的实践。欢迎大家继续关注和反馈！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/GitOps/" term="GitOps" label="GitOps"/></entry><entry><title type="text">GitOps 应用实践系列 - 综述</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/10/19/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E7%BB%BC%E8%BF%B0/"/><id>https://moelove.info/2021/10/19/GitOps-%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97-%E7%BB%BC%E8%BF%B0/</id><updated>2021-11-02T16:57:46+08:00</updated><published>2021-10-19T20:56:29+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 接下来会为大家带来一个 GitOps 的应用实践系列文章，这是第一篇。 什么是 GitOps 首先我们来了解下 GitOps： GitOps 最早是在20……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>接下来会为大家带来一个 GitOps 的应用实践系列文章，这是第一篇。&lt;/p>
&lt;h1 id="什么是-gitops">什么是 GitOps&lt;/h1>
&lt;p>首先我们来了解下 GitOps：&lt;/p>
&lt;p>GitOps 最早是在2017年由 Weaveworks 创立提出，它是一种进行 Kubernetes 集群管理和应用程序交付的方式。 GitOps 使用 Git 作为声明性基础设施和应用程序的单一事实来源。 GitOps 的核心思想是拥有一个 Git repository，包含目标环境中当前所需基础设施的&lt;strong>声明性&lt;/strong>描述，以及使目标环境与 Git repository 中描述的状态相匹配的自动化过程。借助 GitOps，可以针对 Git repository 与集群中运行的内容之间的任何差异发出警报，如果存在差异，Kubernetes reconcilers会根据情况自动更新或回滚集群。 以 Git 作为 pipeline 的中心，开发人员可以使用自己熟悉的工具发出PR，以加速和简化 Kubernetes 中应用程序部署和操作任务。&lt;/p>
&lt;p>这使得 GitOps 在 Twitter 和 KubeCon 上引起了不小的轰动。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/02/diSXjoQ6TGONA8f.png" alt="img">&lt;/p>
&lt;p>这里说一下Weaveworks 这家公司，这是一家为开发人员提供最高效的方式来连接、观察和控制 Docker 容器的公司。在官网上，我们能看到，GitOps 工作流的原则和模式，如何实现它们在生产中大规模运行 Kubernetes， 以及GitOps 和基础设施即代码 (IAC) 配置管理工具之间的区别和最佳实践等等。https://www.weave.works/technologies/gitops/&lt;/p>
&lt;p>K8S的创始人之一：&lt;a href="https://twitter.com/kelseyhightower/status/953638870888849408">Kelsey Hightower&lt;/a> 曾发推文评论过 GitOps是基于声明式基础设施的版本化 CI/CD， 停止脚本化操作，开始（自动化）分发。&lt;/p>
&lt;h1 id="gitops-是如何工作的呢">GitOps 是如何工作的呢？&lt;/h1>
&lt;h2 id="把环境配置作为-git-repository">把环境配置作为 Git repository&lt;/h2>
&lt;p>GitOps 以代码库为核心来组织部署。 我们需要至少有两个仓库：应用程序库和环境配置库。 应用程序库包含应用程序的源代码和部署应用程序的 manifests。 环境配置库包含部署环境当前所需基础架构的所有部署manifests。 它描述了哪些应用程序和基础设施服务（消息代理、服务网格、监控工具等）应该在部署环境中以何种配置和版本运行等内容。&lt;/p>
&lt;h2 id="基于-push-与基于-pull-的部署">基于 push 与基于 pull 的部署&lt;/h2>
&lt;p>两种部署类型之间的区别在于如何确保部署环境与所需的基础架构相同。这里推荐，&lt;strong>首选基于 pull 的方法&lt;/strong>，实现 GitOps 更安全、也有很多已有的最佳实践来借鉴。&lt;/p>
&lt;h3 id="基于-pull-的部署">基于 pull 的部署&lt;/h3>
&lt;p>传统的 CI/CD pipeline由外部事件触发，比如新代码被推送到应用程序库时，就触发了。&lt;/p>
&lt;p>而基于 Pull 的部署方法，引入了operator。 它通过不断将环境配置库中的期望状态与部署环境中的实际状态进行比较来接管pipeline的角色。 当发现差异时，operator会更新部署环境中的状态以匹配环境配置库。 此外，它还可以监控 image registry ，以查找要部署的新镜像版本。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/02/XwlgxTj6cBUYdaf.png" alt="img">&lt;/p>
&lt;p>基于 pull 模型的部署不仅能做到环境配置库更改时更新环境；&lt;/p>
&lt;p>operator也能做到当实际环境与环境配置库中存在差异时进行还原。&lt;/p>
&lt;p>这就确保了所有更改都可以在 Git 日志中进行跟踪，因为任何人都不允许对集群进行直接更改。&lt;/p>
&lt;p>那么，这种方式的监控点就集中在 operator 及各个组件上了（比如，镜像仓库是否能正常拉取到镜像等等）。&lt;/p>
&lt;p>为了避免基于 Push 场景中的上帝模式权限问题，operator 应该始终与要部署的应用程序在同一环境或集群中。（k8s RBAC授权：Kubernetes 从 1.6 开始支持基于角色的访问控制机制（Role-Based Access，RBAC），集群管理员可以对用户或 service account 的角色进行更精确的资源访问控制。在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。）&lt;/p>
&lt;h3 id="基于-push-的部署">基于 push 的部署&lt;/h3>
&lt;p>基于 Push 的部署策略可以利用流行的 CI/CD 工具来实现，例如 Jenkins、CircleCI 或 Travis CI。 应用程序的源代码与部署的应用程序所需的 Kubernetes YAML 一起存在于应用程序库中。 每当更新应用程序代码时，都会触发构建pipeline，构建容器镜像，最后使用新的部署manifest，更新环境配置库。&lt;/p>
&lt;p>也可以将 YAML 的模板存储在应用程序库中。 构建新版本时，可以使用模板在环境配置库中生成 YAML。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/02/1wrJ7eDQ56GZsEU.png" alt="img">&lt;/p>
&lt;p>对环境配置库的更改会触发部署pipeline。pipeline负责将环境配置库中的所有manifests应用到基础设施。这就需要我们更关注部署权限细分及控制。同时，这种方式无法自动注意到环境及其所需状态的任何偏差。 我们需要额外的监控报警方式，来保障环境与环境存储库中描述的内容一致。&lt;/p>
&lt;h2 id="复杂应用环境">复杂应用环境&lt;/h2>
&lt;p>对于大多数应用程序来说，只使用一个应用程序库和一个环境配置库是不现实的。GitOps 也能应对。可以设置多个构建 pipeline 来更新环境配置库。 然后就像上两个描述过程一样，自动化 GitOps 工作流程开始并部署应用程序。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/11/02/mz8Le3duSOAlUXt.png" alt="img">&lt;/p>
&lt;p>我们需要在环境配置库中使用独立的分支，来管理多个环境。 选择设置 operator 或者构建pipeline，自动化 GitOps 工作流程开始并部署应用程序。&lt;/p>
&lt;p>Tips：&lt;/p>
&lt;p>1.不使用k8s的环境也可以考虑使用 GitOps。（目前大多数基于 pull 的 GitOps 都是在Kubernetes 下实现的。）&lt;/p>
&lt;p>2.密码。永远不要在 git 中以纯文本形式存储密码！在 K8s 生态系统中，有工具支持这种加密。(比如 Vault)&lt;/p>
&lt;p>3.dev、qa、prod环境不能直接能用 GitOps 来处理，可以考虑引入 CI/CD pipeline 来管理环境。&lt;/p>
&lt;p>4.DevOps 与GitOps 不冲突。DevOps 是关于组织中的文化变革，可以使程序员及系统维护者们更好地合作。而GitOps 是一种实现持续交付的技术。如果已经在推进 DevOps 那么可能会更好接入 GitOps。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/GitOps/" term="GitOps" label="GitOps"/></entry><entry><title type="text">【译】Lima：Docker Desktop for Mac 的免费开源且自由的替代品</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/09/05/%E8%AF%91LimaDocker-Desktop-for-Mac-%E7%9A%84%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E4%B8%94%E8%87%AA%E7%94%B1%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/"/><id>https://moelove.info/2021/09/05/%E8%AF%91LimaDocker-Desktop-for-Mac-%E7%9A%84%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E4%B8%94%E8%87%AA%E7%94%B1%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/</id><updated>2021-09-06T13:29:47+08:00</updated><published>2021-09-05T10:39:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">近期，Docker Inc. 公司突然修改了其产品定价和策略，Docker Desktop for Mac/Win 不再 免费 供大型企业内个人使用。 关于此新闻中涉及的条款，这里……</summary><content type="html">&lt;p>近期，Docker Inc. 公司突然修改了&lt;a href="https://www.docker.com/blog/updating-product-subscriptions/" title="Docker 新的产品定价策略公告">其产品定价和策略&lt;/a>，Docker Desktop for Mac/Win 不再 &lt;strong>免费&lt;/strong> 供大型企业内个人使用。&lt;/p>
&lt;p>关于此新闻中涉及的条款，这里就不再展开介绍了。我来为大家介绍 &lt;strong>一款免费、自由、开源的 Docker for Mac 替代品，&lt;a href="https://github.com/containerd/containerd" title="containerd">containerd&lt;/a> &amp;amp; &lt;a href="https://github.com/lima-vm/lima" title="Lima">Lima&lt;/a>&lt;/strong> 。&lt;/p>
&lt;p>你只需要执行以下命令即可快速体验：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ brew install lima
$ limactl start
$ lima nerdctl run -it --rm alpine
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意：如果是 Arm 版的 Mac 则需要安装一个额外的 QEMU 的 patch ，请参考 &lt;a href="https://github.com/lima-vm/lima#getting-started">Lima 的文档&lt;/a>。&lt;/p>
&lt;h2 id="什么是-containerd--什么是-nerdctl-">什么是 containerd ? 什么是 nerdctl ?&lt;/h2>
&lt;p>&lt;a href="https://github.com/containerd/containerd">containerd&lt;/a> 是一个开源的容器运行时，被很多项目所使用，包括 Docker，和很多云厂商默认配置的 Kubernetes 集群，例如 AKS， EKS 和 GKE。&lt;/p>
&lt;p>由于 &lt;a href="https://containerd.io/scope/" title="containerd 项目的核心目标">containerd 项目的核心范围仅限于非面向用户的区域&lt;/a>，因此用户很难直接与 containerd 进行交互。所以我们近期贡献了一个人性化的 CLI 作为 containerd 的非核心子项目：&lt;a href="https://github.com/containerd/nerdctl" title="nerdctl">nerdctl&lt;/a> 。&lt;/p>
&lt;p>nerdctl 的功能和用法几乎与 Docker CLI 相同，但是 nerdctl 还支持 Docker 中不存在的几个 containerd 的前沿功能。此类功能包括但不限于 &lt;a href="https://github.com/containerd/nerdctl/blob/master/docs/stargz.md">延迟拉取(stargz)&lt;/a> 和 &lt;a href="https://github.com/containerd/nerdctl/blob/master/docs/ocicrypt.md">运行加密镜像（ocicrypt）&lt;/a>。&lt;/p>
&lt;p>有关更多输 nerdctl 的内容可参考之前的文章：&lt;a href="https://medium.com/nttlabs/nerdctl-359311b32d0e">nerdctl: Docker-compatible CLI for contaiNERD&lt;/a>&lt;/p>
&lt;h2 id="什么是-lima">什么是 Lima？&lt;/h2>
&lt;p>&lt;a href="https://github.com/lima-vm/lima">Lima（Linux MAchines）&lt;/a>可以启动具有自动文件共享、端口转发和使用 containerd 的 Linux 虚拟机。&lt;/p>
&lt;p>Lima 截至到 2021 年 9 月 1 日时已经在 GitHub 上获得了 3k star 。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/05/MGQxt31A6vDo8sb.png" alt="img">&lt;/p>
&lt;p>我们最初创建 Lima 是为了向 Mac 用户推广 containerd 和 nerdctl ，但是 Lima 也可以用于其他的容器引擎，例如 Podman 甚至是非容器化的应用程序。&lt;/p>
&lt;p>Lima 的设计和 WSL2 类似，但 Lima 使用 MacOS 作为其主要的目标主机。Lima 目前不支持 Windows 主机，如果有需求，我们也可以考虑支持 Windows 系统。&lt;/p>
&lt;h3 id="lima-的技术细节">Lima 的技术细节&lt;/h3>
&lt;p>以下是 Lima 的技术细节，感谢的小伙伴可以看看：&lt;/p>
&lt;ul>
&lt;li>管理程序： QEMU， 带 &lt;code>hvf&lt;/code> （Hypervisor.framework）加速器；&lt;/li>
&lt;li>支持的 Guest 操作系统：Ubuntu (默认), Debian, Fedora, Alpine, Arch, and openSUSE；&lt;/li>
&lt;li>文件共享（host-&amp;gt;guset）：当前版本中使用的是 “Reverse SSHFS”，在将来可能会改变，可能会切换到 Samba；&lt;/li>
&lt;li>文件共享（guset-&amp;gt;host）：WebDAV over SSH（在 &lt;a href="https://github.com/lima-vm/sshwebdav">https://github.com/lima-vm/sshwebdav&lt;/a> 中实验）；&lt;/li>
&lt;li>端口转发： &lt;code>ssh -L&lt;/code> 有一个 agent 进程在 guest 中监听 &lt;code>/proc/net/tcp*&lt;/code> ；&lt;/li>
&lt;li>网络：默认在用户空间使用 “slirp”。同时也支持通过 sudo 和 VDE 使用 &lt;code>vmnet.framework&lt;/code> 的高级网络配置，参考 &lt;a href="https://github.com/lima-vm/vde_vmnet">https://github.com/lima-vm/vde_vmnet&lt;/a> ；&lt;/li>
&lt;li>安全：在设计上不需要使用宿主机上的 root 权限，除了可选的 &lt;code>vmnet.framework&lt;/code> 支持；&lt;/li>
&lt;/ul>
&lt;h2 id="快速开始">快速开始&lt;/h2>
&lt;h3 id="安装-lima">安装 Lima&lt;/h3>
&lt;p>如果你使用的是 Intel Mac，只要运行如下 &lt;code>brew&lt;/code> 命令即可完成：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ brew install lima
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你使用的 Arm Mac（M1），当前你需要安装&lt;a href="https://lore.kernel.org/qemu-devel/20210519202253.76782-1-agraf@csgraf.de/">一个 QEMU 的 path 版本&lt;/a>才能启用 &lt;code>hvf&lt;/code> 加速，该补丁可能在不久之后会合并到 QEMU 上游。请参考 &lt;a href="https://github.com/lima-vm/lima#getting-started">Lima 的文档&lt;/a>&lt;/p>
&lt;h3 id="启动-lima">启动 Lima&lt;/h3>
&lt;p>执行 &lt;code>limactl start&lt;/code> 并按下回车选择 &lt;code>Proceed with the default configuration&lt;/code> ，稍等几分钟，Lima 会自动完成下载 VM 镜像和启动虚拟机。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ limactl start
? Creating an instance &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span> &lt;span class="o">[&lt;/span>Use arrows to move, &lt;span class="nb">type&lt;/span> to filter&lt;span class="o">]&lt;/span>
&amp;gt; Proceed with the default configuration
Open an editor to override the configuration
Exit
...
INFO&lt;span class="o">[&lt;/span>0111&lt;span class="o">]&lt;/span> READY. Run &lt;span class="sb">`&lt;/span>lima&lt;span class="sb">`&lt;/span> to open the shell.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在看到 &lt;code>READY&lt;/code> 输出后，执行 &lt;code>lima uname -a&lt;/code> 来确认虚拟机已经在运行了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ lima uname -a
Linux lima-default 5.11.0-31-generic &lt;span class="c1">#33-Ubuntu SMP Wed Aug 11 13:19:04 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-lima-nerdctl-构建和运行一个容器">使用 &lt;code>lima nerdctl&lt;/code> 构建和运行一个容器&lt;/h3>
&lt;p>在宿主机上创建一个文件 &lt;code>~/lima-test/Dockerfile&lt;/code> 并写入以下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> nginx&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;hello lima&amp;#34;&lt;/span> &amp;gt; /usr/share/nginx/html/index.html&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用如下命令构建一个名为 &lt;code>lima-test&lt;/code> 的容器镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ lima nerdctl build -t lima-test ~/lima-test
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lima 将主机的家目录挂载到 guest 文件系统，所以 guest 中的 &lt;code>nerdctl&lt;/code> 可以无缝的访问主机上的 &lt;code>~/lima-test&lt;/code> 目录。为了安全起见，家目录默认被挂载为只读，但是也可以通过在执行 &lt;code>limactl start&lt;/code> 时，通过修改配置来实现可读写模式的挂载。&lt;/p>
&lt;p>刚才构建好的 &lt;code>lima-test&lt;/code> 镜像可通过如下命令进行启动：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ lima nerdctl run -d -p 127.0.0.1:8080:80 lima-test
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lima 将 guest VM 上已经映射了容器中 80 端口的地址 &lt;code>127.0.0.1:8080&lt;/code> 映射到宿主机上的 &lt;code>127.0.0.1:8080&lt;/code> ，所以你可以直接在 Safari 中打开 &lt;a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/&lt;/a> 进而访问到 &lt;code>lima-test&lt;/code> 容器。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/05/exTksJN1ZCfXoEt.png" alt="通过 Safari 访问到 guest VM">&lt;/p>
&lt;h2 id="rancher-desktop--gui">Rancher Desktop &amp;amp; GUI&lt;/h2>
&lt;p>&lt;a href="https://github.com/rancher-sandbox/rancher-desktop">Rancher Desktop&lt;/a> 已经适配了 Lima ，以便在 macOS 上运行 k3s 。(我在之前的 『K8S生态周报』中曾为大家介绍过此项目)&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/05/z6evkARfEjGOI1D.png" alt="安装 Rancher Desktop">&lt;/p>
&lt;p>尽管 Lima 和 nerdctl 它们目前不包含 GUI 控制面，但是 Rancher Desktop 已经使用 Electron 提供了一个很酷的 GUI 。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/05/OWpytz4SrDIV6ws.png" alt="Rancher Desktop v0.4.1">&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/05/EqbpuNJ31lw4Pem.png" alt="Rancher Desktop 在后台运行 Lima ">&lt;/p>
&lt;p>未来，上游的 Lima 和 nerdctl 可能也会有自己的 GUI ，这取决于来自社区的需求（和贡献）。&lt;/p>
&lt;p>&lt;em>原文地址：https://medium.com/nttlabs/containerd-and-lima-39e0b64d2a59&lt;/em>
&lt;em>经原作者 Akihiro Suda 授权翻译&lt;/em>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/containerd/" term="containerd" label="containerd"/></entry><entry><title type="text">开源浪潮下程序员的职业规划和成长</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/08/27/%E5%BC%80%E6%BA%90%E6%B5%AA%E6%BD%AE%E4%B8%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%92%8C%E6%88%90%E9%95%BF/"/><id>https://moelove.info/2021/08/27/%E5%BC%80%E6%BA%90%E6%B5%AA%E6%BD%AE%E4%B8%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%92%8C%E6%88%90%E9%95%BF/</id><updated>2021-08-27T12:35:28+08:00</updated><published>2021-08-27T12:39:40+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 无论从年初开源社发布的《2020 中国开源年度报告》还是整体的大环境，不难看到中国的开源正在崛起，越来越多的来……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>无论从年初开源社发布的《2020 中国开源年度报告》还是整体的大环境，不难看到中国的开源正在崛起，越来越多的来自中国的开源项目和开发者们正在走入大家的视野。在开源浪潮的大趋势下，程序员又该如何规划自己的职业以及个人成长呢？不如听听正在全职做开源的工程师张晋涛怎么说。&lt;/p>
&lt;blockquote>
&lt;p>本文根据张晋涛在又拍云 Open Talk 技术沙龙北京站主题演讲《开源浪潮下程序员的职业规划和成长》整理而成，现场视频及 PPT 可下拉文末点击阅读原文查看。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>张晋涛，支流科技云原生技术专家，Apache APISIX committer, Kubernetes ingress-nginx reviewer，containerd/Docker/Helm/Kubernetes/KIND 等众多开源项目 contributor，对 Docker 和 Kubernetes 等容器化技术有大量实践和深入源码的研究，著有 《Kubernetes 上手实践》和 《Docker 核心知识必知必会》等专栏。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，今天我分享的主题是《开源浪潮下程序员的职业规划和成长》。今天在这里聊两个项目，一个是 Apache APISIX，APISIX 是 Apache 基金会旗下的顶级开源项目。第二个项目是 ingress-nginx，它是 Kubernetes 整个生态圈里头，除去 Kubernetes 自身以外使用频率最高的软件之一了。搞过 Kubernetes 的同学应该基本上都用过这个项目。&lt;/p>
&lt;p>今天我分享的内容主要从四个方面来聊：&lt;/p>
&lt;ul>
&lt;li>开源的文化&lt;/li>
&lt;li>如何参与开源&lt;/li>
&lt;li>关于我的故事&lt;/li>
&lt;li>职业规划相关的内容&lt;/li>
&lt;/ul>
&lt;h1 id="了解开源文化">了解开源文化&lt;/h1>
&lt;h2 id="自由软件运动">自由软件运动&lt;/h2>
&lt;p>提到开源文化，首先需要了解自由软件运动。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/08/27/VTUujOarwgL2zFm.png" alt="img">&lt;/p>
&lt;p>图右是被称为自由软件之父的斯托曼，他在 1983 年提出了 GNU 计划。1984 年，斯托曼提出了 Copyleft 的概念，Copyleft 跟我们平时用到的版权 Copyright 是相对应的，它放弃了 Copyright 类似对版权的严格限制。&lt;/p>
&lt;p>1985 年，斯托曼成立了自由软件基金会，目的是为了能够让自由软件更好地发展。在当时，很多软件都是专有软件或者商用软件，任何人使用这些软件都是需要付费的。斯托曼认为随着计算机的发展，如果商用软件、付费软件掌握在极少数公司的情况下，那么我们将会逐步失去自由。因为很多商业软件或者专用软件都是由商业公司，或者是极少数的人掌握着，如果你依赖这些软件，都必须依赖于其他人，你的命脉就掌握在了他们手中，就不可能获得自由。&lt;/p>
&lt;p>1989 年，出现了第一个 GNU 的通用协议，叫做 GPL。&lt;/p>
&lt;p>接下来，我们来看下在自由软件运动之后发生了什么事情。想必大家都接触过 Linux 操作系统。Linux 操作系统的创始人是林纳斯·托瓦兹，他在 1991 年首次发布了 Linux 操作系统，并且选择了将它的源代码直接发布到网络上，供其他人去使用和分享。&lt;/p>
&lt;p>在这个时候，斯托曼找到了林纳斯。GNU 自由软件基金会的主要目标是希望能够创建出所有人都可以使用的基础软件，包括操作系统。直到 1991 年 Linux 操作系统发布的时候，GNU 自由软件基金会已经完成了所有基础类的自由软件开发，但是它没完成最核心的操作系统的开发。所以，斯托曼找上了林纳斯。结果我们都知道，Linux 操作系统的完整名字是 GNU/Linux。&lt;/p>
&lt;h2 id="开源协作与文化">开源协作与文化&lt;/h2>
&lt;p>聊完自由软件运动、Linux 操作系统，来看下我们现在所接触到的开源协作和开源文化。&lt;/p>
&lt;h3 id="开放">开放&lt;/h3>
&lt;p>在开源协作中，基本的理念就是开放。但很多人可能对此有误解，认为开放源代码就等于开放，其实不然。源代码的开放和真正的开放并不一样。举个简单的例子：MongoDB。&lt;/p>
&lt;p>MongoDB 是一个文档类型的数据库。近几年，MongoDB 修改了一次协议 SSPL，称之为服务端公共许可证，协议更改之后有什么变化呢？它的协议规定任何一个云厂商，如果在云服务上使用了 MongoDB，就必须把在 MongoDB 之上所做的更改，包括管控端的源代码都开源出来。&lt;/p>
&lt;p>大家想一下这个事情可能吗？&lt;/p>
&lt;p>其实不可能，任何一个云厂商，它对所有基础软件，或者所有开源软件的变更，都是它的核心，是它的命脉。所以说，MongoDB 这一次修改其实是带有针对性的，它针对的是这些云厂商。在开源软件的基本协定之下，这其实属于不开放的协议。&lt;/p>
&lt;p>再有就是前段时间，Elasticsearch 也宣布其使用 SSPL，这导致 AWS 基于之前 Apache 协议的代码直接 fork 了一个版本，并称之为 OpenSearch 。这也是对这种不开放的行为的一种应对方式。&lt;/p>
&lt;h3 id="协同">协同&lt;/h3>
&lt;p>开源文化当中提到另外一点，就是协作。Linux 操作系统为什么能够获得成功？因为 1991 年的时候林纳斯发布了第一个 Linux 的版本，把源代码直接公开到了互联网上，其他人可以直接下载源代码，并且对这些源代码进行修改。&lt;/p>
&lt;p>在 1991 年，林纳斯发布完 Linux 第一个可供下载和使用的版本时，其实自由软件基金会旗下还有其他人也在写给 GNU 使用的内核，只是没有 Linux 的完成度高。&lt;/p>
&lt;p>为什么它没有发展起来呢？因为它是由固定的几个人在做这个事情，且仅有那么几个人，只有它真正对外公开发布了一个版本，外界才会了解到。这里就不得不提到一种思想，那就是大教堂与集市。这是一个什么概念呢？&lt;/p>
&lt;p>可以这样理解，传统的软件开发过程像大家在修建一个大教堂一样，只有极少数的精英工匠参与其中。而开源软件提倡的开放和协同，主要指将软件当成一个大集市，每个人都是自由的，大家都可以互相协作，每个人贡献自己的一份力量。有专门一本书，来阐述这些理念，就叫做《大教堂与集市》，感兴趣可以看看。&lt;/p>
&lt;h2 id="开源软件">开源软件&lt;/h2>
&lt;p>聊完开源理念，我们最后来说说开源软件。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/08/27/bI2HQaWx9ygTtMK.png" alt="img">&lt;/p>
&lt;p>开源软件的前提是开放源代码，这是必不可少的。另外，其实每个开源软件都是有开源许可证的，刚才我们聊 MongoDB 的时候也提到了，它的许可证是不被认可的。 &lt;strong>开源软件核心价值观就是不歧视、中立、开放。&lt;/strong>&lt;/p>
&lt;p>目前国内开源生态整体向好，有很多进入开源软件基金会的项目，无论是进入 Apache 软件基金会，还是 CNCF，亦或 Linux 的基金会。其中有很多的项目例如 ApacheAPISIX 就是 Apache 基金会旗下的顶级开源项目，通过 Apache-2.0 License 进行分发，这是一种非常开放且友好的协议。&lt;/p>
&lt;h1 id="如何参与开源">如何参与开源&lt;/h1>
&lt;p>很多人对于参与开源有一些误解。有些人认为，我在使用一个开源软件，并且在它的 GitHub 上面提交了 issue，提交了 pull request 之类的，认为就是在参与开源项目了。还有一些人认为，我写了一个软件或者程序，我把它放在 GitHub 上面，代码是公开的，认为自己在做开源了。其实不然（尽管我们也认可为开源项目所做的贡献）。&lt;/p>
&lt;p>&lt;strong>做开源的前提是基于你对开源文化的认同。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/08/27/qn5g4yIlRzjLX61.png" alt="img">&lt;/p>
&lt;p>开源文化的最主要是平等、中立、开放、一致、文档优先。一致是什么意思呢？意味着你的软件在这个环境和在另外一个环境当中产生的结果是一样的。&lt;/p>
&lt;p>那么如何选择一个开源项目呢？&lt;/p>
&lt;p>从我个人角度来讲， &lt;strong>首先一定是兴趣使然的&lt;/strong>。我不会选择一个自己并不太感兴趣的项目去参与。因为这样子是不可持续的。也有很多人问过我，参与开源你能收获什么？为什么你愿意花费那么多的时间和精力在这个事情上面？在参与开源项目的前期，或者很长的一段时间，其实没有任何收获，尤其是物质上的收获一点都没有。所以这也是我为什么提了一定是要自己感兴趣的。&lt;/p>
&lt;p>&lt;strong>其次，持续投入非常重要。&lt;/strong> 在一个开源项目中，如果你只是想起来了参与一下，而不是持续地投入，也不会有较高的价值产生。&lt;/p>
&lt;p>&lt;strong>最后，应该选择一个比较活跃的社区。&lt;/strong> 如果项目的社区已经非常的不活跃，你参与到这个项目当中就很难。比如你提交 issue，提交 pull request，很少有人会给你对应的回复。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/08/27/oYwRbz7d85uq9mj.png" alt="img">&lt;/p>
&lt;p>这里我选取了三个项目做对比，ApacheAPISIX、Kong 和 tyk。目前可以看到活跃度最高的是 Apache APISIX，每天都有很多的开发者会参与到 Apache APISIX 的社区中，帮助别人解答问题，或者为 Apache APISIX 提交 PR 等，大家彼此都会在这么活跃的社区中成长和收获。&lt;/p>
&lt;p>&lt;strong>开源协作的中立也是一种很重要的价值观。&lt;/strong> 无论你是提交代码，或者回复别人的 issue，这些我认为是其次的。最重要的是应该基于平等、尊重、中立的心态去参与到项目当中。&lt;/p>
&lt;p>我现在主要参与的是 Apache APISIX 当中的一个子项目 APISIX ingress，还有一个是 Kubernetes ingress-nginx。这两个项目都是 Kubernetes controller 的项目，做的事情是类似的，但是参与开源项目过程中，我始终保持着中立的态度，而不会因为我在支流科技就大力发展 APISIX ingress 项目，限制 ingress-nginx 项目的发展，这是不存在的。所以心态很重要，只有保持中立的心态才能持续地参与到开源项目当中。&lt;/p>
&lt;h1 id="聊聊我的故事">聊聊我的故事&lt;/h1>
&lt;h2 id="我的职业路径">我的职业路径&lt;/h2>
&lt;p>接下来聊一下我发展的过程和职业规划上的选择。&lt;/p>
&lt;p>我的第一份工作 title 是 Web 开发工程师，主要是在做后端开发，也会兼顾一部分的前端开发工作，以及运维及 DBA 的任务。第二份工作是在做运维开发，会涉及一部分的运维工作，主业也还是在做开发。再后来就是做容器化的开发，现在我是支流科技的技术专家，做的事情主要是做开源基础软件。这些年前端、后端、运维、数据库、中间件，基础软件，容器化技术基本都有涉及到，这是我的职业整体路线。&lt;/p>
&lt;p>很多人问过我这样的问题，特别是在跟 HR 沟通的时候。他们会问我，你为什么从 Web 开发做了运维开发，这是第一个时间点。第二个时间点，为什么从运维开发，到做基础软件以及全职做开源的事情。&lt;/p>
&lt;p>我做 Web 开发，大概是七八年前，那个时候像服务器通常是 32G 或者 64G 的内存。但是现在，我的笔记本已经是 32G 的内存了，可以想象当时硬件资源是比较紧张的。在实际做后端开发中，当业务量上来的时候，我们会去做很多性能优化相关的工作。&lt;/p>
&lt;p>那个时候，我们会花很多的时间去做优化，现在遇到性能的问题可能很简单，加一台机器扩容一下就搞定了。但在那个时候大家的第一想法就是做性能优化，怎么样可以充分地压榨资源，这是我们当时做的事情。在这个过程当中，偏底层的事情我做得更多些。&lt;/p>
&lt;p>在 2014 年，我开始接触 Docker。2013 年Docker 首次开源，我在国内算是比较早一批接触到 Docker 的。我很喜欢这些底层的技术，包括容器化的技术。在职业选择的时候，我就从 Web 开发转向了运维开发。做运维开发的时候，前期是做运维平台化的开发，运维平台化、运维自动化、包括 GitOps 和ChatOps 等等。&lt;/p>
&lt;p>随着 Kubernetes 在容器化编排技术争夺战中成为了王者。很多公司开始做容器化改造，我们也选择了 Kubernetes 做自己的容器平台。这个时候，由于我在容器化技术这方面，积淀相对比较多一些，自然也就承担了相关的工作内容。&lt;/p>
&lt;p>再后来工作的选择，因为我想要更多的自由，也想更倾向于自己的兴趣，而在公司做项目的话，确实不够自由，所以我现在的工作是全职做开源，我可以在任何一个我喜欢工作的时间，或者想要工作的时间去工作。&lt;/p>
&lt;p>&lt;strong>有一些人评价我说，我是把我的兴趣做成了我的工作&lt;/strong>。 其实是的，即使没有这份工作，我也会持续地去做开源。工作时间做开源，闲暇的时间也在做开源，这个本身来讲也没有什么界限。这是我目前的现状，自由、全职做开源的工程师。&lt;/p>
&lt;h2 id="职业规划">职业规划&lt;/h2>
&lt;p>接下来，我们来看一下职业规划。大家可能对于我到底是什么样的情况并不关心，更应该想知道在开源的场景里如何做职业规划。&lt;/p>
&lt;p>我现在一方面是做开源相关的工作，再有一方面，也在做自媒体。 &lt;strong>我认为做职业规划最重要的一点是基于自己的兴趣。&lt;/strong> 一天一共就 24 小时，除去睡觉的时间，剩下的几个小时如果做的是自己不感兴趣的工作，一直处于不开心的状态，那真是太惨了。 &lt;strong>所以一定要选择自己喜欢的感兴趣的工作，这是第一点。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第二点就是核心竞争力。&lt;/strong> 既然是程序员，无论是前端、后端、运维，还是其他开发，自身的技术实力才是核心竞争力。现在有个词很流行，那就是“内卷”，为什么内卷会让人产生焦虑感呢？焦虑到底是怎么来的？&lt;/p>
&lt;p>我是这么理解的，焦虑就是别人在学，我不学，我可能会很焦虑；别人会，我不会，我也会焦虑；别人知道，我不知道，那更焦虑；还有就是别人在聊这些，我听的一脸懵逼，这些都是焦虑的产生原因。&lt;/p>
&lt;p>那如何应对这个问题呢？那就是提升你的核心竞争力。首先选一个自己最感兴趣的方向，提升自己的技术深度，这样才能持续地提升自己的核心竞争力。技术深度就跟海面上的冰山差不多，海面上你可以看到的只有那么一小点，但在海面之下还有很多很多。&lt;/p>
&lt;p>技术的深度是无限的，当你把技术深度提升到一定程度之后，你会发现好像我不知道的东西越来越多，这是一个技术人常常会有的感觉。如果你很长时间没有这种感觉了，认为好像所有的东西我都知道，所有面临的问题我都能解决。这个情况我认为，你可能需要去参与一些开源项目，或者出去跟别人交流一下，或者换一份工作，开阔一下自己的眼界。 &lt;strong>当你的技术深度到了一定程度，例如能 cover 住面临的绝大多数问题时候，我建议你在这个时候尽量提升一下自己的技术广度。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第三点我要说的是价值。&lt;/strong> 价值这个概念非常宽泛，在做工作中最直观体现价值的，那就是薪资。当然，薪资只是一方面，另一方面在于你能够收获到什么。&lt;/p>
&lt;p>我们回到刚才第一点，也就是工作开不开心的事情。如果说你的工作薪资是令人满意的，同时你又能收获一些开心，那就赚到了。因为公司本来给你提供的，是一种雇佣关系，他给到你的本质上来讲只有你的薪资。而你做这份工作的同时，收获了一些乐趣，其实也就是赚到了。 &lt;strong>收获开心，这是我要提到价值当中的第一点。&lt;/strong>&lt;/p>
&lt;p>此外，在工作的过程当中，你肯定不是一个人在独自战斗， &lt;strong>你也会收获到一些伙伴，这是第二点&lt;/strong>。&lt;/p>
&lt;p>第三点，在这份工作当中，你还实现自己价值的提升。这些价值可以理解为心理学当中或者社会学当中提到的认可， &lt;strong>当你获得别人或者社会的一些认可&lt;/strong>。这也是价值的一部分。&lt;/p>
&lt;h2 id="程序员的副业">程序员的副业&lt;/h2>
&lt;p>最后我们来聊聊程序员的副业，这个事情也许大家会比较感兴趣一些。在谈到副业的时候，你要先评估一下自己能做什么，量力而行在任何情况下都是比较正确的。承认自己在某些方面不擅长，或者某些方面不太懂这个事情其实没有什么的，如果强行做不擅长的事情，可能得到的结果并不太好。&lt;/p>
&lt;p>我来聊一下我自己个人做的一些东西。我之前写了一个专栏，叫 《Kubernetes 上手实践》。后来又写了一个专栏，叫做 《Docker 核心知识必会》。我自己在这方面相对来说积累比较多一点，这里就不多说了，说多了就变成广告了（笑），不过你可以关注下我的公众号：MoeLove ，我会跟你分享一些有价值的技术和内容。&lt;/p>
&lt;p>很多人可能会问我能做什么？我认为其实还是有很多的事情可以做，具体肯定看个人的选择。做副业能为自己带来最直观的，大家可能认为是金钱收益。但实际上如果你把耗费的时间精力折算一下，可能会发现这个事情收益很少。陪陪家人、跟爱人约个会，出去玩一趟，可能能收获的更多。现在整体来说就是两种选择，一是用时间换钱，另一种是用钱换时间。很多事情如果年轻的时候错过了还是会很遗憾的。所以还是要建议大家根据自己的情况衡量一下。&lt;/p>
&lt;p>以上是今天的全部分享内容，来简单总结下：第一部分聊了平等、中立、自由的开源文化；接着谈了如何参与开源，心态一定要摆正，同时要基于自己个人的兴趣；最后聊到一些个人成长，还是建议大家应根据自己的实际情况，合理地规划一下自己的的职业生涯，谢谢大家。&lt;/p>
&lt;p>视频回放：https://www.upyun.com/opentalk/463.html&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/OpenSource/" term="OpenSource" label="OpenSource"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.22.0 正式发布，新特性一览！</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/08/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.22.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/><id>https://moelove.info/2021/08/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.22.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</id><updated>2021-08-05T07:20:31+08:00</updated><published>2021-08-05T05:23:50+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.22 已经在今天正式……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes v1.22 已经在今天正式发布了，这是 2021 年的第二个正式发布的版本。此版本中共包含 53 项增强更新，其中 13 项达到 stable，24 项达到 beta 还有 16 项为 alpha。当然，也有 3 项特性被标记为废弃。&lt;/p>
&lt;p>从今年的 4 月份，Kubernetes 的发布节奏由原来的每 3 个月一个版本修改成了每 4 个月一个版本，这也是第一个应用了此节奏的长周期版本。我们一起来看看有哪些值得注意的变更吧！&lt;/p>
&lt;h3 id="server-side-apply-特性达到-ga">Server-side Apply 特性达到 GA&lt;/h3>
&lt;p>&lt;a href="https://kubernetes.io/docs/reference/using-api/server-side-apply/">Server-side Apply&lt;/a> 这个特性主要目标是把逻辑从 &lt;code>kubectl apply&lt;/code> 移动到 kube-apiserver 中，这可以修复当前遇到的很多有关所有权冲突的问题。&lt;/p>
&lt;p>还记得在之前的『K8S生态周报』中我曾为你介绍过 Kubernetes 新增的 &lt;code>.meta.managedFields&lt;/code> 吗？Server-side Apply 当前就是通过此特性来跟踪对象字段的更改的。&lt;/p>
&lt;p>同时此特性的好处在与你可以直接通过 API 完成声明式配置的操作，而无需依赖于特定的 &lt;code>kubectl apply&lt;/code> 命令，比如直接通过 &lt;code>curl&lt;/code> 即可完成。&lt;/p>
&lt;p>此功能的用法如下：&lt;/p>
&lt;pre>&lt;code>kubectl apply --server-side [--dry-run=server]
&lt;/code>&lt;/pre>&lt;h3 id="pod-security-policy-的替代品">Pod Security Policy 的替代品&lt;/h3>
&lt;p>&lt;a href="https://github.com/kubernetes/website/blob/dev-1.22/content/en/docs/concepts/security/pod-security-admission.md">PodSecurity admission controller&lt;/a> 是&lt;a href="https://sysdig.com/blog/kubernetes-1-21-whats-new/#5">在 Kubernets v1.21 中被废弃的 Pod Security Policies &lt;/a> 的替代品。&lt;/p>
&lt;p>这个 admission controller 可以按 namespace 级别启用 &lt;a href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards&lt;/a> ，可以有以下三种模式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>enforce&lt;/strong>: 违反策略的 Pod 将被拒绝；&lt;/li>
&lt;li>&lt;strong>audit&lt;/strong>：违反策略的 Pod 将会添加审计注释，但其他情况下都允许；&lt;/li>
&lt;li>&lt;strong>warn&lt;/strong>：违反策略的 Pod 将会触发面向用户的警告；&lt;/li>
&lt;/ul>
&lt;p>可通过如下配置文件进行控制：&lt;/p>
&lt;pre>&lt;code>apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
configuration:
defaults: # Defaults applied when a mode label is not set.
enforce: &amp;lt;default enforce policy level&amp;gt;
enforce-version: &amp;lt;default enforce policy version&amp;gt;
audit: &amp;lt;default audit policy level&amp;gt;
audit-version: &amp;lt;default audit policy version&amp;gt;
warn: &amp;lt;default warn policy level&amp;gt;
warn-version: &amp;lt;default warn policy version&amp;gt;
exemptions:
usernames: [ &amp;lt;array of authenticated usernames to exempt&amp;gt; ]
runtimeClassNames: [ &amp;lt;array of runtime class names to exempt&amp;gt; ]
namespaces: [ &amp;lt;array of namespaces to exempt&amp;gt; ]
&lt;/code>&lt;/pre>&lt;h3 id="node-swap-支持">Node swap 支持&lt;/h3>
&lt;p>此特性现在是 Alpha 阶段。&lt;/p>
&lt;p>虽然 swap 并不够快，但是现在有很多场景都是需要用到它的，尤其是一些 Java 和 Node 应用。&lt;/p>
&lt;p>在 Kubernetes 的 issue 列表中有一个存在了 5 年左右的讨论，就是针对于能否开启 swap 支持的。当前这个特性一旦开启就是针对于整个 Node 的，并不能精确到某个 Pod 中。&lt;/p>
&lt;p>你可以通过如下步骤启用此特性：&lt;/p>
&lt;ul>
&lt;li>在 Node 中启用 swap；&lt;/li>
&lt;li>开启 kubelet 的 &lt;code>NodeMemorySwap&lt;/code> 特性；&lt;/li>
&lt;li>设置 &lt;code>--fail-on-swap=false&lt;/code>&lt;/li>
&lt;li>可选在 Kubelet 的配置中增加 &lt;code>MemorySwap.SwapBehavior=UnlimitedSwap&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>更多内容可参考：https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2400-node-swap&lt;/p>
&lt;h3 id="外部客户端凭证提供工具">外部客户端凭证提供工具&lt;/h3>
&lt;p>这个功能允许 client-go 使用外部工具进行身份验证，比如 LDAP、Kerberos、OAuth2、SAML 等。这个特性是从 v1.10 开始引入的。&lt;/p>
&lt;p>使用此特性的话，需要你在 kubeconfig 配置文件中作为 user 字段下的字段进行配置。比如：&lt;/p>
&lt;pre>&lt;code>apiVersion: v1
kind: Config
users:
- name: my-user
user:
exec:
command: &amp;quot;example-client-go-exec-plugin&amp;quot;
apiVersion: &amp;quot;client.authentication.k8s.io/v1beta1&amp;quot;
env:
- name: &amp;quot;FOO&amp;quot;
value: &amp;quot;bar&amp;quot;
args:
- &amp;quot;arg1&amp;quot;
- &amp;quot;arg2&amp;quot;
provideClusterInfo: true
clusters:
...
&lt;/code>&lt;/pre>&lt;p>在 &lt;code>user.exec&lt;/code>字段下配置可用的 client-go-exec plugin 即可。现在也有一个示例项目可供参考 &lt;a href="https://github.com/ankeesler/sample-exec-plugin">https://github.com/ankeesler/sample-exec-plugin&lt;/a>&lt;/p>
&lt;h3 id="可索引的-job-api">可索引的 Job API&lt;/h3>
&lt;p>在 Kubernetes v1.21 中新增的可索引 Job API 可以更加方便的调度并行化的 Job。你可以使用如下的方式通过环境变量让 Job 中的 Pod 知道自己的索引：&lt;/p>
&lt;pre>&lt;code>[...]
spec:
subdomain: my-job-svc
containers:
- name: task
image: registry.example.com/processing-image
command: [&amp;quot;./process&amp;quot;, &amp;quot;--index&amp;quot;, &amp;quot;$JOB_COMPLETION_INDEX&amp;quot;, &amp;quot;--hosts-pattern&amp;quot;, &amp;quot;my-job-{{.id}}.my-job-svc&amp;quot;]
&lt;/code>&lt;/pre>&lt;h3 id="为-job-api-增加-suspend-字段">为 Job API 增加 suspend 字段&lt;/h3>
&lt;p>自 v1.21 起，Job 可以通过设置 &lt;code>.spec.suspend=true&lt;/code> 字段来临时的挂起。可以比较方便的去进行控制，类似 Argo workflow 中，也可以对某个 workflow 进行挂起操作。&lt;/p>
&lt;h3 id="csr-的有效期">CSR 的有效期&lt;/h3>
&lt;p>通过在 &lt;code>CertificateSigningRequestSpec&lt;/code> 中增加的 &lt;code>ExpirationSeconds&lt;/code> 可以接受的最小值是 600（10分钟），这样就可以很好的控制其有效期了。现在默认的是 1 年。&lt;/p>
&lt;h3 id="内存资源的-qos">内存资源的 QoS&lt;/h3>
&lt;p>之前 Kubernetes 在使用 cgroups v1 ，对于 Pod 的 QoS 其实只适用于 CPU 资源。Kubernetes v1.22 中通过引入 cgroups v2 来提供了一个 alpha 特性，允许对内存资源也提供 QoS。（如果没记错，貌似是腾讯云团队提交的 KEP 吧）&lt;/p>
&lt;p>其他值得注意的变更，请参考之前发布的每期『K8S生态周报』及 &lt;a href="https://zhuanlan.zhihu.com/p/384599279">《K8S 生态周报| Kubernetes v1.22.0-beta.0 发布》&lt;/a>&lt;/p>
&lt;p>当然，你也可以通过KIND 使用如下命令来快速的体验 Kubernetes v1.22 ：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">kind create cluster --image&lt;span class="o">=&lt;/span>kindest/node:v1.22.0@sha256:b8bda84bb3a190e6e028b1760d277454a72267a5454b57db34437c34a588d047
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Redis 容器化技术选型，K8S 并非唯一</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/07/02/Redis-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8BK8S-%E5%B9%B6%E9%9D%9E%E5%94%AF%E4%B8%80/"/><id>https://moelove.info/2021/07/02/Redis-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8BK8S-%E5%B9%B6%E9%9D%9E%E5%94%AF%E4%B8%80/</id><updated>2021-07-04T11:49:04+08:00</updated><published>2021-07-02T12:39:40+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本文根据我在〖deeplus直播第247期〗线上分享演讲内容整理而成。 今天将分享的内容分为以下4个方面： 一、缘起 二、介绍多样的容……</summary><content type="html">&lt;p>&lt;strong>本文根据我在〖deeplus直播第247期〗线上分享演讲内容整理而成。&lt;/strong>&lt;/p>
&lt;p>今天将分享的内容分为以下4个方面：&lt;/p>
&lt;ul>
&lt;li>一、缘起&lt;/li>
&lt;li>二、介绍多样的容器化技术&lt;/li>
&lt;li>三、Redis介绍&lt;/li>
&lt;li>四、Redis容器化方案的对比&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>一、缘起&lt;/strong>&lt;/p>
&lt;p>首先我们先聊一下为什么今天我会分享这个主题。我和朋友一起组织了一个 Redis技术交流群，到现在已经经营了6年左右的时间，其中某一天在群里有一个小伙伴就抛出来一个问题：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/640.webp" alt="图片">&lt;/p>
&lt;p>他问大家线上的Redis有没有使用Docker安装？Docker使用Host的网络模式、磁盘使用本地挂载模式这种方案怎么样？这里的话我们暂时先不说这个方案如何，因为在今天的分享之后，我相信大家对于这个方案应该会有一个更清晰的认识和评价。&lt;/p>
&lt;p>&lt;strong>二、介绍多样的容器化技术&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1、chroot和jails&lt;/strong>&lt;/p>
&lt;p>在容器化技术方面，其实历史很久远了。虽然我们现在用的容器化技术，或者说 k8s，还有云原生的概念是近几年才火起来的，但是实际上就容器化技术的发展来说，其实是很早的了。比如说最早的时候来自chroot，chroot大家可能都用过，或者都有了解过，在1979年的时候它是来自Unix，它主要的功能是可以修改进程和子进程的/。&lt;/p>
&lt;p>通过使用chroot达到什么样效果呢？使用chroot加某一个目录，然后再启动一个进程，那么这个进程自己所看到的 / ,就是我们平时所说的 / 目录，这个 / 就会是我们刚才指定的文件夹，或者说刚才指定的路径。这样子的话可以有效的保护我们操作系统上面的一些文件，或者说权限和安全相关的东西。&lt;/p>
&lt;p>在2000年的时候，出现了一个新的技术，叫做jails，其实它已经具备了sandbox，就是沙箱环境的雏形。使用jails的话，可以让一个进程或者说创建的环境拥有独立的网络接口和IP地址，而当我们提到使用jails的话，我们肯定会想到一个问题，就是如果你有了独立的网络接口和IP地址，这样的话就不能发原始的套接字，通常跟原始的套接字接触得比较多的就是我们使用的Ping命令。默认的情况下，这样子是不允许使用原始的套接字的，而有自己的网络接口和IP地址，这个感觉上就像是我们常用的虚拟机。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/2.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>2、Linux VServer和OpenVZ&lt;/strong>&lt;/p>
&lt;p>接下来在2001年的时候，在Linux社区当中就出现了一个新的技术叫做Linux VServer。Linux VServer有时候可以简写成lvs，但是和我们平时用到的4层的代理lvs其实是不一样的。它其实是对Linux内核的一种Patch，它是需要修改Linux内核，修改完成之后，我们可以让它支持系统级的虚拟化，同时使用Linux VServer的话，它可以共享系统调用，它是没有仿真开销的，也就是说我们常用的一些系统调用、系统调用的一些函数都是可以共享的。&lt;/p>
&lt;p>在2005年的时候，出现的一个新的技术—OpenVZ。OpenVZ其实和Linux VServer有很大的相似点，它也是对内核的一种Patch，这两种技术最大的变化就是它对Linux打了很多的Patch，加了很多新的功能，但是在2005年的时候，没有把这些全部都合并到Linux的主干当中，而且在使用OpenVZ的时候，它可以允许每个进程可以有自己的/proc或者说自己的/sys。&lt;/p>
&lt;p>其实我们大家都知道在Linux当中，比如说启动一个进程，你在他的/proc/self下面，你就可以看到进程相关的信息。如果你有了自己独立的/proc，其实你就可以达到和其他的进程隔离开的效果。&lt;/p>
&lt;p>接下来另外一个显著的特点就是它有独立的users和groups，也就是说你可以有独立的用户或者独立的组，而且这个是可以和系统当中其他的用户或者组独立开的。&lt;/p>
&lt;p>其次的话OpenVZ是有商业使用的，就是有很多国外的主机和各种VPS都是用OpenVZ这种技术方案。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/3.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>3、namespace 和 cgroups&lt;/strong>&lt;/p>
&lt;p>到了2002年的时候，新的技术是namespace。在Linux当中我们有了新的技术叫做namespace，namespace可以达到进程组内的特定资源的隔离。因为我们平时用到的namespace其实有很多种，比如说有PID、net等，而且如果你不在相同的namespace下面的话，是看不到其他进程特定的资源的。&lt;/p>
&lt;p>到了2013年的时候，产生了一个新的namespace的特性，就是user namespace。其实当有了user namespace，就和上文提到的OpenVZ实现的独立用户和组的功能是比较像的。&lt;/p>
&lt;p>对于namespace的操作当中，通常会有三种。&lt;/p>
&lt;p>&lt;strong>1）Clone&lt;/strong>&lt;/p>
&lt;p>可以指定子进程在什么namespace下面。&lt;/p>
&lt;p>&lt;strong>2）Unshare&lt;/strong>&lt;/p>
&lt;p>它是与其他进程不共享的，unshare再加一个-net，就可以与其他的进程独立开，不共享自己的net，不共享自己的网络的namespace。&lt;/p>
&lt;p>&lt;strong>3）Setns&lt;/strong>&lt;/p>
&lt;p>就是为进程设置 namespace。&lt;/p>
&lt;p>到了2008年，cgroups开始被引入到Linux内核当中，它可以用于隔离进程组的资源使用，比如说可以隔离CPU、内存、磁盘，还有网络，尤其是他在2013年和user namespace进行了一次组合之后，并且进行了重新的设计，这个时候，就变得更现代化了，就像我们现在经常使用到的Docker的相关特性，其实都来自于这个时候。所以说cgroups和namespace构成现代容器技术的基础。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/4.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>4、LXC 和 CloudFoundry&lt;/strong>&lt;/p>
&lt;p>在2008年的时候，新的一项技术叫做LXC, 我们也会叫他Linux Container（以下均简称LXC）。上文我们提到了很多容器化的技术，比如Linux VServer、OpenVZ，但是这些都是通过打Patch来实现的，而LXC是首个可以直接和上游的Linux内核共同工作的。&lt;/p>
&lt;p>LXC是可以支持特权容器的，意思就是说可以在机器上面去做uid map、gid map，去做映射，而且不需要都拿root用户去启动，这样子就具备了很大的便利性。而且这种方式可以让你的被攻击面大大缩小。LXC支持的这几种比较常规的操作，就是LXC-start，可以用来启动container，LXC-attach就可以进入container当中。&lt;/p>
&lt;p>到2011年的时候，CloudFoundry开始出现了，他实际上是使用了LXC和 Warden这两项技术的组合，在这个时候不得不提到的，就是他的技术架构是CS的模式，也就是说还有一个客户端和server端，而 Warden容器，它通常是有两层，一层是只读os的，就是只读的操作系统的文件系统，另外一层是用于应用程序和其依赖的非持久化的读写层，就是这两层的组合。&lt;/p>
&lt;p>我们之前提到的技术，大多数都是针对于某一台机器的，就是对于单机的。CloudFoundry它最大的不同就是它可以管理跨计算机的容器集群，这其实就已经有了现代容器技术的相关特性了。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/5.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>5、LMCTFY和systemd-nspawn&lt;/strong>&lt;/p>
&lt;p>在2013年的时候， Google开源了自己的容器化的解决方案，叫做LMCTFY。这个方案是可以支持CPU、内存还有设备的隔离。而且它是支持子容器的，可以让应用程序去感知到自己当前是处在容器当中的。另外还可以再为自己创建一个子容器，但是随着2013年发展之后，它逐渐发现只依靠自己不停的做这些技术，就相当于单打独斗，发展始终是有限的，所以它逐步的将自己的主要精力放在抽象和移植上，把自己的核心特性都移植到了libcontainer。而libcontainer之后就是Docker的运行时的一个核心，再之后就是被Docker捐到了OCI，再然后就发展到了runC。这部分内容我们稍后再详细讲解。&lt;/p>
&lt;p>大家都知道服务器它肯定是有一个 PID为1的进程。就是它的初始进程、守护进程，而现代的操作系统的话，大多数大家都使用的是systemd，同样systemd它也提供了一种容器化的解决方案，叫做 systemd-nspawn。这个技术的话，它是可以和systemd相关的工具链进行结合的。&lt;/p>
&lt;p>systemd除了有我们平时用到的systemctl之类的，还有systemd machine ctl，它可以去管理机器，这个机器支持两种主要的接口，一种是管理容器相关的接口，另外一种是管理虚拟机相关的接口。&lt;/p>
&lt;p>而我们通常来讲，就是说systemd提供的容器技术解决方案，它是允许我们通过machine ctl去容器去进行交互的，比如说你可以通过machine ctl start，去启动一个systemd支持的容器，或者通过 machine ctl stop，去关掉它，而在这种技术下，它是支持资源还有网络等隔离的，其实它最主要的是systemd ns，它其实是使用namespace去做隔离。对于资源方面是来自于systemd，systemd是可以使用cgroups去做资源隔离的，其实这也是这两种两种技术方案的组合。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/6.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>6、Docker&lt;/strong>&lt;/p>
&lt;p>而在2013年Docker也出现了。通常来讲，Docker是容器时代的引领者，为什么这么说呢？因为Docker在2013年出现的时候，他首先提到了标准化的部署单元，就是Docker image。同时它还推出了DockerHub，就是中央镜像仓库。允许所有人通过DockerHub去下载预先已经构建好的Docker image，并且通过一行Docker run就可以启动这个容器。&lt;/p>
&lt;p>在众多使用起来比较繁琐、比较复杂的技术下，Docker这时提出来，你只需要一行Docker run，就可以启动一个容器，它大大简化了大家启动容器的复杂度，提升了便捷性。&lt;/p>
&lt;p>所以Docker这项技术就开始风靡全球。而Docker它主要提供的一些功能是什么呢？比如说资源的隔离和管理。而且Docker在0.9之前，它的容器运行时是LXC，在0.9之后，他就开始把LXC替换掉，替换成了libcontainer，而这个libcontainer其实就是我们在上文提到的Google的 LMCTFY。再之后libcontainer捐给了OCI。而那之后Docker现在的容器运行时是什么呢？是containerd。containerd的更下层是runc，runc的核心其实就是libcontainer。&lt;/p>
&lt;p>而到了2014年的时候， Google发现大多数的容器化解决方案，其实都只提供了单机的解决方案，同时由于Docker也是CS架构的，所以它需要有一个Docker demand，它是需要有守护进程存在的，而这个守护进程的话，是需要用root用户去启动的，而root用户启动的守护进程，其实是增加了被攻击面，所以 Docker的安全问题也被很多人诟病。&lt;/p>
&lt;p>在这个时候 Google就发现了这个点，并且把自己的Borg系统去做了开源，开源版本就是Kubernetes。Google还联合了一些公司，组建了一个云原生基金会（CNCF）。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/7.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>7、Kubernetes&lt;/strong>&lt;/p>
&lt;p>通常来讲Kubernetes是云原生应用的基石，也就是说在Kubernetes出现之后，我们的云原生技术开始逐步地发展起来，逐步地引领了潮流，Kubernetes提供了一些主要的特性。&lt;/p>
&lt;p>它可以支持比较灵活的调度、控制和管理，而这个调度程序的话，除了它默认的以外，也可以比较方便的去对它做扩展，比如说我们可以自己去写自己的调度程序，或者说亲和性、反亲和性，这些其实都是我们比较常用到的一些特性。&lt;/p>
&lt;p>还有包括他提供的一些服务，比如说内置的 DNS、kube-DNS或者说现在的CoreDNS，通过域名的方式去做服务发现，以及Kubernetes当中有很多的控制器。它可以将集群的状态调整至我们预期的状态，就比如说有一个pod挂掉了，它可以自动的把它再恢复到我们预期想要的样子。&lt;/p>
&lt;p>另外就是它支持丰富的资源种类，比如说几个主要的层级，最小的是pod，再往上有deployment，或者有StatefulSets，类似于这样子的资源。&lt;/p>
&lt;p>最后一点是它让我们更加喜欢它的因素，就是它有丰富的CRD的拓展，即可以通过自己去写一些自定义的资源，然后对它进行扩展，比如CRD。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/8.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>8、更多的容器化技术&lt;/strong>&lt;/p>
&lt;p>除了刚才我们提到的这些主要的技术以外，其实还有很多我们没有提到的一些容器化的技术，比如说像runc，上文我们没有太多的介绍，还有containerd。containerd其实也是Docker开源出来的自己的核心，他的目标是做一个标准化工业可用的容器运行时，还有CoreOS开源出来的解决方案叫做rkt。而rkt瞄准的点就是上文提到的Docker相关的安全问题。但是rkt现在项目已经终止了。&lt;/p>
&lt;p>还有红帽(Red Hat)开源出来的 podman， podman是一种可以用它来启动容器，可以用它去管理容器，而且没有守护进程，所以就安全性来讲的话，podman可以说比Docker的安全性直观上来看的话会好一些，但是它的便捷性来讲的话，就要大打折扣了。比如说容器的重启、开机起之类的，但是我们都是有一些不同的解决方案的。&lt;/p>
&lt;p>在2017年的时候，这个时候有一个 Kata Container，而这个Kata Container它有一段发展过程，最开始是英特尔，英特尔在搞自己的容器运行时，还有一家初创公司叫做hyper.sh，这家公司也在搞自己的容器运行时，这两家公司瞄准的都是做更安全的容器，他们使用的底层的技术都是基于K8S。而之后这两家公司做了合并，hyper.sh它开源出来的一个解决方案是runv，被英特尔看上了之后就诞生了 Kata Container。在2018年的时候，AWS开源出来自己的Firecracker。&lt;/p>
&lt;p>这两项技术和我们上文提到的机器上的容器化技术其实大有不同，因为它的底层其实相当于是虚拟机，而我们通常来讲，都认为它是轻量级虚拟机的一种容器化的技术。以上就是关于多样的容器化技术的介绍。&lt;/p>
&lt;p>&lt;strong>三、Redis介绍&lt;/strong>&lt;/p>
&lt;p>接下来进入关于Redis相关的介绍，以下是从Redis的官网上面摘抄的一段介绍。&lt;/p>
&lt;p>&lt;strong>1、Redis使用的主要场景&lt;/strong>&lt;/p>
&lt;p>其实Redis现在是使用最广泛的一种KV型数据库。而我们在使用它的时候，主要的使用场景可能有以下几种：&lt;/p>
&lt;ul>
&lt;li>把它当缓存使用，把它放在数据库之前，把它当做缓存去使用；&lt;/li>
&lt;li>把它当DB来用，这种就是需要把真正的拿它来存数据做持久化。&lt;/li>
&lt;li>做消息队列，它支持的数据类型也比较多，这里就不再做介绍了。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2、Redis的特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>它是一个单线程的模型，它其实是可以有多个线程的，但是它的worker线程只有一个，在Redis6.0开始，它支持了io多线程，但io多线程只是可以有多线程去处理有网络相关的部分，实际上你真正去处理数据还是单线程，所以整体而言，我们仍然把它叫做单线程模型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Redis的数据其实都在内存里头，它是一个内存型的数据库。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与HA相关， Redis想要做HA，我们以前在做 Redis的HA主要靠Redis sentinel，而后面在Redis出来cluster之后，我们主要靠Redis cluster去做HA,这是两种主要HA的解决方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://moelove.info/img/redis/9.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>四、Redis容器化方案的对比&lt;/strong>&lt;/p>
&lt;p>当我们提到做 Redis运维相关的时候，我们有哪些需要考虑的点：&lt;/p>
&lt;ul>
&lt;li>部署，如何快速的部署，如何能够快速的部署，而且还要去管理监听的端口，让端口不起冲突,还有日志和持久化文件之类的,这部分都属于部署相关的内容；&lt;/li>
&lt;li>扩/缩容，也是我们经常会遇到的问题；&lt;/li>
&lt;li>监控和报警；&lt;/li>
&lt;li>故障和恢复。&lt;/li>
&lt;/ul>
&lt;p>以上都是我们最关注的几个方面。我接下来就对这几个方面去做一些介绍。&lt;/p>
&lt;p>&lt;strong>1、部署&lt;/strong>&lt;/p>
&lt;p>当我们提到去做单机多实例的时候，Redis作单机多实例去部署的时候，首先第一点就是我们希望能够有进程级别的资源隔离，我们某一个节点上面所有部署的Redis实例，可以有自己的资源，可以不受别的实例的影响，这就是对于进程级别的资源隔离。&lt;/p>
&lt;p>进程级别的资源隔离，它其实主要分为两个方面，一方面是CPU，另一方面是内存，其次的话我们希望在单机上面我们也可以有自己的端口管理，或者说我们可以有独立的网络资源隔离的相关的技术。&lt;/p>
&lt;p>在这种情况下，首先我们提到说进程级别的资源隔离，我们介绍了那么多的容器化相关技术，我们已经知道了，支持进程级别的资源隔离的话，有最简单的一种方案就是用cgroups，如果想要去做网络资源隔离的话，我们有namespace，也就是说所有支持cgroups和 namespace的这种计划的解决方案，都可以满足我们这个地方的需求。&lt;/p>
&lt;p>再有一种方案就是虚拟化的方案，也就是我们上文提到比如说Kata Container，Kata Container这种基于虚拟化的方式，因为虚拟化的方案其实大家都有所接触，大家都知道就是虚拟化的这种技术，其实默认情况下，刚开始全部都做隔离。&lt;/p>
&lt;p>所以对于部署而言，如果你使用的是比如说像Docker，比如说你想使用的像 systemd-nspawn这些它都可以既用到cgroups，又用到了 namespace，是都可以去用的，只不过是你需要考虑一些便捷性，比如说你如果是使用Docker的话，进行一个Docker命令跑过去，然后只要让它映射到不同的端口，其实就结束了。&lt;/p>
&lt;p>如果你使用是systemd-nspawn，这样子的话，你需要去写一些配置文件。如果你要是去用一些虚拟化的解决方案的话，同样的也需要去准备一些镜像。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/10.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>2、扩/缩容&lt;/strong>&lt;/p>
&lt;p>关于扩/缩容，其实会有两种最主要的场景，一种场景就是单实例 maxmemory 调整，就是我们最大内存的调整。还有一种是对于我们的集群化的集群解决方案，就是Redis Cluster。对于这种集群规模，我们有扩/缩容的话，会有两方面的变化。&lt;/p>
&lt;p>一方面是 Node，就是我们的节点的变更，如果会新增节点，也可能会去移除节点。&lt;/p>
&lt;p>另外一种就是Slot的变更，就是希望把我的 slot 去做一些迁移，当然这些和Node节点会是相关的，因为当我们去做扩容的时候，我们把Redis Cluster当中的一些Node节点增多，增多了之后，就可以不给他分配Slot，或者说我想要让某些Slot集中到某些节点上面，其实这些需求也是同样存在的。&lt;/p>
&lt;p>那我们来看一下，如果你当时想要去做maxmemory的调整，如果我们是前提已经做了容器化，想通过 cgroups去对它做资源的限制，就需要有一个可以支持动态调整 cgroups配额的解决方案。&lt;/p>
&lt;p>比如说我们用到Docker update，它是可以直接修改某个实例，或者说其中的某一个容器的cgroups资源的一些限制，比如说我们可以Docker update，给它指定新的内存，可以限制它最大可用内存，当你把它的可用内存数调大，接下来你就可以对实例去调整它的 maxmemory ，也就是说对于单实例 maxmemory，其实最主要的就是需要有cgroups的技术，向cgroups的技术提供一些支持。&lt;/p>
&lt;p>对于集群节点的变更的话，这个部分稍后再做详细介绍。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/11.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>3、监控报警&lt;/strong>&lt;/p>
&lt;p>第三点就是监控报警，不管是使用物理机也好，或者使用云环境也好，或者使用任何解决方案都好，监控报警我们最想要得到的效果就是，它可以自动发现。&lt;/p>
&lt;p>我们希望当启动一个实例之后，我们就可以立马知道这个实例A他已经起来了，并且知道他的状态是什么，而监控报警的话，这部分其实是不依赖于特定的容器化技术的，就即使是在纯粹的物理机上部署，也可以通过一些解决方案自动的发现它，自动的把它注册到我们的监控系统当中去，所以它是属于监控报警的这部分，其实它是不依赖于特定的容器技术的，但唯一的一个问题就是说假如说使用了容器化的方案，可以让常用的 Redis exporter，配合Prometheus去做监控，可以让 Redis exporter和 Redis server，这两个进程可以处于同一个网络的命名空间。&lt;/p>
&lt;p>如果他们两个处于同一个网络的命名空间的话，可以直接通过127.0.0.1:6379，然后直接去联通它,如果我们使用的是k8s的话，可以直接把它俩放到一个pod当中，但是这些都无关紧要，因为它是不依赖于特定的容器化技术的，你可以使用任何你想要用的技术，都可以去做监控和报警。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/12.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>4、故障恢复&lt;/strong>&lt;/p>
&lt;p>最后我们提到的部分是故障和恢复。在这个部分我认为最主要的有三个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一个是实例的重启。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>有可能在某些情况下，某些场景下，你的实例在运行过程当中它可能会宕掉，如果你想让他自动重启的话，你需要有一个进程管理的工具。对于我们而言，上文我们提到了systemd，systemd是可以支持对于某一个进程的自动拉起的，还可以支持进程挂掉之后自动拉起， 可以 restart，或者你使用Docker，它也有一个restart policy，可以指定他为 always或者指定为on-failure，然后让它在挂掉的时候再把它给拉起来。&lt;/p>
&lt;p>如果你使用的是k8s，那么就更简单了，可以自动拉起来。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第二个是主从切换。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>主从切换相对来说是一个常态，但在这里我也把它列到故障恢复当中，是因为可能在主从切换的过程当中，有可能你的集群状况已经不健康了，是会有这种情况存在的。那主从切换的时候我们需要做什么？第一方面，需要让他能够有数据的持久化，另一方面在主从切换的时候，有可能会遇到一种情况，就是资源不够，导致主从切换失败，在这种情况下，其实和我们上文前面提到的扩/缩容其实是相关的，所以在这种情况下就必须得给他加资源，而最好的办法是可以自动给他加资源。&lt;/p>
&lt;p>在k8s当中，想要让它自动加资源，我们通常会给他设置它的request和limit，就是资源的配额，希望它能自动的加起来，我们通常把他叫做vpa。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第三个是数据恢复。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>通常来讲，比如说我们开了 RDB和AOF，而且希望我们的数据可以保存下来，以便于在我们数据恢复的时候可以直接开始使用。所以数据持久化也是一方面。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/13.webp" alt="图片">&lt;/p>
&lt;p>我们去做容器化的时候，我们需要考虑哪些点？如果说你是使用Docker的话，你需要去挂一个券，然后你可以把这个数据去做持久化，比如说你使用systemd-nspawn也需要有一个文件目录去把这个数据做持续化。&lt;/p>
&lt;p>如果你使用的是k8s的话，在挂券的时候，你会有各种各样的选择，比如说你可以去挂 ceph的RDB、s3或者一个本地的某一个文件目录。但是为了更高的可靠性，可能会使用副本数更多的分布式存储。&lt;/p>
&lt;p>&lt;strong>5、Node节点变更&lt;/strong>&lt;/p>
&lt;p>接下来，我们来聊一下上文我们在提到服务扩/缩容的时候，提到的关于Node节点变更，比如说我想要让我的某一个Redis cluster，去扩充一些节点，扩充节点的时候，那就意味着你必须能够加入集群，能够和集群正常通信，这才说明你真正的加入到了集群当中。&lt;/p>
&lt;p>而我们也知道在Redis cluster当中，你要去做集群，最大的一个问题就是k8s，k8s当中做服务发现其实它都是大多数通过一个域名，而我们的Redis当中，比如说我们的NodeIP，它其实只支持IP，它并不支持我们的域名。&lt;/p>
&lt;p>所以如果说Node节点变更，需要做的事情就是允许我们动态地去把NodeIP写到我们的集群配置当中。&lt;/p>
&lt;p>如果想要让它有一个完整的生命周期，以下截图是来自于一个叫Kubedb的operator，在下图中可以看到，Redis这个地方提供了最主要的三个部分：&lt;/p>
&lt;ul>
&lt;li>PVCs，PVCs就是做数据的持久化。&lt;/li>
&lt;li>Services，Services就是做服务发现。&lt;/li>
&lt;li>StatefulSets，StatefulSets其实就是k8s当中的一种资源，而这资源它对于我们的有状态应用会更友好一些。&lt;/li>
&lt;/ul>
&lt;p>其实在整个内容当中还有一点没有介绍的是什么呢？就是Redis背后的公司叫做Redis Labs，它提供了一种商业化的方案，就是Redis Enterprise一种解决方案。其实也是在k8s的解决方案之上的，也是用了Redis operator。他的方案和Kubedb这种方案基本类似，因为核心还都是用的StatefulSets，然后再加上自己的Controller，去完成这个事情。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/14.webp" alt="图片">&lt;/p>
&lt;p>&lt;strong>五、总结&lt;/strong>&lt;/p>
&lt;p>我们来看一下今天的总结。如果是我们单机使用的话，我们可以交给Docker或者其他支持cgroups或者namespace资源管理的工具。因为当你使用了cgroups、namespace的话，你可以做到资源的隔离，可以避免网络的端口的冲突之类的事情都可以实现。&lt;/p>
&lt;p>而如果是像我在上文提到的小伙伴提到的那个问题：他打算使用主机的网络，仅仅是想让Docker去做一个进程管理，而且你也不希望引入新的内容。那么systemd或者systemd-nspawn都是可以考虑的，因为这也是容器化的解决方案。&lt;/p>
&lt;p>如果是在复杂场景下的调度和管理的话，比如想要有很大的规模，并且想要有更灵活的调度和管理，我推荐你使用的是Kubernetes operator，比如说Kubedb，其实也是一种解决方案。如果你的场景没有那么复杂，比较简单，其实原生的Kubernetes StatefulSets稍微做一些调整和修改，也是可以满足你的需求。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/redis/15.webp" alt="图片">&lt;/p>
&lt;p>以上就是我今天分享的主要内容了，感谢大家的参与。&lt;/p>
&lt;p>&lt;strong>&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Q&amp;amp;A&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Q1：请问Redis集群假如用三台物理机做，每台运行2个实例，如何保障每台物理机的实例不是互为主从的？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A1 ：&lt;/strong> 这个问题其实我们通常情况下大家也都会遇到。第一点如果你是使用物理机来做，并且你每台机器上面运行两个实例，三台机器每个机器上面运行2个实例，一共有6个实例。这6个实例你是否可以保证它每个互相都不为主从的，其实是可以直接保证。&lt;/p>
&lt;p>唯一的问题就是假如说这是一个集群，然后发生故障转移，发生节点的主动切换，就非常有可能存在你的主从发生了变更。其实这个地方的话其实我更加建议，如果你发现了这种问题的话，你手动去做切换，因为物理机环境去做这个事情，目前我还没看到有什么特别好的解决办法。&lt;/p>
&lt;p>&lt;strong>Q2 : 请问k8s 中扩容时，如何增加新节点。扩容和分配slot的步骤如何自动化的进行？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A2 ：&lt;/strong> 我们分开两步来讲，第一部分是增加新节点，增加新节点的话，刚才我其实在过程里头已经提到了，增加完新的节点之后，首先你一定要让它能够和集群去做通信，然而这个地方就是需要你去修改集群的配置文件，然后你需要他有一个NodeIP，因为之间是通过IP去做通信的，所以你需要去修改它的配置文件，把它的 NodeIP加进去，这样子他才可以和集群当中的其他节点去做通信，然而这个部分的话，我更推荐的是用operator去做。&lt;/p>
&lt;p>&lt;strong>Q3 : 请问如果不用Redis operator，也不使用分布式存储，k8s如何部署cluster集群呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A3 ：&lt;/strong> 不用Redis operator其实也是可以的，刚才我也介绍过，有两种模式，一种模式就是用StatefulSets，这种模式的话相对来说会比较稳妥一些。同时它的最主要的部分仍然是修改配置，你需要在你的Redis的容器镜像当中，你可以给它加一个init容器，然后可以在这个部分先给他做一次修改配置的操作，这是可以的。修改完配置的操作之后，再把它给拉起来，这样子他才可以加入到集群当中。&lt;/p>
&lt;p>&lt;strong>Q4 : 请问网络延迟在不同网络模型下有什么区别？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A4 ：&lt;/strong> 如果我们直接使用物理机的网络，通常来讲，我们不认为这种方式有延迟，就是主机网络一般情况下我们会忽略掉它的延迟，但是如果你使用的是overlay的这种网络模型的话，因为它是覆盖层的网络，所以你在去做发包解包的时候，当然是会有不同的资源的损耗，性能的损耗都是有的。&lt;/p>
&lt;p>&lt;strong>Q5 : 请问一般建议公司公用一个Redis集群，还是各系统独立集群？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A5 ：&lt;/strong> 这个问题当然是建议各个系统独立集群了，我们来举一个最简单的例子，比如说你在其中用到了list，我们都知道Redis就有一个ziplist的配置项，他其实跟你的存储和你的性能是有关系的。如果你是公司的所有的东西都用同一个集群，那你修改了Redis集群的配置的话，很可能会影响到所有的服务。但如果你是每个系统独立用一个Redis群的话，彼此之间互不影响，也不会出现某一个应用不小心把集群给打挂了，然后造成连锁反应的情况。&lt;/p>
&lt;p>&lt;strong>Q6 : 请问Redis持久化，在生产中如何考虑呢？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A6 ：&lt;/strong> 这部分东西我是这样想的。如果你真的需要去做持久化，一方面Redis提供了两种核心，一种是 RDB，另外一种是AOF，如果说你的数据很多的话，相应你的RDB可能会变得很大。如果你是去做持久化，我通常建议就是两个里头去做一次权衡。因为通常来讲，即使你是使用物理机的环境，我也建议你的存储目录可以放到一个独立的盘里头，或者说你可以去挂在一个分布式的存储，但是前提是你需要保证它的性能，因为你不能因为它的写入性能而拖累你的集群，所以更加推荐的就是你可以全都把它们打开，但是如果你数据其实没那么重要，你可以你只开AOF。&lt;/p>
&lt;p>&lt;strong>Q7 : 请问生产级别的ceph可靠不？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A7 ：&lt;/strong> 其实ceph的可靠性这个问题，很多人都讨论过，就我个人而言，ceph 的可靠性是有保证的。我这边在用的 ceph 很多，并且存了很多比较核心的数据，ceph 的可靠性是 ok 的。&lt;/p>
&lt;p>重点在于说你能不能搞得定他，而且有一家公司其实大家可能有所了解，叫做SUSE，就是一个Linux的一个发行版，这家公司其实提供了一个企业级的存储解决方案，并且它的底层其实还是用的ceph，其实这也是正常的，只要有专人去搞这个事情，然后把它解决掉，我觉得ceph足够稳定的。&lt;/p>
&lt;p>顺便提一下，如果你使用的是 k8s 的话，现在有一个项目叫做 rook，它其实提供了一个 ceph 的 operator，这种方案其实现在已经算是相对来说比较很稳定的了，推荐大家尝试一下。&lt;/p>
&lt;p>&lt;strong>Q8: 请问申请内存、限制内存、还有本身Redis内存怎么配置比较好？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>A8：&lt;/strong> 这里需要考虑几个问题，首先我们先说Redis本身的内存，其实要看你的实际业务的使用场景，或者说你业务的实际需求，你肯定不可能让你的Redis的实例或者Redis集群的内存都占满。&lt;/p>
&lt;p>如果是占满的话，你就需要开启lru去做驱逐之类的事情，这是一方面。另一方面就是申请内存，其实我理解你这个地方要问的问题应该是指，在k8s环境下面，在k8s下面一个是request的，一个是limit，limit肯定是你的可用限制的内存，限制内存你一定需要考虑到Redis本身还要用到的一些内存。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Redis/" term="Redis" label="Redis"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.22.0-beta.0 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/06/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.22.0-beta.0-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2021/06/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.22.0-beta.0-%E5%8F%91%E5%B8%83/</id><updated>2021-06-28T10:03:34+08:00</updated><published>2021-06-27T05:52:12+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 runc v1.0 正式发布 从 2016 年……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="runc-v10-正式发布">runc v1.0 正式发布&lt;/h2>
&lt;p>从 2016 年 6 月发布 v1.0-rc1 版本开始，至今已整整 5 年时间，runc 历经多个 rc 版本终于发布了 v1.0 版本。整个过程及其思考请参考我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/383133561">《开源项目的 5 年长跑，runc v1.0 终于正式发布！》&lt;/a> 。这里我们来看看 v1.0 新版本中带来了哪些值得注意的变更。&lt;/p>
&lt;h3 id="破化性变更">破化性变更&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/2999">#2999&lt;/a> 删除了 &lt;code>libcontainer/configs.Device*&lt;/code> 标识，请使用 &lt;code>libcontainer/devices.*&lt;/code> 来替代（是自 v1.0-rc94 开始废弃的）；&lt;/li>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/2999">#2999&lt;/a> 删除了 &lt;code>libcontainer/system.RunningInUserNS&lt;/code> 函数，请使用 &lt;code>libcontainer/userns.RunningInUserNS&lt;/code> 函数代替（同样是自 v1.0-rc94 开始废弃的）；&lt;/li>
&lt;/ul>
&lt;h3 id="改进">改进&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/2994">#2994&lt;/a> 在 &lt;code>runc update&lt;/code> 的时候设置了 &lt;code>SkipDevices&lt;/code> ，所以在此期间我们就不会更新 cgroups 了；&lt;/li>
&lt;li>&lt;a href="https://github.com/opencontainers/runc/pull/3010">#3010&lt;/a> cgroup1 相关的 blkio 支持 BFQ weight 了，这里需要注意的是 &lt;strong>2018 年 CFQ 已经从 Linux 删除，22019 年发布的 RHEL 8.0 和 Ubuntu 19.01 等发行版中也均使用 BFQ 替代了 CFQ&lt;/strong> 。关于 Linux 内核的 BFQ 和 CFQ 这里就不再展开了，只需要知道 BFQ 相比 CFQ 做到了低延迟和吞吐即可；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0">ReleaseNote&lt;/a> ，现在 Docker/containerd 等项目已将 runc 依赖升级到了 v1.0 ，K8S 项目尚未合并。&lt;/p>
&lt;h2 id="prometheus-v228-正式发布">Prometheus v2.28 正式发布&lt;/h2>
&lt;p>Prometheus v2.28 在使用体验上有了重大提升，我们来看看有哪些值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>PromQL 编辑器默认将会开启， 这个编辑器我在之前的 k8s生态中介绍过了，这里贴个图，看看它的自动补齐, 除此之外还有高亮和 linting 的能力。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/27/imhyDQjLgdO4uYq.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有 metrics 的浏览窗口，为什么会再次提这个功能呢？因为我觉得它很实用。在之前的版本，我要么是需要提前记住有哪些 metrics，要么就是直接去 curl 请求下 metrics 接口，看看有哪些 metrics 可用。现在的话，直接浏览即可。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/06/27/NuVM7F9dYZcEjJR.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可以展示 trace exemplar 了，效果如下：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/28/ykStjmwAJGKN9zP.jpg" alt="">&lt;/p>
&lt;p>这个功能还是蛮方便的，有空了我可以详细介绍下。（flag+1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新增了一个基于 HTTP 的 service discovery ，这个功能比较实用，不再要求非要特定于使用某个组件，只要 HTTP 接口返回的内容符合其要求的格式，即可注册到 Prometheus 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 Kubernetes SD 中，增加了一个 ingress class name 的字段，比如你在使用 Apache APISIX Ingress controller 的时候，通过新版的 Prometheus 采集，就会看到一个 &lt;code>{__meta_kubernetes_ingress_class_name: apisix}&lt;/code> 的字段了；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请查看其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.28.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-v1220-beta0httpsgithubcomkuberneteskubernetesreleasestagv1220-beta0-发布">&lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.22.0-beta.0">Kubernetes v1.22.0-beta.0&lt;/a> 发布&lt;/h2>
&lt;p>Kubernetes v1.22 正在持续的进行迭代和发布，我们来看看 v1.22.0-beta.0 中有哪些值得关注的变更吧！&lt;/p>
&lt;h3 id="废弃">废弃&lt;/h3>
&lt;ul>
&lt;li>&lt;code>--hard-pod-affinity-symmetric-weight&lt;/code> 和 &lt;code>--scheduler-name&lt;/code> 已经从 kube-scheduler 中移除（自 v1.18 废弃）；&lt;/li>
&lt;/ul>
&lt;h3 id="api-变更">API 变更&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99597">#99597&lt;/a> kube-scheduler component config 现在开始用 v1beta2 API ，这意味着三个插件被废弃，分别是 NodeLabel, ServiceAffinity, NodePreferAvoidPods；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102834">#102834&lt;/a> Network Policy EndPort 已达到 beta 级别，并将默认开启使用；&lt;/li>
&lt;/ul>
&lt;h3 id="特性">特性&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/101316">#101316&lt;/a> &lt;strong>为 StatefulSet 增加了一个 minReadySeconds 参数&lt;/strong>，通过此参数可以设置 sts 的最小就绪时间，不会过早的在 Pod 就绪前就把流量引入；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102722">#102722&lt;/a> 为 kubeadm 在 &lt;code>kubeadm init&lt;/code> 增加了 &lt;code>--dry-run&lt;/code> 的选项；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102466">#102466&lt;/a> 将 kubeadm 部署用的 CoreDNS 升级到了 v1.8.4 同时也授予了其 &lt;code>EndpointSlice&lt;/code> 的 list 和 watch 权限；&lt;/li>
&lt;/ul>
&lt;h3 id="bugfix">bugfix&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102840">102840&lt;/a> 更改了 Graceful Node Shutdown Pod 的 Reason 和 Message，变更如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- nodeShutdownReason = &amp;#34;Shutdown&amp;#34;
&lt;/span>&lt;span class="gd">- nodeShutdownMessage = &amp;#34;Node is shutting, evicting pods&amp;#34;
&lt;/span>&lt;span class="gd">- nodeShutdownNotAdmitMessage = &amp;#34;Node is in progress of shutting down, not admitting any new pods&amp;#34;
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ nodeShutdownReason = &amp;#34;Terminated&amp;#34;
&lt;/span>&lt;span class="gi">+ nodeShutdownMessage = &amp;#34;Pod was terminated in response to imminent node shutdown.&amp;#34;
&lt;/span>&lt;span class="gi">+ nodeShutdownNotAdmittedReason = &amp;#34;NodeShutdown&amp;#34;
&lt;/span>&lt;span class="gi">+ nodeShutdownNotAdmittedMessage = &amp;#34;Pod was rejected as the node is shutting down.&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更请参考其 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.22.md#changelog-since-v1220-alpha3">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">更优雅的 Kubernetes 集群事件度量方案</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/06/25/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84-Kubernetes-%E9%9B%86%E7%BE%A4%E4%BA%8B%E4%BB%B6%E5%BA%A6%E9%87%8F%E6%96%B9%E6%A1%88/"/><id>https://moelove.info/2021/06/25/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84-Kubernetes-%E9%9B%86%E7%BE%A4%E4%BA%8B%E4%BB%B6%E5%BA%A6%E9%87%8F%E6%96%B9%E6%A1%88/</id><updated>2021-06-25T14:14:36+08:00</updated><published>2021-06-25T05:53:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 群里有个小伙伴问了我上图中这个问题，如何度量滚动升级这个过程的时间。 这个问题可以抽象为一种通用需求，适用于多……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/25/294ohZRewN7c8qI.jpg" alt="">&lt;/p>
&lt;p>群里有个小伙伴问了我上图中这个问题，如何度量滚动升级这个过程的时间。&lt;/p>
&lt;p>这个问题可以抽象为一种通用需求，适用于多种场景。&lt;/p>
&lt;ul>
&lt;li>比如你是 Kubernetes 集群的管理员，你想度量这个过程中的耗时，以便发现优化点；&lt;/li>
&lt;li>比如你是在做 CI/CD ，你想通过度量这个过程的耗时，来给出 CI/CD 过程的耗时；&lt;/li>
&lt;/ul>
&lt;h2 id="现有方案">现有方案&lt;/h2>
&lt;p>Kubernetes 已经提供了很方便的办法来解决此问题，也就是我回复中谈到的，通过 event 来度量即可。&lt;/p>
&lt;p>比如，我们在 K8S 中，创建一个 deployment，看看这个过程中的 event 信息：&lt;/p>
&lt;pre>&lt;code>➜ ~ kubectl create ns moelove
namespace/moelove created
➜ ~ kubectl -n moelove create deployment redis --image=ghcr.io/moelove/redis:alpine
deployment.apps/redis created
➜ ~ kubectl -n moelove get deploy
NAME READY UP-TO-DATE AVAILABLE AGE
redis 1/1 1 1 16s
➜ ~ kubectl -n moelove get events
LAST SEEN TYPE REASON OBJECT MESSAGE
27s Normal Scheduled pod/redis-687967dbc5-gsz5n Successfully assigned moelove/redis-687967dbc5-gsz5n to kind-control-plane
27s Normal Pulled pod/redis-687967dbc5-gsz5n Container image &amp;quot;ghcr.io/moelove/redis:alpine&amp;quot; already present on machine
27s Normal Created pod/redis-687967dbc5-gsz5n Created container redis
27s Normal Started pod/redis-687967dbc5-gsz5n Started container redis
27s Normal SuccessfulCreate replicaset/redis-687967dbc5 Created pod: redis-687967dbc5-gsz5n
27s Normal ScalingReplicaSet deployment/redis Scaled up replica set redis-687967dbc5 to 1
&lt;/code>&lt;/pre>&lt;p>可以看到我们主要关注的一些事件均已经有记录了。但是总不能每次都通过 kubectl 这么来看吧，有点浪费时间。&lt;/p>
&lt;p>我之前的一种做法是在 K8S 中写了一个程序，持续的监听&amp;amp;收集 K8S 集群中的 event ，并将它写入到我另外开发的一套系统中进行存储和可视化。但这种方法需要做额外的开发也并不普适。这里我来介绍另一个更优的解决方案。&lt;/p>
&lt;h2 id="更优雅的方案">更优雅的方案&lt;/h2>
&lt;p>K8S 中的这些事件，都对应着我们的一个操作，比如上文中是创建了一个 deployment ，它产生了几个 event ， 包括 &lt;code>Scheduled&lt;/code> , &lt;code>Pulled&lt;/code> ，&lt;code>Created&lt;/code> 等。我们将其进行抽象，是不是和我们做的链路追踪（tracing）很像呢？&lt;/p>
&lt;p>这里我们会用到一个 CNCF 的毕业项目 &lt;a href="https://www.jaegertracing.io/" title="Jaeger">Jaeger&lt;/a> ，在之前的 &lt;a href="https://zhuanlan.zhihu.com/container">K8S生态周报&lt;/a> 中我有多次介绍它，Jaeger 是一款开源的，端对端的分布式 tracing 系统。不过本文重点不是介绍它，所以我们&lt;a href="https://www.jaegertracing.io/docs/1.23/getting-started/">查看其文档&lt;/a>，快速的部署一个 Jaeger 即可。另一个 CNCF 的 sandbox 级别的项目是 &lt;a href="https://opentelemetry.io/" title="OpenTelemetry">OpenTelemetry&lt;/a> 是一个云原生软件的可观测框架，我们可以把它跟 Jaeger 结合起来使用。不过本文的重点不是介绍这俩项目，这里暂且略过。&lt;/p>
&lt;p>接下来介绍我们这篇文章的用到的主要项目，是来自 Weaveworks 开源的一个项目，名叫 &lt;a href="https://github.com/weaveworks-experiments/kspan">kspan&lt;/a> ，它的主要做法就是将 K8S 中的 event 作为 trace 系统中的 span 进行组织。&lt;/p>
&lt;h3 id="部署-kspan">部署 kspan&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRoleBinding&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">creationTimestamp&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan-admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">roleRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiGroup&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rbac.authorization.k8s.io&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterRole&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cluster-admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">subjects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker.io/weaveworks/kspan:v0.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{}&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterFirst&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">restartPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Always&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceAccountName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kspan&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以直接使用我这里提供的 YAML 进行部署测试，&lt;strong>但注意上述配置文件别用在生产环境下， RBAC 权限需要修改&lt;/strong> 。&lt;/p>
&lt;p>它默认会使用 &lt;code>otlp-collector.default:55680&lt;/code> 传递 span ，所有你需要确保有这个 svc 存在。以上所有内容部署完成后你大概会是这样：&lt;/p>
&lt;pre>&lt;code>➜ ~ kubectl get all
NAME READY STATUS RESTARTS AGE
pod/jaeger-76c84457fb-89s5v 1/1 Running 0 64m
pod/kspan 1/1 Running 0 35m
pod/otel-agent-sqlk6 1/1 Running 0 59m
pod/otel-collector-69985cc444-bjb92 1/1 Running 0 56m
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/jaeger-collector ClusterIP 10.96.47.12 &amp;lt;none&amp;gt; 14250/TCP 60m
service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 39h
service/otel-collector ClusterIP 10.96.231.43 &amp;lt;none&amp;gt; 4317/TCP,14250/TCP,14268/TCP,9411/TCP,8888/TCP 59m
service/otlp-collector ClusterIP 10.96.79.181 &amp;lt;none&amp;gt; 55680/TCP 52m
NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE
daemonset.apps/otel-agent 1 1 1 1 1 &amp;lt;none&amp;gt; 59m
NAME READY UP-TO-DATE AVAILABLE AGE
deployment.apps/jaeger 1/1 1 1 73m
deployment.apps/otel-collector 1/1 1 1 59m
NAME DESIRED CURRENT READY AGE
replicaset.apps/jaeger-6f77c67c44 0 0 0 73m
replicaset.apps/jaeger-76c84457fb 1 1 1 64m
replicaset.apps/otel-collector-69985cc444 1 1 1 59m
&lt;/code>&lt;/pre>&lt;h3 id="上手实践">上手实践&lt;/h3>
&lt;p>这里我们先创建一个 namespace 用于测试：&lt;/p>
&lt;pre>&lt;code>➜ ~ kubectl create ns moelove
namespace/moelove created
&lt;/code>&lt;/pre>&lt;p>创建一个 Deployment&lt;/p>
&lt;pre>&lt;code>➜ ~ kubectl -n moelove create deployment redis --image=ghcr.io/moelove/redis:alpine
deployment.apps/redis created
➜ ~ kubectl -n moelove get pods
NAME READY STATUS RESTARTS AGE
redis-687967dbc5-xj2zs 1/1 Running 0 10s
&lt;/code>&lt;/pre>&lt;p>在 Jaeger 上进行查看：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/25/FhyKx2c3wpSjqMl.png" alt="">&lt;/p>
&lt;p>点开看详细内容&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/25/cIyzN5Himdb6GEW.png" alt="">&lt;/p>
&lt;p>可以看到，和此创建 deploy 有关的 event 均被归到了一起，在时间线上可以看到其耗时等详细信息。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了如何结合 Jaeger 利用 tracing 的方式来采集 K8S 中的 events ，以便更好的掌握 K8S 集群中所有事件的耗时点，更易于找到优化的方向及度量结果。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Jaeger/" term="Jaeger" label="Jaeger"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">开源项目的 5 年长跑，runc v1.0 终于正式发布！</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/06/23/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84-5-%E5%B9%B4%E9%95%BF%E8%B7%91runc-v1.0-%E7%BB%88%E4%BA%8E%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2021/06/23/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84-5-%E5%B9%B4%E9%95%BF%E8%B7%91runc-v1.0-%E7%BB%88%E4%BA%8E%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-06-23T16:17:53+08:00</updated><published>2021-06-23T02:08:20+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本文我来分享下与我们（搞容器化/K8S 从业者）息息相关的一个基础项目 runc 是如何自 2016 年发布了 v1.0.0-rc1 到现在历经 5 年长跑，从 rc1 一直到 rc95 ，如今……</summary><content type="html">&lt;blockquote>
&lt;p>本文我来分享下与我们（搞容器化/K8S 从业者）息息相关的一个基础项目 &lt;a href="https://github.com/opencontainers/runc" title="runc">runc&lt;/a> 是如何自 2016 年发布了 v1.0.0-rc1 到现在历经 5 年长跑，从 rc1 一直到 rc95 ，如今终于正式发布 v1.0 版本的过程，及这中间的故事。&lt;/p>
&lt;/blockquote>
&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>在 2018 年 11 月底时，我写了一篇文章 &lt;a href="https://zhuanlan.zhihu.com/p/50923312" title="runc-1.0-rc6-发布之际">《runc 1.0-rc6 发布之际》&lt;/a> , 那应该是我第一次公开介绍 runc。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中不再对其概念和用法等进行说明。&lt;/p>
&lt;p>在 2019 年 3 月底时，我写了另一篇文章 &lt;a href="https://zhuanlan.zhihu.com/p/60981504" title="runc 1.0-rc7 发布之际">《runc 1.0-rc7 发布之际》&lt;/a>，介绍 runc 1.0-rc7 发布的原因，及那个版本中最主要的修复 &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5736">&lt;code>CVE-2019-5736&lt;/code>&lt;/a>&lt;/strong> 。其中也介绍了关于 runc/Docker 等对于 Linux 内核兼容性的问题，感兴趣的小伙伴可以看看。&lt;/p>
&lt;p>关注我的朋友们，应该也在 &lt;a href="https://zhuanlan.zhihu.com/container" title="K8S 生态">K8S 生态周报&lt;/a> 中多次看到过我对 runc 的介绍，包括其特性及安全漏洞等方面。&lt;/p>
&lt;p>在 2015 年 6 月， Docker ，CoreOS 和其他一些公司共同成立了 &lt;a href="https://opencontainers.org/">OCI （开放容器计划）&lt;/a> 组织，其最主要的内容有两个：&lt;/p>
&lt;ul>
&lt;li>容器运行时规范&lt;/li>
&lt;li>容器镜像规范&lt;/li>
&lt;/ul>
&lt;p>Docker 将其运行时捐赠给了 OCI ，作为容器运行时规范的基础实现，托管在了 &lt;a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc&lt;/a> 也就是现在大家看到的 runc 了。&lt;/p>
&lt;h2 id="发布历程">发布历程&lt;/h2>
&lt;p>我们来看看 runc 版本发布的历程，以便了解它为何长跑 5 年。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">runc version&lt;/th>
&lt;th style="text-align:center">release time&lt;/th>
&lt;th style="text-align:center">runtime-spec version&lt;/th>
&lt;th style="text-align:center">备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc1&lt;/td>
&lt;td style="text-align:center">2016.06.04&lt;/td>
&lt;td style="text-align:center">v1.0.0-rc1&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc2&lt;/td>
&lt;td style="text-align:center">2016.10.01&lt;/td>
&lt;td style="text-align:center">v1.0.0-rc2-38-g1c7c27d&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc3&lt;/td>
&lt;td style="text-align:center">2017.03.22&lt;/td>
&lt;td style="text-align:center">&lt;a href="https://github.com/opencontainers/runc/pull/1370">v1.0.0-rc5&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc4&lt;/td>
&lt;td style="text-align:center">2017.08.09&lt;/td>
&lt;td style="text-align:center">v1.0.0&lt;/td>
&lt;td style="text-align:center">runtime-spec 首次发布 v1.0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc5&lt;/td>
&lt;td style="text-align:center">2018.02.27&lt;/td>
&lt;td style="text-align:center">v1.0.0&lt;/td>
&lt;td style="text-align:center">首次计划作为最后一个 rc 版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc6&lt;/td>
&lt;td style="text-align:center">2018.11.21&lt;/td>
&lt;td style="text-align:center">v1.0.1-49-g5684b8a&lt;/td>
&lt;td style="text-align:center">计划是 1.0 之前的最后一个功能版本，包含了一些规范合规性的修正&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc7&lt;/td>
&lt;td style="text-align:center">2019.03.28&lt;/td>
&lt;td style="text-align:center">v1.0.1-59-g29686db&lt;/td>
&lt;td style="text-align:center">修复 CVE-2019-5736&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc8&lt;/td>
&lt;td style="text-align:center">2019.04.26&lt;/td>
&lt;td style="text-align:center">v1.0.1-59-g29686db&lt;/td>
&lt;td style="text-align:center">修复 v1.0.0-rc7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc9&lt;/td>
&lt;td style="text-align:center">2019.10.05&lt;/td>
&lt;td style="text-align:center">v1.0.1-59-g29686db&lt;/td>
&lt;td style="text-align:center">修复 CVE-2019-16884&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc10&lt;/td>
&lt;td style="text-align:center">2020.01.23&lt;/td>
&lt;td style="text-align:center">v1.0.1-59-g29686db&lt;/td>
&lt;td style="text-align:center">修复 CVE-2019-19921&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc90&lt;/td>
&lt;td style="text-align:center">2020.05.12&lt;/td>
&lt;td style="text-align:center">v1.0.1-59-g29686db&lt;/td>
&lt;td style="text-align:center">与 runc v1.0-rc10 相同，是为了修正 version scheme&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc91&lt;/td>
&lt;td style="text-align:center">2020.07.02&lt;/td>
&lt;td style="text-align:center">v1.0.2-8-g237cc4f&lt;/td>
&lt;td style="text-align:center">开始支持 cgroup v2 ；一些规范性的问题得到解决&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc92&lt;/td>
&lt;td style="text-align:center">2020.08.06&lt;/td>
&lt;td style="text-align:center">v1.0.2-23-g4d89ac9&lt;/td>
&lt;td style="text-align:center">修复我在 runc v1.0-rc91 中发现的 bug&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc93&lt;/td>
&lt;td style="text-align:center">2021.02.04&lt;/td>
&lt;td style="text-align:center">v1.0.2-35-ge6143ca&lt;/td>
&lt;td style="text-align:center">cgroup v2 得到稳定支持，&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc94&lt;/td>
&lt;td style="text-align:center">2021.05.10&lt;/td>
&lt;td style="text-align:center">v1.0.2-57-g1c3f411&lt;/td>
&lt;td style="text-align:center">修复 runc v1.0-rc93 中的 regressions&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0-rc95&lt;/td>
&lt;td style="text-align:center">2021.05.19&lt;/td>
&lt;td style="text-align:center">v1.0.2-57-g1c3f411&lt;/td>
&lt;td style="text-align:center">修复 &lt;a href="https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r">CVE-2021-30465&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">runc v1.0&lt;/td>
&lt;td style="text-align:center">2021.06.22&lt;/td>
&lt;td style="text-align:center">v1.0.2-57-g1c3f411&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我在上面的表格中，专门增加了一列 &lt;strong>runtime-spec version&lt;/strong> ，表示 OCI 组织中的容器运行时规范的版本。我们来总结下这个发布进程：&lt;/p>
&lt;ul>
&lt;li>在 runc v1.0-rc5 之前，runc 其实也没打算发布正式版，毕竟标准还没正式完成呢，实现也不可能先出稳定版；&lt;/li>
&lt;li>runc v1.0-rc7 , rc 9 ~ rc 10 均是为了修正严重的安全问题；&lt;/li>
&lt;li>runc v1.0-rc90 纯粹是解决 version scheme 的问题；&lt;/li>
&lt;li>runc v1.0-rc91~rc93 主要功能点是在 cgroup v2 的支持，以及一些跟规范集成的问题；&lt;/li>
&lt;li>runc v1.0-93 之后，其实就基本控制代码冻结了，直到 runc v1.0-rc95 修复了一个安全漏洞；&lt;/li>
&lt;li>目前主要的几个仓库也都已经测试了跟 runc 代码仓库中最新代码的集成，相关的问题也已经修复。&lt;/li>
&lt;/ul>
&lt;p>从这里看到的三个主要耗时的点如下：&lt;/p>
&lt;ul>
&lt;li>runtime-spec 尚未正式发布 v1.0 版本；&lt;/li>
&lt;li>修复安全漏洞和自身的 bug ；&lt;/li>
&lt;li>完成新特性的耗时；&lt;/li>
&lt;/ul>
&lt;p>规范未发布 v1.0 耗时的部分这里就不多说了，这也是个依赖项，对于大多数的项目/软件开发都会有类似的情况，只能去推动规范的发布了；&lt;/p>
&lt;p>至于特性，bug 和安全漏洞等的耗时，这其实跟 runc 项目的功能和其定位有关。runc 偏底层了一些，这就需要有更多相关领域的知识来支撑。就拿我在 runc v1.0-rc 91 中发现的那个bug 来说，对 Linux 内核源码不太了解的人，确实会花费比较多时间的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- switch {
&lt;/span>&lt;span class="gd">- case mode&amp;amp;unix.S_IFBLK == unix.S_IFBLK:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ switch mode &amp;amp; unix.S_IFMT {
&lt;/span>&lt;span class="gi">+ case unix.S_IFBLK:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.BlockDevice
&lt;span class="gd">- case mode&amp;amp;unix.S_IFCHR == unix.S_IFCHR:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ case unix.S_IFCHR:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.CharDevice
&lt;span class="gd">- case mode&amp;amp;unix.S_IFIFO == unix.S_IFIFO:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ case unix.S_IFIFO:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.FifoDevice
default:
return nil, ErrNotADevice
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外不得不提的就是在 runc 这些版本中还有一大批比较耗费时间和精力的工作，包括添加测试，以及性能优化等，作为底层的基础软件，性能优化对于上层的应用/平台而言影响重大。&lt;/p>
&lt;p>有趣的是 runc v1.0 版本 Release 的标题是 &lt;strong>&amp;quot;A wizard is never late, nor is he early, he arrives precisely when he means to.&amp;quot;&lt;/strong> 这大概也很符合 runc 的发布历程了吧 :)&lt;/p>
&lt;p>&lt;strong>但无论如何，runc 经过 5 年长跑，终于发布了 v1.0 版本！感谢每一个为之付出过的小伙伴！&lt;/strong>&lt;/p>
&lt;p>欢迎大家下载更新！ &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0">https://github.com/opencontainers/runc/releases/tag/v1.0.0&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/runc/" term="runc" label="runc"/></entry><entry><title type="text">为什么我们需要一个容器镜像的包管理器</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/06/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/><id>https://moelove.info/2021/06/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</id><updated>2021-06-22T15:09:08+08:00</updated><published>2021-06-17T23:55:43+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">TL;DR 我们需要对 container 供应链进行更好的元数据管理，以便更好地进行分析; OCI 规范目前没有办法打包容器镜像工件或一组容器镜像。但他们会慢慢做到……</summary><content type="html">&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;ul>
&lt;li>我们需要对 container 供应链进行更好的元数据管理，以便更好地进行分析;&lt;/li>
&lt;li>OCI 规范目前没有办法打包容器镜像工件或一组容器镜像。但他们会慢慢做到这一点；&lt;/li>
&lt;li>同时，我们需要一个用于容器镜像的包管理器；&lt;/li>
&lt;/ul>
&lt;h2 id="一些背景">一些背景&lt;/h2>
&lt;p>我维护着一个叫做 &lt;a href="https://github.com/vmware/tern" title="Tern">Tern&lt;/a> 的开源项目，这个项目是为容器镜像生成一个软件材料清单（SBOM）。很多安装在容器镜像中的组件都是独立安装的，而非通过包管理器。这使得我们很难弄清楚创建这个容器镜像的作者的意图。它也没有提供更多关于容器镜像贡献者的信息。大多数容器镜像都是基于之前已有的容器镜像，通过客户端工具或者镜像仓库都很难看到这些信息。&lt;/p>
&lt;p>我想如果有一个“容器镜像”的包管理器，应该能解决这个问题。因此，我早在 &lt;a href="https://youtu.be/WY3s_cG9ia8" title="KubeCon 2018">KubeCon 2018&lt;/a> 的时候就提出了 &amp;quot;打包&amp;quot; 的想法，我问容器镜像的 manifest 是否可以保存这些信息，以便工具可以根据容器镜像的供应链来进行分析。&lt;/p>
&lt;p>事实证明，社区已经在考虑如何管理 helm chart、OPA 策略、文件系统和签名等事情了。这就是我参与 &lt;a href="https://opencontainers.org/">开放容器计划（OCI）组织 &lt;/a> 的原因（我还欠 @vbatts 一个介绍我的人情）。当时的理解是，容器镜像除了需要通过摘要来进行识别外，不需要进行其他管理。也不需要管理依赖，因为所有的依赖都被打包进了容器镜像中。通过再次重建容器和保持一个下游消费者可以 pull 的滚动标签来处理更新。&lt;/p>
&lt;p>然而，容器生态除了可移植性外，并没有提供太多东西。和容器镜像一起管理容器元数据可以为使用者和贡献者提供更多关于供应链的宝贵信息。经过了两年时间和几次供应链攻击之后，我们仍然在讨论，如何最好的做到这一点。在这里，我试图将一些提议的概念归纳起来，看看它们如何满足我们对元数据管理的要求。&lt;/p>
&lt;h2 id="回到起点">回到起点&lt;/h2>
&lt;p>我们写一个包管理器主要有以下三个原因：&lt;/p>
&lt;ol>
&lt;li>标识 - 为你的新文件或者包提供一个名字和其他唯一可识别的特征；&lt;/li>
&lt;li>上下文 - 了解你的包和其他包的关系（即，依赖性管理）；&lt;/li>
&lt;li>新鲜度 - 确保你的包在其生态系统中可维护并保持更新；&lt;/li>
&lt;/ol>
&lt;p>实际上还有第4个原因，“构建的可重复性” - 我认为它属于“上下文”，但在这里，它确实值得一提，因为了解你的包在特定时间的状态是很必要的。这样你才能分析出过去的“好”状态，和现在“不那么好”的状态，即：使用二等分的方法分析构建。&lt;/p>
&lt;p>由于一些（善意的）假设，容器镜像生态并没有这些功能。一个容器可以通过它的摘要（digest）被标识。你不需要管理生态，因为整个生态已经存在于一个单元中了。你不需要更新容器 - 只需要构建一个新的镜像，所有需要更新的内容都将被更新。只要你的应用程序没问题，那它便可以正常工作。然而，如果你打算长期维护你的应用程序，你必须准备好处理堆栈更新和重大版本。我们当前除了“下载最新版本”外没有其他好的办法来管理堆栈更新（一个值得注意的例外是 Cloud Native Buildpacks ，但我们此处将专注于通用案例）。堆栈的破坏性变更可能会阻塞你重新构建镜像，这迫使你需要保留一个旧版本的镜像，因为你已经知道这个镜像可以工作。你可以想象到，维护一组容器镜像将变得更加费力。如果维护一组容器镜像所需的信息是内置的，并在需要时可用，那就真的太好了。&lt;/p>
&lt;h2 id="用于管理元数据的镜像仓库">用于管理元数据的镜像仓库&lt;/h2>
&lt;p>我们可以建立一个单独的元数据存储解决方案，但现在我们已经有镜像仓库了。通过一些改进，它们可以被用来和容器镜像一起存储补充元数据。组织已经对包含源 tarball 的源镜像和签名 payload（正如 cosign 所做的那样） 执行此操作。&lt;/p>
&lt;p>使用镜像仓库的好处在于元数据可以和目标镜像一起存储。对 OCI 规范的建议主要涉及结构化和引用这些数据。这基本上是服务端的包管理，让这些建议被合并是很困难的，因为目前存在的客户端-服务端关系是很紧密的，对服务端的任何改变都会影响到客户端，对客户端打包机制的任何变更也都会影响到服务端。因此，目前的 OCI 规范除了扩展与当前 Docker 客户端和 Docker registry 工作方式保持同步的规范外，还不能包括增强功能。&lt;/p>
&lt;p>这篇文章并不是要批评当前的生态，而是想要把对话引到一个社区可以更可持续的维护它们的容器镜像的位置。就我个人而言，我也想证明在容器镜像领域是需要一个包管理器的，尽管镜像仓库可以支持相关 artifacts 和容器镜像的链接，也可以支持在容器镜像之间进行链接。&lt;/p>
&lt;p>其他生态系统中的包管理器也有客户端和服务端的关系，所以在客户端和服务端之间分摊压力的架构并不新鲜。只不过在当前场景下，这种关系略有不同。&lt;/p>
&lt;h2 id="identification-识别">Identification （识别）&lt;/h2>
&lt;p>容器镜像的工作方式有点像 &lt;a href="https://en.wikipedia.org/wiki/Merkle_tree" title="Merkle Tree">Merkle Tree&lt;/a> 有一个&lt;a href="https://github.com/opencontainers/image-spec/blob/master/config.md">镜像配置&lt;/a>的数据块，以及代表容器文件系统的一个或多个数据块。每个数据块都经过了哈希处理，并且放在了经过哈希处理过的 &lt;a href="https://github.com/opencontainers/image-spec/blob/master/manifest.md">Image Manifest&lt;/a> 中。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/19/41Hgwj56GamYzC3.png" alt="img">&lt;/p>
&lt;p>现在可以很好的专门识别这个包，但它缺少其他可识别的特征，最明显的是名称和版本。在容器世界里，名字通常是一个镜像仓库的名称，而版本则通常是一个 tag 。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/19/zPdF2feEk3HJXiu.png" alt="img">&lt;/p>
&lt;p>就像 Git 一样，所有对文件集的引用都是哈希值，其他引用可以指向它们，例如 &lt;code>HEAD&lt;/code>，&lt;code>FETCH_HEAD&lt;/code> 或 tag。tag 可以遵循语义版本控制，可以被移到另一个提交中。在开源的世界里没有人这样做，因为这会破坏项目维护者和社区其他成员间的固有契约。容器镜像的 tag 并没有需要遵循语义版本控制的规则，但很多语言包管理器都依赖它，因此使用语义化版本控制容器镜像是有一定的希望的。&lt;/p>
&lt;p>无论如何，哈希值对容器镜像而言是相当好的一个标识符。&lt;/p>
&lt;p>那么其他可识别的特征呢？以下是一些其他包管理器使用的特征：&lt;/p>
&lt;ul>
&lt;li>许可证和版权信息&lt;/li>
&lt;li>作者/供应商&lt;/li>
&lt;li>发布日期&lt;/li>
&lt;li>指向源代码的链接&lt;/li>
&lt;li>第三方组件的列表（使用的操作系统，需要预安装的包等）&lt;/li>
&lt;/ul>
&lt;p>最后一项可能会变得相当长，因为创建一个容器镜像实际需要的第三方组件可能达到数百个。最近我一直主张将这些信息跟随容器镜像放入一个 SBOM（软件材料清单）中，容器镜像签名是另一个可以和容器镜像一起传播的工件，例如镜像清单的分离式前面，或者一个签名荷载。&lt;/p>
&lt;p>我们现在有多个容器镜像的识别工件，我们希望将它们与容器镜像联系起来。当前的 OCI 建议使用 &lt;em>references&lt;/em> (引用)，一个引用是包含了 blob 哈希和其引用清单的哈希组成的清单。在我们的例子中，引用是图像清单的哈希值。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/FMaW6LcVEhb84xi.png" alt="img">&lt;/p>
&lt;p>这种布局还存在一些问题：&lt;/p>
&lt;ol>
&lt;li>registry 可能只识别被标记的工件，因此会删除任何没有被标记的东西；&lt;/li>
&lt;li>删除镜像会导致空引用；&lt;/li>
&lt;/ol>
&lt;p>一个快速的解决方案可能是标记所有的清单。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/4d61DjGVgEasOcw.png" alt="img">&lt;/p>
&lt;p>这意味着需要有东西能够跟踪标签和它们之间的关系，同时跟踪所有工件的版本。&lt;/p>
&lt;p>一个长期的解决方案可能是定义一个规范的工件清单，registry 将识别并将其视为特殊的存在。如果是这样的话，那就需要计算或者跟踪与每个清单关联的引用数量了。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/vS1MjlQ4GhEC9OA.png" alt="img">&lt;/p>
&lt;p>registry 实现者可以按照他们想要的任何方式来跟踪图中的链接。例如，在这个图中，对每个清单的引用数量都会被跟踪（减去哈希），但镜像清单被删除时，操作将会沿着树向下走到每个引用的末端，并按照一定的顺序去删除它们，直到引用数为 0。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/nPazC5dcS6H4prI.png" alt="">&lt;/p>
&lt;p>但在这里，我们为了追踪所有的相关对象，正在进入一些复杂的追踪系统。这是在 registry 端完成的包管理。可以提出一个论点，实现一个中立的垃圾收集器，它可以被 registry 或客户端使用，但我们现在讲的有点超前了。&lt;/p>
&lt;p>我希望这足以说明有必要对工件的集合进行追踪，无论是在客户端还是服务端，或是两者都有。&lt;/p>
&lt;h2 id="context">Context&lt;/h2>
&lt;p>据了解，一个容器在运行时没有外部依赖性。但是在构建时，最终的容器镜像确实取决于初始容器镜像的状态，通常是 Dockerfile 中的 &lt;code>FROM&lt;/code> 语句所定义的镜像。由于 Merkle Trees 的魔力，衍生的镜像与之前的镜像之间没有任何联系。因此，所有对旧镜像的引用都需要为新镜像创建一次，同时需要添加一些额外的工件。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/TPSYrqUw64eaxnW.png" alt="img">&lt;/p>
&lt;p>与普通的引用机制相比，工件清单机制可能有一个优势，因为在工件元数据被更新的同时，引用的数量被保持在最低水平。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/cTY7PR5A4ohjNUw.png" alt="img">&lt;/p>
&lt;p>这两种机制都支持供应链安全，监管链和系谱检查等要求。这两种机制都需要&lt;strong>引用管理&lt;/strong> 。 在前者中，客户端将会拷贝原始镜像的 SBOM 和签名清单，更新它的引用，和增加新的清单。在后者中，客户端必须下载工件清单，对其进行补充，并与新的容器镜像一起推送。无论哪种方式，客户端都需要理解一些语法，无论是 tag 名称，工件结构或者工件类型，更不用说对工件来自的生态系统的一些理解。（SBOMs 和签名只是其中两种常见的工作类型，可以包括在内）。&lt;/p>
&lt;p>我一直在考虑的一个用例是如何将一系列的镜像链接到一起，来描述一个云原生应用。例如，jaeger 应用程序实际上是有自己依赖关系图的容器集合，&lt;/p>
&lt;p>如果能以一种可以上传到 registry 的格式来描述这些链接，这样整个镜像就可以和它的补充工件，一起在 registry 之间进行转移。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/21/xFzrKSBLMwt8GmN.png" alt="img">&lt;/p>
&lt;p>这是处于我想象力边缘的部分（我的图太复杂了），但我希望这些用例能说明，如果现在不需要包管理器，那么很快就需要它来管理这些高层次的关系。&lt;/p>
&lt;h2 id="更新">更新&lt;/h2>
&lt;p>这是我希望语义版本控制能够得到更认真对待的一个地方。软件包管理器使用语义版本控制来允许一系列在整个堆栈中兼容的版本。这使得下游消费者能以最小的干扰来适应更新。目前，由于容器镜像只能通过其摘要进行识别，tag 是标识容器镜像处于什么版本的唯一办法，这就是包管理器真正有用的地方。&lt;/p>
&lt;p>通常情况下，客户端查询服务器，看看它们应用程序所需的任何包是否有更新。然后客户端告诉用户它们想下载的更新是可用的，如果用户有一个他们的应用程序兼容的版本范围，客户端就会在这个范围内下载新版本。&lt;/p>
&lt;p>当前的 distribution SPEC 支持列出 tags 。除此之外，registry 没有提供任何管理更新的方式，也许这就是 registry 端所需要的一切。这也意味着，检查和更新的工作，主要落在了客户端。&lt;/p>
&lt;h2 id="下一步">下一步&lt;/h2>
&lt;p>社区一致认为，这些提议对于当前的 SPEC 项目而言，要接受的话是过于大了 。然而（希望）能有一场公开的对话，试图将这些变化分解为可吸纳的部分，从而允许向后兼容当前的状态，并推动规范向前发展。&lt;/p>
&lt;p>可能在将来，并不需要有一个包管理器，因为 registry ，镜像和 artifacts 格式，将负责提供推理供应链所需的所有信息。但那是一个遥远的未来，在此期间，我们需要一个东西来填补空白，也就是一个包管理器。&lt;/p>
&lt;p>&lt;em>本文原作者 nishakm 原文地址：https://nishakm.github.io/code/metadata/ 经授权翻译&lt;/em>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v20.10.7 发布，修复了死锁和容器启动失败的问题</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/06/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.7-%E5%8F%91%E5%B8%83%E4%BF%AE%E5%A4%8D%E4%BA%86%E6%AD%BB%E9%94%81%E5%92%8C%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/><id>https://moelove.info/2021/06/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.7-%E5%8F%91%E5%B8%83%E4%BF%AE%E5%A4%8D%E4%BA%86%E6%AD%BB%E9%94%81%E5%92%8C%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</id><updated>2021-06-15T02:50:46+08:00</updated><published>2021-06-14T00:37:32+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v20.10.7 正式发布 Docker 在近……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v20107-正式发布">Docker v20.10.7 正式发布&lt;/h2>
&lt;p>Docker 在近期也发布了 v20.10.7 版本，这个版本中主要都是侧重在稳定性和安全性上，我们一起来看看具体有哪些值得关注的内容吧！&lt;/p>
&lt;h3 id="cli">CLI&lt;/h3>
&lt;p>CLI 方面主要是移除掉了一直以来存在的 &lt;code>WARNING: No kernel memory limit support&lt;/code> 这个 &lt;em>Warning&lt;/em> 信息，同时在 cgroup v2 下也不会再显示 &lt;code>WARNING: No oom kill disable support&lt;/code> 的 Warning 信息了。&lt;/p>
&lt;p>为什么呢？&lt;strong>因为 oom kill disable 在 cgroup v2 下不可用&lt;/strong>。 如果你在 cgroup v2 下使用了 &lt;code>--oom-kill-disable&lt;/code> 选项就会看到如下提示：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ docker info &lt;span class="p">|&lt;/span>grep Cgroup
Cgroup Driver: systemd
Cgroup Version: &lt;span class="m">2&lt;/span>
➜ ~ docker run --rm -it --oom-kill-disable -m 6m alpine sh
WARNING: Your kernel does not support OomKillDisable. OomKillDisable discarded.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里如果要介绍 cgroup v2 那内容就太多了，&lt;a href="https://gitchat.csdn.net/columnTopic/5e215c4ee8f01d4213867952">我在 2019 年接受访谈聊容器技术趋势的时候&lt;/a>就做了如下预测：&lt;/p>
&lt;blockquote>
&lt;p>从底层次技术的角度来看，cgroup v2 将逐步普及，进而取代 cgroup v1，但这个过程可能需要两三年左右。&lt;/p>
&lt;p>整体而言，稳定性和性能优化将会是未来的主旋律。&lt;/p>
&lt;/blockquote>
&lt;p>现在已经过去了一年多的时间，&lt;strong>完全符合我当时的预测。&lt;/strong> 现在包括 runc、containerd、Docker、Kubernetes 等组件已经全部都支持了 cgroup v2 ，包括 Fedora 等操作系统也已将 cgroup v2 设置成了系统默认选项。各公司也都逐步在往 cgroup v2 上进行了迁移。&lt;/p>
&lt;h3 id="networking">Networking&lt;/h3>
&lt;p>在此版本中，主要解决了两个网络相关的问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>修复了一个可能导致 Docker DNS 无法解析的 deadlock 问题，&lt;strong>此问题主要是在使用 Swarm 集群时才会遇到&lt;/strong> ，其他直接使用 Docker 或者将 Docker 作为 Kubernetes 容器运行时的用户不受影响。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于在 Docker v20.10.6 版本中处理了针对有 IPv6 网络机器上容器端口映射 API 的问题，详情请参考我&lt;a href="https://zhuanlan.zhihu.com/p/368003878">之前的 K8S 生态周报 - Docker v20.10.6 发布一文的内容&lt;/a> 。但是这里没有正确的处理当内核带有 &lt;code>ipv6.disable=1&lt;/code> 选项启动时的问题，这会导致 &lt;strong>当服务器启动时候，如果设置了 ipv6.disable=1 参数且进行了端口映射，则容器无法正常启动&lt;/strong> 。&lt;/p>
&lt;p>解决办法有 3 种：&lt;/p>
&lt;ul>
&lt;li>取消 &lt;code>ipv6.disable=1&lt;/code> 选项的设置（但通常这么设置了应该是有特定原因的）；&lt;/li>
&lt;li>&lt;strong>升级到 Docker v20.10.7 版本&lt;/strong>；&lt;/li>
&lt;li>在进行端口映射的时候，手动指定其绑定的 IPv4 地址，例如 &lt;code>docker run -d -p 0.0.0.0:6379:6379 ghcr.io/moelove/redis:alpine&lt;/code> ；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="其他">其他&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>默认使用 containerd v1.4.6 和 runc v1.0.0-rc95 以便于解决 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-30465">CVE-2021-30465&lt;/a> 漏洞；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker scan 更新到了 v0.8 ；&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ docker scan --version
Version: v0.8.0
Git commit: 35651ca
Provider: Snyk &lt;span class="o">(&lt;/span>1.563.0 &lt;span class="o">(&lt;/span>standalone&lt;span class="o">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>这个版本我是推荐大家进行更新的，尤其是如果你受到了文中提到的 v20.10.6 版本相关问题影响的话，那更加值得升级了。&lt;/p>
&lt;h2 id="docker-desktop-340-发布">Docker Desktop 3.4.0 发布&lt;/h2>
&lt;p>这个版本对大多数用户而言，需要关注的点主要有两个：&lt;/p>
&lt;ul>
&lt;li>Docker Inc. 积极听取社区用户的反馈，&lt;strong>跳过更新的功能，不再是付费用户专有了，可以放心选择升级/跳过升级&lt;/strong> ，这个事情的背景可以参考&lt;a href="https://zhuanlan.zhihu.com/p/371258358">我前两期的 K8S 生态周报&lt;/a> ;&lt;/li>
&lt;li>这个版本中对相关组件都进行了升级，包括 Docker Engine 升级到了 v20.10.7 ，Kubernetes 升级到了 v1.21.1 等；&lt;/li>
&lt;/ul>
&lt;h2 id="rook-v165-发布">Rook v1.6.5 发布&lt;/h2>
&lt;p>这是一个 patch release ，变动不大，但这个版本中有个值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>现在可以通过 Helm chart 来配置 CephCluster 这个 CR 了；&lt;/li>
&lt;/ul>
&lt;p>你可以使用类似下面的命令来进行配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">helm repo add rook-master https://charts.rook.io/master
helm install --create-namespace --namespace rook-ceph rook-ceph-cluster &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set &lt;span class="nv">operatorNamespace&lt;/span>&lt;span class="o">=&lt;/span>rook-ceph rook-master/rook-ceph-cluster -f values-override.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式相比之前每次都要写个 YAML 要方便多了，另外值得注意的一点是 &lt;strong>当前的 Helm chart 是实验性的，预计在 v1.7 中达到 stable&lt;/strong> 。&lt;/p>
&lt;h2 id="thanos-v021-发布">Thanos v0.21 发布&lt;/h2>
&lt;p>Thanos 是一个完整的 Prometheus HA 和持久化存储的方案。我在之前的文章中已经介绍过多次（搜了下从 2019 年 Thanos 成为 CNCF sandbox 项目开始就已经在持续介绍它了）&lt;/p>
&lt;p>此次更新最主要的特性只有一个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>为 Thanos API 增加了 TLS 和 basic auth 认证&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;p>这其实也是众多监控项目的一个发展趋势，还记得我之前写的文章《 &lt;a href="https://zhuanlan.zhihu.com/p/144048025">为 Prometheus Node Exporter 加上认证&lt;/a> 》吗？早期解决了有没有及普及度的问题后，就会逐步将注意力往安全性上放了。&lt;/p>
&lt;h2 id="kubernetes-ingress-nginx-v047-发布">Kubernetes Ingress-NGINX v0.47 发布&lt;/h2>
&lt;p>这个版本的发布主要是为了解决两个问题：&lt;/p>
&lt;ul>
&lt;li>修复 NGINX v1.20 的 CVE 漏洞，将其更新到了 v1.20.1 版本；&lt;/li>
&lt;li>为后续版本做准备。在后续版本中，我们计划逐步放弃对旧的 Kubernetes 版本的支持；&lt;/li>
&lt;/ul>
&lt;p>兼容说明如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Kubernetes 版本&lt;/th>
&lt;th style="text-align:center">Ingress-NGINX 版本&lt;/th>
&lt;th style="text-align:center">支持说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">1.22&lt;/td>
&lt;td style="text-align:center">TBD&lt;/td>
&lt;td style="text-align:center">进行中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1.21&lt;/td>
&lt;td style="text-align:center">v0.47.0&lt;/td>
&lt;td style="text-align:center">仅支持 CVE 和 crash 修正&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1.20&lt;/td>
&lt;td style="text-align:center">v0.47.0&lt;/td>
&lt;td style="text-align:center">仅支持 CVE 和 crash 修正&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">1.19&lt;/td>
&lt;td style="text-align:center">v0.47.0&lt;/td>
&lt;td style="text-align:center">在 v1.22 发布后 6 个月废弃&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>另外值得一提的是，这个版本是我和另外两个维护者一起发布的。我们三个人耗费了将近 2 个小时才完成了此次版本的发布，跨时区协作其实蛮累的。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102489">#102489 · kubernetes/kubernetes&lt;/a> &lt;strong>在新发布的几个 patch release 中，包含了一项 regression，会导致 kubelet crash，建议大家不要升级！&lt;/strong> 最新的修正版本本周将会发布。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/100142">#100142 · kubernetes/kubernetes&lt;/a> 在 &lt;code>kubectl get pods&lt;/code> 的输出中添加了 &lt;code>LAST RESTART&lt;/code> 列，例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ kubectl get pods -A
NAMESPACE NAME READY STATUS RESTARTS LAST RESTART AGE
kube-system coredns-74ff55c5b-6qp7j 1/1 Running &lt;span class="m">7&lt;/span> 23h 7d3h
kube-system coredns-74ff55c5b-z79st 1/1 Running &lt;span class="m">7&lt;/span> 23h 7d3h
kube-system etcd-jjacobelli-lt 1/1 Running &lt;span class="m">6&lt;/span> 23h 7d3h
kube-system kube-apiserver-jjacobelli-lt 1/1 Running &lt;span class="m">0&lt;/span> &amp;lt;none&amp;gt; 57s
kube-system kube-controller-manager-jjacobelli-lt 0/1 Running &lt;span class="m">8&lt;/span> 61s 7d3h
kube-system kube-flannel-ds-c8d66 1/1 Running &lt;span class="m">7&lt;/span> 8h 7d3h
kube-system kube-proxy-r9nrx 1/1 Running &lt;span class="m">6&lt;/span> 23h 7d3h
kube-system kube-scheduler-jjacobelli-lt 0/1 Running &lt;span class="m">8&lt;/span> 62s 7d3h
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样做的好处在于，用户可以很快的发现 Pod 上次重启/恢复的时间，而不需要去查看日志，方便了很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/102529/files">#102529 · kubernetes/kubernetes&lt;/a> CronJobControllerV2 达到 GA ！我在《&lt;a href="https://zhuanlan.zhihu.com/p/364074085">K8S 生态周报| Kubernetes v1.21 发布, 带来新的内存管理器&lt;/a>》中曾介绍过它，感兴趣的小伙伴可以看看；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个有趣的提案 &lt;a href="https://github.com/kubernetes/enhancements/pull/2777">KEP 2775&lt;/a> , 这个提案主要目的是 &lt;strong>为了保护集群资源，以及免受关联删除的影响&lt;/strong> ，提出希望增加交互式删除或者延迟删除的功能，有兴趣的小伙伴可以去这个 KEP 下留言，讨论；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GKE Dataplane V2 已于日前 GA ， 请参考我之前的两篇文章了解其背景 《&lt;a href="https://zhuanlan.zhihu.com/p/195759300">K8S 生态周报| Google 选择 Cilium 作为 GKE 下一代数据面&lt;/a>》 和 《&lt;a href="https://zhuanlan.zhihu.com/p/213745089">被 Google 选择的下一代数据面 Cilium 是什么&lt;/a>》 。目前它 GA 也标志着 Cilium 的又一大发展！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Grafana v8.0 正式发布了，在这个版本中增加了 AlertManger 的数据源，在告警方面的一大进步。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;h3 id="apisix-mesh-agent----将-apache-apisix-用于数据面与-istio-等控制面结合使用的-service-mesh-项目-利益相关我是-api7-团队的一员">apisix-mesh-agent - 将 Apache APISIX 用于数据面，与 Istio 等控制面结合使用的 service mesh 项目。 &lt;em>利益相关：我是 api7 团队的一员&lt;/em>&lt;/h3>
&lt;p>推荐此项目主要原因如下：&lt;/p>
&lt;ul>
&lt;li>Envoy 项目的上手学习成本较大。 Apache APISIX 相比之下更易上手和进行扩展；&lt;/li>
&lt;li>Apache APISIX 的性能相较 Envoy 来说是极大的优势；&lt;/li>
&lt;/ul>
&lt;p>如果你正在使用 Istio 但苦于 Envoy 的上手/二次开发难度大，那么我推荐你可以去了解下此项目。不过此项目当前只发布了 v0.6 版本，还需要持续的打磨，欢迎参与！&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/06/14/7qioUAjnCBl2VLG.png" alt="apisix-mesh-overview">&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Cilium v1.10.0 带来 Egress Gateway 等特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/05/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-v1.10.0-%E5%B8%A6%E6%9D%A5-Egress-Gateway-%E7%AD%89%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2021/05/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-v1.10.0-%E5%B8%A6%E6%9D%A5-Egress-Gateway-%E7%AD%89%E7%89%B9%E6%80%A7/</id><updated>2021-05-29T13:19:55+08:00</updated><published>2021-05-24T06:48:53+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KIND v0.11.0 正式发布 KIND (Kubernetes In……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v0110-正式发布">KIND v0.11.0 正式发布&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kind" title="KIND 项目">KIND (Kubernetes In Docker)&lt;/a> 关注我的小伙伴想必已经都很熟悉了，这是我一直都在参与也用的非常多的一个项目，它可以很方便的使用 Docker 容器作为 Kubernetes 的 Node ，快速的启动一个/或多个测试集群。自上个版本发布以来已经过了 4 个月，我们一起来看看这个版本中有哪些值得注意的变更吧！&lt;/p>
&lt;h3 id="破坏性变更">破坏性变更&lt;/h3>
&lt;ul>
&lt;li>在这个版本中默认的 k8s 版本为 v1.21.1;&lt;/li>
&lt;li>移除掉了使用 &lt;code>bazel&lt;/code> 构建镜像的方式，&lt;code>kind build node-image&lt;/code> 的 &lt;code>--type&lt;/code> 参数已废弃；&lt;/li>
&lt;li>&lt;code>kind build node-image&lt;/code> 的 &lt;code>--kube-root&lt;/code> 参数已废弃，将会按照标准模式寻找 k8s 的代码目录的位置；&lt;/li>
&lt;/ul>
&lt;h3 id="新特性">新特性&lt;/h3>
&lt;ul>
&lt;li>&lt;code>kind build node-image&lt;/code> 新增了一个 &lt;code>--arch&lt;/code> 的参数，可支持构建多架构的镜像了；&lt;/li>
&lt;li>KIND 当前发布的预构建镜像，已经都是 multi-arch 的了，可运行在 amd64 和 arm64 架构上；&lt;/li>
&lt;li>当前 KIND 已经可以运行在 rootless 模式下的 Docker 和 rootless 模式下的 Podman 中了，详细指南请参考 &lt;a href="https://kind.sigs.k8s.io/docs/user/rootless/" title="KIND with rootless">KIND 运行在 rootless 模式&lt;/a> ;&lt;/li>
&lt;li>&lt;strong>KIND 默认的 CNI kindnetd 已经支持了双栈网络, 并在 v1.21 版本的 k8s 中默认启用&lt;/strong> ;&lt;/li>
&lt;/ul>
&lt;p>你可以通过以下任意方式安装最新版的 KIND ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GO111MODULE=&amp;quot;on&amp;quot; go get sigs.k8s.io/kind@v0.11.0&lt;/code>;&lt;/li>
&lt;li>&lt;code>wget -O kind https://kind.sigs.k8s.io/dl/v0.11.0/kind-linux-amd64&lt;/code>;&lt;/li>
&lt;li>clone &lt;a href="https://github.com/kubernetes-sigs/kind">KIND 的代码仓库&lt;/a>后，执行 &lt;code>make build&lt;/code> ;&lt;/li>
&lt;/ul>
&lt;p>更多关于 KIND 的使用及说明请参考官方文档：https://kind.sigs.k8s.io/ 欢迎下载使用。&lt;/p>
&lt;h2 id="apisix-ingress-controller-v060-发布">apisix-ingress-controller v0.6.0 发布&lt;/h2>
&lt;p>&lt;a href="https://github.com/apache/apisix-ingress-controller/" title="Apache APISIX Ingress controller">Apache APISIX Ingress controller&lt;/a> 是 Apache APISIX 的控制面组件，可以将其自定义资源（CR）及 Kubernetes 中原生的 Ingress 资源发布至 APISIX 中，进而利用 APISIX 作为入口网关管理南北向的流量。 我们一起来看看本次发布的 v0.6.0 版本中带来了哪些值得注意的变更吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/apache/apisix-ingress-controller/issues/115">#115&lt;/a> 支持了 TCP 代理；&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/apisix-ingress-controller/issues/242">#242&lt;/a> 为已经被 ingress controller 推送的资源增加了 label；&lt;/li>
&lt;li>为 &lt;code>ApisixUpstream&lt;/code> 和 &lt;code>ApisixTls&lt;/code> 增加了 jsonschema 校验；&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/apisix-ingress-controller/issues/394">#394&lt;/a> 记录了资源处理时的 Kubernetes events;&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/apisix-ingress-controller/issues/395">#395&lt;/a> 支持上报资源的 status;&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/apisix-ingress-controller/issues/402">#402&lt;/a> 为 cluster 级别的插件增加 global_rules 配置;&lt;/li>
&lt;/ul>
&lt;h2 id="cilium-v1100-正式发布">Cilium v1.10.0 正式发布&lt;/h2>
&lt;p>&lt;img src="https://cilium.io/static/c7f92a7f0c898d4ccae30eb23c559bfd/a3ebb/intro.png" alt="Cilium v1.10.0 - https://moelove.info">&lt;/p>
&lt;p>Cilium 我在之前的文章中已经介绍过很多次了，它基于 eBPF 技术，可以为 Kubernetes 中应用程序服务间网络和 API 连接提供透明代理和保护。 想快速了解 Cilium 可以参考我之前写的 &lt;a href="https://zhuanlan.zhihu.com/p/213745089">《Cilium 快速上手》&lt;/a> 想快速了解 eBPF 也可以看看我在 PyCon China 2020 上做的分享。&lt;/p>
&lt;p>Cilium v1.10 版本是一个比较大的特性版本，在这个版本中带来了众多值得关注的特性，我们一起来看看吧！&lt;/p>
&lt;h3 id="egress-ip-gateway">Egress IP Gateway&lt;/h3>
&lt;p>在几乎所有网络组件都在做入口网关的时候， Cilium 发现当把云原生应用和传统应用集成时，传统应用大多通过 IP 白名单的方式进行授权, 加上 Pod IP 的动态性，对 IP 地址的管理就成为了一个痛点。&lt;/p>
&lt;p>现在 Cilium 新版本中，通过新的 Kubernetes CRD ，可以在数据包离开 Kubernetes 集群时将静态 IP 与流量相关联，这使得外部防火墙会使用此一致的静态 IP 去识别 Pod 流量。&lt;/p>
&lt;p>其实就是 Cilium 帮忙做了 NAT ，使用起来也很简单：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cilium.io/v2alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumEgressNATPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">egress-sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">podSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># The following label selects default namespace&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">io.kubernetes.pod.namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">destinationCIDRs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="m">192.168.33.13&lt;/span>&lt;span class="l">/32&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egressSourceIP&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;192.168.33.100&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述的配置就是说：使用 &lt;code>egressSourceIP&lt;/code> 中配置的 IP 来处理来自于 default 命名空间中 Pod 的出口流量了。&lt;/p>
&lt;h3 id="bgp-集成的支持">BGP 集成的支持&lt;/h3>
&lt;p>很多小伙伴放弃 Cilium 的一大原因可能是因为 BGP 的支持，但从这个版本开始就不用担心了！&lt;/p>
&lt;p>Cilium 通过集成 MetalLB 来进行的，以此来达到 BGP L3 协议支持，这样 Cilium 可以为 LoadBalancer 类型的服务分配 IP ，并通过 BGP 将其通告的路由器，这样外部的流量就可以正常的访问到服务了。&lt;/p>
&lt;p>配置 BGP 支持的方式也很简单：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ConfigMap&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bgp-config&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">config.yaml&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> peers:
&lt;/span>&lt;span class="sd"> - peer-address: 10.0.0.1
&lt;/span>&lt;span class="sd"> peer-asn: 64512
&lt;/span>&lt;span class="sd"> my-asn: 64512
&lt;/span>&lt;span class="sd"> address-pools:
&lt;/span>&lt;span class="sd"> - name: default
&lt;/span>&lt;span class="sd"> protocol: bgp
&lt;/span>&lt;span class="sd"> addresses:
&lt;/span>&lt;span class="sd"> - 192.0.2.0/24&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要就是 &lt;code>peers&lt;/code> 用于和网络中现有的 BGP 路由器互联，&lt;code>address-pools&lt;/code> 则是 Cilium 为 LoadBalancer 分配的 IP 池。&lt;/p>
&lt;h3 id="基于-xdp-的独立负载均衡">基于 XDP 的独立负载均衡&lt;/h3>
&lt;p>Cilium 基于 eBPF 的负载均衡器最近增加了对 Maglev 一致性哈希的支持，以及 eXpress(XDP) 层上转发平面的加速，这些特性使得它也可以作为独立的 4 层负载均衡存在。&lt;/p>
&lt;p>Cilium XDP L4LB 具有完整的 IPv4/IPv6 双栈支持，可以独立于 Kubernetes 集群独立部署，作为一个可编程的 L4 LB 存在。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>另外就是增加了对 Wireguard 的支持，进行 Pod 间流量的加密；增加了一个新的 Cilium CLI ，用于管理 Cilium 集群；以及 &lt;strong>比以往更加优异的性能！&lt;/strong>&lt;/p>
&lt;p>更多关于 Cilium 项目的变更，请参考其 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.10.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>runc 发布了 v1.0-rc95 版本，大概是 v1.0 前的最后一个版本了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CNCF 网络小组定义了一套 &lt;a href="https://smp-spec.io/" title="Service Mesh Performance 的规范">Service Mesh Performance 的规范&lt;/a>，通过此规范来达成一个统一的标准，用来衡量 Service Mesh 的性能情况；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CNCF 网络小组定义了一套 Service Mesh Performance 的规范，通过此规范来达成一个统一的标准，用来衡量 Service Mesh 的性能情况；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Rancher Desktop v0.1.0 抢先一览</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/04/30/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rancher-Desktop-v0.1.0-%E6%8A%A2%E5%85%88%E4%B8%80%E8%A7%88/"/><id>https://moelove.info/2021/04/30/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rancher-Desktop-v0.1.0-%E6%8A%A2%E5%85%88%E4%B8%80%E8%A7%88/</id><updated>2021-05-24T06:51:00+08:00</updated><published>2021-04-30T17:01:30+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Trivy v0.17 正式发布 Trivy 是一……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="trivy-v017-正式发布">Trivy v0.17 正式发布&lt;/h2>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> 是一款由 Aqua Security 开源的镜像漏洞安全扫描程序，在之前的周报中我已经介绍过它很多次了，特别方便使用！（吃我安利！）本周 Trivy 发布了 v0.17 版本，我们一起来看看本次值得关注的变更。&lt;/p>
&lt;h3 id="破坏性变更">破坏性变更&lt;/h3>
&lt;p>Trivy 在之前的版本中，允许为 &lt;code>--skip-dirs&lt;/code> 参数通过逗号（,）分割，设定多个目录。自此版本中，将遵循大多数软件的默认行为，通过多次传递&lt;code>--skip-dirs&lt;/code> 来传递多个值，每个参数只处理一个目录。&lt;/p>
&lt;p>v0.17 版本之前：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">trivy image --skip-dirs &lt;span class="s2">&amp;#34;/usr/lib/ruby/gems,/etc&amp;#34;&lt;/span> fluent/fluentd:edge
&lt;/code>&lt;/pre>&lt;/div>&lt;p>v0.17 版本及之后：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">trivy image --skip-dirs /usr/lib/ruby/gems --skip-dirs &lt;span class="s2">&amp;#34;/etc&amp;#34;&lt;/span> fluent/fluentd:edge
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果有在使用此特性的小伙伴，在升级时需要格外注意！以免影响到自己的工作流.&lt;/p>
&lt;h3 id="新增特性">新增特性&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>可以支持 Go 二进制文件扫描了。主要实现方式可以参考我之前写的文章&lt;a href="https://zhuanlan.zhihu.com/p/351354405" title="逆向 Go 二进制文件">《逆向 Go 二进制文件，获取其依赖信息》&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以支持 JAVA 相关归档文件的漏洞扫描了，比如 JAR，WAR 和 EAR 等格式。
但请注意： &lt;strong>此功能目前无法在离线环境中使用&lt;/strong> ，需要发送 HTTP 请求以便拿到更多信息。所以如果网络环境较差，可能此过程会耗时久一些，可以通过增加 &lt;code>--timeout&lt;/code> 参数来控制超时时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>新增了 Plugin 机制&lt;/strong>，使用类似 kubectl 和 Helm 的 &lt;a href="https://aquasecurity.github.io/trivy/v0.17.0/plugins/">Plugin 机制&lt;/a>。 &lt;em>提问：如果 trivy 集成了 kubectl 作为 plugin ，而 kubectl 又用 trivy 做了 plugin 那会怎么样呢？&lt;/em> 欢迎留言讨论～&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sprig 函数可以在 trivy 的自定义模板中使用了。有没有很眼熟？之前的周报中介绍过 Helm 3.5 也支持了同样的内容。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的详细信息请参考其 &lt;a href="https://github.com/aquasecurity/trivy/discussions/966">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="alertmanager-v0220-rc0-发布">Alertmanager v0.22.0-rc.0 发布&lt;/h2>
&lt;p>使用 Prometheus 的小伙伴对 Alertmanager 应该都不陌生，此版本中增加了很多实用的特性：&lt;/p>
&lt;ul>
&lt;li>有了新的创建 Silence 的形式，新日历；&lt;/li>
&lt;li>Routes 可以按时间进行设置了， 这也就可以解决很多“非工作时间，不对测试环境报警”之类的需求了；&lt;/li>
&lt;li>在界面上筛选的时候，可以支持 “非” 的匹配条件了， 比如我们可以直接做如下操作：“非生产环境，都关闭”；&lt;/li>
&lt;li>Web 界面原生支持 TLS 和 basic auth ；&lt;/li>
&lt;li>增加了 OAuth2.0/OIDC 支持；&lt;/li>
&lt;li>苹果 M1 支持；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的详细信息，请参考其 &lt;a href="https://github.com/prometheus/alertmanager/releases/tag/v0.22.0-rc.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rancher-desktop-v010-发布">Rancher Desktop v0.1.0 发布&lt;/h2>
&lt;p>Rancher 最近推出了一个基于 electron 构建的桌面工具，用于在 Windows 和 macOS 等桌面环境下管理 Kubernetes 和容器等。它的核心特性如下：&lt;/p>
&lt;ul>
&lt;li>支持自选 Kubernetes 版本（通过 k3s 提供支持）；&lt;/li>
&lt;li>可测试 Kubernetes 版本升级时，应用负载的变化（也通过 k3s 提供）；&lt;/li>
&lt;li>容器镜像的 build/pull/push 等（通过 &lt;a href="https://github.com/rancher/kim">kim&lt;/a> 和 BuildKit 等实现）；&lt;/li>
&lt;li>支持本地端口映射（通过 kubectl port-forward 实现）；&lt;/li>
&lt;/ul>
&lt;p>这里简单来聊聊我对这个工具的看法吧。从上面的介绍来看，其实很容易就能发现，这是奔着 Docker Desktop 的市场来的。到目前为止，市面上所有工具中，能完全涵盖和替换 Docker Desktop 的还没有。无论说容器&amp;amp;镜像管理，镜像安全扫描，内置 k8s 集群等这些工具都能为开发者提供极大的便利性。这也是 Docker 仍然能在开发者工具中占有大量市场的一个主要原因。&lt;/p>
&lt;p>其次，我们来看看这个工具推出的时机。最近 Docker Desktop 由于在新版本中将“关闭更新提醒”的功能设置成了付费用户可用，而遭到了大量的批判。这个工具选择在此时发布第一个版本，也许是凑巧，也许就恰好给一些人多了个选择。&lt;/p>
&lt;p>额外多说一点，Docker Desktop 新版本中那个功能变更的事情，其实在各大社交媒体/论坛上都有过很多讨论了，就我个人而言，我觉得这个决定是合理的，也是 Docker Inc. 必须得做的。这个公司在开源方面已经做了足够多了，如果在自己的闭源产品上，也不做些策略，那就真的危险了。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/101093">#101093 · kubernetes/kubernetes&lt;/a> 在今年年初的 &lt;a href="https://github.com/kubernetes/kubernetes/pull/98571">#98571&lt;/a>中为了在 Pod 优雅退出时候停止 probe 所以引入了非预期行为。此 PR 中对其进行了修复。该问题的场景是 Pod 在重启后 &lt;code>startupProbe&lt;/code> 不能正常的执行。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v20.10.6 发布， 修正了 K8S 中 dind 的异常行为</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/04/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.6-%E5%8F%91%E5%B8%83-%E4%BF%AE%E6%AD%A3%E4%BA%86-K8S-%E4%B8%AD-dind-%E7%9A%84%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA/"/><id>https://moelove.info/2021/04/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.6-%E5%8F%91%E5%B8%83-%E4%BF%AE%E6%AD%A3%E4%BA%86-K8S-%E4%B8%AD-dind-%E7%9A%84%E5%BC%82%E5%B8%B8%E8%A1%8C%E4%B8%BA/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-04-18T09:20:05+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v20.10.6 发布 距离上个版……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v20106-发布">Docker v20.10.6 发布&lt;/h2>
&lt;p>距离上个版本已经过去了一个多月，Docker 于近日发布了 v20.10.6 版本，还有 Docker Desktop 也发布了新版。这个版本中除了带来了 M1 的支持外，还带来了很多值得关注的内容，我们一起来看看吧！&lt;/p>
&lt;h3 id="cli-和构建器">CLI 和构建器&lt;/h3>
&lt;p>在 Docker v1.7 版本之前，Docker CLI 在执行完 docker login 后，会将相关信息存储到本地的 &lt;code>~/.dockercfg&lt;/code> 配置文件中。自从 v1.7 版本开始，Docker 引入了新的配置文件 &lt;code>~/.docker/config.json&lt;/code>，为了保持兼容性，Docker 一直在同时支持这两种配置文件。&lt;/p>
&lt;p>从当前版本开始，如果发现还在用 &lt;code>~/.dockercfg&lt;/code> 则会输出一行警告信息。提醒用户该配置文件将在后续版本中删除，请使用新的配置文件路径&amp;amp;格式。&lt;/p>
&lt;p>此外，从这个版本开始，如果在使用旧版的 builder 并且在 Dockerfile 中有其不支持的命令或参数，则会打印相关报错，并提示使用 BuildKit 来完成构建。这也是 Docker 社区想要将 BuildKit 提升为默认构建器的进一步举措。&lt;/p>
&lt;h3 id="日志">日志&lt;/h3>
&lt;p>&lt;a href="https://github.com/moby/moby/pull/42174">#42174 · moby/moby&lt;/a>修正了 Docker v20.10 版本中，当使用默认的 json-file 日志驱动时，偶发会遇到 io.UnexpectedEOF 的错误。&lt;/p>
&lt;p>&lt;strong>在实际测试中，在大量日志持续输出的情况下，比较容易复现此问题。&lt;/strong>&lt;/p>
&lt;h3 id="网络">网络&lt;/h3>
&lt;p>此版本中修正了 v20.10 中，当容器停止后 iptables 规则无法自动清理的问题；同时也解决了 Docker 在有 IPv6 网络机器上，暴露端口时，虽然可以同时通过 IPv4 和 IPv6 的地址访问该端口，但是 docker inspect 的 API 中默认不返回 IPv6 地址信息的问题。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>在这个版本中，如果使用 Docker 官方源进行 Docker CE 安装的话，默认会建议安装 docker-scan-plugin 包，这是一个 docker CLI 的插件，可用于扫描镜像漏洞。&lt;/p>
&lt;p>该插件我在之前的 K8S 生态周报中已经介绍过了，最初先引入到了 Docker Desktop 中，这个插件还是很方便的。&lt;/p>
&lt;p>另外， &lt;strong>这个版本也解决了一个比较严重的问题&lt;/strong> 。 虽然此问题并非 Docker 自身导致的，但是在使用 Docker In Docker 模式时，会触发到，所以在此进行额外的说明。&lt;/p>
&lt;p>当在 Kubernetes 中使用 Docker In Docker v20.10 版本时候，由于 Kubernetes 有 QoS 的机制，它确定了 Pod 的调度和驱逐优先级。实际上，Kubelet 是通过判断 Pod 的 oom_score_adj 来判定何时对它进行 OOM 。关于容器资源管理的部分，请参考我之前的文章&lt;a href="https://zhuanlan.zhihu.com/p/104207255">《聊聊容器资源管理》&lt;/a>&lt;/p>
&lt;p>如果是 BestEffort QoS 的 Pod，则 Kubernetes 会将它的 oom_score_adj 设置为 1000 ，但是 containerd 为了能避免 shim 不至于在子进程之前推出，所以在 &lt;code>AdjustOOMScore&lt;/code> 函数中，进行了对 oom_score_adj 加 1 的行为。会导致如下报错信息：&lt;/p>
&lt;pre>&lt;code>docker: Error response from daemon: io.containerd.runc.v2: failed to adjust OOM score for shim: set shim OOM score: write /proc/211/oom_score_adj: invalid argument
&lt;/code>&lt;/pre>&lt;p>前面也已经说到了 Besteffort QoS 为它设置的是 1000， 这已经是该值的最大值啦，要 +1 自然也就报错了。&lt;/p>
&lt;p>对应的修正方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gh">diff --git a/sys/oom_unix.go b/sys/oom_unix.go
&lt;/span>&lt;span class="gh">index d49d5bc8d..c381e1a7e 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/sys/oom_unix.go
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/sys/oom_unix.go
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -26,8 +26,12 @@ import (
&lt;/span>&lt;span class="gu">&lt;/span> &amp;#34;strings&amp;#34;
)
&lt;span class="gd">-// OOMScoreMaxKillable is the maximum score keeping the process killable by the oom killer
&lt;/span>&lt;span class="gd">-const OOMScoreMaxKillable = -999
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+const (
&lt;/span>&lt;span class="gi">+ // OOMScoreMaxKillable is the maximum score keeping the process killable by the oom killer
&lt;/span>&lt;span class="gi">+ OOMScoreMaxKillable = -999
&lt;/span>&lt;span class="gi">+ // OOMScoreAdjMax is from OOM_SCORE_ADJ_MAX https://github.com/torvalds/linux/blob/master/include/uapi/linux/oom.h
&lt;/span>&lt;span class="gi">+ OOMScoreAdjMax = 1000
&lt;/span>&lt;span class="gi">+)
&lt;/span>&lt;span class="gi">&lt;/span>
&lt;span class="gh">diff --git a/runtime/v2/shim/util_unix.go b/runtime/v2/shim/util_unix.go
&lt;/span>&lt;span class="gh">index 2b0d0ada3..9fb7cc573 100644
&lt;/span>&lt;span class="gh">&lt;/span>&lt;span class="gd">--- a/runtime/v2/shim/util_unix.go
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+++ b/runtime/v2/shim/util_unix.go
&lt;/span>&lt;span class="gi">&lt;/span>&lt;span class="gu">@@ -53,6 +53,7 @@ func SetScore(pid int) error {
&lt;/span>&lt;span class="gu">&lt;/span>
// AdjustOOMScore sets the OOM score for the process to the parents OOM score +1
// to ensure that they parent has a lower* score than the shim
&lt;span class="gi">+// if not already at the maximum OOM Score
&lt;/span>&lt;span class="gi">&lt;/span> func AdjustOOMScore(pid int) error {
parent := os.Getppid()
score, err := sys.GetOOMScoreAdj(parent)
&lt;span class="gu">@@ -60,6 +61,9 @@ func AdjustOOMScore(pid int) error {
&lt;/span>&lt;span class="gu">&lt;/span> return errors.Wrap(err, &amp;#34;get parent OOM score&amp;#34;)
}
shimScore := score + 1
&lt;span class="gi">+ if shimScore &amp;gt; sys.OOMScoreAdjMax {
&lt;/span>&lt;span class="gi">+ shimScore = sys.OOMScoreAdjMax
&lt;/span>&lt;span class="gi">+ }
&lt;/span>&lt;span class="gi">&lt;/span> if err := sys.SetOOMScore(pid, shimScore); err != nil {
return errors.Wrap(err, &amp;#34;set shim OOM score&amp;#34;)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，就是在 AdjustOOMScore 中，如果发现发现调整后的 oom_score_adj 大于了系统默认的最大值，则将它设置为系统的最大值。&lt;/p>
&lt;p>如果在生产环境中使用 containerd 及 Docker In Docker 的，建议升级到此版本进行解决。&lt;/p>
&lt;p>好了，以上就是此版本中需要注意的内容，更多详细的变更，请查看其 &lt;a href="https://docs.docker.com/engine/release-notes/#20106">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kube-state-metrics-v20-发布">kube-state-metrics v2.0 发布&lt;/h2>
&lt;p>做 Kubernetes 集群监控的小伙伴，大多对这个项目都不陌生。kube-state-metrics 可以根据 Kubernetes 的资源状态来生成 Prometheus 格式，极大的满足了我们对集群可观测性的需求。&lt;/p>
&lt;p>这个版本主要是将一些 metrics 的名字做了替换，替换成了更加标准和统一的格式。&lt;/p>
&lt;p>同时，将镜像的位置从 Quay.io 迁移到了 k8s.gcr.io/kube-state-metrics/kube-state-metrics 中。&lt;/p>
&lt;p>更多关于此版本的变更，请查看其 &lt;a href="https://github.com/kubernetes/kube-state-metrics/blob/master/CHANGELOG.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99839">#99839 · kubernetes/kubernetes&lt;/a> 修正了 port-forward 的内存泄漏问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99963">#99963 · kubernetes/kubernetes&lt;/a> 确保 job controller 可以在 Pod 完成后清理掉它；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/100644">#100644 · kubernetes/kubernetes&lt;/a> 将 KubeConfig 暴露在 scheduler framework 中，以便于树外插件使用。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.21 发布, 带来新的内存管理器</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/04/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.21-%E5%8F%91%E5%B8%83-%E5%B8%A6%E6%9D%A5%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8/"/><id>https://moelove.info/2021/04/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.21-%E5%8F%91%E5%B8%83-%E5%B8%A6%E6%9D%A5%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-04-10T13:02:19+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.21 正式发布 作为 2021……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v121-正式发布">Kubernetes v1.21 正式发布&lt;/h2>
&lt;p>作为 2021 年的首个版本， Kubernetes v1.21 们带来了众多很棒的特性，共计 51 项特性变更，其中 13 项升级到 Stable， 16 项目升级到 Beta，20 项成为 alpha，以及 2 项将被废弃。我们一起来看看我认为比较重要的一些内容。&lt;/p>
&lt;h3 id="cronjob-升级到-stable">CronJob 升级到 Stable&lt;/h3>
&lt;p>CronJob 顾名思义就是定时/周期性任务，CronJob 从 Kubernetes v1.4 开始引入，到 v1.8 时进入到 Beta 阶段。事实上在 2021 年 2 月份的时候，&lt;a href="https://github.com/kubernetes/kubernetes/pull/98878">CronJobV2 controller 已经成为了它默认的控制器版本&lt;/a>，也就是说当你在 Kubernetes v1.21 版本中使用 CronJob 时，如果不想使用 CronJobV2 的控制器，而想要换回原始的控制器时，那你需要显式的将它禁用掉，比如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">--feature-gates&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;CronJobControllerV2=false&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但我个人还是建议使用 CronJobV2 controller ，这个版本用了延迟队列和 informer 缓存，原始版本的控制器简陋了些，也会带来一些问题，比如当镜像/服务不可用时，会产生无限的 Pod 泄漏的问题。&lt;/p>
&lt;p>我在生产用 CronJob 还蛮多的，备份/同步任务等，当然也踩过上面提到的坑，但整体来说，CronJob 是个挺有用的特性。&lt;/p>
&lt;h3 id="内存管理器kubelet">内存管理器（kubelet）&lt;/h3>
&lt;p>在 Kubernetes v1.21 中在 kubelet 组件生态中新增了一个 &lt;strong>内存管理器&lt;/strong> ，在 Linux 系统中，为需要保证 QoS 的 Pod 在多 NUMA 节点保障内存和大内存页分配。这个特性非常有用，尤其是当数据库类或者使用 DPDK 进行高性能数据包处理的应用要部署到 Kubernetes 中时，内存对其性能影响至关重要。&lt;/p>
&lt;p>这里稍微聊点和 NUMA 相关的内容。简单来说就是在多 NUMA 结构下，为了保证效率，所以会按内存和 CPU 的相对距离来按 node 定义是否为 local memory 或者说本地内存，同时由于实际位置不同，所以就可能会产生内存分配不均匀的情况了。比如，我们可以使用 numactl 管理工具查看下当前机器上的情况：&lt;/p>
&lt;pre>&lt;code>[tao@moelove ~]# numactl -H
available: 2 nodes (0-1)
node 0 cpus: 0 1 2 3 4 5 6 7 8 9 20 21 22 23 24 25 26 27 28 29
node 0 size: 65186 MB
node 0 free: 9769 MB
node 1 cpus: 10 11 12 13 14 15 16 17 18 19 30 31 32 33 34 35 36 37 38 39
node 1 size: 65536 MB
node 1 free: 15206 MB
node distances:
node 0 1
0: 10 21
1: 21 10
&lt;/code>&lt;/pre>&lt;p>可以看到在我当前的这台机器上就存在着比较明显的内存分配不均的情况。所以当某个进程达到了其 local memory 的上限，那自然就会影响到它的性能。我最早折腾 NUMA 相关问题是在前些年大量使用 MongoDB 的时候，在这上面也花了些时间，不过这也不影响我对 MongoDB 的喜爱~&lt;/p>
&lt;p>这次在 kubelet 中增加的内存管理器便可以很好的解决这个问题，可以在启动 kubelet 的时候通过 &lt;code>--reserved-memory&lt;/code> 以及配合 &lt;code>--memory-manager-policy&lt;/code> 等参数来一起设置。例如：&lt;/p>
&lt;pre>&lt;code>--memory-manager-policy static --reserved-memory 0:memory=1Gi,hugepages-1M=2Gi --reserved-memory 1:memory=2Gi
&lt;/code>&lt;/pre>&lt;p>注意：&lt;code>memory-manager-policy&lt;/code> 必须设置为 static，如果不设置则默认为 none，即不采取任何行为。&lt;/p>
&lt;p>不过这个特性还在较早期的阶段，目前只为 &lt;code>Guaranteed&lt;/code> QoS 类的 Pod 提供支持。另外，如果正确启用了此特性，则在机器的 /var/lib/kubelet/memory_manager_state 可以看到其详细信息。&lt;/p>
&lt;p>&lt;img src="https://github.com/kubernetes/enhancements/raw/master/keps/sig-node/1769-memory-manager/mm_tm_diagram.png" alt="内存管理器的设计 - https://moelove.info">&lt;/p>
&lt;p>最终将会影响到拓扑管理器。&lt;/p>
&lt;h3 id="replicaset-缩容算法调整">ReplicaSet 缩容算法调整&lt;/h3>
&lt;p>当前的缩容算法，主要是优先删除生命周期最短的 Pod，本次修改主要是为了避免某些场景：&lt;/p>
&lt;p>比如在缩容的时候，一次性把新扩容的所有的 Pod 给删掉了之类的。所以计划对他们进行对数计算，也可以简单的理解为想要相对随机的对 Pod 进行清理。&lt;/p>
&lt;p>这个调整确实能避免掉上述提到的那种场景，不过也可能会带来一些其他的关于服务可用性相关的问题，比如通常情况下运行时间越久的 Pod 可能当前服务的用户数就越多，连接销毁时，可能就会比新 Pod 带来的影响大一些了。当然，这些也都是可以通过其他的方式来避免的，感兴趣的小伙伴可以给我留言，一起讨论。&lt;/p>
&lt;p>其他的一些值得关注的变更，我在每周的「K8S 生态周报」中都有介绍过了，这里就不再赘述啦，感兴趣的小伙伴可以翻看每期「K8S 生态周报」中 “上游进展” 的部分。关于此版本中的其他变更，可参考其 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.21.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="containerd-v150-rc0-发布">containerd v1.5.0-rc.0 发布&lt;/h2>
&lt;p>本周 containerd 发布了 v1.5.0-rc.0 版本，这是 containerd 的第六个大版本，带来了众多值得关注的变更：&lt;/p>
&lt;h3 id="runtime">runtime&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4647">#4647&lt;/a> 由于 CRI-API 的更新，可以在 task update 的 API 中添加 annotations 了；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4502">#4502&lt;/a> 当 terminal 为 true 时，添加二进制日志的支持；&lt;/li>
&lt;/ul>
&lt;h3 id="distribution">Distribution&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4523">#4523&lt;/a> 在日志中记录 registry 返回的异常状态码；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4653">#4653&lt;/a> 改进了在 registry 为 HTTP 1.1 协议下 pull image 的性能；&lt;/li>
&lt;/ul>
&lt;h3 id="cri">CRI&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/cri/pull/1552">cri#1552&lt;/a> 实验性的添加了 NRI（Node Resource Interface） 的注入点;&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4978/files">#4978&lt;/a> 允许为 CRI 的 registry 配置类似 docker 的 &lt;code>/etc/docker/certs.d&lt;/code> 目录，可以进行更方便的配置；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/5135/files">#5135&lt;/a> 默认开启 ocicrypt 支持；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请查看其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.5.0-rc.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="cilium-v1100-rc0-发布">Cilium v1.10.0-rc0 发布&lt;/h2>
&lt;p>Cilium 我已经多次介绍过了，感兴趣的小伙伴可以查看我之前的文章《&lt;a href="https://zhuanlan.zhihu.com/p/213745089">被 Google 选择的下一代数据面 Cilium 是什么&lt;/a>》。该项目于近期发布了 v1.10.0-rc0 版本，我们看看主要的变更：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/13670">#13670 · cilium/cilium&lt;/a> 添加了 &lt;code>--datapath-mode=lb-only&lt;/code> 选项，以支持仅 LB 模式，这样就可以让 cilium-agent 作为一个独立的 loadbalancer 运行了，不需要连接 kube-apiserver 或者 kvstore ；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/14858">#14858 · cilium/cilium&lt;/a> 在 wireguard, tun 等无二层设备上添加 NodePort BPF 支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/14207">#14207 · cilium/cilium&lt;/a> 添加 arm64 支持；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请查看其 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.10.0-rc0">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Prometheus v2.26 发布, 带来众多实用特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/04/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-v2.26-%E5%8F%91%E5%B8%83-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E5%AE%9E%E7%94%A8%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2021/04/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-v2.26-%E5%8F%91%E5%B8%83-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E5%AE%9E%E7%94%A8%E7%89%B9%E6%80%A7/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-04-01T08:09:27+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Prometheus v2.26.0 正式发布 Prometheus 本周……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="prometheus-v2260-正式发布">Prometheus v2.26.0 正式发布&lt;/h2>
&lt;p>Prometheus 本周发布了 v2.26.0 版本，除了 &lt;strong>从此版本开始默认使用 Alertmanager v2 API&lt;/strong> 外，还带来了众多值得关注的更新，我们一起来看看吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8542">#8542&lt;/a> Prometheus 和 Promtool 现在将把 &lt;code>--help&lt;/code> 信息打印到 stdout 而非原来的 stderr ，这样以后就可以很直接的 grep 搜索了，而不需重定向了；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8509">#8509&lt;/a> remote write 中添加了对 AWS SigV4 认证方法的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8487">#8487&lt;/a> 允许使用 &lt;code>--enable-feature=promql-negative-offset&lt;/code> 标志来启用负偏移量，负偏移量的实际含义也就是 “将来”，我暂时还没使用它的需求；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/6635">#6635&lt;/a> 允许使用 &lt;code>--enable-feature=exemplar-storage&lt;/code> 标志来启用内存样本存储。其实深挖这个特性的话，背后包含了一套相对完整的理论，这个技术最初是 2018 年 Google 在&lt;a href="https://www.youtube.com/watch?v=TzFjweKACMY">一次分享中公开的&lt;/a>，主要是为了能更好的度量系统的特定域内的性能指标，简单来说就当作是 metrics 系统与 trace 系统结合的一种方式吧，有兴趣的小伙伴可以深入了解下。就目前而言，还有一些问题需要解决；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8634">#8634&lt;/a> UI 部分在输入框为 PromQL 增加了高级的自动补全，语法高亮和 lint ，写表达式的时候就更方便啦。注意需要勾选 “Use experimental editor”&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://moelove.info/img/prometheus-226-editor.png" alt="Prometheus New UI - https://moelove.info">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/prometheus/prometheus/pull/8457">#8457&lt;/a> PromQL 增加了几个有用的新函数：&lt;/p>
&lt;ul>
&lt;li>clamp：限定 metrics 的值在确定区间内；&lt;/li>
&lt;li>last_over_time：它的行为很像是 offset，但其实它只返回指定区间的最后一个值，可以参考 max_over_time 函数；&lt;/li>
&lt;li>sgn：它是定义了一个向量，如果值为正，则返回 1，如果值为负则返回 -1 ，如果值为 0 则返回 0；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/prometheus/prometheus/pull/8512">#8512&lt;/a> Prometheus 的 Authorization 头，现在可以直接使用 Bearer Token 了。例如：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>原先：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;moelove&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">bearer_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;5YWs5LyX5Y+3IE1vZUxvdmUK&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;localhost:9999&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;moelove&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">authorization&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">credentials&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;5YWs5LyX5Y+3IE1vZUxvdmUK&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;localhost:9999&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样可以更灵活点，也方便以后的扩展。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8546">#8546&lt;/a> 添加了一个 follow_redirects 的选项，可以用来禁用重定向跟随。&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的其他变更，请参考其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.26.0" title="Prometheus v2.26.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-8-周岁啦">Docker 8 周岁啦！&lt;/h2>
&lt;p>每年 Docker 社区都会为 Docker 的生日准备一次特殊的庆祝活动，今年也不例外。去年我们准备了一次线上的交流，今年则是采用了准备了 8 个有趣的答题环节，有兴趣的小伙伴可以访问 &lt;a href="https://www.docker.com/blog/a-birthday-challenge-as-docker-turns-8/">Docker 8 周年特别地址&lt;/a>参与活动。&lt;/p>
&lt;p>&lt;img src="https://i0.wp.com/www.docker.com/blog/wp-content/uploads/2021/03/Docker-8-year-Birthday.png?w=1024&amp;amp;ssl=1" alt="Docker 8 - https://moelove.info">&lt;/p>
&lt;h2 id="podman-v310-正式发布">Podman v3.1.0 正式发布&lt;/h2>
&lt;p>Podman 的更新频率还是蛮快的，我们来看看这个版本中比较值得关注的一些特性吧！&lt;/p>
&lt;ul>
&lt;li>新增了一组 secret 命令。例如 &lt;code>podman secret create&lt;/code> ， &lt;code>podman secret inspect&lt;/code> 等，允许在 &lt;code>podman run&lt;/code> 通过 &lt;code>--secret&lt;/code> 选项进行传递；&lt;/li>
&lt;li>增加了一个清理网络的命令， &lt;code>podman network prune&lt;/code>；&lt;/li>
&lt;li>新增 &lt;code>podman network exists&lt;/code>, &lt;code>podman volume exists&lt;/code> 和 &lt;code>podman manifest exists&lt;/code> 等命令，来判断对应资源是否存在；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的其他变更，请参考其 &lt;a href="https://github.com/containers/podman/releases/tag/v3.1.0" title="Podman v3.1.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>Kubernetes v1.21 即将发布，将带来众多有用的更新，敬请期待；&lt;/li>
&lt;li>PodSecurityPolicy（PSP）在 v1.21 中已弃用，&lt;a href="https://github.com/kubernetes/enhancements/issues/2579">KEP 2579&lt;/a> 是相对应的增强建议，关于 PSP 相关的内容可参考 k8s 官方的博客内容 &lt;a href="https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/" title="PodSecurityPolicy Deprecation: Past, Present, and Future">PodSecurityPolicy Deprecation: Past, Present, and Future | Kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">万字长文：彻底搞懂容器镜像构建</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/03/14/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/"/><id>https://moelove.info/2021/03/14/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-03-14T23:36:58+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 我将在这篇文章中深入 Docker 的源码，与你聊聊镜像构建的原理。 Docker 架构 这里我们先从宏观上对 Docker 有个大概的认识，它整体上是……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>我将在这篇文章中深入 Docker 的源码，与你聊聊镜像构建的原理。&lt;/p>
&lt;h2 id="docker-架构">Docker 架构&lt;/h2>
&lt;p>这里我们先从宏观上对 &lt;code>Docker&lt;/code> 有个大概的认识，它整体上是个 C/S 架构；我们平时使用的 &lt;code>docker&lt;/code> 命令就是它的 CLI 客户端，而它的服务端是 &lt;code>dockerd&lt;/code> 在 Linux 系统中，通常我们是使用 &lt;code>systemd&lt;/code> 进行管理，所以我们可以使用 &lt;code>systemctl start docker&lt;/code> 来启动服务。（但是请注意，&lt;code>dockerd&lt;/code> 是否能运行与 &lt;code>systemd&lt;/code> 并无任何关系，你可以像平时执行一个普通的二进制程序一样，直接通过 &lt;code>dockerd&lt;/code> 来启动服务，注意需要 root 权限）&lt;/p>
&lt;p>实际上也就是&lt;/p>
&lt;p>&lt;img src="https://docs.docker.com/engine/images/engine-components-flow.png" alt="Docker 架构">&lt;/p>
&lt;p>(图片来源：docker overview)&lt;/p>
&lt;p>&lt;code>docker&lt;/code> CLI 与 &lt;code>dockerd&lt;/code> 的交互是通过 REST API 来完成的，当我们执行 &lt;code>docker version&lt;/code> 的时候过滤 API 可以看到如下输出：&lt;/p>
&lt;pre>&lt;code>➜ ~ docker version |grep API
API version: 1.41
API version: 1.41 (minimum version 1.12)
&lt;/code>&lt;/pre>&lt;p>上面一行是 &lt;code>docker&lt;/code> CLI 的 API 版本，下面则代表了 &lt;code>dockerd&lt;/code> 的 API 版本，它的后面还有个括号，是因为 Docker 具备了很良好的兼容性，这里表示它最小可兼容的 API 版本是 1.12 。&lt;/p>
&lt;p>对于我们进行 C/S 架构的项目开发而言，一般都是 API 先行, 所以我们先来看下 API 的部分。&lt;/p>
&lt;p>当然，本文的主体是构建系统相关的，所以我们就直接来看构建相关的 API 即可。&lt;/p>
&lt;p>接下来会说 CLI，代码以 v20.10.5 为准。最后说服务端 Dockerd 。&lt;/p>
&lt;h2 id="api">API&lt;/h2>
&lt;p>Docker 维护团队在每个版本正式发布之后，都会将 API 文档发布出来，可以通过 &lt;a href="https://docs.docker.com/engine/api/v1.41/">Docker Engine API 在线浏览&lt;/a>，也可以自行构建 API 文档。&lt;/p>
&lt;p>首先 clone Docker 的源代码仓库, 进入项目仓库内执行 &lt;code>make swagger-docs&lt;/code> 即可在启动一个容器同时将端口暴露至本地的 &lt;code>9000&lt;/code> 端口， 你可以直接通过 &lt;a href="http://127.0.0.1:9000">http://127.0.0.1:9000&lt;/a> 访问本地的 API 文档。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ git clone https://github.com/docker/docker.git docker
(MoeLove) ➜ cd docker
(MoeLove) ➜ docker git:(master) git checkout -b v20.10.5 v20.10.5
(MoeLove) ➜ docker git:(v20.10.5) make swagger-docs
API docs preview will be running at http://localhost:9000
&lt;/code>&lt;/pre>&lt;p>打开 &lt;a href="http://127.0.0.1:9000/#operation/ImageBuild">http://127.0.0.1:9000/#operation/ImageBuild&lt;/a> 这个地址就可以看到 1.41 版本的构建镜像所需的 API 了。我们对此 API 进行下分析。&lt;/p>
&lt;h3 id="请求地址和方法">请求地址和方法&lt;/h3>
&lt;p>接口地址是 &lt;code>/v1.41/build&lt;/code> 方法是 &lt;code>POST&lt;/code> ，我们可以使用一个较新版本的 &lt;code>curl&lt;/code> 工具来验证下此接口（需要使用 &lt;code>--unix-socket&lt;/code> 连接 Docker 监听的 UNIX Domain Socket ）。&lt;code>dockerd&lt;/code> 默认情况下监听在 &lt;code>/var/run/docker.sock&lt;/code> ，当然你也可以给 &lt;code>dockerd&lt;/code> 传递 &lt;code>--host&lt;/code> 参数用于监听 HTTP 端口或者其他路径的 unix socket .&lt;/p>
&lt;pre>&lt;code>/ # curl -X POST --unix-socket /var/run/docker.sock localhost/v1.41/build
{&amp;quot;message&amp;quot;:&amp;quot;Cannot locate specified Dockerfile: Dockerfile&amp;quot;}
&lt;/code>&lt;/pre>&lt;p>从上面的输出我们可以看到，我们确实访问到了该接口，同时该接口的响应是提示需要 &lt;code>Dockerfile&lt;/code> .&lt;/p>
&lt;h3 id="请求体">请求体&lt;/h3>
&lt;blockquote>
&lt;p>A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
string &lt;binary>&lt;/p>
&lt;/blockquote>
&lt;p>请求体是一个 &lt;code>tar&lt;/code> 归档文件，可选择无压缩、&lt;code>gzip&lt;/code>、&lt;code>bzip2&lt;/code>、&lt;code>xz&lt;/code> 压缩等形式。关于这几种压缩格式就不再展开介绍了，但值得注意的是 &lt;strong>如果使用了压缩，则传输体积会变小，即网络消耗会相应减少。但压缩/解压缩需要耗费 CPU 等计算资源&lt;/strong> 这在我们对大规模镜像构建做优化时是个值得权衡的点。&lt;/p>
&lt;h3 id="请求头">请求头&lt;/h3>
&lt;p>因为要发送的是个 &lt;code>tar&lt;/code> 归档文件，&lt;code>Content-type&lt;/code> 默认是 &lt;code>application/x-tar&lt;/code> 。另一个会发送的头是 &lt;code>X-Registry-Config&lt;/code>，这是一个由 Base64 编码后的 Docker Registry 的配置信息，内容与 &lt;code>$HOME/.docker/config.json&lt;/code> 中的 &lt;code>auths&lt;/code> 内的信息一致。&lt;/p>
&lt;p>这些配置信息，在你执行 &lt;code>docker login&lt;/code> 后会自动写入到 &lt;code>$HOME/.docker/config.json&lt;/code> 文件内的。这些信息被传输到 &lt;code>dockerd&lt;/code> 在构建过程中作为拉取镜像的认证信息使用。&lt;/p>
&lt;h3 id="请求参数">请求参数&lt;/h3>
&lt;p>最后就是请求参数了，参数有很多，通过 &lt;code>docker build --help&lt;/code> 基本都可以看到对应含义的，这里不再一一展开了，后面会有一些关键参数的介绍。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>上面我们介绍了 &lt;code>Docker&lt;/code> 构建镜像相关的 API，我们可以直接访问&lt;a href="https://docs.docker.com/engine/api/v1.41/">Docker Engine 的 API 文档&lt;/a>。或者通过源码仓库，自己来构建一个本地的 API 文档服务，使用浏览器进行访问。&lt;/p>
&lt;p>通过 API 我们也知道了该接口所需的请求体是一个 &lt;code>tar&lt;/code> 归档文件（可选择压缩算法进行压缩），同时它的请求头中会携带用户在镜像仓库中的认证信息。这提醒我们， &lt;strong>如果在使用远程 &lt;code>Dockerd&lt;/code> 构建时，请注意安全，尽量使用 &lt;code>tls&lt;/code> 进行加密，以免数据泄漏。&lt;/strong>&lt;/p>
&lt;h2 id="cli">CLI&lt;/h2>
&lt;p>API 已经介绍完了，我们来看下 &lt;code>docker&lt;/code> CLI，我以前的文章中介绍过现在 Docker 中有两个构建系统，一个是 v1 版本的 &lt;code>builder&lt;/code> 另一个是 v2 版本的即 &lt;code>BuildKit&lt;/code> 我们来分别深入源码来看看在构建镜像时，他们各自的行为吧。&lt;/p>
&lt;h3 id="准备代码">准备代码&lt;/h3>
&lt;p>CLI 的代码仓库在 &lt;a href="https://github.com/docker/cli">https://github.com/docker/cli&lt;/a> 本文的代码以 &lt;code>v20.10.5&lt;/code> 为准。&lt;/p>
&lt;p>通过以下步骤使用此版本的代码：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ git clone https://github.com/docker/cli.git
(MoeLove) ➜ cd cli
(MoeLove) ➜ cli git:(master) git checkout -b v20.10.5 v20.10.5
&lt;/code>&lt;/pre>&lt;h3 id="逐步分解">逐步分解&lt;/h3>
&lt;p>&lt;code>docker&lt;/code> 是我们所使用的客户端工具，用于与 &lt;code>dockerd&lt;/code> 进行交互。关于构建相关的部分， 我们所熟知的便是 &lt;code>docker build&lt;/code> 或者是 &lt;code>docker image build&lt;/code>，在 19.03 中新增的是 &lt;code>docker builder build&lt;/code> ，但其实他们都是同一个只是做了个 alias 罢了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cmd/docker/docker.go#L237
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">aliasMap&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;builder&amp;#34;&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">aliases&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">aliases&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{{&lt;/span>&lt;span class="s">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">}},&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{{&lt;/span>&lt;span class="s">&amp;#34;image&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">}},&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>真正的入口函数其实在 &lt;code>cli/command/image/build.go&lt;/code>；区分如何调用的逻辑如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">runBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Cli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">buildkitEnabled&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">BuildKitEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServerInfo&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">buildkitEnabled&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">runBuildBuildKit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 省略掉了对于 builder 的实际逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里就是判断下是否支持 &lt;code>buildkit&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cli/command/cli.go#L176
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">BuildKitEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">si&lt;/span> &lt;span class="nx">ServerInfo&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">buildkitEnabled&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">si&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuildkitVersion&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuilderBuildKit&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">buildkitEnv&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Getenv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;DOCKER_BUILDKIT&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">buildkitEnv&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>
&lt;span class="nx">buildkitEnabled&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">strconv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ParseBool&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buildkitEnv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;DOCKER_BUILDKIT environment variable expects boolean value&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">buildkitEnabled&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，从这里可以得到两个信息：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>dockerd&lt;/code> 的配置可开启 &lt;code>buildkit&lt;/code> 。在 &lt;code>/etc/docker/daemon.json&lt;/code> 中添加如下内容，并重启 &lt;code>dockerd&lt;/code> 即可：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;features&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;buildkit&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在 &lt;code>docker&lt;/code> CLI 上也可开启 &lt;code>buildkit&lt;/code> 的支持，并且 CLI 的配置可覆盖服务端配置。通过 &lt;code>export DOCKER_BUILDKIT=1&lt;/code> 即可开启 &lt;code>buildkit&lt;/code> 的支持，设置为 0 则关闭（0/false/f/F 之类的也都是相同的结果）&lt;/li>
&lt;/ul>
&lt;p>从上面的介绍也看到了，对于原本默认的 builder 而言， 入口逻辑在 &lt;code>runBuild&lt;/code> 中， 而对于使用 buildkit 的则是 &lt;code>runBuildBuildKit&lt;/code> 接下来，我们对两者进行逐步分解。&lt;/p>
&lt;h3 id="builder-v1">builder v1&lt;/h3>
&lt;p>在 &lt;code>runBuild&lt;/code> 函数中，大致经历了以下阶段：&lt;/p>
&lt;h4 id="参数处理">参数处理&lt;/h4>
&lt;p>最开始的部分是一些对参数的处理和校验。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>stream&lt;/code> 和 &lt;code>compress&lt;/code> 不可同时使用。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>因为如果我们指定了 &lt;code>compress&lt;/code> 的话，则 CLI 会使用 &lt;code>gzip&lt;/code> 将构建上下文进行压缩，这样也就没法很好的通过 &lt;code>stream&lt;/code> 的模式来处理构建的上下文了。&lt;/p>
&lt;p>当然你也可能会想，从技术上来讲，压缩和流式没有什么必然的冲突，是可实现的。事实的确如此，如果从技术的角度上来讲两者并非完全不能一起存在，无非就是增加解压缩的动作。但是当开启 &lt;code>stream&lt;/code> 模式，对每个文件都进行压缩和解压的操作那将会是很大的资源浪费，同时也增加了其复杂度，所以在 CLI 中便直接进行了限制，不允许同时使用 &lt;code>compress&lt;/code> 和 &lt;code>stream&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>不可同时使用 &lt;code>stdin&lt;/code> 读取 &lt;code>Dockerfile&lt;/code> 和 &lt;code>build context&lt;/code>。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在进行构建时，如果我们将 &lt;code>Dockerfile&lt;/code> 的名字传递为 &lt;code>-&lt;/code> 时，表示从 &lt;code>stdin&lt;/code> 读取其内容。&lt;/p>
&lt;p>例如，某个目录下有三个文件 &lt;code>foo&lt;/code> &lt;code>bar&lt;/code> 和 &lt;code>Dockerfile&lt;/code>，通过管道将 &lt;code>Dockerfile&lt;/code> 的内容通过 &lt;code>stdin&lt;/code> 传递给 &lt;code>docker build&lt;/code>&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ x ls
bar Dockerfile foo
(MoeLove) ➜ x cat Dockerfile | DOCKER_BUILDKIT=0 docker build -f - .
Sending build context to Docker daemon 15.41kB
Step 1/3 : FROM scratch
---&amp;gt;
Step 2/3 : COPY foo foo
---&amp;gt; a2af45d66bb5
Step 3/3 : COPY bar bar
---&amp;gt; cc803c675dd2
Successfully built cc803c675dd2
&lt;/code>&lt;/pre>&lt;p>可以看到通过 &lt;code>stdin&lt;/code> 传递 &lt;code>Dockerfile&lt;/code> 的方式能成功的构建镜像。接下来我们尝试通过 &lt;code>stdin&lt;/code> 将 &lt;code>build context&lt;/code> 传递进去。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ x tar -cvf x.tar foo bar Dockerfile
foo
bar
Dockerfile
(MoeLove) ➜ x cat x.tar| DOCKER_BUILDKIT=0 docker build -f Dockerfile -
Sending build context to Docker daemon 10.24kB
Step 1/3 : FROM scratch
---&amp;gt;
Step 2/3 : COPY foo foo
---&amp;gt; 09319712e220
Step 3/3 : COPY bar bar
---&amp;gt; ce88644a7395
Successfully built ce88644a7395
&lt;/code>&lt;/pre>&lt;p>可以看到通过 &lt;code>stdin&lt;/code> 传递 &lt;code>build context&lt;/code> 的方式也可以成功构建镜像。&lt;/p>
&lt;p>但如果 &lt;code>Dockerfile&lt;/code> 的名称与构建的上下文都指定为 &lt;code>-&lt;/code> 即 &lt;code>docker build -f - -&lt;/code> 时，会发生什么呢？&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ x DOCKER_BUILDKIT=0 docker build -f - -
invalid argument: can't use stdin for both build context and dockerfile
&lt;/code>&lt;/pre>&lt;p>就会报错了。所以， &lt;strong>不能同时使用 &lt;code>stdin&lt;/code> 读取 &lt;code>Dockerfile&lt;/code> 和 &lt;code>build context&lt;/code>&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>build context&lt;/code> 支持四种行为。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">contextFromStdin&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nf">isLocalDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">specifiedContext&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nx">urlutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsGitURL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">specifiedContext&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nx">urlutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsURL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">specifiedContext&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unable to prepare context: path %q not found&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">specifiedContext&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从 &lt;code>stdin&lt;/code> 传入，上文已经演示过了，传递给 &lt;code>stdin&lt;/code> 的是 &lt;code>tar&lt;/code> 归档文件。当然也可以是指定一个具体的 &lt;code>PATH&lt;/code>，我们通常使用的 &lt;code>docker build .&lt;/code> 便是这种用法；&lt;/p>
&lt;p>或者可以指定一个 &lt;code>git&lt;/code> 仓库的地址，CLI 会调用 &lt;code>git&lt;/code> 命令将仓库 &lt;code>clone&lt;/code> 至一个临时目录，进行使用；&lt;/p>
&lt;p>最后一种是，给定一个 &lt;code>URL&lt;/code> 地址，该地址可以是 &lt;strong>一个具体的 Dockerfile 文件地址&lt;/strong> 或者是 &lt;strong>一个 &lt;code>tar&lt;/code> 归档文件的下载地址&lt;/strong> 。&lt;/p>
&lt;p>这几种基本就是字面上的区别，至于 CLI 的行为差异，主要是最后一种，当 &lt;code>URL&lt;/code> 地址是一个具体的 &lt;code>Dockerfile&lt;/code> 文件地址，在这种情况下 &lt;code>build context&lt;/code> 相当于只有 &lt;code>Dockerfile&lt;/code> 自身，所以并不能使用 &lt;code>COPY&lt;/code> 之类的指定，至于 &lt;code>ADD&lt;/code> 也只能使用可访问的外部地址。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可使用 &lt;code>.dockerignore&lt;/code> 忽略不需要的文件&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我在之前的文章中有分享过相关的内容。这里我们看看它的实现逻辑。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cli/command/image/build/dockerignore.go#L13
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">ReadDockerignore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">contextDir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">([]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">excludes&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>
&lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">contextDir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;.dockerignore&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsNotExist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">excludes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">dockerignore&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReadAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>.dockerignore&lt;/code> 是一个固定的文件名，并且需要放在 &lt;code>build context&lt;/code> 的根目录下。类似前面提到的，使用一个 &lt;code>Dockerfile&lt;/code> 文件的 URL 地址作为 &lt;code>build context&lt;/code> 传入的方式，便无法使用 &lt;code>.dockerignore&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.dockerignore&lt;/code> 文件可以不存在，但在读取的时候如果遇到错误，便会抛出错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 &lt;code>.dockerignore&lt;/code> 将会过滤掉不希望加入到镜像内，或者过滤掉与镜像无关的内容。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后 CLI 会将 &lt;code>build context&lt;/code> 中的内容经过 &lt;code>.dockerignore&lt;/code> 过滤后，打包成为真正的 &lt;code>build context&lt;/code> 即真正的构建上下文。这也是为什么有时候你发现自己明明在 &lt;code>Dockerfile&lt;/code> 里面写了 &lt;code>COPY xx xx&lt;/code> 但是最后没有发现该文件的情况。 很可能就是被 &lt;code>.dockerignore&lt;/code> 给忽略掉了。 &lt;strong>这样有利于优化 CLI 与 &lt;code>dockerd&lt;/code> 之间的传输压力之类的。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>docker&lt;/code> CLI 还会去读取 &lt;code>~/.docker/config.json&lt;/code> 中的内容。&lt;/li>
&lt;/ul>
&lt;p>这与前面 API 部分所描述的内容基本是一致的。将认证信息通过 &lt;code>X-Registry-Config&lt;/code> 头传递给 &lt;code>dockerd&lt;/code> 用于在需要拉取镜像时进行身份校验。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>调用 API 进行实际构建任务&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>当一切所需的校验和信息都准备就绪之后，则开始调用 &lt;code>dockerCli.Client&lt;/code> 封装的 API 接口，将请求发送至 &lt;code>dockerd&lt;/code>，进行实际的构建任务。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Client&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ImageBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">quiet&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Err&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">progBuff&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">response&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这里其实一次构建的过程中 CLI 所处理的流程就基本结束了，之后便是按照传递的参数进行进度的输出或是将镜像 ID 写入到文件之类的。 这部分就不进行展开了。&lt;/p>
&lt;h4 id="小结-1">小结&lt;/h4>
&lt;p>整个过程大致如下图：&lt;/p>
&lt;p>&lt;img src="https://images.gitbook.cn/6a69dde0-933a-11e9-8825-e7da71af5ddb" alt="docker builder 处理流程">&lt;/p>
&lt;p>从入口函数 &lt;code>runBuild&lt;/code> 开始，经过判断是否支持 &lt;code>buildkit&lt;/code> ，如果不支持 &lt;code>buildkit&lt;/code> 则继续使用 v1 的 &lt;code>builder&lt;/code>。接下来读取各类参数，按照不同的参数执行各类不同的处理逻辑。这里需要注意的就是 &lt;code>Dockerfile&lt;/code> 及 &lt;code>build context&lt;/code> 都可支持从文件或者 &lt;code>stdin&lt;/code> 等读入，具体使用时，需要注意。另外 &lt;code>.dockerignore&lt;/code> 文件可过滤掉 &lt;code>build context&lt;/code> 中的一些文件，在使用时，可通过此方法进行构建效率的优化，当然也需要注意，在通过 URL 获取 &lt;code>Dockerfile&lt;/code> 的时候，是不存在 &lt;code>build context&lt;/code> 的，所以类似 &lt;code>COPY&lt;/code> 这样的命令也就无法使用了。当所有的 &lt;code>build context&lt;/code> 和参数都准备就绪后，接下来调用封装好的客户端，将这些请求按照本文开始之初介绍的 API 发送给 &lt;code>dockerd&lt;/code> ，由其进行真正的构建逻辑。&lt;/p>
&lt;p>最后当构建结束后，CLI 根据参数决定是否要显示构建进度或者结果。&lt;/p>
&lt;h3 id="buildkit">buildkit&lt;/h3>
&lt;p>接下来我们来看看 &lt;code>buildkit&lt;/code> 如何来执行构建，方法入口与 &lt;code>builder&lt;/code> 一致，但是在 &lt;code>buildkitEnabled&lt;/code> 处，由于开启了 &lt;code>buildkit&lt;/code> 支持，所以跳转到了 &lt;code>runBuildBuildKit&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">runBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Cli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">buildkitEnabled&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">BuildKitEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServerInfo&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">buildkitEnabled&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">runBuildBuildKit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 省略掉了对于 builder 的实际逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="创建会话">创建会话&lt;/h4>
&lt;p>但是与 &lt;code>builder&lt;/code> 不同的是，这里先执行了一次 &lt;code>trySession&lt;/code> 函数。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cli/command/image/build_buildkit.go#L50
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">trySession&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;buildkit not supported by daemon&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个函数是用来做什么的呢？我们来找到该函数所在的文件 &lt;code>cli/command/image/build_session.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cli/command/image/build_session.go#L29
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">trySession&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Cli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">contextDir&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">forStream&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Session&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nf">isSessionSupported&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">forStream&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">sharedKey&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getBuildSharedKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">contextDir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSession&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">filepath&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Base&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">contextDir&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nx">sharedKey&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to create session&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然还包括它其中最主要的 &lt;code>isSessionSupported&lt;/code> 函数：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// cli/command/image/build_session.go#L22
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">isSessionSupported&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Cli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">forStream&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">forStream&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">versions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GreaterThanOrEqualTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Client&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ClientVersion&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;1.39&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServerInfo&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nx">HasExperimental&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">versions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GreaterThanOrEqualTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Client&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ClientVersion&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="s">&amp;#34;1.31&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>isSessionSupported&lt;/code> 很明显是用于判断是否支持 &lt;code>Session&lt;/code>，这里由于我们会传入 &lt;code>forStream&lt;/code> 为 &lt;code>false&lt;/code> ，而且当前的 API 版本是 1.41 比 1.39 大，所以此函数会返回 &lt;code>true&lt;/code> 。其实在 &lt;code>builder&lt;/code> 中也执行过相同的逻辑，只不过是在传递了 &lt;code>--stream&lt;/code> 参数后，使用 &lt;code>Session&lt;/code> 获取一个长连接以达到 &lt;code>stream&lt;/code> 的处理能力。&lt;/p>
&lt;p>这也就是为什么会有下面 &lt;code>dockerCli.ServerInfo().HasExperimental &amp;amp;&amp;amp; versions.GreaterThanOrEqualTo(dockerCli.Client().ClientVersion(), &amp;quot;1.31&amp;quot;)&lt;/code> 这个判断存在的原因了。&lt;/p>
&lt;p>当确认支持 &lt;code>Session&lt;/code> 时，则会调用 &lt;code>session.NewSession&lt;/code> 创建一个新的会话。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// github.com/moby/buildkit/session/session.go#L47
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSession&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">sharedKey&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Session&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">id&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">identity&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">unary&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UnaryServerInterceptor&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">stream&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StreamServerInterceptor&lt;/span>
&lt;span class="nx">serverOpts&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ServerOption&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">span&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">opentracing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SpanFromContext&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">span&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">tracer&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">span&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Tracer&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">unary&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">otgrpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OpenTracingServerInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tracer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">traceFilter&lt;/span>&lt;span class="p">()))&lt;/span>
&lt;span class="nx">stream&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">otgrpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">OpenTracingStreamServerInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">span&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Tracer&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nf">traceFilter&lt;/span>&lt;span class="p">()))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">unary&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpcerrors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UnaryServerInterceptor&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">stream&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpcerrors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StreamServerInterceptor&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">serverOpts&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverOpts&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">UnaryInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">serverOpts&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverOpts&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">UnaryInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">grpc_middleware&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ChainUnaryServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unary&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">serverOpts&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverOpts&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StreamInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">serverOpts&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverOpts&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StreamInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">grpc_middleware&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ChainStreamServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stream&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">Session&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">id&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">sharedKey&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">sharedKey&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">grpcServer&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">grpc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverOpts&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">grpc_health_v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">RegisterHealthServer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">grpcServer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">health&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewServer&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>它创建了一个长连接会话，接下来的操作也都会基于这个会话来做。接下来的操作与 &lt;code>builder&lt;/code> 大体一致，先判断 &lt;code>context&lt;/code> 是以哪种形式提供的；当然它也与 &lt;code>builder&lt;/code> 一样，是不允许同时从 &lt;code>stdin&lt;/code> 获取 &lt;code>Dockerfile&lt;/code> 和 &lt;code>build context&lt;/code> 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">switch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">contextFromStdin&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="c1">// 省略处理逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nf">isLocalDir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略处理逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nx">urlutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsGitURL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略处理逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">case&lt;/span> &lt;span class="nx">urlutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsURL&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1">// 省略处理逻辑
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Errorf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;unable to prepare context: path %q not found&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的处理逻辑与 v1 &lt;code>builder&lt;/code> 保持一致的原因，主要在于用户体验上，当前的 CLI 的功能已经基本稳定，用户也已经习惯，所以即使是增加了 &lt;code>BuildKit&lt;/code> 也并没有对主体的操作逻辑造成多大改变。&lt;/p>
&lt;h4 id="选择输出模式">选择输出模式&lt;/h4>
&lt;p>&lt;code>BuildKit&lt;/code> 支持了三种不同的输出模式 &lt;code>local&lt;/code> &lt;code>tar&lt;/code> 和正常模式（即存储在 &lt;code>dockerd&lt;/code> 中）， 格式为 &lt;code>-o type=local,dest=path&lt;/code> 如果需要将构建的镜像进行分发，或是需要进行镜像内文件浏览的话，使用这个方式也是很方便的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">outputs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">parseOutputs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">outputs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wrapf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;failed to parse outputs&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">out&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">outputs&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Type&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;local&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">case&lt;/span> &lt;span class="s">&amp;#34;tar&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>其实它支持的模式还有第 4 种， 名为 &lt;code>cacheonly&lt;/code> 但它并不会像前面提到的三种模式一样，有个很直观的输出，而且用的人可能会很少，所以就没有单独写了。&lt;/strong>&lt;/p>
&lt;h4 id="读取认证信息">读取认证信息&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">dockerAuthProvider&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">authprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDockerAuthProvider&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stderr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerAuthProvider&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的行为与上面提到的 &lt;code>builder&lt;/code> 的行为基本一致，这里主要有两个需要注意的点：&lt;/p>
&lt;ul>
&lt;li>Allow() 函数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Session&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="nx">Attachable&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Register&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">grpcServer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 &lt;code>Allow&lt;/code> 函数就是允许通过上面提到的 grpc 会话访问给定的服务。&lt;/p>
&lt;ul>
&lt;li>&lt;code>authprovider&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>authprovider&lt;/code> 是 &lt;code>BuildKit&lt;/code> 提供的一组抽象接口集合，通过它们可以访问到机器上的配置文件，进而拿到认证信息，行为与 &lt;code>builder&lt;/code> 基本一致。&lt;/p>
&lt;h4 id="高阶特性mount-secrets-和-ssh">高阶特性：mount &lt;code>secrets&lt;/code> 和 &lt;code>ssh&lt;/code>&lt;/h4>
&lt;p>我其他的文章讲过这两种高阶特性的使用了，本篇中就不再多使用进行过多说明了，只来大体看下该部分的原理和逻辑。&lt;/p>
&lt;p>&lt;code>secretsprovider&lt;/code> 和 &lt;code>sshprovider&lt;/code> 都是 &lt;code>buildkit&lt;/code> 在提供的，利用这两种特性可以在 Docker 镜像进行构建时更加安全，且更加灵活。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">parseSecretSpecs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sl&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Attachable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">fs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nx">secretsprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Source&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sl&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">sl&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">parseSecret&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">fs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">store&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">secretsprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewStore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">fs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">secretsprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSecretProvider&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">store&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于 &lt;code>secrets&lt;/code> 方面，最终的 &lt;code>parseSecret&lt;/code> 会完成格式相关的校验之类的；&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">parseSSHSpecs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sl&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Attachable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">configs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nx">sshprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AgentConfig&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sl&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">v&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">sl&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">parseSSH&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">configs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">configs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">sshprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewSSHAgentProvider&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">configs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而关于 &lt;code>ssh&lt;/code> 方面，则与上方的 &lt;code>secrets&lt;/code> 基本一致，通过 &lt;code>sshprovider&lt;/code> 允许进行 ssh 转发之类的，这里不再深入展开了。&lt;/p>
&lt;h4 id="调用-api-发送构建请求">调用 API 发送构建请求&lt;/h4>
&lt;p>这里主要有两种情况。&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>build context&lt;/code> 是从 &lt;code>stdin&lt;/code> 读，并且是一个 &lt;code>tar&lt;/code> 文件时&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">buildID&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">stringid&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GenerateRandomID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">body&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">eg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Go&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">buildOptions&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildOptions&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Version&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuilderBuildKit&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">BuildID&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">uploadRequestRemote&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;:&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">buildID&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Client&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ImageBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">response&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>它会执行上述这部分逻辑，但同时也要注意，这是使用的是 Golang 的 &lt;code>goroutine&lt;/code>，到这里也并不是结束，这部分代码之后的代码也同样会被执行。这就说到了另一种情况了(通常情况)。&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>doBuild&lt;/code> 完成逻辑&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">eg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Go&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}()&lt;/span>
&lt;span class="nx">buildOptions&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">imageBuildOptions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuilderBuildKit&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Dockerfile&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">dockerfileName&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RemoteContext&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">remote&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">SessionID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuildID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">buildID&lt;/span>
&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Outputs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">outputs&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">doBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">eg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stdoutUsed&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那 &lt;code>doBuild&lt;/code> 会做些什么呢？它同样也调用了 API 向 &lt;code>dockerd&lt;/code> 发起了构建请求。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">doBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">eg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">errgroup&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Group&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dockerCli&lt;/span> &lt;span class="nx">command&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Cli&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stdoutUsed&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildOptions&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildOptions&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">at&lt;/span> &lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Attachable&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">finalErr&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">response&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dockerCli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Client&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ImageBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Background&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">response&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// 省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从以上的介绍我们可以先做个小的总结。 &lt;strong>当 &lt;code>build context&lt;/code> 从 &lt;code>stdin&lt;/code> 读，并且是个 &lt;code>tar&lt;/code> 归档时，实际会向 &lt;code>dockerd&lt;/code> 发起两次 &lt;code>/build&lt;/code> 请求&lt;/strong> 而一般情况下只会发送一次请求。&lt;/p>
&lt;p>那这里会有什么差别呢？此处先不展开，我们留到下面讲 &lt;code>dockerd&lt;/code> 服务端的时候再来解释。&lt;/p>
&lt;h4 id="小结-2">小结&lt;/h4>
&lt;p>这里我们对开启了 &lt;code>buildkit&lt;/code> 支持的 CLI 构建镜像的过程进行了分析，大致过程如下：&lt;/p>
&lt;p>从入口函数 &lt;code>runBuild&lt;/code> 开始，判断是否支持 &lt;code>buildkit&lt;/code> ，如果支持 &lt;code>buildkit&lt;/code> 则调用 &lt;code>runBuildBuildKit&lt;/code>。与 v1 的 &lt;code>builder&lt;/code> 不同的是，开启了 &lt;code>buildkit&lt;/code> 后，会首先创建一个长连接的会话，并一直保持。其次，与 &lt;code>builder&lt;/code> 相同，判断 &lt;code>build context&lt;/code> 的来源，格式之类的，校验参数等。当然，&lt;code>buildkit&lt;/code> 支持三种不同的输出格式 &lt;code>tar&lt;/code>, &lt;code>local&lt;/code> 或正常的存储于 Docker 的目录中。另外是在 &lt;code>buildkit&lt;/code> 中新增的高阶特性，可以配置 &lt;code>secrets&lt;/code> 和 &lt;code>ssh&lt;/code> 密钥等功能。最后，再调用 API 与 &lt;code>dockerd&lt;/code> 交互完成镜像的构建。&lt;/p>
&lt;h2 id="服务端dockerd">服务端：dockerd&lt;/h2>
&lt;p>上面分别介绍了 API， CLI 的 v1 &lt;code>builder&lt;/code> 和 &lt;code>buildkit&lt;/code> ，接下来我们看看服务端的具体原理和逻辑。&lt;/p>
&lt;h3 id="client-函数">Client 函数&lt;/h3>
&lt;p>还记得上面部分中最后通过 API 与服务端交互的 &lt;code>ImageBuild&lt;/code> 函数吗？在开始 &lt;code>dockerd&lt;/code> 的介绍前，我们来看下这个客户端接口的具体内容。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// github.com/docker/docker/client/image_build.go#L20
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">cli&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Client&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">ImageBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildContext&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Reader&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildOptions&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildResponse&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">query&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">cli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">imageBuildOptionsToQuery&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildResponse&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">headers&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Header&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">][]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Marshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AuthConfigs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildResponse&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">headers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;X-Registry-Config&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">base64&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">URLEncoding&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EncodeToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">headers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Content-Type&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;application/x-tar&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">serverResp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">cli&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">postRaw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;/build&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">buildContext&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">headers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildResponse&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">osType&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getDockerOS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">serverResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">header&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Server&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageBuildResponse&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Body&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">serverResp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">OSType&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">osType&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">},&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>没有什么太特别的地方，行为与 API 一致。 通过这里我们确认它确实访问的 &lt;code>/build&lt;/code> 接口，所以，我们来看看 &lt;code>dockerd&lt;/code> 的 &lt;code>/build&lt;/code> 接口，看看它在构建镜像的时候做了什么。&lt;/p>
&lt;h3 id="dockerd">&lt;code>dockerd&lt;/code>&lt;/h3>
&lt;p>由于本文集中讨论的是构建系统相关的部分，所以也就不再过多赘述与构建无关的内容了，我们直接来看，当 CLI 通过 &lt;code>/build&lt;/code> 接口发送请求后，会发生什么。&lt;/p>
&lt;p>先来看该 API 的入口：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// api/server/router/build/build.go#L32
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">buildRouter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">initRoutes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">routes&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">router&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Route&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">router&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewPostRoute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/build&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">postBuild&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="nx">router&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewPostRoute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/build/prune&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">postPrune&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="nx">router&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewPostRoute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/build/cancel&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">postCancel&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>dockerd&lt;/code> 提供了一套类 RESTful 的后端接口服务，处理逻辑的入口便是上面的 &lt;code>postBuild&lt;/code> 函数。&lt;/p>
&lt;p>该函数的内容较多，我们来分解下它的主要步骤。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">newImageBuildOptions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">errf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>newImageBuildOptions&lt;/code> 函数就是构造构建参数的，将通过 API 提交过来的参数转换为构建动作实际需要的参数形式。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AuthConfigs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">getAuthConfigs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Header&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>getAuthConfigs&lt;/code> 函数用于从请求头拿到认证信息&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">imgID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">br&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">backend&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">backend&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuildConfig&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Source&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">body&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Options&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">buildOptions&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">ProgressWriter&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nf">buildProgressWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wantAux&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">createProgressReader&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">errf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里就需要注意了: 真正的构建过程要开始了。&lt;strong>使用 backend 的 &lt;code>Build&lt;/code> 函数来完成真正的构建过程&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// api/server/backend/build/backend.go#L53
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Backend&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span> &lt;span class="nx">backend&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuildConfig&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">options&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Options&lt;/span>
&lt;span class="nx">useBuildKit&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Version&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuilderBuildKit&lt;/span>
&lt;span class="nx">tagger&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">NewTagger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">imageComponent&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ProgressWriter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StdoutFormatter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Tags&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">build&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">builder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">useBuildKit&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">build&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">buildkit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">build&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">builder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">build&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">imageID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">build&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ImageID&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Squash&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">imageID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">squashBuild&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">build&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">imageComponent&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ProgressWriter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AuxFormatter&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ProgressWriter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">AuxFormatter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;moby.image.id&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuildResult&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">ID&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">imageID&lt;/span>&lt;span class="p">});&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">useBuildKit&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">stdout&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ProgressWriter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">StdoutFormatter&lt;/span>
&lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stdout&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Successfully built %s\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">stringid&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">TruncateID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">imageID&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">imageID&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">tagger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">TagImages&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">image&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">imageID&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">imageID&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个函数看着比较长，但主要功能就以下三点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>NewTagger&lt;/code> 是用于给镜像打标签，也就是我们的 &lt;code>-t&lt;/code> 参数相关的内容，这里不做展开。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过判断是否使用了 &lt;code>buildkit&lt;/code> 来调用不同的构建后端。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="nx">useBuildKit&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Version&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">types&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BuilderBuildKit&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">build&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">builder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">useBuildKit&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">build&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">buildkit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">build&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">builder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Build&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">config&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>处理构建完成后的动作。&lt;/li>
&lt;/ul>
&lt;p>到这个函数之后，就分别是 v1 &lt;code>builder&lt;/code> 与 &lt;code>buildkit&lt;/code> 对 &lt;code>Dockerfile&lt;/code> 的解析，以及对 &lt;code>build context&lt;/code> 的操作了。&lt;/p>
&lt;p>这里涉及到的内容与我下一篇文章《高效构建 Docker 镜像的最佳实践》的内部关联比较大，此处就不再进行展开了。敬请期待下一篇文章。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文首先介绍了 Docker 的 C/S 架构，介绍了构建镜像所用的 API , API 文档可以在线查看或者本地构建。之后深入到 Docker CLI 的源码中，逐步分解 v1 &lt;code>builder&lt;/code> 与 &lt;code>buildkit&lt;/code> 在构建镜像时执行的过程的差异。最后，我们深入到 &lt;code>dockerd&lt;/code> 的源码中，了解到了对不同构建后端的调用。至此，Docker 构建镜像的原理及主体代码就介绍完毕。&lt;/p>
&lt;p>但这还并不是结束，我会在后续文章中分享镜像构建的相关实践，敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/golang/" term="golang" label="golang"/></entry><entry><title type="text">K8S 生态周报| Docker v20.10.5 发布，修复 Bug 及提升稳定性</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/02/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.5-%E5%8F%91%E5%B8%83%E4%BF%AE%E5%A4%8D-Bug-%E5%8F%8A%E6%8F%90%E5%8D%87%E7%A8%B3%E5%AE%9A%E6%80%A7/"/><id>https://moelove.info/2021/02/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.5-%E5%8F%91%E5%B8%83%E4%BF%AE%E5%A4%8D-Bug-%E5%8F%8A%E6%8F%90%E5%8D%87%E7%A8%B3%E5%AE%9A%E6%80%A7/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-02-28T22:10:50+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v20.10.5 发布 这里我同时……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v20105-发布">Docker v20.10.5 发布&lt;/h2>
&lt;p>这里我同时介绍下 Docker v20.10.4 和 v20.10.5 中值得注意的变更：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/docker/cli/pull/2959">cli#2959&lt;/a> 修复了一个在 &lt;code>docker login&lt;/code> 时，可能触发的 panic 。这个问题可能会发生在使用 Debian 系统全新安装 Docker v20.10.[0~3] 版本，并且通过 apt 安装了 docker-compose 的场景下。解决办法，要么升级到最新版本，要么就需要手动创建 &lt;code>~/.docker/config.json&lt;/code> 文件。 &lt;strong>对于绝大多数的用户应该都不会受到此问题影响&lt;/strong>；&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/42049">#42049&lt;/a> 修复了一个仅在 v20.10 版本下，同步 pull 失败的情况。这个问题只有在 v20.10 版本，且启用了 BuildKit ，并且在构建镜像时候存在并发 pull 的情况下才会触发，算是触发概率极低的情况了；&lt;/li>
&lt;li>&lt;a href="https://github.com/docker/cli/pull/2987">cli#2987&lt;/a> 修复了 &lt;code>docker start -a&lt;/code> 可能 hang 住的问题。说实话，要不是查这个问题，我已经基本忘记了 docker start 有个 &lt;code>-a&lt;/code> 的选项了。我通常会直接用 &lt;code>docker run&lt;/code> 启动当前要用的容器，或者 &lt;code>docker start&lt;/code> 后，再 &lt;code>docker exec&lt;/code> ， &lt;strong>attach&lt;/strong> 相关的命令和参数基本都没有再用了。&lt;/li>
&lt;/ul>
&lt;p>更多关于 Docker v20.10 的相关内容，请查看其 &lt;a href="https://github.com/moby/moby/releases" title="Docker ReleaseNote">ReleaseNote&lt;/a>。&lt;/p>
&lt;h2 id="coredns-v183-发布">CoreDNS v1.8.3 发布&lt;/h2>
&lt;p>在之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/278701087">K8S 生态周报| Helm v3.4 发布&lt;/a> 中我介绍了 CoreDNS v1.8.0 版本相关的特性及变更,感兴趣的小伙伴可以复习一下。本次我来介绍下自 CoreDNS v1.8.1 到 v1.8.3 之间有哪些值得关注的变更。&lt;/p>
&lt;ul>
&lt;li>新增了一个名为 &lt;a href="https://coredns.io/plugins/local/">local&lt;/a> 的 plugin，用于响应 local 的请求。即：所有 &lt;code>localhost.&amp;lt;domain&amp;gt;&lt;/code> 的请求都会解析为 127.0.0.1 例如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">➜ ~ dig +short @127.0.0.1 -p &lt;span class="m">9987&lt;/span> localhost.moelove.info
127.0.0.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果 Corefile 中启用了 &lt;code>debug&lt;/code> 和 &lt;code>log&lt;/code> plugin 的话，会看到类似的输出：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">[&lt;/span>DEBUG&lt;span class="o">]&lt;/span> plugin/local: Intercepting localhost query &lt;span class="k">for&lt;/span> &lt;span class="s2">&amp;#34;localhost.moelove.info.&amp;#34;&lt;/span> A, from 127.0.0.1
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> 127.0.0.1:37324 - &lt;span class="m">17796&lt;/span> &lt;span class="s2">&amp;#34;A IN localhost.moelove.info. udp 63 false 4096&amp;#34;&lt;/span> NOERROR qr,rd &lt;span class="m">78&lt;/span> 0.000327638s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要是为了解析 localhost 后跟任意的 domain name 的请求。更具体的背景请参考 &lt;a href="https://github.com/coredns/coredns/issues/4260">issue #4260&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>修正了 file plugin 中对于链式 CNAME 查询时的返回值。根据 &lt;a href="https://tools.ietf.org/html/rfc6604#section-3" title="RFC 6604">RFC 6604&lt;/a> 中的说明，当遵循链式查询时，返回值应该与最后一次的查询结果相同。也就是说，当出现 &amp;quot;A CNAME B&amp;quot; 但是 B 不存在的情况时，应当返回 &lt;code>NXDOMAIN&lt;/code> 而不是 &lt;code>NOERROR&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>我用下面的配置进行说明，首先写一个 zone 文件，并命名为 test.moelove.info.txt ：&lt;/p>
&lt;pre>&lt;code>$ORIGIN moelove.info.
@ 3600 SOA ns1.foo.com. (
zone-admin.foo.com. ; address of responsible party
2016072701 ; serial number
3600 ; refresh period
600 ; retry period
604800 ; expire time
1800 ) ; minimum ttl
86400 NS ns1.foo.com.
86400 NS ns2.foo.com.
3600 MX 10 mail.moelove.info.
60 A 10.10.10.10
3600 TXT &amp;quot;v=moe includemoelove.info ~all&amp;quot;
mail 14400 A 11.11.11.11
www 43200 CNAME moelove.info.
b.c 43200 CNAME c.c.moelove.info.
c.c 43200 CNAME d.c.moelove.info.
&lt;/code>&lt;/pre>&lt;p>可以看到，这里将 &lt;code>b.c&lt;/code> CNAME 到 &lt;code>c.c&lt;/code> ，&lt;code>c.c&lt;/code> CNAME 到 &lt;code>d.c&lt;/code> ，但是 &lt;code>d.c&lt;/code> 并不存在。&lt;/p>
&lt;p>CoreDNS 用下面的内容作为配置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">moelove.info {&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">file test.moelove.info.txt&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">log&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">debug&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别使用 CoreDNS v1.7.1 和 v1.8.3 进行测试：&lt;/p>
&lt;p>&lt;strong>v1.7.1&lt;/strong>&lt;/p>
&lt;pre>&lt;code>➜ ~ ./coredns-v1.7 -conf Corefile -dns.port 9987
&lt;/code>&lt;/pre>&lt;p>使用 dig 进行测试：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ dig @127.0.0.1 -p &lt;span class="m">9987&lt;/span> b.c.moelove.info
&lt;span class="p">;&lt;/span> &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.27-RedHat-9.11.27-1.fc32 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @127.0.0.1 -p &lt;span class="m">9987&lt;/span> b.c.moelove.info
&lt;span class="p">;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="m">1&lt;/span> server found&lt;span class="o">)&lt;/span>
&lt;span class="p">;;&lt;/span> global options: +cmd
&lt;span class="p">;;&lt;/span> Got answer:
&lt;span class="p">;;&lt;/span> -&amp;gt;&amp;gt;HEADER&lt;span class="s">&amp;lt;&amp;lt;- opco&lt;/span>de: QUERY, status: NOERROR, id: &lt;span class="m">14077&lt;/span>
&lt;span class="p">;;&lt;/span> flags: qr aa rd&lt;span class="p">;&lt;/span> QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: &lt;span class="m">1&lt;/span>
&lt;span class="p">;;&lt;/span> WARNING: recursion requested but not available
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到返回中 &lt;code>status: NOERROR&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>v1.8.3&lt;/strong>&lt;/p>
&lt;pre>&lt;code>➜ ~ ./coredns-v1.8 -conf Corefile -dns.port 9988
&lt;/code>&lt;/pre>&lt;p>使用 dig 进行测试：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ dig @127.0.0.1 -p &lt;span class="m">9988&lt;/span> b.c.moelove.info
&lt;span class="p">;&lt;/span> &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.11.27-RedHat-9.11.27-1.fc32 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @127.0.0.1 -p &lt;span class="m">9988&lt;/span> b.c.moelove.info
&lt;span class="p">;&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="m">1&lt;/span> server found&lt;span class="o">)&lt;/span>
&lt;span class="p">;;&lt;/span> global options: +cmd
&lt;span class="p">;;&lt;/span> Got answer:
&lt;span class="p">;;&lt;/span> -&amp;gt;&amp;gt;HEADER&lt;span class="s">&amp;lt;&amp;lt;- opco&lt;/span>de: QUERY, status: NXDOMAIN, id: &lt;span class="m">832&lt;/span>
&lt;span class="p">;;&lt;/span> flags: qr aa rd&lt;span class="p">;&lt;/span> QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: &lt;span class="m">1&lt;/span>
&lt;span class="p">;;&lt;/span> WARNING: recursion requested but not available
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到返回中是 &lt;code>status: NXDOMAIN&lt;/code> 。&lt;/p>
&lt;p>这个修正对于我们判断 DNS 记录是否正确/工作是否正常，有很大的帮助。&lt;/p>
&lt;p>更多关于 CoreDNS v1.8+ 版本的特性变更，请参考其 &lt;a href="https://coredns.io/2021/02/24/coredns-1.8.3-release/" title="CoreDNS ReleaseNote">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99561">#99561&lt;/a> 正式移除了 Bazel 构建系统！这是一个非常大的变更，涉及到的内容很广，但没什么太需要介绍的，这一天终于来啦，轻松了很多！&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/99158">#99158&lt;/a> 支持为 Pod 设置 Sysctls 的特性现在已经 GA， 这是一个从 K8S v1.4 版本开始的功能，到 v1.11 的时候进入 Beta，如今正式 GA，并将在 v1.21 中公布，且会默认启用此特性；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/97099">#97099&lt;/a> &lt;strong>用户可以通过 &lt;code>kubectl.kubernetes.io/default-container&lt;/code> 声明 kubectl exec 时的默认容器了&lt;/strong>，这个功能类似于 &lt;code>kubectl.kubernetes.io/default-logs-container&lt;/code> 的声明，我们可以将主体容器作为默认容器，这样 exec 或者 logs 的时候，就不需要再去指定容器名称了，非常实用！ 当然，&lt;code>kubectl cp&lt;/code> 也会遵循此行为。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.5 正式发布，带来完备的 OCI 支持</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/02/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.5-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E5%AE%8C%E5%A4%87%E7%9A%84-OCI-%E6%94%AF%E6%8C%81/"/><id>https://moelove.info/2021/02/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.5-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E5%AE%8C%E5%A4%87%E7%9A%84-OCI-%E6%94%AF%E6%8C%81/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-02-21T22:25:43+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KIND v0.10 正式发布 KIND （K……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v010-正式发布">KIND v0.10 正式发布&lt;/h2>
&lt;p>KIND （Kubernetes In Docker ）是我很喜欢也一直在参与贡献的 Kubernetes SIG 子项目，本周 KIND 发布了 v0.10 版本，距离上次 v0.9 版本已过去了 4 个多月，在此期间，我们做了很多的优化和改进。下面我来具体介绍下：&lt;/p>
&lt;h3 id="破坏性变更">破坏性变更&lt;/h3>
&lt;p>这个部分显然是大家最为关心的，这里有三个需要注意的点：&lt;/p>
&lt;ul>
&lt;li>默认的 Node 镜像版本已经更新为了 Kubernetes v1.20.2 版本，所以个别有关 Kubernetes 自身特性变更的方面需要注意下；&lt;/li>
&lt;li>IPv6 Pod 子网默认从 /64 修改成了 /56 ，这里的修改参考了&lt;a href="https://www.ripe.net/publications/docs/ripe-690#4--size-of-end-user-prefix-assignment---48---56-or-something-else-" title="终端用户的 IPv6 子网划分最佳实践"> RIPE 的一篇关于 IPv6 子网规划的最佳实践&lt;/a>，有兴趣的朋友可以了解下；&lt;/li>
&lt;li>我们目前能保障 KIND 与 v1.14.0+ 的 Kubernetes 完备的兼容，但对于 v1.13.x 版本我们只能尽量做到最好；&lt;/li>
&lt;/ul>
&lt;h3 id="新特性">新特性&lt;/h3>
&lt;ul>
&lt;li>当构建 v1.19+ 版本的 Kubernetes 镜像时，可以不构建 dockershim 组件，以便减小镜像的体积；&lt;/li>
&lt;li>通过优化编译参数，显著的减少了 KIND 二进制文件的体积（~7MB）；&lt;/li>
&lt;li>&lt;code>kind export logs&lt;/code> 导出的 log 中将包含 KIND 的版本信息，以便于更好的定位问题；&lt;/li>
&lt;li>实验性使用 GitHub Action CI 提供 docker/podman/cgroup v2 等环境的支持；&lt;/li>
&lt;li>文档内容的优化和完善，包括 WSL2，负载均衡等方面；&lt;/li>
&lt;/ul>
&lt;h3 id="修正">修正&lt;/h3>
&lt;ul>
&lt;li>优化了 cgroups 相关的处理逻辑；&lt;/li>
&lt;li>优化了一些错误信息的内容；&lt;/li>
&lt;/ul>
&lt;p>大家可以直接在&lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.10.0" title="KIND v0.10.0 Release"> KIND v0.10.0 版本的 Release 页面&lt;/a>下载预编译好的二进制文件进行体验，有任何问题欢迎随时反馈。&lt;/p>
&lt;h2 id="helm-v35-正式发布">Helm v3.5 正式发布&lt;/h2>
&lt;p>Helm v3.5 是 Helm 的一个特性版本，此版本的特性主要集中在 OCI 支持和模板函数，以下是我认为值得关注的一些变更：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/9126">#9126&lt;/a> Helm 的 template 中新增加了超过 20 个的函数支持，具体函数列表可&lt;a href="https://github.com/Masterminds/sprig/releases/tag/v3.2.0" title="Helm v3.5 新增函数说明">参考 sprig 的列表&lt;/a>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/8843">#8843&lt;/a> 允许在设置了 &lt;code>HELM_EXPERIMENTAL_OCI&lt;/code> 环境变量的前提下，通过 &lt;code>helm pull oci://&lt;/code> 的方式来下载 OCI 仓库中下载 Chart 和更新依赖；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/8886">#8886&lt;/a> 为 &lt;code>helm dep build&lt;/code> 增加了一个 &lt;code>--skip-refresh&lt;/code> 的参数，这样就不会刷新本地仓库中的 cache 了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/8363">#8363&lt;/a> 添加了一个 &lt;code>wait-for-jobs&lt;/code> 的参数，当同时设置了 &lt;code>--wait&lt;/code> 时候，&lt;code>helm install&lt;/code> 等命令将会等待所有的 Job 都执行完成后，才会认为本次操作完成。当然，它也会受到 &lt;code>--timeout&lt;/code> 参数的影响，最多等待时间不会超过 timeout 设置的时间；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/8958">#8958&lt;/a> 添加了 &lt;code>--kube-cafile&lt;/code> 的参数和等价的 &lt;code>HELM_KUBECAFILE&lt;/code> 环境变量，用来指定连接 Kubernetes 时的 CA 。在此变更之前，如果 Kubernetes 集群的证书未在系统层信任的话，就会出现失败的情况，提示 &lt;code>x509: certificate signed by unknown authority&lt;/code> 之类的。以下是三种可用的解决方案：&lt;/p>
&lt;ul>
&lt;li>在系统层信任证书，这个就不多说了；&lt;/li>
&lt;li>Kubeconfig 增加 certificate-authority：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>KUBECONFIG=~/.mycustomkubeconfig
kubectl config set-cluster internal.company --server=https://internal.company:443 --certificate-authority=/tmp/ca.crt
kubectl config set-context some-context --cluster=internal.company --namespace=myns
kubectl config use-context some-context
HELM_NAMESPACE=myns HELM_KUBEAPISERVER=https://internal.company:443 helm install --kubeconfig=&amp;quot;${KUBECONFIG}&amp;quot; some-app company/some-app
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>通过此处提供的 &lt;code>HELM_KUBECAFILE&lt;/code> 的环境变量：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>HELM_NAMESPACE=myns HELM_KUBEAPISERVER=https://internal.company:443 HELM_KUBECAFILE=/tmp/ca.crt helm install some-app company/some-app
&lt;/code>&lt;/pre>&lt;p>可以看到，方便了很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/8626">#8626&lt;/a> 用 Artifact Hub 替代了 Helm Hub 。我在去年的 &lt;a href="https://zhuanlan.zhihu.com/p/267670759" title="Helm Hub 迁移到 Artifact Hub">K8S 生态周报| Helm 五周岁啦！&lt;/a> 中曾具体介绍过此事，感兴趣的小伙伴可以看看具体内容；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.5.0" title="Helm v3.5 Release">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="事件">事件&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.docker.com/blog/donating-docker-distribution-to-the-cncf/" title="Docker 把 Distribution 捐给了 CNCF">Docker 把 Distribution 捐给了 CNCF&lt;/a>，Docker Distribution 是 Docker Hub 及众多镜像仓库的底层实现，捐给 CNCF 有望为其带来更强大的生命力；&lt;/li>
&lt;li>&lt;a href="https://github.com/docker/hub-tool">Docker Hub Tool 开源啦&lt;/a> 可以在我之前的&lt;a href="https://zhuanlan.zhihu.com/p/339131328">Docker Hub Tool 文章&lt;/a>中了解其具体特性；&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/96021">#96021&lt;/a> 当往 CSI 卷上创建卷数据文件期间如果发生异常，不会再自动删除全部数据了，现在仅删除数据文件和卷路径；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/98678">#98678&lt;/a> TTLAfterFinished 特性将默认启用，并且升级至 beta 。此特性是用于控制 Job 和 Pod 完成后的清理时间，通过 &lt;code>.spec.ttlSecondsAfterFinished&lt;/code> 进行设置，在资源创建或完成后都可以修改这个值，但是一旦超过 TTL，并且 K8S 认为可删除资源的时候，再修改这个 TTL 也没有效果了；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">从 Go 的二进制文件中获取其依赖的模块信息</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/02/17/%E4%BB%8E-Go-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF/"/><id>https://moelove.info/2021/02/17/%E4%BB%8E-Go-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-02-17T23:44:41+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">大家好，我是张晋涛。 我们用 Go 构建的二进制文件中默认包含了很多有用的信息。例如，可以获取构建用的 Go 版本： (这里我使用我一直参与的一……</summary><content type="html">&lt;p>大家好，我是张晋涛。&lt;/p>
&lt;p>我们用 Go 构建的二进制文件中默认包含了很多有用的信息。例如，可以获取构建用的 Go 版本：&lt;/p>
&lt;p>(这里我使用我一直参与的一个开源项目 &lt;a href="https://github.com/kubernetes-sigs/kind" title="KIND 项目地址">KIND&lt;/a> 为例)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ go version ./bin/kind
./bin/kind: go1.16
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者也可以获取该二进制所依赖的模块信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ go version -m ./bin/kind
./bin/kind: go1.16
path sigs.k8s.io/kind
mod sigs.k8s.io/kind &lt;span class="o">(&lt;/span>devel&lt;span class="o">)&lt;/span>
dep github.com/BurntSushi/toml v0.3.1
dep github.com/alessio/shellescape v1.4.1
dep github.com/evanphx/json-patch/v5 v5.2.0
dep github.com/mattn/go-isatty v0.0.12
dep github.com/pelletier/go-toml v1.8.1 h1:1Nf83orprkJyknT6h7zbuEGUEjcyVlCxSUGTENmNCRM&lt;span class="o">=&lt;/span>
dep github.com/pkg/errors v0.9.1
dep github.com/spf13/cobra v1.1.1
dep github.com/spf13/pflag v1.0.5
dep golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c h1:VwygUrnw9jn88c4u8GD3rZQbqrP/tgas88tPUbBxQrk&lt;span class="o">=&lt;/span>
dep gopkg.in/yaml.v2 v2.2.8
dep gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo&lt;span class="o">=&lt;/span>
dep k8s.io/apimachinery v0.20.2
dep sigs.k8s.io/yaml v1.2.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 KIND 代码仓库中的 &lt;a href="https://github.com/kubernetes-sigs/kind/blob/f291e2baed5346e139afa802453eab85bb30215e/go.mod#L5-L18">go.mod&lt;/a>文件，都包含在内了。&lt;/p>
&lt;p>其实 Linux 系统中二进制文件包含额外的信息并非 Go 所特有的，下面我将具体介绍其内部原理和实现。当然，用 Go 构建的二进制文件仍是本文的主角。&lt;/p>
&lt;h2 id="linux-elf-格式">Linux ELF 格式&lt;/h2>
&lt;p>ELF 是 Executable and Linkable Format 的缩写，是一种用于可执行文件、目标文件、共享库和核心转储(core dump)的标准文件格式。ELF 文件 &lt;strong>通常&lt;/strong> 是编译器之类的输出，并且是二进制格式。以 Go 编译出的可执行文件为例，我们使用 file 命令即可看到其具体类型 &lt;code>ELF 64-bit LSB executable&lt;/code> ：&lt;/p>
&lt;pre>&lt;code>➜ kind git:(master) ✗ file ./bin/kind
./bin/kind: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
&lt;/code>&lt;/pre>&lt;p>本文中我们来具体看看 64 位可执行文件使用的 ELF 文件格式的结构和 Linux 内核源码中对它的定义。&lt;/p>
&lt;p>使用 ELF 文件格式的可执行文件是由 &lt;strong>ELF 头（ELF Header）&lt;/strong> 开始，后跟 &lt;strong>程序头（Program Header）&lt;/strong> 或 &lt;strong>节头（Section Header）&lt;/strong> 或两者均有组成的。&lt;/p>
&lt;h3 id="elf-头">ELF 头&lt;/h3>
&lt;p>&lt;strong>ELF 头始终位于文件的零偏移（zero offset）处（即：起点位置），同时在 ELF 头中还定义了程序头和节头的偏移量。&lt;/strong>&lt;/p>
&lt;p>我们可以通过 readelf 命令查看可执行文件的 ELF 头，如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">➜ kind git:(master) ✗ readelf -h ./bin/kind &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">ELF Header&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Magic&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Class&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ELF64&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="l">&amp;#39;s complement, little endian&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(current)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">OS/ABI&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">UNIX - System V&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ABI Version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">EXEC (Executable file)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Machine&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Advanced Micro Devices X86-64&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0x1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Entry point address&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0x46c460&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Start of program headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(bytes into file)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Start of section headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">400&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(bytes into file)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Flags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0x0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Size of this header&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(bytes)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Size of program headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">56&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(bytes)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Number of program headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">6&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Size of section headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">64&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">(bytes)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Number of section headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">15&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">Section header string table index&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的输出我们可以看到，ELF 头是以某个 Magic 开始的，此 Magic 标识了有关文件的信息，即：前四个 16 进制数，表示这是一个 ELF 文件。具体来说，将它们换算成其对应的 ASCII 码即可：&lt;/p>
&lt;p>45 = E&lt;/p>
&lt;p>4c = L&lt;/p>
&lt;p>46 = F&lt;/p>
&lt;p>7f 是其前缀，当然，也可以直接在 &lt;a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/uapi/linux/elf.h#L340-L343" title="ELF Magic 内核源码">Linux 内核源码&lt;/a>中拿到此处的具体定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/elf.h#L340-L343
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define ELFMAG0 0x7f &lt;/span>&lt;span class="cm">/* EI_MAG */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#define ELFMAG1 &amp;#39;E&amp;#39;
&lt;/span>&lt;span class="cp">#define ELFMAG2 &amp;#39;L&amp;#39;
&lt;/span>&lt;span class="cp">#define ELFMAG3 &amp;#39;F&amp;#39;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来的数 02 是与 Class 字段相对应的，表示其体系结构，它可以是 32 位（=01） 或是 64 位（=02）的，此处显示 02 表示是 64 位的，再有 readelf 将其转换为 ELF64 进行展示。这里的取值同样可以在 &lt;a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/uapi/linux/elf.h#L347-L350" title="ELF Class 内核定义">Linux 内核源码&lt;/a>中找到：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/elf.h#L347-L349
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define ELFCLASSNONE 0 &lt;/span>&lt;span class="cm">/* EI_CLASS */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#define ELFCLASS32 1
&lt;/span>&lt;span class="cp">#define ELFCLASS64 2
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再后面的两个 01 01 则是与 Data 字段和 Version 字段相对应的，Data 有两个取值分别是 LSB（01）和 MSB（02），这里倒没什么必要展开。另外就是 Version 当前只有一个取值，即 01 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/elf.h#L352-L358
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define ELFDATANONE 0 &lt;/span>&lt;span class="cm">/* e_ident[EI_DATA] */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#define ELFDATA2LSB 1
&lt;/span>&lt;span class="cp">#define ELFDATA2MSB 2
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define EV_NONE 0 &lt;/span>&lt;span class="cm">/* e_version, EI_VERSION */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#define EV_CURRENT 1
&lt;/span>&lt;span class="cp">#define EV_NUM 2
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来需要注意的就是我前面提到的关于偏移量的内容，即输出中的以下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh"> Start of program headers: &lt;span class="m">64&lt;/span> &lt;span class="o">(&lt;/span>bytes into file&lt;span class="o">)&lt;/span>
Start of section headers: &lt;span class="m">400&lt;/span> &lt;span class="o">(&lt;/span>bytes into file&lt;span class="o">)&lt;/span>
Flags: 0x0
Size of this header: &lt;span class="m">64&lt;/span> &lt;span class="o">(&lt;/span>bytes&lt;span class="o">)&lt;/span>
Size of program headers: &lt;span class="m">56&lt;/span> &lt;span class="o">(&lt;/span>bytes&lt;span class="o">)&lt;/span>
Number of program headers: &lt;span class="m">6&lt;/span>
Size of section headers: &lt;span class="m">64&lt;/span> &lt;span class="o">(&lt;/span>bytes&lt;span class="o">)&lt;/span>
Number of section headers: &lt;span class="m">15&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ELF 头总是在起点，在此例中接下来是程序头（Program Header），随后是节头（Section Header），这里的输出显示程序头是从 64 开始的，所以节头的位置就是：&lt;/p>
&lt;pre>&lt;code>64 + 56 * 6 = 400
&lt;/code>&lt;/pre>&lt;p>与上述输出符合，同理，节头的结束位置是：&lt;/p>
&lt;pre>&lt;code>400 + 15 * 64 = 1360
&lt;/code>&lt;/pre>&lt;p>下一节内容中将用到这部分知识。&lt;/p>
&lt;h3 id="程序头">程序头&lt;/h3>
&lt;p>通过 &lt;code>readelf -l&lt;/code> 可以看到其程序头，包含了若干段（Segment），内核看到这些段时，将调用 mmap syscall 来使用它们映射到虚拟地址空间。这部分不是本文的重点，我们暂且跳过有个印象即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ readelf -l ./bin/kind
Elf file &lt;span class="nb">type&lt;/span> is EXEC &lt;span class="o">(&lt;/span>Executable file&lt;span class="o">)&lt;/span>
Entry point 0x46c460
There are &lt;span class="m">6&lt;/span> program headers, starting at offset &lt;span class="m">64&lt;/span>
Program Headers:
Type Offset VirtAddr PhysAddr
FileSiz MemSiz Flags Align
PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040
0x0000000000000150 0x0000000000000150 R 0x1000
LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000
0x0000000000333a75 0x0000000000333a75 R E 0x1000
LOAD 0x0000000000334000 0x0000000000734000 0x0000000000734000
0x00000000002b3be8 0x00000000002b3be8 R 0x1000
LOAD 0x00000000005e8000 0x00000000009e8000 0x00000000009e8000
0x0000000000020ac0 0x00000000000552d0 RW 0x1000
GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000
0x0000000000000000 0x0000000000000000 RW 0x8
LOOS+0x5041580 0x0000000000000000 0x0000000000000000 0x0000000000000000
0x0000000000000000 0x0000000000000000 0x8
Section to Segment mapping:
Segment Sections...
&lt;span class="m">00&lt;/span>
&lt;span class="m">01&lt;/span> .text
&lt;span class="m">02&lt;/span> .rodata .typelink .itablink .gosymtab .gopclntab
&lt;span class="m">03&lt;/span> .go.buildinfo .noptrdata .data .bss .noptrbss
&lt;span class="m">04&lt;/span>
&lt;span class="m">05&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="节头">节头&lt;/h3>
&lt;p>使用 &lt;code>readelf -S&lt;/code> 即可查看其节头，其结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/elf.h#L317-L328
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">elf64_shdr&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">Elf64_Word&lt;/span> &lt;span class="n">sh_name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Section name, index in string tbl */&lt;/span>
&lt;span class="n">Elf64_Word&lt;/span> &lt;span class="n">sh_type&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Type of section */&lt;/span>
&lt;span class="n">Elf64_Xword&lt;/span> &lt;span class="n">sh_flags&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Miscellaneous section attributes */&lt;/span>
&lt;span class="n">Elf64_Addr&lt;/span> &lt;span class="n">sh_addr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Section virtual addr at execution */&lt;/span>
&lt;span class="n">Elf64_Off&lt;/span> &lt;span class="n">sh_offset&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Section file offset */&lt;/span>
&lt;span class="n">Elf64_Xword&lt;/span> &lt;span class="n">sh_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Size of section in bytes */&lt;/span>
&lt;span class="n">Elf64_Word&lt;/span> &lt;span class="n">sh_link&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Index of another section */&lt;/span>
&lt;span class="n">Elf64_Word&lt;/span> &lt;span class="n">sh_info&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Additional section information */&lt;/span>
&lt;span class="n">Elf64_Xword&lt;/span> &lt;span class="n">sh_addralign&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Section alignment */&lt;/span>
&lt;span class="n">Elf64_Xword&lt;/span> &lt;span class="n">sh_entsize&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* Entry size if section holds table */&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">Elf64_Shdr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对照实际的命令输出，含义就很明显了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ readelf -S ./bin/kind
There are &lt;span class="m">15&lt;/span> section headers, starting at offset 0x190:
Section Headers:
&lt;span class="o">[&lt;/span>Nr&lt;span class="o">]&lt;/span> Name Type Address Offset
Size EntSize Flags Link Info Align
&lt;span class="o">[&lt;/span> 0&lt;span class="o">]&lt;/span> NULL &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">00000000&lt;/span>
&lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="o">[&lt;/span> 1&lt;span class="o">]&lt;/span> .text PROGBITS &lt;span class="m">0000000000401000&lt;/span> &lt;span class="m">00001000&lt;/span>
0000000000332a75 &lt;span class="m">0000000000000000&lt;/span> AX &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span> 2&lt;span class="o">]&lt;/span> .rodata PROGBITS &lt;span class="m">0000000000734000&lt;/span> &lt;span class="m">00334000&lt;/span>
000000000011f157 &lt;span class="m">0000000000000000&lt;/span> A &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span> 3&lt;span class="o">]&lt;/span> .shstrtab STRTAB &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">00453160&lt;/span>
00000000000000a4 &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="o">[&lt;/span> 4&lt;span class="o">]&lt;/span> .typelink PROGBITS &lt;span class="m">0000000000853220&lt;/span> &lt;span class="m">00453220&lt;/span>
00000000000022a0 &lt;span class="m">0000000000000000&lt;/span> A &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span> 5&lt;span class="o">]&lt;/span> .itablink PROGBITS 00000000008554c0 004554c0
&lt;span class="m">0000000000000978&lt;/span> &lt;span class="m">0000000000000000&lt;/span> A &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span> 6&lt;span class="o">]&lt;/span> .gosymtab PROGBITS 0000000000855e38 00455e38
&lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">0000000000000000&lt;/span> A &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span>
&lt;span class="o">[&lt;/span> 7&lt;span class="o">]&lt;/span> .gopclntab PROGBITS 0000000000855e40 00455e40
0000000000191da8 &lt;span class="m">0000000000000000&lt;/span> A &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span> 8&lt;span class="o">]&lt;/span> .go.buildinfo PROGBITS 00000000009e8000 005e8000
&lt;span class="m">0000000000000020&lt;/span> &lt;span class="m">0000000000000000&lt;/span> WA &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">16&lt;/span>
&lt;span class="o">[&lt;/span> 9&lt;span class="o">]&lt;/span> .noptrdata PROGBITS 00000000009e8020 005e8020
&lt;span class="m">0000000000017240&lt;/span> &lt;span class="m">0000000000000000&lt;/span> WA &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span>10&lt;span class="o">]&lt;/span> .data PROGBITS 00000000009ff260 005ff260
&lt;span class="m">0000000000009850&lt;/span> &lt;span class="m">0000000000000000&lt;/span> WA &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span>11&lt;span class="o">]&lt;/span> .bss NOBITS 0000000000a08ac0 00608ac0
000000000002f170 &lt;span class="m">0000000000000000&lt;/span> WA &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span>12&lt;span class="o">]&lt;/span> .noptrbss NOBITS 0000000000a37c40 00637c40
&lt;span class="m">0000000000005690&lt;/span> &lt;span class="m">0000000000000000&lt;/span> WA &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">32&lt;/span>
&lt;span class="o">[&lt;/span>13&lt;span class="o">]&lt;/span> .symtab SYMTAB &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">00609000&lt;/span>
0000000000030a20 &lt;span class="m">0000000000000018&lt;/span> &lt;span class="m">14&lt;/span> &lt;span class="m">208&lt;/span> &lt;span class="m">8&lt;/span>
&lt;span class="o">[&lt;/span>14&lt;span class="o">]&lt;/span> .strtab STRTAB &lt;span class="m">0000000000000000&lt;/span> 00639a20
000000000004178d &lt;span class="m">0000000000000000&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span>
Key to Flags:
W &lt;span class="o">(&lt;/span>write&lt;span class="o">)&lt;/span>, A &lt;span class="o">(&lt;/span>alloc&lt;span class="o">)&lt;/span>, X &lt;span class="o">(&lt;/span>execute&lt;span class="o">)&lt;/span>, M &lt;span class="o">(&lt;/span>merge&lt;span class="o">)&lt;/span>, S &lt;span class="o">(&lt;/span>strings&lt;span class="o">)&lt;/span>, I &lt;span class="o">(&lt;/span>info&lt;span class="o">)&lt;/span>,
L &lt;span class="o">(&lt;/span>link order&lt;span class="o">)&lt;/span>, O &lt;span class="o">(&lt;/span>extra OS processing required&lt;span class="o">)&lt;/span>, G &lt;span class="o">(&lt;/span>group&lt;span class="o">)&lt;/span>, T &lt;span class="o">(&lt;/span>TLS&lt;span class="o">)&lt;/span>,
C &lt;span class="o">(&lt;/span>compressed&lt;span class="o">)&lt;/span>, x &lt;span class="o">(&lt;/span>unknown&lt;span class="o">)&lt;/span>, o &lt;span class="o">(&lt;/span>OS specific&lt;span class="o">)&lt;/span>, E &lt;span class="o">(&lt;/span>exclude&lt;span class="o">)&lt;/span>,
l &lt;span class="o">(&lt;/span>large&lt;span class="o">)&lt;/span>, p &lt;span class="o">(&lt;/span>processor specific&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go-二进制文件探秘">Go 二进制文件探秘&lt;/h2>
&lt;p>&lt;strong>本文中，我们重点关注名为 &lt;code>.go.buildinfo&lt;/code> 的部分。&lt;/strong> 使用 objdump 查看其具体内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ objdump -s -j .go.buildinfo ./bin/kind
./bin/kind: file format elf64-x86-64
Contents of section .go.buildinfo:
9e8000 ff20476f &lt;span class="m">20627569&lt;/span> 6c64696e 663a0800 . Go buildinf:..
9e8010 a0fc9f00 &lt;span class="m">00000000&lt;/span> e0fc9f00 &lt;span class="m">00000000&lt;/span> ................
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们按顺序来，先看到第一行的 16 个字节。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/elf-go-buildinfo.png" alt="">&lt;/p>
&lt;ul>
&lt;li>前 14 个字节是魔术字节，必须为 &lt;code>\xff Go buildinf:&lt;/code> ；&lt;/li>
&lt;li>第 15 字节表示其指针大小，这里的值为 &lt;code>0x08&lt;/code>，表示 8 个字节；&lt;/li>
&lt;li>第 16 字节用于判断字节序是大端模式还是小端模式，非 0 为大端模式，0 为小端模式。&lt;/li>
&lt;/ul>
&lt;p>我们继续看第 17 字节开始的内容。&lt;/p>
&lt;h3 id="go-版本信息">Go 版本信息&lt;/h3>
&lt;p>前面我们也看到了当前使用的字节序是小端模式，这里的地址应该是 &lt;code>0x009ffca0&lt;/code> 。&lt;/p>
&lt;p>我们来取出 16 字节的内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ objdump -s --start-address 0x009ffca0 --stop-address 0x009ffcb0 ./bin/kind
./bin/kind: file format elf64-x86-64
Contents of section .data:
9ffca0 f5027d00 &lt;span class="m">00000000&lt;/span> &lt;span class="m">06000000&lt;/span> &lt;span class="m">00000000&lt;/span> ..&lt;span class="o">}&lt;/span>.............
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里前面的 8 个字节是 Go 版本的信息，后 8 个字节是版本所占的大小（这里表示占 6 个字节）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ objdump -s --start-address 0x007d02f5 --stop-address 0x007d02fb ./bin/kind
./bin/kind: file format elf64-x86-64
Contents of section .rodata:
7d02f5 676f31 2e3136 go1.16
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，如上所示，我们拿到了构建此二进制文件所用的 Go 版本的信息，是用 Go 1.16 进行构建的。&lt;/p>
&lt;h3 id="go-module-信息">Go Module 信息&lt;/h3>
&lt;p>前面我们使用了 17~24 字节的信息，这次我们继续往后使用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ objdump -s --start-address 0x009ffce0 --stop-address 0x009ffcf0 ./bin/kind
./bin/kind: file format elf64-x86-64
Contents of section .data:
9ffce0 5a567e00 &lt;span class="m">00000000&lt;/span> e6020000 &lt;span class="m">00000000&lt;/span> ZV~.............
&lt;/code>&lt;/pre>&lt;/div>&lt;p>与前面获取 Go 版本信息时相同，前 8 个字节是指针，后 8 个字节是其大小。也就是说从 &lt;code>0x007e565a&lt;/code> 开始，大小为 &lt;code>0x000002e6&lt;/code> ，所以我们可以拿到以下内容：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ kind git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ objdump -s --start-address 0x007e565a --stop-address 0x7e5940 ./bin/kind
./bin/kind: file format elf64-x86-64
Contents of section .rodata:
7e565a &lt;span class="m">3077&lt;/span> af0c9274 080241e1 c107e6d6 18e6 0w...t..A.......
7e566a &lt;span class="m">7061&lt;/span> &lt;span class="m">74680973&lt;/span> 6967732e 6b38732e 696f path.sigs.k8s.io
7e567a 2f6b 696e640a 6d6f6409 &lt;span class="m">73696773&lt;/span> 2e6b /kind.mod.sigs.k
7e568a &lt;span class="m">3873&lt;/span> 2e696f2f 6b696e64 &lt;span class="m">09286465&lt;/span> &lt;span class="m">7665&lt;/span> 8s.io/kind.&lt;span class="o">(&lt;/span>deve
7e569a 6c29 090a6465 &lt;span class="m">70096769&lt;/span> &lt;span class="m">74687562&lt;/span> 2e63 l&lt;span class="o">)&lt;/span>..dep.github.c
7e56aa 6f6d 2f427572 6e745375 7368692f 746f om/BurntSushi/to
7e56ba 6d6c 0976302e 332e3109 0a646570 &lt;span class="m">0967&lt;/span> ml.v0.3.1..dep.g
7e56ca &lt;span class="m">6974&lt;/span> 6875622e 636f6d2f 616c6573 &lt;span class="m">7369&lt;/span> ithub.com/alessi
7e56da 6f2f 7368656c 6c657363 &lt;span class="m">61706509&lt;/span> &lt;span class="m">7631&lt;/span> o/shellescape.v1
7e56ea 2e34 2e31090a &lt;span class="m">64657009&lt;/span> &lt;span class="m">67697468&lt;/span> &lt;span class="m">7562&lt;/span> .4.1..dep.github
7e56fa 2e63 6f6d2f65 76616e70 68782f6a 736f .com/evanphx/jso
7e570a 6e2d &lt;span class="m">70617463&lt;/span> 682f7635 0976352e 322e n-patch/v5.v5.2.
7e571a &lt;span class="m">3009&lt;/span> 0a646570 &lt;span class="m">09676974&lt;/span> 6875622e 636f 0..dep.github.co
7e572a 6d2f 6d617474 6e2f676f 2d697361 &lt;span class="m">7474&lt;/span> m/mattn/go-isatt
7e573a &lt;span class="m">7909&lt;/span> 76302e30 2e313209 0a646570 &lt;span class="m">0967&lt;/span> y.v0.0.12..dep.g
7e574a &lt;span class="m">6974&lt;/span> 6875622e 636f6d2f 70656c6c &lt;span class="m">6574&lt;/span> ithub.com/pellet
7e575a &lt;span class="m">6965&lt;/span> 722f676f 2d746f6d 6c097631 2e38 ier/go-toml.v1.8
7e576a 2e31 0968313a 314e6638 336f7270 726b .1.h1:1Nf83orprk
7e577a 4a79 6b6e5436 68377a62 &lt;span class="m">75454755&lt;/span> 456a JyknT6h7zbuEGUEj
7e578a &lt;span class="m">6379&lt;/span> 566c4378 &lt;span class="m">53554754&lt;/span> 454e6d4e &lt;span class="m">4352&lt;/span> cyVlCxSUGTENmNCR
7e579a 4d3d 0a646570 &lt;span class="m">09676974&lt;/span> 6875622e 636f &lt;span class="nv">M&lt;/span>&lt;span class="o">=&lt;/span>.dep.github.co
7e57aa 6d2f 706b672f 6572726f &lt;span class="m">72730976&lt;/span> 302e m/pkg/errors.v0.
7e57ba 392e 31090a64 &lt;span class="m">65700967&lt;/span> &lt;span class="m">69746875&lt;/span> 622e 9.1..dep.github.
7e57ca 636f 6d2f7370 6631332f 636f6272 &lt;span class="m">6109&lt;/span> com/spf13/cobra.
7e57da &lt;span class="m">7631&lt;/span> 2e312e31 090a6465 &lt;span class="m">70096769&lt;/span> &lt;span class="m">7468&lt;/span> v1.1.1..dep.gith
7e57ea &lt;span class="m">7562&lt;/span> 2e636f6d 2f737066 31332f70 666c ub.com/spf13/pfl
7e57fa &lt;span class="m">6167&lt;/span> 0976312e 302e3509 0a646570 &lt;span class="m">0967&lt;/span> ag.v1.0.5..dep.g
7e580a 6f6c 616e672e 6f72672f 782f7379 &lt;span class="m">7309&lt;/span> olang.org/x/sys.
7e581a &lt;span class="m">7630&lt;/span> 2e302e30 2d323032 &lt;span class="m">31303132&lt;/span> &lt;span class="m">3431&lt;/span> v0.0.0-202101241
7e582a &lt;span class="m">3534&lt;/span> 3534382d &lt;span class="m">32326461&lt;/span> &lt;span class="m">36326531&lt;/span> &lt;span class="m">3263&lt;/span> 54548-22da62e12c
7e583a &lt;span class="m">3063&lt;/span> 0968313a &lt;span class="m">56777967&lt;/span> 55726e77 396a 0c.h1:VwygUrnw9j
7e584a 6e38 &lt;span class="m">38633475&lt;/span> &lt;span class="m">38474433&lt;/span> 725a5162 &lt;span class="m">7172&lt;/span> n88c4u8GD3rZQbqr
7e585a 502f &lt;span class="m">74676173&lt;/span> &lt;span class="m">38387450&lt;/span> &lt;span class="m">55624278&lt;/span> &lt;span class="m">5172&lt;/span> P/tgas88tPUbBxQr
7e586a 6b3d 0a646570 09676f70 6b672e69 6e2f &lt;span class="nv">k&lt;/span>&lt;span class="o">=&lt;/span>.dep.gopkg.in/
7e587a &lt;span class="m">7961&lt;/span> 6d6c2e76 &lt;span class="m">32097632&lt;/span> 2e322e38 090a yaml.v2.v2.2.8..
7e588a &lt;span class="m">6465&lt;/span> 7009676f 706b672e 696e2f79 616d dep.gopkg.in/yam
7e589a 6c2e &lt;span class="m">76330976&lt;/span> 332e302e 302d3230 &lt;span class="m">3231&lt;/span> l.v3.v3.0.0-2021
7e58aa &lt;span class="m">3031&lt;/span> &lt;span class="m">30373139&lt;/span> &lt;span class="m">32393232&lt;/span> 2d343936 &lt;span class="m">3534&lt;/span> 0107192922-49654
7e58ba &lt;span class="m">3561&lt;/span> &lt;span class="m">36333037&lt;/span> &lt;span class="m">62096831&lt;/span> 3a683871 446f 5a6307b.h1:h8qDo
7e58ca &lt;span class="m">7461&lt;/span> 4550754a 4154724d 6d573034 4e43 taEPuJATrMmW04NC
7e58da &lt;span class="m">7767&lt;/span> &lt;span class="m">37763232&lt;/span> &lt;span class="m">61484832&lt;/span> &lt;span class="m">38777770&lt;/span> &lt;span class="m">6175&lt;/span> wg7v22aHH28wwpau
7e58ea &lt;span class="m">5568&lt;/span> 4b394f6f 3d0a6465 70096b38 732e &lt;span class="nv">UhK9Oo&lt;/span>&lt;span class="o">=&lt;/span>.dep.k8s.
7e58fa 696f 2f617069 6d616368 696e6572 &lt;span class="m">7909&lt;/span> io/apimachinery.
7e590a &lt;span class="m">7630&lt;/span> 2e32302e 32090a64 &lt;span class="m">65700973&lt;/span> &lt;span class="m">6967&lt;/span> v0.20.2..dep.sig
7e591a 732e 6b38732e 696f2f79 616d6c09 &lt;span class="m">7631&lt;/span> s.k8s.io/yaml.v1
7e592a 2e32 2e30090a f9324331 &lt;span class="m">86182072&lt;/span> &lt;span class="m">0082&lt;/span> .2.0...2C1.. r..
7e593a &lt;span class="m">4210&lt;/span> 4116d8f2 B.A...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>我们成功的拿到了其所依赖的 Modules 相关的信息，&lt;/strong>
这与我们在文章开头执行 &lt;code>go version -m ./bin/kind&lt;/code> 是可以匹配上的，只不过这里的内容相当于是做了序列化。&lt;/p>
&lt;h2 id="具体实现">具体实现&lt;/h2>
&lt;p>在前面的内容中，关于如何使用 readelf 和 objdump 命令获取二进制文件的的 Go 版本和 Module 信息就已经涉及到了其具体的原理。这里我来介绍下 Go 代码的实现。&lt;/p>
&lt;p>节头的名称是&lt;a href="https://github.com/golang/go/blob/f21be2fdc6f1becdbed1592ea0b245cdeedc5ac8/src/cmd/go/internal/version/exe.go#L106-L110">硬编码在代码&lt;/a>中的&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">//src/cmd/go/internal/version/exe.go#L106-L110
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="k">range&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Sections&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;.go.buildinfo&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Addr&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，魔术字节也是通过如下定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">var&lt;/span> &lt;span class="nx">buildInfoMagic&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;\xff Go buildinf:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取 Version 和 Module 相关信息的逻辑如下，在前面的内容中也已经基本介绍过了，这里需要注意的也就是字节序相关的部分了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="nx">ptrSize&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="nx">bigEndian&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">bo&lt;/span> &lt;span class="nx">binary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ByteOrder&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">bigEndian&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">bo&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">binary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">BigEndian&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">bo&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">binary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">LittleEndian&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">readPtr&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">uint64&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">ptrSize&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">readPtr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">uint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">bo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Uint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">b&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">readPtr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">bo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Uint64&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">vers&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">readString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ptrSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">readPtr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">readPtr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">:]))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">vers&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">mod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">readString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ptrSize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">readPtr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">readPtr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">ptrSize&lt;/span>&lt;span class="p">:]))&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mod&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">33&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">mod&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mod&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Strip module framing.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">mod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">mod&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">16&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mod&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我在这篇文章中分享了如何从 Go 的二进制文件中获取构建它时所用的 Go 版本及它依赖的模块信息。如果对原理不感兴趣的话，直接通过 &lt;code>go version -m 二进制文件&lt;/code> 即可获取相关的信息。&lt;/p>
&lt;p>具体实现还是依赖于 ELF 文件格式中的相关信息，同时也介绍了 readelf 和 objdump 工具的基本使用，ELF 格式除了本文介绍的这种场景外，还有很多有趣的场景可用，比如为了安全进行逆向之类的。&lt;/p>
&lt;p>另外，你可能会好奇从 Go 的二进制文件获取这些信息有什么作用。最直接的来说，可以用于安全漏洞扫描，比如检查其依赖项是否有安全漏洞；或是可以对依赖进行分析（主要指：接触不到源代码的场景下）会比较有用。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Go/" term="Go" label="Go"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">新晋程序员奶爸的云原生之路</title><link rel="alternate" type="text/html" href="https://moelove.info/2021/01/01/%E6%96%B0%E6%99%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A5%B6%E7%88%B8%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B9%8B%E8%B7%AF/"/><id>https://moelove.info/2021/01/01/%E6%96%B0%E6%99%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A5%B6%E7%88%B8%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B9%8B%E8%B7%AF/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2021-01-01T08:14:53+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">一眨眼已经 2021 年了，虽然我每年也都会惯例的做个小回顾，但 2020 年对我意义更加不同。我打算换个方式来聊。 生活 很多人说 2020 年过于魔幻，这一年……</summary><content type="html">&lt;blockquote>
&lt;p>一眨眼已经 2021 年了，虽然我每年也都会惯例的做个小回顾，但 2020 年对我意义更加不同。我打算换个方式来聊。&lt;/p>
&lt;/blockquote>
&lt;h2 id="生活">生活&lt;/h2>
&lt;p>很多人说 2020 年过于魔幻，这一年确实发生了很多事情，疫情、山火、蝗灾、洪水等。&lt;/p>
&lt;p>而这一年对我来说意义更加非凡。正如我在&lt;a href="https://zhuanlan.zhihu.com/p/100618036" title="2019 小回顾">去年的总结文&lt;/a>分享的那样，我是在 2019 年和我的小可爱结婚的，2020 年我俩的宝宝出生啦！&lt;/p>
&lt;p>我现在对那天仍记忆犹新。那天晚上我总觉得好像需要做点什么，但其实那种感觉也描述不出来。最终我是打开电脑看了几遍孕妇学校老师给的关于临产前准备工作视频后睡觉的。当时小可爱还笑我是不是太紧张了。凌晨时我们一起去了医院，经过小可爱的一番努力，从此我也就增加了新的角色， 成为了一名奶爸，谢谢我的小可爱！&lt;/p>
&lt;p>有了孩子之后，生活自然也就不像之前了，很多时候要考虑孩子的情况，比如半夜需要哄他，每天为他洗澡之类的。等稍微大点之后好了不少，也变得更加有趣了。周末会带他去早教中心，其实主要就是带他去玩，能看见其他小朋友，跟其他小朋友打招呼之类的，每次他都很开心。&lt;/p>
&lt;p>在作为“奶爸”这个角色上，我没有经验，也还在学习和摸索中。（很早以前我和几个好朋友一起聊过，是不是大家应该组群一起聊聊奶爸心得之类的，交流下经验~ 哈哈哈）&lt;/p>
&lt;p>正如我 7 月份在接受思否社区访谈时说的那样， &lt;a href="https://segmentfault.com/a/1190000023260535">思否有约丨张晋涛：一直在学习，包括更好的工作和如何成为合格的父亲&lt;/a>。对于后者，这里我就不聊太多了，刚刚起步，以后的路还长着呢~&lt;/p>
&lt;h2 id="个人学习和成长">个人学习和成长&lt;/h2>
&lt;p>接下来就聊聊个人学习和成长相关的部分吧。&lt;/p>
&lt;p>今年的主要研究方向仍然专注于容器运行时，Kubernetes 以及 Prometheus 等云原生相关的技术。&lt;/p>
&lt;p>在容器运行时方面参与开源社区最多，Docker v20.10 也是我花时间精力最多的一个版本， 关于 &lt;a href="https://zhuanlan.zhihu.com/p/341163077">Docker v20.10 相关的介绍请参考我之前的文章&lt;/a>。在此过程中，我对 containerd, runc，firecracker 等技术也都在源码层有了更深的理解以及做了一些相关实践和尝试。&lt;/p>
&lt;p>对于 Kubernetes 来说，今年代码提交方面表现一般。多数时间花在了理清其某些功能的设计及演进过程等方面，积累了一些奇奇怪怪的知识，如果大家感兴趣的话，以后我可以考虑写一些文章来聊聊，以及对 Kubernetes 一些周边技术进行了探索和实践。&lt;/p>
&lt;p>至于 Prometheus 的话，有几篇规划中的文章没来得及写。反倒是给 &lt;a href="https://book.douban.com/subject/35239877/">Prometheus云原生监控： 运维与开发实战&lt;/a> 这本书写了个推荐语。
同时 Prometheus 在我司也正逐步落地推进，但受资源和人力等因素的限制，远没达到我预期的效果，还有很长的路要走。
2021 年我计划要把它整体架构及周边基础设施完善下，希望能迈入一个新的阶段。&lt;/p>
&lt;p>除此之外，还有一些值得记录的内容。&lt;/p>
&lt;p>2020 年年初，更新完了我在 GitChat 上的专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">Docker 核心知识必知必会&lt;/a> ，按照 GitChat 上的字数统计，这个专栏有将近 10w 字，涉及到了 Docker 原理的方方面面。从开始策划到全部更新完成，这期间一共换了 3 位编辑（前 2 位离职了），耗时半年，感谢各位编辑和读者们的支持！感谢我的小可爱催稿！让我终于能按时完稿。
更新专栏的那些天，要么是写到凌晨，要么是凌晨起床就开始写，感觉还是蛮辛苦的。但完稿之后，回头来看，好像也还好。果然一个人的上限是需要逼自己一下的。&lt;/p>
&lt;p>此外，自 2019 年 3 月份开始，我也一直在更新着 &lt;a href="https://zhuanlan.zhihu.com/container" title="K8S生态周报">「K8S 生态周报」&lt;/a> 在 2020 年推送了 44 篇，中间有几篇断更，感谢各位新老读者朋友们的支持！未来会继续保持更新。&lt;/p>
&lt;p>我的小可爱&lt;a href="https://space.bilibili.com/20831032" title="bilibili: 无尽的胖">在 2020 年也开始了视频版的输出&lt;/a>。小可爱比我要认真，视频版比文字版要详细的多，包括具体的操作演示之类的。此外，视频中也会有些彩蛋，喜欢看视频的小伙伴可以来一波关注~&lt;/p>
&lt;p>除了&lt;a href="https://zhuanlan.zhihu.com/container">「K8S 生态周报」&lt;/a>外，2020 年我一共写了 15 篇博客，有个别几篇未公开，今年修改润色后会公开发布，此外也把博客重新整理了下，换了个主题，清爽了一些，欢迎大家访问 &lt;a href="https://moelove.info/">https://moelove.info/&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/2020-posts.png" alt="2020 年博客截图">&lt;/p>
&lt;p>2020 年另外的几件事情：&lt;/p>
&lt;ul>
&lt;li>收到了公司第一份非合同制的聘书 TM599&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://moelove.info/img/TM599.jpg" alt="网易TM599聘书">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>做了 5 次公开的技术分享：&lt;/p>
&lt;ul>
&lt;li>7 月初在公司的 Tech Talk Time 分享 Docker 构建优化；&lt;/li>
&lt;li>7 月底在 Python Meetup 分享 Docker 和 Kubernetes；&lt;/li>
&lt;li>&lt;a href="https://dbaplus.cn/activity-12-1063-1.html">9 月份在 dbplus 分享 Redis 容器化的技术选型和对比&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://segmentfault.com/area/pyconchina-2020">11 月在 PyCon China 分享使用 eBPF 技术调试容器&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://shangzhibo.tv/watch/10226294">12 月在 Upyun Open Talk Time 分享 containerd 的上手实践&lt;/a>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上半年其实还有一个 RedHat 的 Open TestCon ，不过受疫情影响取消了。下半年基本保持每月 1 次的节奏。根据主办方数据和参会者的反馈来看，效果还不错，感谢大家的支持！这些分享的 PPT ，可以直接&lt;a href="https://github.com/tao12345666333/slides" title="技术分享的 PPT">在我的 GitHub 仓库中下载&lt;/a>。&lt;/p>
&lt;p>这几次分享，大家其实也可以看到，每次都是不一样的，有各自不同的侧重，包括容器化/Kubernetes，容器运行时，eBPF 等技术。 &lt;strong>PS: 我坚信，近五年 eBPF 技术会有更大规模的生产实践，它也是一个很好的突破口。&lt;/strong> 除 Cilium 外，我也计划之后分享更多好玩和实用的 eBPF 实践，当然，我也计划在我司的环境中，做一些其他的尝试。&lt;/p>
&lt;p>既然是年度的总结和回顾，我也来聊一些不那么满意和做的不好的地方吧。&lt;/p>
&lt;p>就我个人而言，2020 年上半年有过一小段时间的迷茫，或者说“注意力分散”。各类技术层出不穷，更新也很频繁，唯有持续学习和跟进。关注太多东西，虽然能让自己保持敏锐的判断 &amp;amp; 更轻松的解决问题，然而个人精力有限，持续这样会分散很多注意力。&lt;/p>
&lt;p>所以我主动的屏蔽掉了一些信息 &amp;amp; 对相关内容做了分级，将自己的注意力更好的集中在几个主要的领域内，其他内容周期性的回顾下，也未尝不可。这也就是我在开头提到的主要研究方向。&lt;/p>
&lt;p>另一方面则是对团队/系统相关的，当前面临较大的问题是信息孤岛（information island），虽说信息孤岛是技术产业发展中不可避免的一个问题，但现在可能出现的早了点，也严重了点。导致了很多孤立的系统 &amp;amp; 信息闭塞。希望明年通过平台建设能改善一些这种问题。&lt;/p>
&lt;h2 id="flag">flag&lt;/h2>
&lt;p>2019 年，在 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;amp;mid=2247491168&amp;amp;idx=4&amp;amp;sn=99c75223a96c3f0a4ba4802162a7176b&amp;amp;chksm=e82bff71df5c7667eeeabc6a12c1ed5d7e2589dd6d81c015a9fdf4896af0d99019c71182ab27&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1577896952072&amp;amp;sharer_shareid=ca2e51094588e06bf753d47ce6ce6894&amp;amp;exportkey=AeBs7IZvP2YDdO0PAERxHsc%3D&amp;amp;pass_ticket=sUqDG7gi77aHI1AzhT8QG4acbC2iGtoHfL5dhjaRgAIB%2BMOsBIpQ8jHnQ671eH1e#rd">GitChat 的访谈中&lt;/a> 让我聊 2020 年容器的技术趋势。我当时的主要观点如下：&lt;/p>
&lt;blockquote>
&lt;p>作为云原生技术的基石，Kubernetes 在 2020 年的热度将会持续上升。而各个公司的集群规模，以及对容器技术的推进都将会持续加大。在经历了初步容器化后，更多的公司将面临的问题是稳定性和性能优化问题。与此同时，service mesh，serverless 等技术也都会逐步得到普遍应用。
从底层次技术的角度来看，cgroups v2 将逐步普及，进而取代 cgroups v1，但这个过程可能需要两三年左右。
整体而言，稳定性和性能优化将会是未来的主旋律。&lt;/p>
&lt;/blockquote>
&lt;p>回过头来看，确实 2020 年 Kubernetes 热度是在持续上升。关于稳定性方面，看看 Chaos Engineering 去年在各公司 Kubernetes 中的相关实践，基本也得到印证。&lt;/p>
&lt;p>至于性能优化，无论是阿里，腾讯，网易等各家也都对外公开分享了基于 eBPF 等技术的相关优化和实践，这点也没问题。&lt;/p>
&lt;p>cgroups v2 2020 年无论是 runc, containerd, Docker 等均已经增加了相关的支持，也基本得到了印证。&lt;/p>
&lt;p>&lt;strong>唯一没有提到的，可能是安全性相关的部分。&lt;/strong> 在 2020 年，Kubernetes/容器化技术方面的安全性，也进一步得到了重视。（这和各种前期没有太在意的安全漏洞被发现也有很大关系）。&lt;/p>
&lt;p>再来看看年初立的 flag 吧：&lt;/p>
&lt;ul>
&lt;li>工作方面希望能推动更多业务的改造和接入，算是个长线计划；&lt;/li>
&lt;li>社区活动方面，今年希望多参与一些，把一些理念和实践经验 push 到社区，也能从中学习到社区的一些经验；&lt;/li>
&lt;li>社区贡献方面，会继续投入更多精力来做，但与 2019 年的重点可能会稍有不同；&lt;/li>
&lt;li>生活方面，希望宝宝健康的出生，和我的小可爱共同经营好我们的家庭。&lt;/li>
&lt;/ul>
&lt;p>基本符合预期。工作方面业务方和同事们都比较配合，推进也较为顺利。社区活动方面，谢谢每个参与者！生活方面，谢谢我的小可爱！感谢每个家人！&lt;/p>
&lt;p>惯例贴一张图:&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/2020-oss.png" alt="2020 overview - https://moelove.info">&lt;/p>
&lt;p>至于 2021 年的小目标，这次就不写了。愿：平安喜乐！&lt;/p>
&lt;p>还有文章前的你，感谢你的关注和支持，希望我们能各有收获！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">K8S 生态周报| 年终大放送！Docker v20.10</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/12/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E5%B9%B4%E7%BB%88%E5%A4%A7%E6%94%BE%E9%80%81Docker-v20.10/"/><id>https://moelove.info/2020/12/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E5%B9%B4%E7%BB%88%E5%A4%A7%E6%94%BE%E9%80%81Docker-v20.10/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-12-28T01:53:25+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v20.10 主要特性一览 在……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v2010-主要特性一览">Docker v20.10 主要特性一览&lt;/h2>
&lt;p>在之前的 &lt;a href="https://zhuanlan.zhihu.com/p/268647812" title="K8S 生态周报| Docker v20.10.0-beta1 发布">K8S 生态周报| Docker v20.10.0-beta1 发布&lt;/a> 一文中，我曾为你介绍过 Docker v20.10.0-beta1 发布相关的信息，但是并没有具体介绍 Docker v20.10 版本的具体功能特性等细节。&lt;/p>
&lt;blockquote>
&lt;p>Docker v20.10 版本，变化非常的大。提供了 CGroup v2 的支持，增强了 rootless 模式的支持，双栈日志，更灵活的内置 DNS 等，我在这个版本中也花费了很多时间。&lt;/p>
&lt;p>详细的变更，我会在 v20.10 正式发布后再进行介绍。欢迎大家进行测试和反馈，目前已经收到了一些反馈的建议。我们会尽快修正并发布下个版本。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>正如我当时承诺的那样，作为 2020 年最后一篇周报，我来在本篇周报中详细介绍下 Docker v20.10 版本。&lt;/strong>&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>Docker v20.10 发布于 2020 年 12 月 8 日，是自 Docker v19.03 （2019 年 7 月）后发布的首个大版本。你可以直接通过以下命令来自动化的安装 Docker v20.10。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ curl -fsSL https://get.docker.com &lt;span class="p">|&lt;/span>sh
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cgroup-v2-支持">cgroup v2 支持&lt;/h3>
&lt;p>Docker v19.03 是没有 cgroup v2 支持的，但自从 Fedora 31 开始，这成为了 Fedora 上的默认 cgroup 版本。在 Docker v20.10 发布之前，Fedora 31 及以上用户，需要将系统的 cgroup 设置为 v1 才能正常运行 Docker 。&lt;/p>
&lt;p>其实这里面涉及到了大量的修改，包括 runc， containerd 直到 Docker 都添加了 cgroup v2 的支持，此功能才能真正给用户使用。&lt;/p>
&lt;p>在此过程中，我也发现了 runc v1.0-rc91 中隐藏的 bug ，会导致 Docker 无法正常通过增加 &lt;code>--privileged&lt;/code> 参数以特权模式运行容器。后来对 runc 进行了修改，发布了 runc v1.0-rc92 ，至此才使得 Docker 中的 cgroup v2 特性得以顺利完成。&lt;/p>
&lt;p>关于此处更详细的内容，我在 &lt;a href="https://zhuanlan.zhihu.com/p/178227659" title="K8S 生态周报| runc v1.0-rc92 发布">《K8S 生态周报| runc v1.0-rc92 发布》&lt;/a> 中已做了详细介绍，感兴趣的小伙伴可以看看。&lt;/p>
&lt;h3 id="rootless-mode-ga">rootless mode GA&lt;/h3>
&lt;p>Docker 有个一直被人诟病的点，就在于 docker daemon 必须是以 root 权限来启动，这样才可以使用它的全部特性。这也就意味着，凡是可以操作 docker daemon 的用户，也就有机会获取操作系统的 root 权限。&lt;/p>
&lt;p>我们在 Docker v19.03 版本中提供了实验性的 rootless mode 的支持，允许用户无需 root 权限即可运行 docker daemon 。这大大提升了系统的安全性。但当时还处于实验阶段，有部分功能缺失。&lt;/p>
&lt;p>&lt;strong>我想趁此次 Docker v20.10 发布，正式为你介绍下 Docker 的 rootless mode ，并且，它已经达到 GA 从实验性毕业了，并且也提供了很多功能。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>rootless mode 是在用户名称空间中运行 docker daemon 和容器，完全不需要 root 权限。&lt;/strong>&lt;/p>
&lt;p>你可以通过以下命令安装 Docker rootless 模式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ curl -fsSL https://get.docker.com/rootless &lt;span class="p">|&lt;/span> sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者直接通过 Docker 官方的 RPM/DEB 包进行安装。安装完之后，通过 &lt;code>systemctl&lt;/code> 管理 Docker 服务即可。&lt;/p>
&lt;pre>&lt;code>➜ ~ systemctl --user start docker
&lt;/code>&lt;/pre>&lt;p>更多关于 rootless mode 的详细用法及最佳实践，请参考 &lt;a href="https://docs.docker.com/engine/security/rootless/#best-practices" title="Docker 官方文档：以非 root 用户运行 docker daemon">Docker 官方文档：以非 root 用户运行 docker daemon&lt;/a>&lt;/p>
&lt;h3 id="dockerfile-run---mounttypesshsecretcache-等特性达到-ga">Dockerfile: RUN --mount=type=(ssh|secret|cache) 等特性达到 GA&lt;/h3>
&lt;p>Docker v18.06 开始实验性的添加了 &lt;code>RUN --mount=type=cache&lt;/code> 该特性可用于在构建过程中，保留包管理器的缓存文件。&lt;/p>
&lt;p>之后在 v18.09 中又增加了 &lt;code>RUN --mount=type=ssh&lt;/code> 和 &lt;code>RUN --mount=type=secret&lt;/code> 用于在构建过程中，传递密钥或者用户凭证等私密信息，以防止泄漏等。这些高级特性，在我之前的文章 &lt;a href="https://gitbook.cn/books/5cf02802ff33b82ee0eb425d/index.html#-3">《进阶：Dockerfile 高阶使用指南及镜像优化》&lt;/a> 曾详细介绍过。&lt;/p>
&lt;p>这些特性非常有用，基本涵盖了你构建镜像时关于安全性方面的绝大多数的需求。大家如果感兴趣，欢迎随时与我交流，后续我也可能会再写相关的文章进行介绍。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;ul>
&lt;li>此次还优化了内置 DNS 相关的逻辑，可以提供更好的性能；&lt;/li>
&lt;li>docker build 可支持直接 ssh 远程构建私有仓库的镜像了；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，可以参考其 &lt;a href="https://docs.docker.com/engine/release-notes/#20100" title="Docker v20.10 ReleaseNote">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-v154-发布">Rook v1.5.4 发布&lt;/h2>
&lt;p>关于此版本有两个格外需要注意的信息：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/issues/6849">#6849&lt;/a> 最新版的 Ceph 不支持使用分区的 OSD 了。就我个人经验，我倒是基本没有把 OSD 装到过某个分区中，一般都直接使用整块盘；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6769">#6769&lt;/a> Ceph-CSI 默认更新到了 v3.2.0;&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的信息，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.5.4" title="Rook v1.5.4 RelaseNote">ReleaseNote&lt;/a> 。&lt;/p>
&lt;h2 id="etcd-从-cncf-正式毕业">etcd 从 CNCF 正式毕业&lt;/h2>
&lt;p>etcd 想必大家不会陌生，我在「K8S 生态周报」中也曾多次介绍它，这里就不再赘述了。&lt;/p>
&lt;p>感兴趣的小伙伴可查看官方公告： &lt;a href="https://www.cncf.io/announcements/2020/11/24/cloud-native-computing-foundation-announces-etcd-graduation/" title="CNCF 宣布 etcd 正式毕业">CNCF 宣布 etcd 正式毕业&lt;/a>&lt;/p>
&lt;p>再次恭喜 etcd !&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>今年是 2020 年阳历的最后一天了， &lt;strong>感谢大家的关注和支持！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>接下来，我将会发布一份 “2020 年 K8S 生态演进报告” 与你分享在 2020 年 K8S 生态相关不容错误的信息，以及 2021 年 K8S 生态相关的展望及发展方向，敬请期待！&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Docker 新发布的 hub-tool 可直接查看账户配额</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/12/19/Docker-%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84-hub-tool-%E5%8F%AF%E7%9B%B4%E6%8E%A5%E6%9F%A5%E7%9C%8B%E8%B4%A6%E6%88%B7%E9%85%8D%E9%A2%9D/"/><id>https://moelove.info/2020/12/19/Docker-%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84-hub-tool-%E5%8F%AF%E7%9B%B4%E6%8E%A5%E6%9F%A5%E7%9C%8B%E8%B4%A6%E6%88%B7%E9%85%8D%E9%A2%9D/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-12-19T23:58:34+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker Desktop v3.0 已于前两周正式发布，从这个版本起，Docker 官方承诺每次的更新将以增量更新的方式来提供，以便减少下载包的体积，提升效率。……</summary><content type="html">&lt;p>Docker Desktop v3.0 已于前两周正式发布，从这个版本起，Docker 官方承诺每次的更新将以增量更新的方式来提供，以便减少下载包的体积，提升效率。&lt;/p>
&lt;p>除了将 Docker Engine 更新至 v20.10.0 外，也对其他的依赖做了更新，如下图：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-desktop-version.png" alt="Docker Desktop v3.0">&lt;/p>
&lt;p>最吸引我的是本次新增的 &lt;a href="https://github.com/docker/roadmap/issues/117" title="Docker Hub CLI">Docker Hub Tool v0.2.0&lt;/a> ，它是 Docker 官方提供的 Docker Hub CLI 工具，具备管理 DockerHub 上的帐号，镜像等相关资源的能力。&lt;/p>
&lt;p>以下，我来为你介绍下 Hub Tool 的主要功能。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool -h
A tool to manage your Docker Hub images
Usage:
hub-tool
hub-tool &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
account Manage your account
&lt;span class="nb">help&lt;/span> Help about any &lt;span class="nb">command&lt;/span>
login Login to the Hub
&lt;span class="nb">logout&lt;/span> Logout of the Hub
org Manage organizations
repo Manage repositories
tag Manage tags
token Manage Personal Access Tokens
version Version information about this tool
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> hub-tool
--verbose Print logs
--version Display the version of this tool
Use &lt;span class="s2">&amp;#34;hub-tool [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从一级菜单来看，主要功能包括：&lt;/p>
&lt;ul>
&lt;li>登录/登出 DockerHub;&lt;/li>
&lt;li>账户相关管理功能；&lt;/li>
&lt;li>组织相关管理功能；&lt;/li>
&lt;li>仓库和 tag 的相关管理功能；&lt;/li>
&lt;li>token 的相关管理功能；&lt;/li>
&lt;/ul>
&lt;p>当前我使用的是最新版本 v0.2.0 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool version
Version: v0.2.0
Git commit: 0edf43ac9091e7cac892cbc4cbc6efbafb665aa4
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="登录退出">登录/退出&lt;/h2>
&lt;p>登录/退出只要执行 &lt;code>hub-tool login&lt;/code> 或者 &lt;code>hub-tool logout&lt;/code> 即可。&lt;/p>
&lt;p>但这里需要注意的是 &lt;strong>Hub Tool 并没有使用 Docker Desktop 默认的用户凭证&lt;/strong>，也就是说，即使你在 Docker Desktop 中已经登录了帐号，你同样还是需要再次在终端下执行 login 操作。&lt;/p>
&lt;p>关于为何没有共用用户凭证的问题，我跟 Docker Inc. 的产品经理聊过，是因为当前 Hub Tool 还是一个独立的 CLI 工具，并没有与 docker CLI 进行集成，也暂时没想好要如何集成。等真正要集成进 docker CLI 的时候，就会直接共用用户凭证了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool login
Username: moelove
Password:
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="账户管理">账户管理&lt;/h2>
&lt;p>账户管理的两个功能：&lt;/p>
&lt;ul>
&lt;li>查看账户信息；&lt;/li>
&lt;li>&lt;strong>查看当前账户下的流量限制&lt;/strong> , 这是我个人觉得比较有用的一个功能；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool account
Manage your account
Usage:
hub-tool account
hub-tool account &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
info Print the account information
rate-limiting Print the rate limiting information
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> account
Global Flags:
--verbose Print logs
Use &lt;span class="s2">&amp;#34;hub-tool account [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool account rate-limiting
Limit: 200, &lt;span class="m">6&lt;/span> hours window
Remaining: 200, &lt;span class="m">6&lt;/span> hours window
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool account info
Username: moelove.info
Full name: Jintao Zhang
Company:
Location:
Joined: &lt;span class="m">6&lt;/span> years ago
Plan: free
Limits:
Seats: &lt;span class="m">1&lt;/span>
Private repositories: &lt;span class="m">1&lt;/span>
Parallel builds: &lt;span class="m">1&lt;/span>
Collaborators: unlimited
Teams: unlimited
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="组织管理">组织管理&lt;/h2>
&lt;p>可以看到，&lt;code>hub-tool org&lt;/code> 的功能就是展示一些相关信息了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool org
Manage organizations
Usage:
hub-tool org
hub-tool org &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
ls List all the organizations
members List all the members in an organization
teams List all the teams in an organization
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> org
Global Flags:
--verbose Print logs
Use &lt;span class="s2">&amp;#34;hub-tool org [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool org ls
NAMESPACE NAME MY ROLE TEAMS MEMBERS
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="仓库和-tag-管理">仓库和 tag 管理&lt;/h2>
&lt;p>由于这两个都和镜像有直接的关系，我就聚合到一起介绍了。&lt;/p>
&lt;ul>
&lt;li>对 repo 的查询和删除功能：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool repo -h
Manage repositories
Usage:
hub-tool repo
hub-tool repo &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
ls List all the repositories from your account or an organization
rm Delete a repository
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> repo
Global Flags:
--verbose Print logs
Use &lt;span class="s2">&amp;#34;hub-tool repo [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool repo ls
REPOSITORY DESCRIPTION LAST UPDATE PULLS STARS PRIVATE
taobeier/saythx-work &lt;span class="m">2&lt;/span> years ago &lt;span class="m">56989&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="nb">false&lt;/span>
...
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool repo ls -h
List all the repositories from your account or an organization
Usage:
hub-tool repo ls &lt;span class="o">[&lt;/span>ORGANIZATION&lt;span class="o">]&lt;/span>
Aliases:
ls, list
Flags:
--all Fetch all available repositories
--format string Print values using a custom format &lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;json&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> ls
Global Flags:
--verbose Print logs
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>对 tag 的列表，查询，查看详细等功能。 这里 &lt;strong>可以看到 tag 最近一次的 Push/Pull 操作，如果明年 Docker 开始实行镜像保留策略的话，我建议你关注一下&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool tag
Manage tags
Usage:
hub-tool tag &lt;span class="o">[&lt;/span>flags&lt;span class="o">]&lt;/span>
hub-tool tag &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
inspect Show the details of an image in the registry
ls List all the images in a repository
rm Delete a tag in a repository
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> tag
Global Flags:
--verbose Print logs
Use &lt;span class="s2">&amp;#34;hub-tool tag [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
See &lt;span class="s1">&amp;#39;hub-tool tag ls --help&amp;#39;&lt;/span>.
Usage: hub-tool tag ls &lt;span class="o">[&lt;/span>OPTION&lt;span class="o">]&lt;/span> REPOSITORY
List all the images in a repository
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool tag ls taobeier/saythx-work
TAG DIGEST STATUS LAST UPDATE LAST PUSHED LAST PULLED SIZE
taobeier/saythx-work:latest sha256:3133a607d062dd3a8b46f38c8271099c258f5e59cecd652bebddf6e15789cb32 active &lt;span class="m">2&lt;/span> years ago &lt;span class="m">2&lt;/span> years &lt;span class="m">6&lt;/span> days 52.94MB
taobeier/saythx-work:1.0 sha256:3133a607d062dd3a8b46f38c8271099c258f5e59cecd652bebddf6e15789cb32 active &lt;span class="m">2&lt;/span> years ago &lt;span class="m">2&lt;/span> years &lt;span class="m">6&lt;/span> days 52.94MB
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="token-相关管理功能">Token 相关管理功能&lt;/h2>
&lt;p>对个人 Token 的创建/删除，激活/失效，列表，查询详细等功能。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool token -h
Manage Personal Access Tokens
Usage:
hub-tool token &lt;span class="o">[&lt;/span>flags&lt;span class="o">]&lt;/span>
hub-tool token &lt;span class="o">[&lt;/span>command&lt;span class="o">]&lt;/span>
Available Commands:
activate Activate a Personal Access Token
create Create a Personal Access Token
deactivate Deactivate a Personal Access Token
inspect Inspect a Personal Access Token
ls List all the Personal Access Tokens
rm Delete a Personal Access Token
Flags:
-h, --help &lt;span class="nb">help&lt;/span> &lt;span class="k">for&lt;/span> token
Global Flags:
--verbose Print logs
Use &lt;span class="s2">&amp;#34;hub-tool token [command] --help&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information about a command.
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool token ls
DESCRIPTION UUID LAST USED CREATED ACTIVE
test-docker-token xxxxxxxx-xxxx-xxxx-xxxx-moelove.info &lt;span class="m">9&lt;/span> months ago &lt;span class="m">9&lt;/span> months &lt;span class="nb">true&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hub-tool token inspect xxxxxxxx-xxxx-xxxx-xxxx-moelove.info
Token:
UUID: xxxxxxxx-xxxx-xxxx-xxxx-moelove.info
Description: test-docker-token
Is Active: &lt;span class="nb">true&lt;/span>
Created: &lt;span class="m">9&lt;/span> months ago
Last Used: &lt;span class="m">9&lt;/span> months ago
Creator User Agent: Mozilla/5.0 &lt;span class="o">(&lt;/span>X11&lt;span class="p">;&lt;/span> Fedora&lt;span class="p">;&lt;/span> Linux x86_64&lt;span class="o">)&lt;/span> AppleWebKit/537.36 &lt;span class="o">(&lt;/span>KHTML, like Gecko&lt;span class="o">)&lt;/span> Chrome/80.0.4103.116 Safari/537.36
Creator IP: 100.000.000.00
Generated: By user via Web UI
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上就是关于 Docker 新发布的 Hub Tool 的全部功能介绍了。
当前它是随着 Docker Desktop 一起发行的，所以 Linux 下暂时没有。但是计划会尽快开源。敬请期待！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/DockerHub/" term="DockerHub" label="DockerHub"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/></entry><entry><title type="text">Go 1.16 中关于 go get 和 go install 你需要注意的地方</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/12/19/Go-1.16-%E4%B8%AD%E5%85%B3%E4%BA%8E-go-get-%E5%92%8C-go-install-%E4%BD%A0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/><id>https://moelove.info/2020/12/19/Go-1.16-%E4%B8%AD%E5%85%B3%E4%BA%8E-go-get-%E5%92%8C-go-install-%E4%BD%A0%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-12-19T02:27:18+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Go (golang) 已于 18 日发布了 1.16 beta1 版本，至此其主体功能已经基本确定。我看大多数人都在关注 Go 在苹果(Apple) M1 上的支持，甚至 Go 官方博客中也……</summary><content type="html">&lt;p>Go (golang) 已于 18 日发布了 1.16 beta1 版本，至此其主体功能已经基本确定。我看大多数人都在关注 Go 在苹果(Apple) M1 上的支持，甚至 Go 官方博客中也有一篇专门的说明 &lt;a href="https://blog.golang.org/ports" title="Go on ARM and Beyond">Go on ARM and Beyond&lt;/a> ，来介绍 Go 在此方面的支持。&lt;/p>
&lt;p>我就不凑热闹了，我来聊聊 Go 1.16 中关于 &lt;code>go get&lt;/code> 和 &lt;code>go install&lt;/code> 你需要注意的地方。&lt;/p>
&lt;p>目前 Docker 官方镜像尚未发布，我是本地构建了个镜像来使用。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ go version
go version go1.16beta1 linux/amd64
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="概览">概览&lt;/h2>
&lt;p>Go 1.16 中包含着大量的 Modules 相关的更新，详细内容可直接查看其 &lt;a href="https://tip.golang.org/doc/go1.16#tools" title="Go 1.16 Release Note">Release Note&lt;/a>。整体而言，包含以下要点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GO111MODULE&lt;/code> 默认为 &lt;code>on&lt;/code> ，如果要恢复到之前的行为，则需要将 &lt;code>GO111MODULE&lt;/code> 设置为 &lt;code>auto&lt;/code> ，这样差不多意味着 GOPATH 模式要逐步淡出人们的视野了；&lt;/li>
&lt;li>&lt;code>go install&lt;/code> 命令可以接受一个版本后缀了，（例如，go install &lt;a href="mailto:sigs.k8s.io/kind@v0.9.0">sigs.k8s.io/kind@v0.9.0&lt;/a>），并且它是在模块感知的模式下运行，可忽略当前目录或上层目录的 &lt;code>go.mod&lt;/code> 文件。这对于在不影响主模块依赖的情况下，安装二进制很方便；&lt;/li>
&lt;li>在将来，&lt;code>go install&lt;/code> 被设计为“用于构建和安装二进制文件”， &lt;code>go get&lt;/code> 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 &lt;code>-d&lt;/code> 参数共用，在将来版本中 &lt;code>-d&lt;/code> 可能会默认启用；&lt;/li>
&lt;li>&lt;code>go build&lt;/code> 和 &lt;code>go test&lt;/code> 默认情况下不再修改 &lt;code>go.mod&lt;/code> 和 &lt;code>go.sum&lt;/code>。可通过 &lt;code>go mod tidy&lt;/code> ，&lt;code>go get&lt;/code> 或者手动完成；&lt;/li>
&lt;/ul>
&lt;p>总结而言，关于 &lt;code>go install&lt;/code> 和 &lt;code>go get&lt;/code> 必须要注意的是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基本上 &lt;code>go install &amp;lt;package&amp;gt;@&amp;lt;version&amp;gt;&lt;/code> 是用于命令的全局安装：&lt;/p>
&lt;ul>
&lt;li>例如：&lt;code>go install sigs.k8s.io/kind@v0.9.0&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go get&lt;/code> 安装二进制的功能，后续版本将会删除；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>go get&lt;/code> 主要被设计为修改 &lt;code>go.mod&lt;/code> 追加依赖之类的，但还存在类似 &lt;code>go mod tidy&lt;/code> 之类的命令，所以使用频率可能不会很高；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="go-116-中已解决的工具安装问题">Go 1.16 中已解决的工具安装问题&lt;/h2>
&lt;p>到目前为止，Go 一直使用 &lt;code>go get&lt;/code> 命令，将我们需要的工具安装到 &lt;code>$GOPATH/bin&lt;/code> 目录下，但这种方式存在一个很严重的问题。&lt;code>go get&lt;/code> 由于具备更改 &lt;code>go.mod&lt;/code> 文件的能力，因此我们 &lt;strong>必须要避免执行 &lt;code>go get&lt;/code> 命令时，让它接触到我们的 &lt;code>go.mod&lt;/code> 文件&lt;/strong> ，否则它会将我们安装的工具作为一个依赖。&lt;/p>
&lt;p>目前的解决方案通常是：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ &lt;span class="nb">cd&lt;/span> &lt;span class="k">$(&lt;/span>mktemp -d&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nv">GO111MODULE&lt;/span>&lt;span class="o">=&lt;/span>on go get sigs.k8s.io/kind@v0.9.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>自 1.16 开始，我们可以直接使用下面的方式：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ go install sigs.k8s.io/kind@v0.9.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>非常的简单直观。需要注意的是 &lt;code>go install &amp;lt;package&amp;gt;@&amp;lt;version&amp;gt;&lt;/code> 是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 &lt;code>$GOPATH/bin&lt;/code> 下安装指定版本的工具。&lt;/p>
&lt;p>此外由于 Go 1.16 中 &lt;code>GO111MODULE&lt;/code> 默认是打开的，&lt;code>go install&lt;/code> 不会修改 &lt;code>go.mod&lt;/code> 之类的文件，不会造成任何意外。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;p>&lt;code>@version&lt;/code> 只能安装主软件包。非主程序包不受此格式约束。&lt;/p>
&lt;h3 id="关于不带-version-的-go-install">关于不带 &lt;code>@version&lt;/code> 的 &lt;code>go install&lt;/code>&lt;/h3>
&lt;ul>
&lt;li>在模块外，不带 &lt;code>@version&lt;/code> 是无法安装的，会有如下错误:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ go install -v sigs.k8s.io/kind
go install: version is required when current directory is not in a module
Try &lt;span class="s1">&amp;#39;go install sigs.k8s.io/kind@latest&amp;#39;&lt;/span> to install the latest version
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果你在模块目录中，并且你不带 &lt;code>@version&lt;/code> 执行安装的话，只能安装 &lt;code>go.mod&lt;/code> 中已经包含的版本。并且不能安装未出现在 &lt;code>go.mod&lt;/code> 中的包。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ mkdir -p /go/src/github.com/moelove/iris
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ &lt;span class="nb">cd&lt;/span> /go/src/github.com/moelove/iris
&lt;span class="c1"># 初始化模块&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris go mod init
go: creating new go.mod: module github.com/moelove/iris
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris cat go.mod
module github.com/moelove/iris
go 1.16
&lt;span class="c1"># 不带 @version 无法安装&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris go install -v sigs.k8s.io/kind
no required module provides package sigs.k8s.io/kind&lt;span class="p">;&lt;/span> try &lt;span class="s1">&amp;#39;go get -d sigs.k8s.io/kind&amp;#39;&lt;/span> to add it
&lt;span class="c1"># 用 go get -d 下载&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris go get -d sigs.k8s.io/kind
go get: added sigs.k8s.io/kind v0.9.0
&lt;span class="c1"># 可以看到已经被添加到了模块依赖中&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris cat go.mod
module github.com/moelove/iris
go 1.16
require sigs.k8s.io/kind v0.9.0 // indirect
&lt;span class="c1"># 删除本地的 kind 工具&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris which kind
/go/bin/kind
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris rm /go/bin/kind
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris which kind
&lt;span class="c1"># 不带 @version 进行安装&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris go install -v sigs.k8s.io/kind
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris which kind
/go/bin/kind
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /go/src/github.com/moelove/iris kind version
kind v0.9.0 go1.16beta1 linux/amd64
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="关于-go-get-和-gomod">关于 &lt;code>go get&lt;/code> 和 &lt;code>go.mod&lt;/code>&lt;/h2>
&lt;p>&lt;code>go get&lt;/code> 将二进制安装相关的功能都转移到了 &lt;code>go install&lt;/code>, 仅作为用于编辑 &lt;code>go.mod&lt;/code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 &lt;code>go get&lt;/code> 安装二进制的功能，接下来 &lt;code>go get&lt;/code> 的行为就等同于我们现在执行 &lt;code>go get -d&lt;/code> 命令了，仅需下载源码，并将依赖添加至 &lt;code>go.mod&lt;/code> 即可。&lt;/p>
&lt;h3 id="gomod-如何编辑">&lt;code>go.mod&lt;/code> 如何编辑&lt;/h3>
&lt;p>在 Go 1.16 中，另一个行为变更是 &lt;code>go build&lt;/code> 和 &lt;code>go test&lt;/code> 不会自动编辑 &lt;code>go.mod&lt;/code> 了，基于以上信息，Go 1.16 中将进行如下处理：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过在代码中修改 import 语句，来修改 &lt;code>go.mod&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>go get&lt;/code> 可用于添加新模块；&lt;/li>
&lt;li>&lt;code>go mod tidy&lt;/code> 删除掉无用的模块；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>将未导入的模块写入 &lt;code>go.mod&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>go get &amp;lt;package&amp;gt;[@&amp;lt;version&amp;gt;]&lt;/code>;&lt;/li>
&lt;li>&lt;code>go mod tidy&lt;/code> 也可以；&lt;/li>
&lt;li>手动编辑；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="从-115-升级需要注意什么">从 1.15 升级需要注意什么？&lt;/h2>
&lt;p>由于 &lt;code>go build&lt;/code> 和 &lt;code>go test&lt;/code> 不会自动编辑 &lt;code>go.mod&lt;/code> 了，所以可以将原本的行为通过 &lt;code>go mod tidy&lt;/code> 共同处理。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Go 1.16 中 &lt;code>go install&lt;/code> 和 &lt;code>go get&lt;/code> 方面有些不兼容的变更，但是 1.16 中模块更加简洁，减少了使用时的心智负担，我还是很期待这个版本的。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/golang/" term="golang" label="golang"/></entry><entry><title type="text">K8S 弃用 Docker 了？Docker 不能用了？别逗了！</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/12/03/K8S-%E5%BC%83%E7%94%A8-Docker-%E4%BA%86Docker-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%E5%88%AB%E9%80%97%E4%BA%86/"/><id>https://moelove.info/2020/12/03/K8S-%E5%BC%83%E7%94%A8-Docker-%E4%BA%86Docker-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%E5%88%AB%E9%80%97%E4%BA%86/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-12-03T22:32:59+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。 概览 2013 年 Docker 是在 2013 年……</summary><content type="html">&lt;blockquote>
&lt;p>Docker 大概没想到，2020 年，它在技术圈内的两次成为（舆论的）焦点，竟然都是因为信息差（说是“标题党”也不为过）。&lt;/p>
&lt;/blockquote>
&lt;h2 id="概览">概览&lt;/h2>
&lt;h3 id="2013-年">2013 年&lt;/h3>
&lt;p>Docker 是在 2013 年的 PyCon 上首次正式对外公布的。
它带来了一种先进的软件交付方式，即，通过容器镜像进行软件的交付。
工程师们只需要简单的 &lt;code>docker build&lt;/code> 命令即可制作出自己的镜像，并通过 &lt;code>docker push&lt;/code> 将其发布至 DockerHub 上。
通过简单的 &lt;code>docker run&lt;/code> 命令即可快速的使用指定镜像启动自己的服务。&lt;/p>
&lt;p>通过这种办法，可以有效的解决软件运行时环境差异带来的问题，达到其 &lt;strong>Build once, Run anywhere&lt;/strong> 的目标。&lt;/p>
&lt;p>从此 &lt;strong>Docker 也基本成为了容器的代名词，并成为容器时代的引领者。&lt;/strong>&lt;/p>
&lt;h3 id="2014-年">2014 年&lt;/h3>
&lt;p>2014 年 Google 推出 Kubernetes 用于解决大规模场景下 Docker 容器编排的问题。&lt;/p>
&lt;p>&lt;strong>这是一个逻辑选择，在当时 Docker 是最流行也是唯一的运行时。&lt;/strong> Kubernetes 通过对 Docker 容器运行时的支持，迎来了大量的用户。&lt;/p>
&lt;p>同时，Google 及 Kubernetes 社区与 Docker 也在进行着密切的合作，在其官方博客上有如下内容：&lt;/p>
&lt;blockquote>
&lt;p>We’ll continue to build out the feature set, while collaborating with the Docker community to incorporate the best ideas from Kubernetes into Docker.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://cloudplatform.googleblog.com/2014/06/an-update-on-container-support-on-google-cloud-platform.html" title="An update on container support on Google Cloud Platform">An update on container support on Google Cloud Platform&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Kubernetes is an open source manager for Docker containers, based on Google’s years of experience using containers at Internet scale.
Docker is delivering the full container stack that Kubernetes schedules into, and is looking to move critical capabilities upstream and align the Kubernetes framework with Libswarm.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://cloudplatform.googleblog.com/2014/07/welcome-microsoft-redhat-ibm-docker-and-more-to-the-kubernetes-community.html" title="Welcome Microsoft, RedHat, IBM, Docker and more to the Kubernetes community">Welcome Microsoft, RedHat, IBM, Docker and more to the Kubernetes community&lt;/a>&lt;/p>
&lt;p>并在同一个月的 DockerCon 上发布演讲，介绍了 Kubernetes 并受到了广泛的关注。&lt;/p>
&lt;p>此时 &lt;strong>Docker Inc. 也发布了其容器编排工具， libswarm （也就是后来的 swarmkit） 。&lt;/strong>&lt;/p>
&lt;h3 id="2015-年">2015 年&lt;/h3>
&lt;p>2015 年 OCI （Open Container Initiative）由 Docker 和其他容器行业领导者共同成立（它也是 Linux 基金会旗下项目）&lt;/p>
&lt;p>OCI 主要包含两个规范：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>运行时规范（runtime-spec）：容器运行时，如何运行指定的 文件系统上的包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>容器镜像规范（image-spec）：如何创建一个 OCI 运行时可运行的文件系统上的包&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Docker 把它自己的容器镜像格式和 runtime ( &lt;strong>现在的 runc&lt;/strong> ) 都捐给了 OCI 作为初始工作。&lt;/p>
&lt;h3 id="2016-年">2016 年&lt;/h3>
&lt;p>2016 年 6 月，Docker v1.12 发布，带来了 &lt;strong>Docker 在多主机多容器的编排解决方案，Docker Swarm 。&lt;/strong>
这里也需要注意的是，Docker v1.12 的设计原则：&lt;/p>
&lt;ul>
&lt;li>Simple Yet Powerful （简单而强大）&lt;/li>
&lt;li>Resilient（弹性）&lt;/li>
&lt;li>Secure（安全）&lt;/li>
&lt;li>Optional Features and Backward Compatibility（可选功能及向后兼容）&lt;/li>
&lt;/ul>
&lt;p>所以你可以通过配置自行选择是否需要使用 Docker Swarm ，而无需担心有什么副作用。&lt;/p>
&lt;p>2016 年 12 月， &lt;strong>Kubernetes 发布 CRI （Container Runtime Interface）&lt;/strong> ，这当中一部分原因是由于 Kubernetes 尝试支持另一个由 CoreOS 领导的容器运行时项目 rkt ，但是需要写很多兼容的代码之类的，为了避免后续兼容其他运行时带来的维护工作，所以发布了统一的 CRI 接口，凡是支持 CRI 的运行时，皆可直接作为 Kubernetes 的底层运行时；&lt;/p>
&lt;p>当然， &lt;strong>Kubernetes 也是在 2016 年逐步取得那场容器编排战争的胜利的。&lt;/strong>&lt;/p>
&lt;h3 id="2017-年">2017 年&lt;/h3>
&lt;p>2017 年， Docker 将自身从 v1.11 起开始引入的&lt;a href="https://github.com/containerd/containerd/" title="containerd">容器运行时 containerd&lt;/a> 捐给了 &lt;a href="https://www.cncf.io/" title="CNCF website">CNCF&lt;/a>&lt;/p>
&lt;p>2017 年，Docker 的网络组件 libnetwork 增加了 CNI 的支持；
同时通过&lt;a href="https://github.com/kubernetes/kubernetes/pull/46580" title="在 K8S 中增加 IPvs 的负载均衡">使用 Docker 为 Docker Swarm 提供的 ipvs 相关的代码&lt;/a>，也在 Kubernetes 中实现了基于 IPvs 的 service 负载均衡。不过在 v1.18 中开始移除了相关的依赖。&lt;/p>
&lt;p>同年 11 月，&lt;a href="https://kubernetes.io/blog/2017/11/containerd-container-runtime-options-kubernetes/" title="Containerd Brings More Container Runtime Options for Kubernetes">Kubernetes 中新增了 containerd 的支持&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://lh5.googleusercontent.com/sfkhKO3jiLZ9_TtPpxTsKxkbe1KHg1nrfqkbJYrjN2DbNQE_y31NJVSyDIXe0oQjSwVcQ4gFCyr1MZ9_V4GZuuiHwuU3Pq6ldpRhcRiiuTJaRVuezPK9KFLKovP8mQ6sXTYF_eru" alt="cri-containerd">&lt;/p>
&lt;h3 id="2018-年">2018 年&lt;/h3>
&lt;p>2018 年， &lt;a href="https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/" title="Kubernetes Containerd Integration Goes GA">Kubernetes 的 containerd 集成，正式 GA&lt;/a>&lt;/p>
&lt;p>之前版本的架构：&lt;/p>
&lt;p>&lt;img src="https://d33wubrfki0l68.cloudfront.net/6b4290afef76cad8a084292cd1b5e468e31c9bb3/c26ce/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png" alt="containerd 1.0 cri-containerd">&lt;/p>
&lt;p>新的架构：&lt;/p>
&lt;p>&lt;img src="https://d33wubrfki0l68.cloudfront.net/f8dfc688157620f656f96bfd8872deccfbd409e7/51b10/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/containerd.png" alt="containerd 1.1 cri-containerd">&lt;/p>
&lt;h3 id="2019-年">2019 年&lt;/h3>
&lt;p>2019 年，上文中提到的另一个容器运行时项目 rkt 被 CNCF 归档，终止使命了；
2019 年 Mirantis 收购 Docker 的企业服务。&lt;/p>
&lt;h3 id="2020-年">2020 年&lt;/h3>
&lt;p>时间回到今年，Docker 主要被误会的两件事：&lt;/p>
&lt;ul>
&lt;li>Docker Inc. 修改 DockerHub 的定价和 TOS 。国内争论较多的主要是关于合规性的问题（但是被标题党带歪了，免不了恐慌）；&lt;/li>
&lt;li>Kubernetes 宣布开始进入废弃 dockershim 支持的倒计时，被人误以为 Docker 不能再用了；&lt;/li>
&lt;/ul>
&lt;h2 id="说明">说明&lt;/h2>
&lt;p>&lt;strong>关于 DockerHub 修改定价和 TOS 的事情，这里就不再多说了，毕竟 DockerHub 目前大家仍然用的很欢乐，远不像当初那些标题党宣称的那样。&lt;/strong>&lt;/p>
&lt;p>重点来说一下第二件事情吧。&lt;/p>
&lt;p>Kubernetes 当初选择 Docker 作为其容器运行时，本身就是因为当时它没有其他的选择，并且选择 Docker 可为它带来众多的用户。
所以，开始时，它便提供了内置的对 Docker 运行时的支持。&lt;/p>
&lt;p>而 Docker 其实创建之初，并没有考虑到“编排”的这个功能，当然也没有考虑到 Kubernetes 的存在（因为当时还没有）。&lt;/p>
&lt;p>&lt;strong>dockershim&lt;/strong> 一直都是 Kubernetes 社区为了能让 Docker 成为其支持的容器运行时，所维护的一个兼容程序。 &lt;strong>本次所谓的废弃，也仅仅是 Kubernetes 要放弃对现在 Kubernetes 代码仓库中的 dockershim 的维护支持。&lt;/strong> 以便其可以像开始时计划的那样，仅负责维护其 CRI ，任何兼容 CRI 的运行时，皆可作为 Kubernetes 的 runtime 。&lt;/p>
&lt;p>在 Kubernetes 提出 CRI 时，有人建议在 Docker 中实现它。但是这种方式也会带来一个问题，即使 Docker 实现了 CRI，但它仍然不是一个单纯的容器运行时，它本身包含了大量的非 “纯底层容器运行时” 所具备的功能。&lt;/p>
&lt;p>所以后来 &lt;strong>自 Docker 中分离出来的 containerd 项目，作为一个底层容器运行时出现了，它是 Kubernetes 容器运行时更好的选择。&lt;/strong>&lt;/p>
&lt;p>Docker 使用 containerd 作为其底层容器运行时以及众多的云厂商及公司在生产环境中使用 containerd 作为其 Kubernetes 的运行时，这也从侧面验证了 containerd 的稳定性。&lt;/p>
&lt;p>现在 Kubernetes 和 Docker 社区都相信 containerd 已经足够成熟可直接作为 Kubernetes 的运行时了，而无需再通过 dockershim 使用 Docker 作为 Kubernetes 的运行时了。这也标志着 Docker 为 Kubernetes 提供一个现代化的容器运行时的承诺最终兑现了。&lt;/p>
&lt;p>&lt;strong>而本次事件中，重点的 dockershim 之后的方向如何呢？Kubernetes 代码仓库中的 dockershim 将会在未来版本中移除，但是 Mirantis 公司已经和 Docker 达成合作，在未来会共同维护一份 dockershim 组件，以便支持 Docker 作为 Kubernetes 的容器运行时。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Otherwise, if you’re using the open source Docker Engine, the dockershim project will be available as an open source component, and you will be able to continue to use it with Kubernetes; it will just require a small configuration change, which we will document.&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-2/" title="Mirantis to take over support of Kubernetes dockershim">Mirantis 公司宣布将维护 dockershim&lt;/a>&lt;/p>
&lt;h2 id="qa">Q&amp;amp;A&lt;/h2>
&lt;p>Q：本次 Kubernetes 放弃对 dockershim 的维护，到底有什么影响？
A：对于普通用户而言，没有任何影响；对于在 Kubernetes 之上进行开发的工程师，没什么太大影响；对于集群管理员，需要考虑是否要在未来版本中，将容器运行时，升级为支持 CRI 的运行时，比如 containerd 。
当然，如果你并不想切换容器运行时，那也没关系，Mirantis 公司未来会和 Docker 共同维护 dockershim , 并作为一个开源组件提供。&lt;/p>
&lt;p>Q: Docker 不能用了吗？
A：Docker 仍然是本地开发，或者单机部署最佳的容器工具，它提供了更为人性化的用户体验，并且也有丰富的特性。目前 Docker 已经和 AWS 达成合作，可直接通过 Docker CLI 与 AWS 集成。另外，Docker 也仍然可以作为 Kubernetes 的容器运行时，并没有立即中止对其支持。&lt;/p>
&lt;p>Q：听说 Podman 可以借机上位了？
A：想太多。Podman 也并不兼容 CRI ，并且它也不具备作为 Kubernetes 容器运行时的条件。我个人也偶尔有在用 Podman， 并且我们在 KIND 项目中也提供了对 Podman 的支持， 但实话讲，它也就是只是一个 CLI 工具，某些情况下会有些作用，比如如果你的 Kubernetes 容器运行时使用 cri-o 的情况下，可以用来本地做下调试。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文主要介绍了 Docker 和 Kubernetes 的发展历程，也解释了本次 Kubernetes 仅仅是放弃其对 dockershim 组件的支持。未来更推荐的 Kubernetes 运行时是 兼容 CRI 的 containerd 之类的底层运行时。&lt;/p>
&lt;p>Mirantis 公司将会和 Docker 共同维护 dockershim 并作为开源组件提供。&lt;/p>
&lt;p>Docker 仍然是一款最佳的本地开发测试和部署的工具。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/></entry><entry><title type="text">K8S 生态周报| Cilium v1.9.0 带来更好的性能</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/11/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-v1.9.0-%E5%B8%A6%E6%9D%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/"/><id>https://moelove.info/2020/11/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Cilium-v1.9.0-%E5%B8%A6%E6%9D%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-11-15T18:32:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Cilium v1.9.0 正式发布 Cilium 本周……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="cilium-v190-正式发布">Cilium v1.9.0 正式发布&lt;/h2>
&lt;p>Cilium 本周发布了 v1.9.0 版本，这个版本带来了众多值得关注的特性变更，我们一起来看看吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/12716">#12716&lt;/a> 增加了 deny policy ，你可以添加类似下面这样的规则：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium.io/v2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumNetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;guestbook-web&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">endpointSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s-app.guestbook&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">web&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ingress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">fromEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s-app.guestbook&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">redis&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ingressDeny&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">fromEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s-app.guestbook&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">redis&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/13131">#13131&lt;/a> Cilium 的 eBPF kube-proxy 部分为其在 NodePort/LoadBalancer/externalIP 等部分的后端选择逻辑中，增加了基于 &lt;a href="https://research.google/pubs/pub44824/" title="Maglev 算法">Maglev 算法&lt;/a>的一致性哈希，通过此特性，可以减少后端变更对实际业务请求的影响。此特性可以通过设置 &lt;code>global.nodePort.algorithm=maglev&lt;/code> 来开启。关于 Maglev 算法的内容，此处暂时略过，建议对此内容感兴趣的朋友看看；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/12611">#12611&lt;/a> 添加对 K8S v1.19 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/12409">#12409&lt;/a> Cilium operator HA 模式；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/13330">#13330&lt;/a> 借助 &lt;code>redirect_neigh&lt;/code> 优化主机网络数据路径；&lt;/li>
&lt;li>&lt;a href="https://github.com/cilium/cilium/pull/12831">#12831&lt;/a> 引入 eBPF 本机重定向功能；&lt;/li>
&lt;/ul>
&lt;p>此版本需要格外关注，更多关于此版本的变更，请参考其 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.9.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-v15-正式发布">Rook v1.5 正式发布&lt;/h2>
&lt;p>本周 Rook 发布了 v1.5 的版本，此版本中也包含了很多新的更新，值得关注：&lt;/p>
&lt;p>Rook 此版本仅支持 Kubernetes v1.11 及以上版本，如果集群版本较低，请注意。&lt;/p>
&lt;p>破坏性变更：&lt;/p>
&lt;ul>
&lt;li>CRD 配置从 &lt;code>common.yaml&lt;/code> 移动到 &lt;code>crds.yaml&lt;/code> 以便提供更高的灵活性；&lt;/li>
&lt;li>CRD 使用的 API 版本从 &lt;code>apiextensions.k8s.io/v1beta1&lt;/code> 更换为 &lt;code>apiextensions.k8s.io/v1&lt;/code>；&lt;/li>
&lt;li>Rook 将禁止偶数 Ceph mons，必须将其设置为奇数个；&lt;/li>
&lt;/ul>
&lt;p>特性变更：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Ceph Cluster&lt;/p>
&lt;ul>
&lt;li>集群容量将更新到 CephCluster CR 状态中；&lt;/li>
&lt;li>通过 Vault 提供加密支持；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Ceph CSI&lt;/p>
&lt;ul>
&lt;li>支持为 DaemonSet 和 Deployment 自定义标签；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Ceph Filesystem&lt;/p>
&lt;ul>
&lt;li>&lt;code>preserveFilesystemOnDelete&lt;/code> 选项替代 &lt;code>preservePoolsOnDelete&lt;/code> 以避免在卸载时，删除文件系统；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.5.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="jaeger-v1210-发布">Jaeger v1.21.0 发布&lt;/h2>
&lt;p>Jaeger 本周也发布了一个新版本，并且近期发布都比较频繁。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2545">#2545&lt;/a> 在分发的时，为 Jaeger 后端增加了 debug Docker 镜像；&lt;/li>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2547">#2547&lt;/a>Jaeger UI 中增加了版本信息；&lt;/li>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2580">#2580&lt;/a> OTLP-proto encoding 支持 Kafka supported in the OTEL Ingester ;&lt;/li>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2496">#2496&lt;/a> 配置参数可以在运行时注入，通过 admin 的 &lt;code>/debug/vars&lt;/code> 接口；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/jaegertracing/jaeger/releases/tag/v1.21.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94115">#94115&lt;/a> 这是一个相对较小的修复，可以在执行 exec 探针期间正确检查超时错误。但是如果想要使用的话，建议你仔细检查集群中对 exec 探针的使用，以避免引起一些非预期的结果。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.4 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/11/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.4-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/11/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.4-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-11-07T20:30:49+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.4 正式发布 Helm v3.4 是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v34-正式发布">Helm v3.4 正式发布&lt;/h2>
&lt;p>Helm v3.4 是一个特性更新版本，我们来看看此版本有哪些值得关注的变化：&lt;/p>
&lt;ul>
&lt;li>11 月 13 日， Helm stable 和 incubator 仓库将到达终结日，这些 Chart 的归档将会存储到另外的位置，如果你使用这两个仓库的话，Helm 将会先检查原先的位置，然后进行重定向；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8543">#8543&lt;/a> &lt;code>helm lint&lt;/code> 将检查名称长度的错误；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8529">#8529&lt;/a> &lt;code>helm status&lt;/code> 新增 &lt;code>--show-desc&lt;/code> 参数，可用来展示描述；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8874">#8874&lt;/a> 让 &lt;code>helm create&lt;/code> 创建的 chart 缩进保持一致；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/7970">#7970&lt;/a> &lt;code>helm lint&lt;/code> 现在也可以检查依赖了；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8438">#8438&lt;/a> &lt;code>helm show values&lt;/code> 增加 jsonpath 输出的支持;&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8613">#8613&lt;/a> 优化了 service ready 的判断逻辑，改成了判断是否有 ClusterIP；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变化，请查看其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.4.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="coredns-v18-正式发布">CoreDNS v1.8 正式发布&lt;/h2>
&lt;p>CoreDNS 今日发布了 v1.8 版本，整体而言变化不是太大，且也做了向后兼容，可能会受影响的是使用 外部 plugin 或者域外流量的用户。&lt;/p>
&lt;p>因为CoreDNS 依赖的 Caddy 已经在开发 v2 版本了， 且变化蛮大的。为了包装 CoreDNS 的独立 &amp;amp; 稳定，所以 CoreDNS 团队将其 fork 了一个，成为了新的 &lt;a href="https://github.com/coredns/caddy">https://github.com/coredns/caddy&lt;/a> 。带来的变化是所有的依赖需要变更下。&lt;/p>
&lt;p>最后 &lt;code>transfer&lt;/code> 插件已经成为头等公民，如果在使用此插件的话，升级后需要按如下规则修改配置：&lt;/p>
&lt;p>由&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">example.org {&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">file example.org.signed {&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">transfer to *&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">transfer to 10.240.1.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="l">example.org {&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">file example.org.signed&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">transfer {&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">to * 10.240.1.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>}&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>}&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/4182">#4182&lt;/a> 修复了使用 DoH 时候 http/2 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/4184">#4184&lt;/a> 修复了没有 plugin 时候，可能崩溃的问题。使用 CoreDNS 的时候，确实默认都会给它配置插件..很少出现没有配置插件的情况；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/4167">#4167&lt;/a> 在 shutdown 的时候，不再返回 200 了；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变化，请查看其 &lt;a href="https://coredns.io/2020/10/22/coredns-1.8.0-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="prometheus-operator-v043-发布">prometheus-operator v0.43 发布&lt;/h2>
&lt;p>最近 prometheus-operator 发布了 v0.43 版本，此版本中新增了 &lt;code>AlertmanagerConfig&lt;/code> CRD &lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3451">#3451&lt;/a>， 在此之前配置是直接用 configmap 的，通过此次变更，允许将 Alertmanager 的配置分割成不同的对象。&lt;/p>
&lt;p>不过当前的 CRD 仅支持 PagerDuty, OpsGenie 和 webhook receiver 。 此处我就不得不提一句 &lt;strong>PagerDuty 和 OpsGenie 真的棒，尤其是 OpsGenie&lt;/strong> 。 另外，当前的 API 版本是 &lt;code>v1alpha1&lt;/code> 意味着之后也会逐步增加新功能/对现有功能调整。 期待后续版本。&lt;/p>
&lt;p>此外还有一些比较值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3457">#3457&lt;/a> 为 Prometheus 使用了单独的 reloader sidecar 。&lt;code>--config-reloader-image&lt;/code> 参数后续版本将会移除，请确保至少在 v0.43 版本以上使用 &lt;code>--prometheus-config-reloader&lt;/code> 参数，否则 Prometheus 将启动失败；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3598">#3598&lt;/a> 为 Prometheus, Alertmanager, 和 ThanosRuler CRD 增加 Pod 拓扑约束的功能；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3525">#3525&lt;/a> 允许自定义 Prometheus web 的 title , 我个人是觉得没啥用了；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3617">#3617&lt;/a> 添加 &lt;code>prometheus_operator_prometheus_enforced_sample_limit&lt;/code> metrics;&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3502">#3502&lt;/a> 在 Prometheus replay WAL 的时候，移除 liveness probes 以免 Prometheus 容器被杀掉；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3526">#3526&lt;/a> 修正了在更新 service 时候遇到的 &lt;code>spec.ipFamily: Invalid value: &amp;quot;null&amp;quot;: field is immutable&lt;/code> 错误；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus-operator/prometheus-operator/pull/3641">#3641&lt;/a> 也修复了 Alertmanager controller 的同步逻辑，为此还专门发布了 v0.43.1 版本；&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/95985/">#95985&lt;/a> 随着 seccomp 转为 GA， 现在默认的 seccomp profile annotation 从 &lt;code>docker/default&lt;/code> 转换为了 &lt;code>runtime/default&lt;/code>。所以也要默认允许 &lt;code>runtime/default&lt;/code> 如果用户设置的是 &lt;code>docker/default&lt;/code> ;&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/95856">#95856&lt;/a> APIserver 自 v1.10 开始废弃的 insecure port 终于被移除，主要影响 &lt;code>--address&lt;/code>, &lt;code>--insecure-bind-address&lt;/code>, &lt;code>--port&lt;/code>, 和 &lt;code>--insecure-port&lt;/code> 这几个参数；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker V2 GitHub Action 宣布 GA</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-V2-GitHub-Action-%E5%AE%A3%E5%B8%83-GA/"/><id>https://moelove.info/2020/10/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-V2-GitHub-Action-%E5%AE%A3%E5%B8%83-GA/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-10-31T22:21:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker V2 GitHub Action 已 GA Docker Inc. 近……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v2-github-action-已-ga">Docker V2 GitHub Action 已 GA&lt;/h2>
&lt;p>Docker Inc. 近期在其&lt;a href="https://www.docker.com/blog/docker-v2-github-action-is-now-ga">官方博客宣布&lt;/a> Docker V2 GitHub Action 已经 GA 。&lt;/p>
&lt;p>我在之前的文章&lt;a href="https://zhuanlan.zhihu.com/p/115367323">《K8S 生态周报| 首个 Docker 官方 Action 发布》&lt;/a> 中曾详细介绍过 Docker 提供的V1 GitHub Action 的用法。&lt;/p>
&lt;p>此次，V2 版本带来的最大变化是由原先单一的 GitHub Action 转换成了现在的多个模块化，且包含复杂功能的独立 Action。这里我也介绍下其中重点的内容：&lt;/p>
&lt;h3 id="独立的-login-action">独立的 Login Action&lt;/h3>
&lt;p>本次发布了独立的 Login Action ，之前版本的 Action 是将登录操作同时封装在整个 Action 流程中的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Login to DockerHub&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker/login-action@v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">username&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.DOCKER_USERNAME }} &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.DOCKER_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，在 Action 执行完成后，会有个 Post Login 的 job ，自动将 Login 动作时创建的用户凭证进行销毁。&lt;/p>
&lt;h3 id="集成-docker-buildx">集成 Docker Buildx&lt;/h3>
&lt;p>通过此 Action 可以将 builder 设置为 Buildkit，以便提供更灵活和丰富的特性。关于 Buildx 之前的周报中都介绍过了，此处略过。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Docker Buildx&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker/setup-buildx-action@v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="多平台构建">多平台构建&lt;/h3>
&lt;p>可通过设置 QEMU 和 Buildx 来实现多平台的构建，比如通过以下配置可同时构建 &lt;code>linux/amd64&lt;/code> 和 &lt;code>linux/s390x&lt;/code> 平台的镜像，并将其推送至 DockerHub 的指定镜像仓库中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup QEMU&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker/setup-qemu-action@v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build and push&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker_build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker/build-push-action@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">context&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./Dockerfile&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">platforms&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">linux/amd64,linux/s390x&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tags&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.DOCKER_USERNAME }}/redis:6.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多关于此次变更的示例，请参考&lt;a href="https://github.com/tao12345666333/docker-github-action" title="docker-github-action">我的示例代码仓库&lt;/a>&lt;/p>
&lt;h2 id="dockerhub-正式启用限速">DockerHub 正式启用限速&lt;/h2>
&lt;p>在 8 月份的文章 &lt;a href="https://zhuanlan.zhihu.com/p/186265631">《K8S 生态周报| DockerHub 修改了定价和 TOS》&lt;/a> 一文中，我曾介绍过 Docker Inc. 修改了 DockerHub 的定价，以及在 11 月份将启用限速功能。&lt;/p>
&lt;p>&lt;strong>限速策略是对于匿名用户限制 100 次/6小时，而对于登录的普通用户则限制为 200次/6小时。&lt;/strong>&lt;/p>
&lt;p>这里我来详细介绍下这个限速具体的 &lt;strong>实施方式&lt;/strong> ：&lt;/p>
&lt;p>首先，它是 &lt;strong>基于对 DockerHub 上镜像 manifest 的请求数量&lt;/strong> ；其次它区分的账户类型是根据拉取镜像的帐号来的，而不是根据镜像所有者进行限制；&lt;/p>
&lt;p>最后， &lt;strong>对于匿名用户/未登录用户，则是根据其单个 IP 进行限制的。&lt;/strong>&lt;/p>
&lt;p>在了解了上述的基本概念后，我们再来看看实际在使用时，是如何消耗配额的。其 &lt;strong>基本流程如&lt;/strong> 下：&lt;/p>
&lt;p>在执行 &lt;code>docker pull &amp;lt;image&amp;gt;&lt;/code> 的时候， 首先会向 registry 请求该镜像的 manifest;&lt;/p>
&lt;p>如果该镜像是支持多架构的，那么会在其中匹配对应需要拉取的架构，并选择其对应层（layer） 的 blob 进行下载。&lt;/p>
&lt;p>前面提到本次限制是基于对镜像的 manifest 请求做的。所以，在 &lt;strong>拉取镜像的时候，无论镜像是只包含 一层还是多层，实际都是算一次。&lt;/strong> 这对用户体验来说是非常好的。这也是 Docker Inc. 在充分听取社区用户反馈后做出的调整。&lt;/p>
&lt;p>我们看看如何知道自己还有多少配额呢？&lt;/p>
&lt;p>可以直接使用 curl 或者其他方式构造任意构造一个对 DockerHub 上镜像的 manifest 的请求，在响应头中，会包含两个自定义的头：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RateLimit-Limit&lt;/code> : 表示配额是多少，比如 匿名用户是 100 ， 已经登录的普通用户是 200；&lt;/li>
&lt;li>&lt;code>RateLimit-Remaining&lt;/code>：表示当前剩余的额度；&lt;/li>
&lt;/ul>
&lt;p>此外，我也在之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/256359308">《突破 DockerHub 限制，全镜像加速服务》&lt;/a> 中，介绍了企业/个人如何突破 DockerHub 限制，更好的使用 DockerHub 的镜像服务。&lt;/p>
&lt;h2 id="kubernetes-v1200-beta0-发布">Kubernetes v1.20.0-beta.0 发布&lt;/h2>
&lt;p>此版本中最主要的变化在于双栈 service 相关的变化。以及一些其他的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91452">#91452&lt;/a> 添加了 Windows 1809, 1903, 1909, 2004 的 pause 3.4 版本的镜像；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/95505">#95505&lt;/a> Windows hyper-v container featuregate 在 1.20 中废弃，将在 1.21 中删除；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参阅其 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#downloads-for-v1200-beta0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="thanos-v0160-发布">Thanos v0.16.0 发布&lt;/h2>
&lt;p>Thanos v0.16.0 于本周正式发布，我们来看看此版本中最主要的变更：&lt;/p>
&lt;ul>
&lt;li>Thanos 新的组件 &lt;a href="https://thanos.io/tip/components/query-frontend.md/">Query Frontend&lt;/a> 增加了更多选项和支持共享缓存，当前是 Memcached；&lt;/li>
&lt;li>为 Thanos UI 增加了 Debug 模式；&lt;/li>
&lt;li>为 Thanos 所有组件改善其 Debug， 增加了 off-CPU profile；&lt;/li>
&lt;li>显著改善了用于获取指标的 Sidecar 的延迟和 CPU 使用率；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参与其 &lt;a href="https://github.com/thanos-io/thanos/releases/tag/v0.16.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91824">#91824&lt;/a> 双栈 service 支持。这是一个 Break Change，原先的一个 &lt;code>ipFamily&lt;/code> 修改成了三个字段：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ipFamilyPolicy&lt;/code> 的可选项为 &lt;code>SingleStack&lt;/code> &lt;code>PreferDualStack&lt;/code> 和 &lt;code>RequireDualStack&lt;/code> ；&lt;/li>
&lt;li>&lt;code>ipFamilies&lt;/code>&lt;/li>
&lt;li>&lt;code>clusterIPs&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当然，多数用户其实也无需担心，默认情况下 Kubernetes 会自动处理相关的配置。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v20.10.0-beta1 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/10/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.0-beta1-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/10/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v20.10.0-beta1-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-10-24T22:38:38+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker 发布 v20.10.0-beta1 版本 Docker 在本……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-发布-v20100-beta1-版本">Docker 发布 v20.10.0-beta1 版本&lt;/h2>
&lt;p>Docker 在本周发布了 v20.10.0-beta1 版本，作为 v20.10 版本的首个测试版本，目前可以通过 Docker 官方的 test channel 进行下载，或者直接通过 &lt;code>docker:20.10.0-beta1&lt;/code> 和 &lt;code>docker:20.10.0-beta1-dind&lt;/code> 等镜像进行体验。 &lt;strong>如有遇到问题，欢迎大家反馈~&lt;/strong>&lt;/p>
&lt;p>这个版本算是姗姗来迟吧，按照原定发布路线的话，v19.03 版本后的下个大版本便是 v20.03 了。不过目前 v19.03 社区也还在积极进行维护，延长了其维护周期，并计划发布 v19.03.14 版本。&lt;/p>
&lt;p>Docker v20.10 版本，变化非常的大。提供了 CGroup v2 的支持，增强了 rootless 模式的支持，双栈日志，更灵活的内置 DNS 等，我在这个版本中也花费了很多时间。&lt;/p>
&lt;p>详细的变更，我会在 v20.10 正式发布时再进行介绍。欢迎大家进行测试和反馈，目前已经收到了一些反馈的建议。我们会尽快修正并发布下个版本。&lt;/p>
&lt;h2 id="docker-hub-镜像保留策略将延期">Docker Hub 镜像保留策略将延期&lt;/h2>
&lt;p>两个月前，我在 &lt;a href="https://zhuanlan.zhihu.com/p/186265631">K8S 生态周报&lt;/a> 中曾介绍过 DockerHub 修改了定价的内容，其中包括了一项： &lt;strong>镜像保留策略&lt;/strong> 的变更， &lt;strong>对于非活跃镜像，默认只保留 6 个月&lt;/strong> 。这项更新原定是在 11 月 1 日正式实施。&lt;/p>
&lt;p>但这项计划公布后，收到了很多来自社区的反馈。本周，Docker Inc. 宣布将对上述提到的镜像保留策略的实施进行延期执行，目前计划是先延期至 2021 年年中。在 2021 年年初会公布新的计划时间表。&lt;/p>
&lt;p>同时，Docker Inc. 将推出实验性的 Hub CLI 管理工具，Hub Dashboard 和新的 API 等，专注于更好的为开发者提供服务。&lt;/p>
&lt;p>另外，也再次提醒，自 11 月 1 日起，DockerHub 将限制下载频率。对于匿名用户 100 次/6小时；对于已登录用户 200次/6小时。建议参考我的另一篇文章 &lt;a href="https://zhuanlan.zhihu.com/p/256359308">《突破 DockerHub 限制，全镜像加速服务》&lt;/a> 来避免受此策略的影响。&lt;/p>
&lt;h2 id="prometheus-v2220-正式发布">Prometheus v2.22.0 正式发布&lt;/h2>
&lt;p>在 Prometheus v2.22 中最大的变化是移除了实验性的 gRPC API v2 &lt;a href="https://github.com/prometheus/prometheus/pull/7935">#7935&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/6957">#6957&lt;/a> 在 UI 中，target 页面增加一键收起全部列表的按钮, 这个功能很实用；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/7936">#7936&lt;/a> 在 Alert 页面，增加了筛选；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/8004">#8004&lt;/a> 优雅的处理未知类型的 WAL 记录；&lt;/li>
&lt;/ul>
&lt;p>更多关于次版本的信息，请参考其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.22.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="trivy-v0120-发布">Trivy v0.12.0 发布&lt;/h2>
&lt;p>Trivy 发布了 v0.12.0 版本，带来了一些更新：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy/pull/641">#641&lt;/a> 为 fs 和 repo 增加了 &lt;code>--skip-update&lt;/code> 选项；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy/pull/624">#624&lt;/a> 增加了 &lt;code>--skip-files&lt;/code> 选项；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy/pull/644">#644&lt;/a> 为 Trivy server 增加了健康检查，例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">$ curl http://127.0.0.1:4954/healthz
ok
$ curl http://127.0.0.1:4954/healthz -v
* Trying 127.0.0.1...
* TCP_NODELAY &lt;span class="nb">set&lt;/span>
* Connected to 127.0.0.1 &lt;span class="o">(&lt;/span>127.0.0.1&lt;span class="o">)&lt;/span> port &lt;span class="m">4954&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="c1">#0)&lt;/span>
&amp;gt; GET /healthz HTTP/1.1
&amp;gt; Host: 127.0.0.1:4954
&amp;gt; User-Agent: curl/7.54.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 &lt;span class="m">200&lt;/span> OK
&amp;lt; Date: Sun, &lt;span class="m">20&lt;/span> Sep &lt;span class="m">2020&lt;/span> 03:11:57 GMT
&amp;lt; Content-Length: &lt;span class="m">2&lt;/span>
&amp;lt; Content-Type: text/plain&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>utf-8
&amp;lt;
* Connection &lt;span class="c1">#0 to host 127.0.0.1 left intact&lt;/span>
ok
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/95566">#95566&lt;/a> SCTP 支持现在达到 GA 。但需要注意的是，并非所有的云平台或者网络组件都支持 SCTP 流量。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm 五周岁啦！</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/10/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E4%BA%94%E5%91%A8%E5%B2%81%E5%95%A6/"/><id>https://moelove.info/2020/10/18/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-%E4%BA%94%E5%91%A8%E5%B2%81%E5%95%A6/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-10-18T18:22:19+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm 五周岁啦！ Helm 于 2015……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-五周岁啦">Helm 五周岁啦！&lt;/h2>
&lt;p>Helm 于 2015 年，在 Deis 的黑客松中创建（该公司已被微软收购）。在同年的首届 KubeCon 上正式推出现在被称之为 Helm classic 的版本。&lt;/p>
&lt;p>2016 年 Helm 团队和 Google，Skippbox，以及 Bitnami 一起创建了 Helm 2 。自此 Helm Chart 工作流就基本定义好了，也就是我们现在在用的样子。&lt;/p>
&lt;p>2018 年 6 月，Helm 成为了 CNCF 的孵化项目。在那之后，Helm Hub 也开始托管 Helm Chart 。&lt;/p>
&lt;p>最近 Helm 团队做出了一个重大的决定：&lt;/p>
&lt;h3 id="hub-迁移到了-artifact-hub">Hub 迁移到了 Artifact Hub&lt;/h3>
&lt;p>&lt;a href="https://hub.helm.sh">Helm Hub&lt;/a> 正式迁移到了 &lt;a href="https://artifacthub.io">Artifact Hub&lt;/a> 。&lt;/p>
&lt;p>Helm Hub 是构建在 Monocular 项目之上的，根据 Helm 团队的说法，这个项目设计之初仅为处理有限的 Helm repo 。 但随着现在 Helm 应用的越来越广泛，Monocular 项目的局限性就暴露了出来。&lt;/p>
&lt;p>现在 Helm 团队决定将 Helm Hub 正式迁移到 Artifact Hub 。这个项目可以很好的处理现在的增长问题，并且它不仅可以处理 Helm Chart 也可以处理更多 CNCF 生态中的其他内容。比如 Artifact Hub 中也包含了很多 Falco 规则，可以很方便的一键应用到自己的环境中。&lt;/p>
&lt;p>在我使用 GitHub 帐号登录 Artifact Hub 时，总是遇到错误，不过我还没有看具体原因~ 另外，Artifact Hub 项目缺少一些文档之类的信息，但也在逐步完善中。&lt;/p>
&lt;p>另外， Artifact Hub 也可能会支持 OCI 兼容的 Helm repo，期待中。&lt;/p>
&lt;p>此外，2020 年 4 月 Helm 正式从 CNCF 毕业，现在 Helm 有超过 1500 家公司在使用 Helm 或为 Helm 贡献代码，Helm 组织也管理者大量的 GitHub 仓库。&lt;/p>
&lt;p>但在存储 Chart 方面，之前 Helm stable chart 一直托管在 Google 的对象存储中。&lt;/p>
&lt;p>在 Helm 五周岁之际，Helm 团队也宣布了一个重要的决定：&lt;/p>
&lt;p>&lt;strong>Helm stable 和 incubator 的 Chart 仓库，将直接托管在 GitHub 上&lt;/strong>&lt;/p>
&lt;p>并发布了 &lt;a href="https://github.com/marketplace/actions/helm-chart-releaser" title="Helm Chart Releaser">Helm Chart Releaser&lt;/a> GitHub Action 工具。&lt;/p>
&lt;p>感兴趣的朋友欢迎直接在 GitHub 上体验~&lt;/p>
&lt;h2 id="rook-正式从-cncf-毕业">Rook 正式从 CNCF 毕业&lt;/h2>
&lt;p>Rook 为 Kubernetes 提供了云原生的存储解决方案。包括平台，框架，以及对多种存储解决方案的支持，例如： Ceph，minio 等。&lt;/p>
&lt;p>它从 2018 年开始被接受成为 CNCF 项目，是第 13 个正式从 CNCF 毕业的项目，也是第一个提供了 block , file 和对象存储的存储类项目。&lt;/p>
&lt;p>我也在使用 Rook 来管理 Kubernetes 中的 Ceph 集群，用来提供块存储和对象存储。整体而言是比较方便的，只是版本升级之类的，需要注意下，不需要追的太紧。我在「K8S 生态周报」中，也在持续跟进 Rook 的发展，及每个版本中包含的问题和解决方案之类的，有兴趣的朋友可以看看历史文章。&lt;/p>
&lt;p>最后，再次恭喜 Rook 正式毕业！&lt;/p>
&lt;h2 id="rook-v146-发布">Rook v1.4.6 发布&lt;/h2>
&lt;p>此次版本中包含了一些比较重要的更新，我们一起来看看吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6283">#6283&lt;/a> 提供了对 IPv6 单栈的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6437">#6437&lt;/a> 对于规模较小的集群，比如但节点的测试集群，则仅启动一个 CSI provisioner， 之前默认是 2；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6184">#6184&lt;/a> 在 LV-backed PVC 上让 OSD 使用 RAW 模式，而非 LVM 模式；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.4.6">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="containerd-v1214-发布">containerd v1.2.14 发布&lt;/h2>
&lt;p>如果还有在使用 containerd v1.2.x 版本的小伙伴请注意。 此版本主要是为了修复 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2020-15157">CVE-2020-15157&lt;/a> 。 &lt;strong>该漏洞仅影响 containerd v1.3 之前的版本&lt;/strong>&lt;/p>
&lt;p>相应的，在 Docker v19.03.13 之前，默认使用的均是 containerd v1.2.x 版本。所以如果为了避免受此安全漏洞的影响，也需要对应的升级 Docker 所使用的 containerd 版本，或者直接将 Docker 升级到 v19.03.13 版本。&lt;/p>
&lt;p>此漏洞的具体影响是：containerd v1.2.14 之前的版本中，在请求容器镜像的 manifest 时，如果服务端返回 401 响应头，则它会尝试提供登录凭据进行认证。&lt;/p>
&lt;p>这种情况下，如果对应的服务端地址是由攻击者控制的，则攻击者就可以获取用户的登录凭证。&lt;/p>
&lt;p>解决办法是升级 containerd v1.2.14 或者 containerd v1.3+ 以上的版本。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/95125">#95125&lt;/a> kubeadm 废弃了实验性的自托管功能的支持 &lt;code>kubeadm alpha self-hosting&lt;/code> 命令将在之后版本进行移除；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94712">#94712&lt;/a> 避免在日志中泄漏 &lt;code>.dockercfg&lt;/code> 的内容；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/78153">#78153&lt;/a> 新增 &lt;code>kubectl create ingress&lt;/code> 命令；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/enhancements/pull/1899">KEP#1899&lt;/a> 增强处理 exec 请求以避免 SSRF 攻击；&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>非常抱歉，近期工作很忙，拖更了两篇。感谢大家没有取关~ 后续会继续坚持更新的！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.3.4 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.3.4-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/09/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.3.4-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-26T12:58:50+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.3.4 发布 本周 Helm v3.3.4 发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v334-发布">Helm v3.3.4 发布&lt;/h2>
&lt;p>本周 Helm v3.3.4 发布了, 这个版本是一个 bugfix 版本, 修复了自 Helm v3.3.2 中引入的一些问题。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8779">#8779&lt;/a> 确保 warning 信息输出到 stderr 而不是 stdout ；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8791">#8791&lt;/a> 修复了自 &lt;a href="https://github.com/helm/helm/pull/8779">#8779&lt;/a> 中引入的，在 windows 上 build 的异常。主要是在 PR CI 中没有测试 Windows 平台；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8777">#8777&lt;/a> 修复了自 v3.3.2 中带来的 break change 。在 v3.3.1 及之前版本中，&lt;code>helm repo add&lt;/code> 是一个幂等操作，但自 v3.3.2 中为了修复安全问题，引入了一个 break change ，如果要添加同名的 repo ，需要增加 &lt;code>--force-update&lt;/code> 参数才可以。这导致了很多自动化工具的失败，所以在 v3.3.4 版本中对此进行了修复。即：如果添加的 repo 完全相同，则此操作还是幂等的，如果 repo 仅是 name 相同，但是 url 或者 repo 的信息不同，则需要增加 &lt;code>--force-update&lt;/code> 参数才可以。&lt;/li>
&lt;/ul>
&lt;h2 id="docker-v190313-发布">Docker v19.03.13 发布&lt;/h2>
&lt;p>Docker v19.03.13 发布了， 虽然这个版本的变更看起来不多，在 ReleaseNote 中没有做太多的说明，但 &lt;strong>这个版本其实需要格外注意&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>修复了 rootless 模式下，端口转发造成的资源泄漏问题，主要是 rootless 模式下依赖的组件的泄漏导致的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修复了 network sandbox 未被完全回收的问题，主要是代码中的用来清理的 &lt;code>defer&lt;/code> 函数检查的变量有误；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>将 containerd 升级至 v1.3.7&lt;/strong> 在此版本之前，Docker v19.03 系列一直在使用 containerd v1.2.x 版本。在 Docker v19.03.12 版本中，使用的是 containerd v1.2.13 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>containerd v1.2 系列原定于 2020 年 9 月 26 日终止维护（EOL），现在经过维护者们讨论，决定将此时间延长至 10 月 15 日，以便用于迁移至 v1.3 版本中去。&lt;/p>
&lt;p>也就是说， &lt;strong>如果你在负责 Docker / 相关容器基础环境的话，我建议你将 Docker 版本升级至 v19.03.13 ，或者直接将 containerd 从 v1.2 系列升级至 v1.3.7 版本。&lt;/strong>&lt;/p>
&lt;p>至于 containerd v1.3 版本与 v1.2 之间的变化，我建议你阅读我往期的 「K8S 生态周报」，自去年 9 月 containerd v1.3.0 发布开始，几乎每个版本我都有详细介绍过。&lt;/p>
&lt;h2 id="podman-v21-发布">Podman v2.1 发布&lt;/h2>
&lt;p>Podman 在 v2.1 带来了很多新的特性，我们一起来看看吧：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>新增 &lt;code>podman save&lt;/code> 和 &lt;code>podman load&lt;/code> 现在也可以像 docker 那样，创建或者加载包含多个镜像的归档文件了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现在的配置文件默认使用 &lt;code>$HOME/.config/containers/containers.conf&lt;/code> 了，如果从旧版本升级可能会遇到如下提示：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>WARN[0000] Found deprecated file /home/tao/.config/containers/libpod.conf, please remove. Use /home/tao/.config/containers/containers.conf to override defaults.
WARN[0000] Ignoring libpod.conf EventsLogger setting &amp;quot;journald&amp;quot;. Use &amp;quot;/home/tao/.config/containers/containers.conf&amp;quot; if you want to change this setting and remove libpod.conf files.
WARN[0000] Found deprecated file /home/tao/.config/containers/libpod.conf, please remove. Use /home/tao/.config/containers/containers.conf to override defaults.
WARN[0000] Ignoring libpod.conf EventsLogger setting &amp;quot;journald&amp;quot;. Use &amp;quot;/home/tao/.config/containers/containers.conf&amp;quot; if you want to change this setting and remove libpod.conf files.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>rootless 模式下，现在完全支持 &lt;code>podman network&lt;/code> 相关功能，并且 rootless 容器可加入网络；&lt;/li>
&lt;li>&lt;code>podman run&lt;/code> 和 &lt;code>podman create&lt;/code> 为 &lt;code>--cgroups&lt;/code> 模式增加了一个新的选项 &lt;code>--cgroups=split&lt;/code>，这对于将 podman 容器作为 systemd unit 运行时比较有用；&lt;/li>
&lt;li>&lt;code>podman play kube&lt;/code> 做了很多改进，比如支持 &lt;code>read-only&lt;/code> 挂载，可以处理 &lt;code>HostAlias&lt;/code> 等；&lt;/li>
&lt;li>&lt;code>podman run&lt;/code> 和 &lt;code>podman create&lt;/code> 可以增加 &lt;code>--tz&lt;/code> 参数，用来直接设置容器的时区，算是个比较有用的功能。&lt;/li>
&lt;/ul>
&lt;h2 id="安全漏洞-cve-2020-14386">安全漏洞 CVE-2020-14386&lt;/h2>
&lt;p>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-14386" title="CVE-2020-14386">CVE-2020-14386&lt;/a> 这个漏洞我在 9 月初就看到了邮件组的消息，当时做了下大概的测试，不过没有写相关内容出来。&lt;/p>
&lt;p>今天正好有朋友又讨论到这个漏洞，这里简单的聊一下好了。&lt;/p>
&lt;p>这是一个影响面很广泛的漏洞，因为是内核漏洞而非应用层漏洞，并且 &lt;strong>内核版本是 &lt;code>v4.6-rc1&lt;/code> 到 &lt;code>v5.9-rc4&lt;/code> 之间的，全部会受此漏洞影响。&lt;/strong>&lt;/p>
&lt;p>我在 CentOS 8 的系统上，直接下载 &lt;a href="https://seclists.org/oss-sec/2020/q3/att-146/trigger_bug_c.bin">https://seclists.org/oss-sec/2020/q3/att-146/trigger_bug_c.bin&lt;/a> 使用 &lt;code>gcc&lt;/code> 编译后，执行会立即使系统 crash 并重启。&lt;/p>
&lt;p>ReaHat 对此&lt;a href="https://access.redhat.com/security/cve/CVE-2020-14386" title="CVE-2020-14386 RedHat">漏洞有一篇介绍&lt;/a>， 其中介绍了触发此漏洞的条件是，具备 &lt;code>CAP_NET_RAW&lt;/code> 权限的本地用户才能触发此漏洞。&lt;/p>
&lt;p>对于云原生从业者而言，如果你在用 Kubernetes ，那我建议你如果没有啥特殊原因，可以直接设置 PSP ，禁止 &lt;code>CAP_NET_RAW&lt;/code> 权限。&lt;/p>
&lt;p>或者跳过受影响版本的内核。 当前在内核 5.4.64 和 5.8.8 均已修复。我已经将自己的环境升级到了 5.8.11 版本的内核。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94728">#94728&lt;/a> &lt;code>kubectl portforward&lt;/code> 可以继续转发 TCP 和 UDP 了。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| KIND v0.9 发布带来众多更新</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-KIND-v0.9-%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%9B%B4%E6%96%B0/"/><id>https://moelove.info/2020/09/20/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-KIND-v0.9-%E5%8F%91%E5%B8%83%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%9B%B4%E6%96%B0/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-20T20:19:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KIND v0.9 正式发布 KIND 是我……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v09-正式发布">KIND v0.9 正式发布&lt;/h2>
&lt;p>KIND 是我很喜欢也一直在参与贡献的 Kubernetes SIG 子项目，本周 KIND 发布了 v0.9 版本，距离上次 v0.8 版本已过去了 4 个多月，在此期间，我们做了很多的优化和改进。下面我来具体介绍下：&lt;/p>
&lt;h3 id="破坏性变更">破坏性变更&lt;/h3>
&lt;ul>
&lt;li>默认的 Node 镜像版本已经升级为最新的 Kubernetes v1.19.1 版本；&lt;/li>
&lt;li>&lt;code>v1alpha3&lt;/code> 版本的 KIND config 配置文件版本已被废弃，当前最新的版本是 &lt;code>v1alpha4&lt;/code>；&lt;/li>
&lt;li>执行 &lt;code>kind build node-image&lt;/code> 命令时，如果 &lt;code>--type&lt;/code> 指定为 &lt;code>bazel&lt;/code> ，则仅能与 Kubernetes v1.15+ 版本兼容。如果使用默认的 &lt;code>docker&lt;/code> 类型的构建方式，则可以与 v1.13+ 版本兼容；&lt;/li>
&lt;li>使用 KIND v0.9.0 版本构建的节点 image，仅支持与 KIND v0.9.0+ 版本一起工作。如果是使用 KIND v0.8+ 版本构建的镜像，也可与 KIND 最新版一起工作，但是少了一些内部优化的特性；&lt;/li>
&lt;li>&lt;strong>不再支持 Kubernetes v1.13 之前的 Kubernetes 版本了。&lt;/strong> 多节点集群的话，仅支持 Kubernetes v1.14+ 版本了，主要是与 &lt;code>kubeadm&lt;/code> 有关；&lt;/li>
&lt;/ul>
&lt;h3 id="新特性">新特性&lt;/h3>
&lt;ul>
&lt;li>KIND 的配置文件中直接支持 Kubernetes RuntimeConfig 的配置了；&lt;/li>
&lt;li>NFS volume 应该可以工作了；&lt;/li>
&lt;li>目前我们为每个节点设置了一个以 &lt;code>kind://&lt;/code> 前缀开头的 &lt;code>providerID&lt;/code>，但以后可能会再做改动；&lt;/li>
&lt;li>如果配置了 proxy ，则会自动增加 &lt;code>no_proxy&lt;/code> 相关的配置；&lt;/li>
&lt;li>默认的 CNI 会自动匹配网关的 MTU；&lt;/li>
&lt;/ul>
&lt;h3 id="修正">修正&lt;/h3>
&lt;ul>
&lt;li>对 HA 模式及 restart 相关逻辑的修正；&lt;/li>
&lt;li>IPv6 相关网络问题的修正；&lt;/li>
&lt;li>个别场景下端口转发的问题修正；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，可直接访问 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.9.0" title="KIND v0.9 release 页面">Release 页面&lt;/a> 下载预编译的二进制使用。&lt;/p>
&lt;h2 id="open-service-mesh-osm-已捐献给-cncf">Open Service Mesh (OSM) 已捐献给 CNCF&lt;/h2>
&lt;p>Open Service Mesh (OSM) &lt;a href="https://openservicemesh.io/blog/open-service-mesh-osm-accepted-into-cncf-as-a-sandbox-project/" title="OSM 官宣博客">目前已经捐献给 CNCF &lt;/a>成为 sandbox 级别的项目。正如 OSM 创建之初时说的那样， 它将会按照 CNCF 的开源治理模型发展，应该会有个不错的后续的。&lt;/p>
&lt;p>Open Service Mesh（OSM）是一个轻量级，可扩展的云原生服务网格，它使用户能够统一管理，保护和获得针对高度动态微服务环境的开箱即用的可观察性功能。&lt;/p>
&lt;p>OSM 在 Kubernetes 上运行基于 Envoy 的控制平面，可以使用 SMI API 进行配置。它通过以 sidecar 的形式注入 Envoy 代理来工作。&lt;/p>
&lt;p>控制面负责持续配置代理，以配置策略和路由规则等都保持最新。代理主要负责执行访问控制的规则，路由控制，采集 metrics 等。（这和目前我们常见到的 Service Mesh 方案基本都一样的）&lt;/p>
&lt;p>对 Open Service Mesh (OSM) 感兴趣的小伙伴，可参考我之前写的文章 &lt;a href="https://zhuanlan.zhihu.com/p/171550414" title="初试 Open Service Mesh（OSM）">初试 Open Service Mesh（OSM）&lt;/a>&lt;/p>
&lt;h2 id="containerd-141-发布">containerd 1.4.1 发布&lt;/h2>
&lt;p>containerd 1.4.1 是 v1.4 系列的第一个 patch 版本，在此版本中带来了一些重要的改进，我们一起来看看吧：&lt;/p>
&lt;ul>
&lt;li>总是保持消费 shim 的日志；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>上面这句话看似简单，但背后的影响很大。&lt;/strong>&lt;/p>
&lt;p>在将 &lt;code>containerd&lt;/code> 升级至 &lt;code>v1.4.0&lt;/code> 后，众多 &lt;code>Arch Linux&lt;/code> 的用户都遇到了&lt;code>配置了健康检查的容器 Hang 住&lt;/code>的问题。详细情况请参考 &lt;a href="https://bugs.archlinux.org/task/67773?dev=25983" title="arch linux containerd v1.4 容器 hang 住">Arch Linux 上的 bug 记录&lt;/a>。&lt;/p>
&lt;p>目前 ArchLinux 的仓库中，已经重新构建了 containerd 的包，可以直接更新使用。&lt;/p>
&lt;p>当然，还有另外两种解决办法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>直接更新至 containerd v1.4.1 版本。 此版本中已经加入了相关逻辑，始终消费 shim 的日志；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开启 &lt;code>shim_debug&lt;/code> 选项（ &lt;strong>仅作为一种不能快速升级时的临时解决办法，开启 shim_debug 后，可能会带来更多问题，比如日志更多之类的&lt;/strong> ）；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>更新了 seccomp 默认的 profile ；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，可参阅其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.4.1" title="containerd v1.4.1">ReleaseNote&lt;/a> 了解更多信息。&lt;/p>
&lt;h2 id="harbor-v21-发布">Harbor v2.1 发布&lt;/h2>
&lt;p>Harbor v2.1 本周发布了，具体上个版本 v2.0 已经过去了挺长时间了。本次 Harbor v2.1 有一些值得关注的新特性：&lt;/p>
&lt;ul>
&lt;li>Harbor 可作为 Proxy Cache 。但 Harbor 目前的实现，是将 proxy cache 也作为一个 Harbor 中的项目来处理，所以需要将待拉取的镜像设置为 &lt;code>&amp;lt;harbor_servername&amp;gt;/&amp;lt;proxy_project_name&amp;gt;/repo/name:tag&lt;/code> 的形式，才能作为缓存使用。我个人感觉这样是不太方便的。 &lt;strong>最方便的形式是 pull through cache, 也就是 docker daemon 中的 registry-mirror ，可以正常 pull 镜像，然后由 docker 对请求镜像转发处理&lt;/strong>， 感兴趣的小伙伴，可以参考我发布的文章 &lt;a href="https://zhuanlan.zhihu.com/p/256359308" title="突破 DockerHub 限制，全镜像加速服务">突破 DockerHub 限制，全镜像加速服务&lt;/a>&lt;/li>
&lt;li>非阻塞的 GC （GC 一直是 Harbor 比较受人诟病的点）；&lt;/li>
&lt;li>P2P 分发，与 Dragonfly 或 Kraken 集成；&lt;/li>
&lt;li>新增 sysdig 镜像扫描集成；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，可参阅其 &lt;a href="https://github.com/goharbor/harbor/releases/tag/v2.1.0" title="harbor v2.1.0">ReleaseNote&lt;/a> 了解更多信息。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88337">#88337&lt;/a> &lt;code>kubectl/drain&lt;/code> 支持自定义 pod 过滤了, 仅作为库使用时。目前尚未在 CLI 中暴露相关选项；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94140">#94140&lt;/a> &lt;code>PidLimits&lt;/code> 特性 GA 了！非常实用的特性，可以规避很多问题。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">突破 DockerHub 限制，全镜像加速服务</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/20/%E7%AA%81%E7%A0%B4-DockerHub-%E9%99%90%E5%88%B6%E5%85%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/"/><id>https://moelove.info/2020/09/20/%E7%AA%81%E7%A0%B4-DockerHub-%E9%99%90%E5%88%B6%E5%85%A8%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-20T10:10:48+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近 DockerHub 修改了定价，对于免费帐号会限制 200 pulls/6小时，对于匿名帐号则限制 100 pulls/6小时。 本文我来介绍下如何使用 Cache 来应对……</summary><content type="html">&lt;blockquote>
&lt;p>最近 DockerHub 修改了定价，对于免费帐号会限制 200 pulls/6小时，对于匿名帐号则限制 100 pulls/6小时。 本文我来介绍下如何使用 Cache 来应对此问题。&lt;/p>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>DockerHub 是全世界最早也是最大的容器镜像仓库，托管着众多操作系统发行版及各类软件的 Docker 镜像。&lt;/p>
&lt;p>在推进业务容器化的过程中，不可避免的，我们会需要使用来自 DockerHub 上的容器镜像。 &lt;em>无论是在个人本地环境中使用，还是用于跑测试服务&lt;/em>&lt;/p>
&lt;p>以下是两种主要的解决方案：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>构建一些公共基础镜像，存放在企业的私有镜像仓库中给业务方使用：&lt;/p>
&lt;p>这种方案下，如果业务方偶尔需要一些小众的/非基础的镜像，可能只是临时测试使用，那通常情况下是没必要将此类镜像作为基础镜像维护的。&lt;/p>
&lt;p>结果可能是：&lt;/p>
&lt;ul>
&lt;li>使用中直接从 DockerHub pull 镜像，网络状况不佳时，就是无尽的等待；&lt;/li>
&lt;li>先 pull 镜像，然后 &lt;code>docker tag&lt;/code> 重 tag 后， push 到企业的私有镜像仓库中。这种情况下，如果没有较好的镜像管理规则，那么镜像仓库中就会存在各种无意义的镜像，造成存储资源的浪费。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>为 docker daemon 配置 Proxy 进行加速：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>众多国内镜像加速服务，仅提供 Docker 官方镜像的加速服务，个人/组织下的镜像不提供加速服务&lt;/strong>；&lt;/li>
&lt;li>即使在不同节点上，下载相同的镜像，仍然需要通过网络加速，会产生额外的海外带宽成本；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>并且近期 DockerHub 修改了&lt;a href="https://www.docker.com/pricing" title="DockerHub 定价">其服务价格&lt;/a>, 对于免费用户，进行了如下限制：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>未登录用户，每 6 小时只允许 pull 100 次&lt;/strong>&lt;/li>
&lt;li>&lt;strong>已登录用户，每 6 小时只允许 pull 200 次&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如果我们继续使用上述两种模式的话，由于出口 IP 是相对固定的，所以很容易触发 DockerHub 的配额限制。 此限制将于 11 月 1 日正式全面实施。&lt;/p>
&lt;p>为了能 &lt;strong>提升效率&lt;/strong> ，以及 &lt;strong>节约加速带宽成本&lt;/strong> ，企业内部/个人就非常需要一个 DockerHub 全镜像加速服务了，也就是我们常说的 &lt;code>pull through cache&lt;/code>。&lt;/p>
&lt;p>下面我来介绍下，如何利用 Docker 开源的项目 &lt;code>registry:2&lt;/code> 来实现这一需求。&lt;/p>
&lt;h2 id="启动服务">启动服务&lt;/h2>
&lt;p>使用 &lt;code>registry:2&lt;/code> 部署镜像缓存服务很简单，这里先执行 &lt;code>docker pull registry:2&lt;/code> 下载所需的镜像：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ docker pull registry:2
2: Pulling from library/registry
cbdbe7a5bc2a: Pull &lt;span class="nb">complete&lt;/span>
47112e65547d: Pull &lt;span class="nb">complete&lt;/span>
46bcb632e506: Pull &lt;span class="nb">complete&lt;/span>
c1cc712bcecd: Pull &lt;span class="nb">complete&lt;/span>
3db6272dcbfa: Pull &lt;span class="nb">complete&lt;/span>
Digest: sha256:8be26f81ffea54106bae012c6f349df70f4d5e7e2ec01b143c46e2c03b9e551d
Status: Downloaded newer image &lt;span class="k">for&lt;/span> registry:2
docker.io/library/registry:2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最小化配置的 DockerHub 镜像缓存服务，只需要使用一个配置项 &lt;code>REGISTRY_PROXY_REMOTEURL&lt;/code> 即可：&lt;/p>
&lt;p>这里我顺便为它单独创建了一个名为 &lt;code>hub-cache&lt;/code> 的 network ，以及创建了对应的 volume 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker network create hub-cache
19a39f873a23150d3bdaf021e040ccccb092ee3071884d64d52a92df0397b220
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker volume create hub-cache
hub-cache
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker run --name&lt;span class="o">=&lt;/span>cache -d --restart&lt;span class="o">=&lt;/span>always --network&lt;span class="o">=&lt;/span>hub-cache -v hub-cache:/var/lib/registry -p 5000:5000 -e &lt;span class="nv">REGISTRY_PROXY_REMOTEURL&lt;/span>&lt;span class="o">=&lt;/span>https://registry-1.docker.io registry:2
6cbdcbdcc2d62ec781479901c20be43184a48b2d73e06f04bd4693253c0c5a73
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker ps -l
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
6cbdcbdcc2d6 registry:2 &lt;span class="s2">&amp;#34;/entrypoint.sh /etc…&amp;#34;&lt;/span> &lt;span class="m">8&lt;/span> seconds ago Up &lt;span class="m">6&lt;/span> seconds 0.0.0.0:5000-&amp;gt;5000/tcp cache
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="验证加速效果">验证加速效果&lt;/h2>
&lt;p>启动一个全新的 Docker In Docker 容器进行验证，避免受到本地环境的影响。&lt;/p>
&lt;p>通过传递 &lt;code>--registry-mirror http://cache:5000&lt;/code> ，将刚才启动的 registry 设置为 mirror 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker run --network&lt;span class="o">=&lt;/span>hub-cache -d --privileged docker:dind --registry-mirror http://cache:5000
73c56ac25d68927c9f5b0e458f2babc0699cf8595df0d1e86c021fd03d477384
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker &lt;span class="nb">exec&lt;/span> -it &lt;span class="k">$(&lt;/span>docker ps -ql&lt;span class="k">)&lt;/span> sh
/ &lt;span class="c1"># 检查配置是否生效&lt;/span>
/ &lt;span class="c1"># docker info --format &amp;#39;{{ .RegistryConfig.Mirrors }}&amp;#39; &lt;/span>
&lt;span class="o">[&lt;/span>http://cache:5000/&lt;span class="o">]&lt;/span>
/ &lt;span class="c1"># time docker pull prom/prometheus&lt;/span>
Using default tag: latest
latest: Pulling from prom/prometheus
76df9210b28c: Pull &lt;span class="nb">complete&lt;/span>
559be8e06c14: Pull &lt;span class="nb">complete&lt;/span>
6a4bb3319487: Pull &lt;span class="nb">complete&lt;/span>
2cca90a64593: Pull &lt;span class="nb">complete&lt;/span>
d2014e464a99: Pull &lt;span class="nb">complete&lt;/span>
70b42590e4a2: Pull &lt;span class="nb">complete&lt;/span>
54645fcbd6cc: Pull &lt;span class="nb">complete&lt;/span>
67d9943de656: Pull &lt;span class="nb">complete&lt;/span>
b9c749b1af90: Pull &lt;span class="nb">complete&lt;/span>
9723d8eb5323: Pull &lt;span class="nb">complete&lt;/span>
7d20502d5322: Pull &lt;span class="nb">complete&lt;/span>
3e519cce6f63: Pull &lt;span class="nb">complete&lt;/span>
Digest: sha256:d43417c260e516508eed1f1d59c10c49d96bbea93eafb4955b0df3aea5908971
Status: Downloaded newer image &lt;span class="k">for&lt;/span> prom/prometheus:latest
docker.io/prom/prometheus:latest
real 0m 42.71s
user 0m 0.12s
sys 0m 0.09s
/ &lt;span class="c1"># docker image ls&lt;/span>
REPOSITORY TAG IMAGE ID CREATED SIZE
prom/prometheus latest cdfc440228d0 &lt;span class="m">8&lt;/span> days ago 168MB
/ &lt;span class="c1"># docker rmi prom/prometheus &lt;/span>
Untagged: prom/prometheus:latest
Untagged: prom/prometheus@sha256:d43417c260e516508eed1f1d59c10c49d96bbea93eafb4955b0df3aea5908971
Deleted: sha256:cdfc440228d01d7a94937d7a047fa6461efc1b1806bb20677043fee032810830
Deleted: sha256:c72f348fd2f923996ea80222feb77e34aba9de397bd96206ddc3c8651adc306d
Deleted: sha256:e34df2c00334266a67bb846b958ba6eae3b1d5cdfe9d763707027a23e7c85100
Deleted: sha256:d2cb38310ada122064b7333bbfc12c67dc58acb30e29146b3ba1e24adc27a950
Deleted: sha256:7a87cd520d19a83b3582541aac4d95098ae5016b092e72eaf80dc54f587bf51e
Deleted: sha256:f84c79dceed6b5a27234c1291d0bdccab5c459d587f13934d74db9b9e79471c6
Deleted: sha256:f542b0cffe0fe16c31c98e7eed934d5fea5e598c03b53b4efd308a62e0e9c6a9
Deleted: sha256:f746b4a525727bcb79367d009d707ef45d75bac09aaa18a68c20a19046df0897
Deleted: sha256:09b45653ee7062c7cd754885bf46ebe554d0794573fb2e200acea8644e64670f
Deleted: sha256:867526c56b30e67493341ef33890aa242c1131e4bb4151e60011b4d450892d59
Deleted: sha256:86d629b358ee70bdb0f0a11c10915b8551e904fe337f9a8bfcad476977329532
Deleted: sha256:842455c528af7383ba4a0de424fc63664a0248581a191516d6dbf45195c69426
Deleted: sha256:1be74353c3d0fd55fb5638a52953e6f1bc441e5b1710921db9ec2aa202725569
/ &lt;span class="c1"># time docker pull prom/prometheus&lt;/span>
Using default tag: latest
latest: Pulling from prom/prometheus
76df9210b28c: Pull &lt;span class="nb">complete&lt;/span>
559be8e06c14: Pull &lt;span class="nb">complete&lt;/span>
6a4bb3319487: Pull &lt;span class="nb">complete&lt;/span>
2cca90a64593: Pull &lt;span class="nb">complete&lt;/span>
d2014e464a99: Pull &lt;span class="nb">complete&lt;/span>
70b42590e4a2: Pull &lt;span class="nb">complete&lt;/span>
54645fcbd6cc: Pull &lt;span class="nb">complete&lt;/span>
67d9943de656: Pull &lt;span class="nb">complete&lt;/span>
b9c749b1af90: Pull &lt;span class="nb">complete&lt;/span>
9723d8eb5323: Pull &lt;span class="nb">complete&lt;/span>
7d20502d5322: Pull &lt;span class="nb">complete&lt;/span>
3e519cce6f63: Pull &lt;span class="nb">complete&lt;/span>
Digest: sha256:d43417c260e516508eed1f1d59c10c49d96bbea93eafb4955b0df3aea5908971
Status: Downloaded newer image &lt;span class="k">for&lt;/span> prom/prometheus:latest
docker.io/prom/prometheus:latest
real 0m 5.27s
user 0m 0.06s
sys 0m 0.03s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>可以看到，在首次 pull &lt;code>prom/prometheus&lt;/code> 镜像时，耗费了 42+s 的时间，而删除掉已下载的镜像后，再次 pull， 则只需要耗费 5+s 的时间。速度提升非常的明显。镜像加速效果达成&lt;/strong>&lt;/p>
&lt;h2 id="使用配置">使用配置&lt;/h2>
&lt;p>对于 Linux 系统而言，仅需要在 &lt;code>/etc/docker/daemon.json&lt;/code> 文件（如果没有此文件，直接创建即可）中写入你的镜像加速服务的域名，重启 docker daemon 即可（也可选择 reload 配置）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;registry-mirrors&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s2">&amp;#34;https://hub-cache.moelove.info&amp;#34;&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者是在 docker daemon 的启动参数中加入 &lt;code>registry-mirror&lt;/code> 配置项。&lt;/p>
&lt;p>对于 Mac 和 Windows 用户，直接在 Docker Desktop 系统设置中，配置 registry-mirrors 即可。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong> 如果 Docker daemon 中配置了 &lt;code>HTTP_PROXY&lt;/code> 或 &lt;code>HTTPS_PROXY&lt;/code> ，那么需要将加速域名配置在 &lt;code>NO_PROXY&lt;/code> 中，避免被代理。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了如何使用 Docker 开源的 &lt;code>registry:2&lt;/code> 搭建 DockerHub 的镜像加速服务。这里只介绍了最简单的配置。&lt;/p>
&lt;p>但如果在企业环境中部署的话，需要有更多的配置。比如，可以通过配置 &lt;code>REGISTRY_HTTP_DEBUG_PROMETHEUS_ENABLED&lt;/code> 暴露 Prometheus metrics ，用于监控服务可用性及查看 cache 的效果；可以对日志及相关字段进行配置；
为了避免在 11 月后，触发到 DockerHub 的流量限制，可以横向进行扩容，准备多出口 IP，以及配置账户等。&lt;/p>
&lt;p>最近新发布的 Harbor v2.1 貌似多了一个&lt;a href="https://goharbor.io/docs/2.1.0/administration/configure-proxy-cache/">作为 &lt;code>proxy cache&lt;/code> 的特性&lt;/a>，但它与本文介绍的 &lt;code>pull through cache&lt;/code> 并不相同，使用 Harbor 的 proxy cache 特性，需要将待 pull 的镜像，设置成 &lt;code>&amp;lt;harbor_servername&amp;gt;/&amp;lt;proxy_project_name&amp;gt;/repo/name:tag&lt;/code> 的形式，这样子只是省去了本文一开始介绍的那种手动重 tag 的操作，不够方便，但也是个很不错的特性了。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Istio v1.7.1 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/13/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-v1.7.1-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/09/13/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-v1.7.1-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-13T17:08:06+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Istio v1.7.1 发布 这是 Istio v1.7 系……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="istio-v171-发布">Istio v1.7.1 发布&lt;/h2>
&lt;p>这是 Istio v1.7 系列的第一个 patch 版本。此次更新有些值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/istio/istio/pull/26625">#26625&lt;/a> 修复了 &lt;code>istioctl x authz check&lt;/code> 使其能更好的兼容 v1beta1 AuthorizationPolicy ；&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/26617">#26617&lt;/a> 修复了 headless services endpoint 更新不会触发任何 xds pushes 的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/26938">##26938&lt;/a> 修复了当使用 &lt;code>IstioCNI&lt;/code> 时 &lt;code>remove-from-mesh&lt;/code> 未移除 init container 的问题；&lt;/li>
&lt;/ul>
&lt;h2 id="rook-v143-发布">Rook v1.4.3 发布&lt;/h2>
&lt;p>这是个 patch 版本，主要修复了一些和 Ceph 有关的问题, 以及引入了一些小功能：&lt;/p>
&lt;p>修复：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6232">#6232&lt;/a> 由于 Ceph-CSI driver 在某些集群中会把垃圾回收清理掉，所以创建 &lt;code>csidriver&lt;/code> 对象时不再为它设置 &lt;code>ownerRef&lt;/code> 了。主要是因为 &lt;code>csidriver&lt;/code> 是集群级别的对象，不应该将 namespace 级别的对象设置为它的 &lt;code>ownerRef&lt;/code>；&lt;/li>
&lt;/ul>
&lt;p>修改：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6225">#6225&lt;/a> 为 OSD pod 添加 storageClassDeviceSet 标签&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6145">#6145&lt;/a> 为 Ceph 集群增加 &lt;code>uninstall&lt;/code> 模式，如果 &lt;code>UninstallMode&lt;/code> CR spec 设置为 &lt;code>yes-really-uninstall-even-if-in-use&lt;/code>， 那么集群会直接全部删除，而不会等待 PVC 的等待；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6198">##6198&lt;/a> 仅在 Dashboard 设置为 true 的时候，才会启动 init 容器；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6127">#6127&lt;/a> 如果一个 OSD down 了，并且需要从 cluster 中移除，则会启动一个 job 去清理它。如果 OSD 仍然 up， 则该 job 会被拒绝；&lt;/li>
&lt;/ul>
&lt;h2 id="thanos-v0150-发布">Thanos v0.15.0 发布&lt;/h2>
&lt;p>本次新增了一个组件 &lt;a href="https://thanos.io/tip/components/query-frontend.md/" title="Query Frontend">Query Frontend &lt;/a> 这是基于 &lt;a href="https://cortexmetrics.io/docs/architecture/#query-frontend" title="Cortex Query Frontend"> Cortex Query Frontend &lt;/a> 的，所以它们有些相同的特性，比如 &lt;code>Splitting&lt;/code> 和 &lt;code>Results Caching&lt;/code>&lt;/p>
&lt;p>更多关于此版本的信息，请参考其 &lt;a href="https://github.com/thanos-io/thanos/releases/tag/v0.15.0" title="Thanos v0.15">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94398">#94398&lt;/a> kubeadm 将 &lt;code>kube-scheduler&lt;/code> 和 &lt;code>kube-controller-manager&lt;/code> 的 kubeconfig 配置文件中 API Server 的地址指向了本地的 API Server 地址。主要是为了避免升级过程中，当这些组件与 API Server 版本不一致时，向 API Server 请求不存在的 API 地址；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94395">#94395&lt;/a> &lt;code>kubeadm upgrade&lt;/code> 时，无论 etcd 版本是否有变化，将确保 etcd manifest 重新生成；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 是时候从 k8s v1.16 升级了</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E6%98%AF%E6%97%B6%E5%80%99%E4%BB%8E-k8s-v1.16-%E5%8D%87%E7%BA%A7%E4%BA%86/"/><id>https://moelove.info/2020/09/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E6%98%AF%E6%97%B6%E5%80%99%E4%BB%8E-k8s-v1.16-%E5%8D%87%E7%BA%A7%E4%BA%86/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-05T22:37:11+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.16.15 发布 Kubernetes v1.16.15 是 v1.16 系……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v11615-发布">Kubernetes v1.16.15 发布&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.16.md/#v11615">Kubernetes v1.16.15&lt;/a> 是 v1.16 系列的最后一个更新，我在之前的周报中也有介绍过。&lt;/p>
&lt;p>是时候考虑将 v1.16 升级至更高版本了！&lt;/p>
&lt;p>以下介绍从 v1.16 升级至 v1.17 需要关注的一些重点。&lt;/p>
&lt;h3 id="etcd">etcd&lt;/h3>
&lt;p>就外部依赖而言，最主要的变化是 etcd 从 &lt;code>v3.3.13&lt;/code> 升级到了 &lt;code>v3.4.3&lt;/code> 。&lt;/p>
&lt;p>在升级 etcd 前，我建议你先阅读下 &lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/upgrades/upgrade_3_4.md" title="etcd 升级文档">etcd 的升级文档&lt;/a>。 我从中说几个重点内容：&lt;/p>
&lt;blockquote>
&lt;p>In the general case, upgrading from etcd 3.3 to 3.4 can be a zero-downtime, rolling upgrade:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>one by one, stop the etcd v3.3 processes and replace them with etcd v3.4 processes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>after running all v3.4 processes, new features in v3.4 are available to the cluster&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>这是 etcd 文档中的内容，看起来是很安全的。&lt;/p>
&lt;p>但也有一些非常关键的信息值得注意， 主要是破坏性变更：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ETCDCTL_API=3 etcdctl&lt;/code> 成为默认；&lt;/li>
&lt;li>&lt;code>etcd --enable-v2=false&lt;/code> 默认关掉了 v2 支持；&lt;/li>
&lt;li>&lt;code>etcd --ca-file&lt;/code> 和 &lt;code>etcd --peer-ca-file&lt;/code> 已过期；&lt;/li>
&lt;/ul>
&lt;p>整体而言涉及到的内容就是 &lt;code>etcd v2 API&lt;/code> 了。&lt;/p>
&lt;p>假如你使用的 CNI 是 Flannel 的话，你需要注意 &lt;a href="https://github.com/coreos/flannel/issues/1191" title="Flannel 不支持 etcd v3 API">Flannel 目前还不支持使用 etcd v3 API&lt;/a> ， 需要自行设置 &lt;code>--enable-v2&lt;/code> 。&lt;/p>
&lt;h2 id="kube-apiserver">kube-apiserver&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/81668">默认的 service IP CIDR 10.0.0.0/24 &lt;/a> 已经过期，并将在之后版本删除，所以需要注意给 kube-apiserver 设置 &lt;code>--service-cluster-ip-range&lt;/code> 选项，以免在之后升级时发生问题。&lt;/p>
&lt;h2 id="kubelet--csi">kubelet &amp;amp; CSI&lt;/h2>
&lt;p>如果你的某个节点使用了 CSI raw block volume ，那么在升级 kubelet 前， &lt;strong>必须&lt;/strong> &lt;code>kubectl drain node-x&lt;/code> 以避免遇到&lt;a href="https://github.com/kubernetes/kubernetes/pull/74026" title="kubelet &amp;amp; CSI v1.17">问题&lt;/a>&lt;/p>
&lt;p>最值得关注的问题主要就这些，祝你升级顺利 :)&lt;/p>
&lt;h2 id="rook-v142-发布">Rook v1.4.2 发布&lt;/h2>
&lt;p>Rook 本次发布的 v1.4.2 版本，主要集中在对 Ceph 相关内容的改进。我们来看看有哪些值得关注的内容吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6118">#6118&lt;/a> 为 OSD prepare 做了资源限制；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/6170">#6170&lt;/a> 为所有对象存储的 debug 信息增加了完整的 DNS 后缀，比如（&lt;code>.svc.cluster.local&lt;/code>）;&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.4.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="cilium-v183-发布">Cilium v1.8.3 发布&lt;/h2>
&lt;p>关于 Cilium 的介绍可参考我的上一篇文章 &lt;a href="https://zhuanlan.zhihu.com/p/213745089">Cilium 上手实践&lt;/a> ，这里就不再赘述了。&lt;/p>
&lt;p>本周 Cilium 发布了 v1.8.3 版本，我们来看看有哪些值得注意的变更吧：&lt;/p>
&lt;ul>
&lt;li>为 &lt;a href="https://github.com/cilium/cilium/pull/12409" title="Cilium operator HA mode">Cilium operator 增加了 HA 模式&lt;/a> ， 但是要注意的是 &lt;strong>HA 模式由于使用了 coordination.k8s.io/v1 API 所以不支持 Kubernetes v1.14 之前版本的 K8S&lt;/strong> ；&lt;/li>
&lt;li>Hubble/relay: 在 ServerStatus 会报告 Node 连接状态了；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/cilium/cilium/releases/tag/v1.8.3" title="Cilium v1.8.3 ReleaseNote">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/93548">#93548&lt;/a> &lt;code>kubectl&lt;/code> path 增加了一个 &lt;code>--patch-file&lt;/code> 的选项，允许使用 patch 文件；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/94309">#94309&lt;/a> &lt;code>kubectl get ingress&lt;/code> 默认将使用 &lt;code>networking.k8s.io/v1&lt;/code> API 而不是之前的 &lt;code>extensions/v1beta1&lt;/code> ；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">被 Google 选择的下一代数据面 Cilium 是什么</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/09/02/%E8%A2%AB-Google-%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E9%9D%A2-Cilium-%E6%98%AF%E4%BB%80%E4%B9%88/"/><id>https://moelove.info/2020/09/02/%E8%A2%AB-Google-%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E9%9D%A2-Cilium-%E6%98%AF%E4%BB%80%E4%B9%88/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-09-02T10:51:21+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">背景 在我之前的文章 K8S 生态周报| Google 选择 Cilium 作为 GKE 下一代数据面 一文中，我介绍了 Google 宣布使用 Cilium 作为 GKE 的下一代数据面，及其背后的故事。 Google 选择……</summary><content type="html">&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/195759300" title="Google 选择 Cilium 作为 GKE 下一代数据面">K8S 生态周报| Google 选择 Cilium 作为 GKE 下一代数据面&lt;/a> 一文中，我介绍了 Google 宣布使用 Cilium 作为 GKE 的下一代数据面，及其背后的故事。&lt;/p>
&lt;p>Google 选择 Cilium 主要是为了增加 GKE 平台的容器安全性和可观测性。那么，Cilium 到底是什么，为什么会有这么强的吸引力呢？&lt;/p>
&lt;p>摘一段官网的介绍：&lt;/p>
&lt;blockquote>
&lt;p>Cilium is open source software for transparently securing the network connectivity between application services deployed using Linux container management platforms like Docker and Kubernetes.&lt;/p>
&lt;/blockquote>
&lt;p>Cilium 是一个用于透明保护部署在 Linux 容器管理平台（比如 Docker 和 Kubernetes）上的应用服务之间网络连接的开源软件。&lt;/p>
&lt;p>为什么着重强调是 “Linux 容器管理平台” 呢？这就不得不提到 Cilium 的实现了。Cilium 的基础是一种称为 eBPF 的 Linux 内核技术，使用 eBPF 可以在 Linux 自身内部动态的插入一些控制逻辑，从而满足可观察性和安全性相关的需求。&lt;/p>
&lt;p>只谈概念毕竟过于空洞，本节我们直接上手实践一下 Cilium 。&lt;/p>
&lt;h2 id="准备集群">准备集群&lt;/h2>
&lt;p>这里我使用 &lt;a href="https://kind.sigs.k8s.io/" title="Kubernetes IN Docker">KIND&lt;/a> 来创建一套多节点的本地集群。&lt;/p>
&lt;h3 id="写配置文件">写配置文件&lt;/h3>
&lt;p>在创建集群时候，通过配置文件来禁用掉 KIND 默认的 CNI 插件。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kind.x-k8s.io/v1alpha4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">nodes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">networking&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">disableDefaultCNI&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动集群">启动集群&lt;/h3>
&lt;p>将配置文件命名为 &lt;code>kindconfig&lt;/code> ，通过 &lt;code>--config&lt;/code> 参数来指定它。 通过 &lt;code>--image&lt;/code> 参数可指定创建集群所使用的镜像，这里我使用 &lt;code>kindest/node:v1.19.0@sha256:6a6e4d588db3c2873652f382465eeadc2644562a64659a1da4&lt;/code> 来创建一个最新的 Kubernetes v1.19.0 版本的集群。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kind create cluster --config&lt;span class="o">=&lt;/span>kindconfig --image&lt;span class="o">=&lt;/span>kindest/node:v1.19.0@sha256:6a6e4d588db3c2873652f382465eeadc2644562a64659a1da4
db73d3beaa8848
Creating cluster &lt;span class="s2">&amp;#34;kind&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.19.0&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦 📦 📦 📦
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing StorageClass 💾
✓ Joining worker nodes 🚜
Set kubectl context to &lt;span class="s2">&amp;#34;kind-kind&amp;#34;&lt;/span>
You can now use your cluster with:
kubectl cluster-info --context kind-kind
Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看状态">查看状态&lt;/h3>
&lt;p>由于我们已经禁用了 KIND 默认的 CNI ，所以现在集群的 Node 都是 &lt;code>NotReady&lt;/code> 的状态，等待 CNI 的初始化。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get nodes
NAME STATUS ROLES AGE VERSION
kind-control-plane NotReady master 85s v1.19.0
kind-worker NotReady &amp;lt;none&amp;gt; 49s v1.19.0
kind-worker2 NotReady &amp;lt;none&amp;gt; 49s v1.19.0
kind-worker3 NotReady &amp;lt;none&amp;gt; 49s v1.19.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="部署-cilium">部署 Cilium&lt;/h2>
&lt;p>部署 Cilium 可以有多种方式，这里我们选择最简单的，直接使用 Helm 3 进行部署。&lt;/p>
&lt;h3 id="添加-helm-仓库">添加 Helm 仓库&lt;/h3>
&lt;p>Cilium 提供了官方维护的 Helm 仓库，我们先来添加它。&lt;/p>
&lt;p>注意： &lt;strong>请使用 Helm 3&lt;/strong>。 在之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/186265631" title="Helm v2 进入维护期倒计时">K8S 生态周报| Helm v2 进入维护期倒计时&lt;/a> 中，我曾介绍过 Helm v2 的维护期已经进入倒计时，三个月后将停止为 Helm v2 提供安全补丁，届时 Helm v2 的维护期就彻底终止了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ helm repo add cilium https://helm.cilium.io/
&lt;span class="s2">&amp;#34;cilium&amp;#34;&lt;/span> has been added to your repositories
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="预加载镜像">预加载镜像&lt;/h3>
&lt;p>&lt;strong>这一步并非必须&lt;/strong>。 只是由于每个在 Node 上都需要下载 &lt;code>cilium/cilium:v1.8.2&lt;/code> 的镜像，会很耗时，所以我们可以直接使用 &lt;code>kind load docker-image&lt;/code> 将主机 Docker 中的镜像加载到 KIND 创建的集群中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 下载镜像&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker pull cilium/cilium:v1.8.2
v1.8.2: Pulling from cilium/cilium
Digest: sha256:9dffe79408025f7523a94a1828ac1691b997a2b1dbd69af338cfbecc8428d326
Status: Image is up to date &lt;span class="k">for&lt;/span> cilium/cilium:v1.8.2
docker.io/cilium/cilium:v1.8.2
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 将镜像加载到 KIND 集群中&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kind load docker-image cilium/cilium:v1.8.2
Image: &lt;span class="s2">&amp;#34;cilium/cilium:v1.8.2&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:009715be68951ab107617f04dc50bcceb3d3f1e0c09db156aacf95e56eb0d5cc&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker3&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;cilium/cilium:v1.8.2&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:009715be68951ab107617f04dc50bcceb3d3f1e0c09db156aacf95e56eb0d5cc&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-control-plane&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;cilium/cilium:v1.8.2&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:009715be68951ab107617f04dc50bcceb3d3f1e0c09db156aacf95e56eb0d5cc&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker&amp;#34;&lt;/span>, loading...
Image: &lt;span class="s2">&amp;#34;cilium/cilium:v1.8.2&amp;#34;&lt;/span> with ID &lt;span class="s2">&amp;#34;sha256:009715be68951ab107617f04dc50bcceb3d3f1e0c09db156aacf95e56eb0d5cc&amp;#34;&lt;/span> not yet present on node &lt;span class="s2">&amp;#34;kind-worker2&amp;#34;&lt;/span>, loading...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>镜像加载完成后，可使用如下命令进行二次确认：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="k">for&lt;/span> i in &lt;span class="sb">`&lt;/span>docker ps --filter &lt;span class="nv">label&lt;/span>&lt;span class="o">=&lt;/span>io.x-k8s.kind.cluster&lt;span class="o">=&lt;/span>kind -q&lt;span class="sb">`&lt;/span>
&lt;span class="k">do&lt;/span>
docker &lt;span class="nb">exec&lt;/span> &lt;span class="nv">$i&lt;/span> ctr -n k8s.io -a /run/containerd/containerd.sock i ls &lt;span class="p">|&lt;/span>grep cilium
&lt;span class="k">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-helm-部署-cilium">使用 Helm 部署 Cilium&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ helm install cilium cilium/cilium --version 1.8.2 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --namespace kube-system &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.nodeinit.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.kubeProxyReplacement&lt;span class="o">=&lt;/span>partial &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hostServices.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.externalIPs.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.nodePort.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hostPort.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.pullPolicy&lt;span class="o">=&lt;/span>IfNotPresent &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set config.ipam&lt;span class="o">=&lt;/span>kubernetes &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hubble.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hubble.relay.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hubble.ui.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --set global.hubble.metrics.enabled&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;{dns,drop,tcp,flow,port-distribution,icmp,http}&amp;#34;&lt;/span>
NAME: cilium
LAST DEPLOYED: Wed Sep &lt;span class="m">2&lt;/span> 21:03:23 &lt;span class="m">2020&lt;/span>
NAMESPACE: kube-system
STATUS: deployed
REVISION: &lt;span class="m">1&lt;/span>
TEST SUITE: None
NOTES:
You have successfully installed Cilium with Hubble Relay and Hubble UI.
Your release version is 1.8.2.
For any further help, visit https://docs.cilium.io/en/v1.8/gettinghelp
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里对几个配置项做下说明：&lt;/p>
&lt;ul>
&lt;li>&lt;code>global.hubble.enabled=true&lt;/code> ： 表示启用 Hubble 。&lt;/li>
&lt;li>&lt;code>global.hubble.metrics.enabled=&amp;quot;{dns,drop,tcp,flow,port-distribution,icmp,http}&lt;/code>：表示 Hubble 暴露出的 metrics 中包含哪些内容，如果不指定则表示禁用它。&lt;/li>
&lt;li>&lt;code>global.hubble.ui.enabled=true&lt;/code> ：表示启用 Hubble UI&lt;/li>
&lt;/ul>
&lt;p>对于 Hubble 是什么，我们稍后再介绍。&lt;/p>
&lt;p>当 Cilium 部署完成后，我们可以查看下部署的 ns 下的 Pod 情况：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl -n kube-system get pods
NAME READY STATUS RESTARTS AGE
cilium-86dbc 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
cilium-cjcps 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
cilium-f8dtm 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
cilium-node-init-9r9cm 1/1 Running &lt;span class="m">1&lt;/span> 2m11s
cilium-node-init-bkg28 1/1 Running &lt;span class="m">1&lt;/span> 2m11s
cilium-node-init-jgx6r 1/1 Running &lt;span class="m">1&lt;/span> 2m11s
cilium-node-init-s7xhx 1/1 Running &lt;span class="m">1&lt;/span> 2m11s
cilium-operator-756cc96896-brlrh 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
cilium-t8kqc 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
coredns-f9fd979d6-7vfnq 1/1 Running &lt;span class="m">0&lt;/span> 6m16s
coredns-f9fd979d6-h7rfw 1/1 Running &lt;span class="m">0&lt;/span> 6m16s
etcd-kind-control-plane 1/1 Running &lt;span class="m">0&lt;/span> 6m19s
hubble-relay-666ddfd69b-2lpsz 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
hubble-ui-7854cf65dc-ncj89 1/1 Running &lt;span class="m">0&lt;/span> 2m11s
kube-apiserver-kind-control-plane 1/1 Running &lt;span class="m">0&lt;/span> 6m19s
kube-controller-manager-kind-control-plane 1/1 Running &lt;span class="m">0&lt;/span> 6m19s
kube-proxy-48rwk 1/1 Running &lt;span class="m">0&lt;/span> 6m16s
kube-proxy-8mn58 1/1 Running &lt;span class="m">0&lt;/span> 5m59s
kube-proxy-jptln 1/1 Running &lt;span class="m">0&lt;/span> 5m59s
kube-proxy-pp24h 1/1 Running &lt;span class="m">0&lt;/span> 5m59s
kube-scheduler-kind-control-plane 1/1 Running &lt;span class="m">0&lt;/span> 6m19s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 Node 的状态：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get nodes
NAME STATUS ROLES AGE VERSION
kind-control-plane Ready master 7m1s v1.19.0
kind-worker Ready &amp;lt;none&amp;gt; 6m26s v1.19.0
kind-worker2 Ready &amp;lt;none&amp;gt; 6m26s v1.19.0
kind-worker3 Ready &amp;lt;none&amp;gt; 6m26s v1.19.0
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="cilium-功能体验">Cilium 功能体验&lt;/h2>
&lt;h3 id="hubble-介绍">Hubble 介绍&lt;/h3>
&lt;p>上文中，通过 Helm 部署 Cilium 时，我们指定了一些与 Hubble 有关的参数，但尚未介绍 Hubble 具体是什么。这里简单介绍下。&lt;/p>
&lt;p>Hubble 是一个完全分布式的网络和安全性的可观察性平台，它建立在 Cilium 和 eBPF 之上，以完全透明的方式深入了解服务以及网络基础结构的通信和行为。&lt;/p>
&lt;p>由于它是构建在 Cilium 之上的，Hubble 可以利用 eBPF 获得可见性。通过使用 eBPF ，所有可见性都是可编程的，并且可以最大程度的减少开销，同时根据用户需要提供深入和详尽的可见性。例如：&lt;/p>
&lt;ul>
&lt;li>了解服务之间的依赖关系。可以观测到服务之间是否有通信，通信频率，以及 HTTP 调用产生的状态码等；&lt;/li>
&lt;li>监控网络和告警。可以观测到网络连接是否异常，是 L4 还是 L7 有问题，DNS 查询是否异常等；&lt;/li>
&lt;li>监控应用程序。可以观测到 HTTP 4xx/5xx 的错误率，HTTP 请求和响应的 95 值，99值等；&lt;/li>
&lt;li>监控安全问题。可以观测到哪些请求是被 Network Policy 所拒绝的，哪些服务解析了特定的域名等；&lt;/li>
&lt;/ul>
&lt;h3 id="可观察性">可观察性&lt;/h3>
&lt;p>我们可以直接使用 &lt;code>hubble observe&lt;/code> 观测当前集群中的连接情况：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ hubble-ui git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> kubectl &lt;span class="nb">exec&lt;/span> -n kube-system -t ds/cilium -- hubble observe
TIMESTAMP SOURCE DESTINATION TYPE VERDICT SUMMARY
Sep &lt;span class="m">2&lt;/span> 07:06:41.624 kube-system/coredns-f9fd979d6-h7rfw:8181 10.244.1.50:52404 to-stack FORWARDED TCP Flags: ACK, FIN
Sep &lt;span class="m">2&lt;/span> 07:06:41.625 10.244.1.50:52404 kube-system/coredns-f9fd979d6-h7rfw:8181 to-endpoint FORWARDED TCP Flags: ACK, FIN
Sep &lt;span class="m">2&lt;/span> 07:06:42.376 10.244.1.12:4240 10.244.0.76:45164 to-overlay FORWARDED TCP Flags: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:42.376 10.244.0.76:45164 10.244.1.12:4240 to-endpoint FORWARDED TCP Flags: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:42.778 10.244.1.50:37512 10.244.1.12:4240 to-endpoint FORWARDED TCP Flags: ACK, PSH
Sep &lt;span class="m">2&lt;/span> 07:06:42.778 10.244.1.12:4240 10.244.1.50:37512 to-stack FORWARDED TCP Flags: ACK, PSH
Sep &lt;span class="m">2&lt;/span> 07:06:44.941 10.244.1.50:59870 10.244.0.108:4240 to-overlay FORWARDED TCP Flags: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:44.941 10.244.1.12:4240 10.244.2.220:47616 to-overlay FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:44.941 10.244.1.50:52090 10.244.3.159:4240 to-overlay FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:44.941 10.244.1.50:52958 10.244.2.81:4240 to-overlay FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:44.941 10.244.2.220:47616 10.244.1.12:4240 to-endpoint FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:45.448 10.244.1.12:4240 10.244.3.111:54012 to-overlay FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:45.449 10.244.3.111:54012 10.244.1.12:4240 to-endpoint FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:47.631 kube-system/coredns-f9fd979d6-h7rfw:36120 172.18.0.4:6443 to-stack FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:47.822 10.244.1.50:60914 kube-system/coredns-f9fd979d6-h7rfw:8080 to-endpoint FORWARDED TCP Fla
gs: SYN
Sep &lt;span class="m">2&lt;/span> 07:06:47.822 kube-system/coredns-f9fd979d6-h7rfw:8080 10.244.1.50:60914 to-stack FORWARDED TCP Fla
gs: SYN, ACK
Sep &lt;span class="m">2&lt;/span> 07:06:47.822 10.244.1.50:60914 kube-system/coredns-f9fd979d6-h7rfw:8080 to-endpoint FORWARDED TCP Fla
gs: ACK
Sep &lt;span class="m">2&lt;/span> 07:06:47.823 kube-system/coredns-f9fd979d6-h7rfw:8080 10.244.1.50:60914 to-stack FORWARDED TCP Fla
gs: ACK, PSH
Sep &lt;span class="m">2&lt;/span> 07:06:47.823 kube-system/coredns-f9fd979d6-h7rfw:8080 10.244.1.50:60914 to-stack FORWARDED TCP Fla
gs: ACK, FIN
Sep &lt;span class="m">2&lt;/span> 07:06:47.823 10.244.1.50:60914 kube-system/coredns-f9fd979d6-h7rfw:8080 to-endpoint FORWARDED TCP Fla
gs: ACK, PSH
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到内容很详细，包括通信的两端，以及发的包是 &lt;code>ACK&lt;/code> 还是 &lt;code>SYN&lt;/code> 等信息均可观测到。&lt;/p>
&lt;h3 id="部署测试应用">部署测试应用&lt;/h3>
&lt;p>这里我们部署一个测试应用来实际体验下 Cilium 提供的强大功能。官方仓库中提供了一个 &lt;a href="https://raw.githubusercontent.com/cilium/cilium/HEAD/examples/kubernetes/connectivity-check/connectivity-check.yaml" title="connectivity-check">connectivity-check&lt;/a> 的测试用例，这里我对它做了精简和修改，以便理解。&lt;/p>
&lt;p>这里定义的内容如下：&lt;/p>
&lt;ul>
&lt;li>1 个名为 &lt;code>echo-a&lt;/code> 的 svc ，用于暴露 &lt;code>echo-a&lt;/code> 这个测试服务；&lt;/li>
&lt;li>4 个 deploy ，分别是 1 个测试服务，以及三个用于测试与 &lt;code>echo-a&lt;/code> 联通性的 deploy;&lt;/li>
&lt;li>2 个 CiliumNetworkPolicy，用来控制是否允许与 &lt;code>echo-a&lt;/code> 联通；&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ClusterIP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker.io/cilium/json-mock:1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;curl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-sS&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;--fail&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/dev/null&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;localhost&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-allowed-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-allowed-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-allowed-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-allowed-cnp-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker.io/byrnedo/alpine-curl:0.1.8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/ash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;sleep 1000000000&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;curl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-sS&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;--fail&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/dev/null&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;echo-a&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;curl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-sS&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;--fail&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/dev/null&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;echo-a&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium.io/v2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumNetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;pod-to-a-allowed-cnp&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">endpointSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-allowed-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">toEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">toPorts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;80&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">toEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s:io.kubernetes.pod.namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s:k8s-app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-dns&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">toPorts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;53&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">UDP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-l3-denied-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-l3-denied-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-l3-denied-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-l3-denied-cnp-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker.io/byrnedo/alpine-curl:0.1.8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/ash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;sleep 1000000000&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">7&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;ash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;! curl -sS --fail --connect-timeout 5 -o /dev/null echo-a&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">readinessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">timeoutSeconds&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">7&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;ash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;! curl -sS --fail --connect-timeout 5 -o /dev/null echo-a&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;cilium.io/v2&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CiliumNetworkPolicy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;pod-to-a-l3-denied-cnp&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">endpointSelector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-l3-denied-cnp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">egress&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">toEndpoints&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s:io.kubernetes.pod.namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">k8s:k8s-app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-dns&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">toPorts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;53&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">UDP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-to-a-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">docker.io/byrnedo/alpine-curl:0.1.8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/ash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;sleep 1000000000&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">livenessProbe&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;curl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-sS&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;--fail&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;-o&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;/dev/null&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;echo-a&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接部署即可：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl apply -f cilium-demo.yaml
service/echo-a created
deployment.apps/echo-a created
deployment.apps/pod-to-a-allowed-cnp created
ciliumnetworkpolicy.cilium.io/pod-to-a-allowed-cnp created
deployment.apps/pod-to-a-l3-denied-cnp created
ciliumnetworkpolicy.cilium.io/pod-to-a-l3-denied-cnp created
deployment.apps/pod-to-a created
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看 Pod 状态，看看状态是否正常：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get pods
NAME READY STATUS RESTARTS AGE
echo-a-8b6595b89-w9kt2 1/1 Running &lt;span class="m">0&lt;/span> 49s
pod-to-a-5567c85856-xsg5b 1/1 Running &lt;span class="m">0&lt;/span> 49s
pod-to-a-allowed-cnp-7b85c8db8-jrjhx 1/1 Running &lt;span class="m">0&lt;/span> 49s
pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm 1/1 Running &lt;span class="m">0&lt;/span> 49s
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="命令行观测">命令行观测&lt;/h3>
&lt;p>接下来，使用 &lt;code>hubble observe&lt;/code> 观察下效果，已经可以看到我们部署的应用产生的连接了。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl &lt;span class="nb">exec&lt;/span> -n kube-system -t ds/cilium -- hubble observe
TIMESTAMP SOURCE DESTINATION TYPE VERDICT SUMMARY
Sep &lt;span class="m">3&lt;/span> 00:00:13.481 default/pod-to-a-5567c85856-xsg5b:60784 default/echo-a-8b6595b89-w9kt2:80 to-endpoint FORWARDED TCP Flags: ACK, PSH
Sep &lt;span class="m">3&lt;/span> 00:00:15.429 kube-system/coredns-f9fd979d6-h7rfw:53 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:43696 to-endpoint FORWARDED UDP
Sep &lt;span class="m">3&lt;/span> 00:00:16.010 10.244.1.12:4240 10.244.2.220:50830 to-overlay FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:16.010 10.244.1.12:4240 10.244.1.50:40402 to-stack FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:16.010 10.244.1.50:40402 10.244.1.12:4240 to-endpoint FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:16.011 10.244.2.220:50830 10.244.1.12:4240 to-endpoint FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:16.523 10.244.1.12:4240 10.244.3.111:57242 to-overlay FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:16.523 10.244.3.111:57242 10.244.1.12:4240 to-endpoint FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:21.376 kube-system/coredns-f9fd979d6-h7rfw:53 default/pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm:44785 to-overlay FORWARDED UDP
Sep &lt;span class="m">3&lt;/span> 00:00:21.377 kube-system/coredns-f9fd979d6-h7rfw:53 default/pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm:44785 to-overlay FORWARDED UDP
Sep &lt;span class="m">3&lt;/span> 00:00:23.896 kube-system/coredns-f9fd979d6-h7rfw:36120 172.18.0.4:6443 to-stack FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:25.428 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 default/echo-a-8b6595b89-w9kt2:80 L3-L4 FORWARDED TCP Flags: SYN
Sep &lt;span class="m">3&lt;/span> 00:00:25.428 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 default/echo-a-8b6595b89-w9kt2:80 to-endpoint FORWARDED TCP Flags: SYN
Sep &lt;span class="m">3&lt;/span> 00:00:25.428 default/echo-a-8b6595b89-w9kt2:80 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 to-endpoint FORWARDED TCP Flags: SYN, ACK
Sep &lt;span class="m">3&lt;/span> 00:00:25.428 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 default/echo-a-8b6595b89-w9kt2:80 to-endpoint FORWARDED TCP Flags: ACK
Sep &lt;span class="m">3&lt;/span> 00:00:25.428 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 default/echo-a-8b6595b89-w9kt2:80 to-endpoint FORWARDED TCP Flags: ACK, PSH
Sep &lt;span class="m">3&lt;/span> 00:00:25.429 default/pod-to-a-allowed-cnp-7b85c8db8-jrjhx:55678 default/echo-a-8b6595b89-w9kt2:80 to-endpoint FORWARDED TCP Flags: ACK, FIN
Sep &lt;span class="m">3&lt;/span> 00:00:29.546 10.244.1.50:57770 kube-system/coredns-f9fd979d6-h7rfw:8080 to-endpoint FORWARDED TCP Flags: SYN
Sep &lt;span class="m">3&lt;/span> 00:00:29.546 kube-system/coredns-f9fd979d6-h7rfw:8080 10.244.1.50:57770 to-stack FORWARDED TCP Flags: SYN, ACK
Sep &lt;span class="m">3&lt;/span> 00:00:29.546 10.244.1.50:57770 kube-system/coredns-f9fd979d6-h7rfw:8080 to-endpoint FORWARDED TCP Flags: ACK
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="hubble-ui-观测">Hubble UI 观测&lt;/h3>
&lt;p>还记得我们在上文中部署 Cilium 时候配置的几个关于 Hubble 的参数么，现在我们可以使用 Hubble UI 来看看效果。&lt;/p>
&lt;p>先检查下 &lt;code>kube-system&lt;/code> ns 下，是否有 &lt;code>hubble-ui&lt;/code> 这个 svc 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ kubectl -n kube-system get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
hubble-metrics ClusterIP None &amp;lt;none&amp;gt; 9091/TCP 4m31s
hubble-relay ClusterIP 10.102.90.19 &amp;lt;none&amp;gt; 80/TCP 4m31s
hubble-ui ClusterIP 10.96.69.234 &amp;lt;none&amp;gt; 80/TCP 4m31s
kube-dns ClusterIP 10.96.0.10 &amp;lt;none&amp;gt; 53/UDP,53/TCP,9153/TCP 8m51s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接使用 &lt;code>kubectl port-forward&lt;/code> ，从本地来访问 Hubble UI 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl -n kube-system port-forward svc/hubble-ui 12000:80
Forwarding from 127.0.0.1:12000 -&amp;gt; &lt;span class="m">12000&lt;/span>
Forwarding from &lt;span class="o">[&lt;/span>::1&lt;span class="o">]&lt;/span>:12000 -&amp;gt; &lt;span class="m">12000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>浏览器中打开 &lt;a href="http://127.0.0.1:12000">http://127.0.0.1:12000&lt;/a> 即可。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/hubble-ui.png" alt="Hubble UI - https:/moelove.info">&lt;/p>
&lt;p>可以看到我们刚才部署的所有 Pod，以及查看到相应的 CiliumNetworkPolicy 等信息，这里就不赘述了，有兴趣的小伙伴可以自行探索下。&lt;/p>
&lt;h3 id="hubble-metrics-观测">Hubble metrics 观测&lt;/h3>
&lt;p>我们也可以使用 Hubble 暴露出来的 metrics 进行观测：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl port-forward -n kube-system ds/cilium 19091:9091
Forwarding from 127.0.0.1:19091 -&amp;gt; &lt;span class="m">9091&lt;/span>
Forwarding from &lt;span class="o">[&lt;/span>::1&lt;span class="o">]&lt;/span>:19091 -&amp;gt; &lt;span class="m">9091&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>简单看下其中的内容，包含各类请求/响应/丢弃等相关的统计信息，还有包括每个目标端口包的数量统计等。感兴趣的小伙伴可以自行探索下。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ curl -s localhost:19091/metrics &lt;span class="p">|&lt;/span> head -n &lt;span class="m">22&lt;/span>
&lt;span class="c1"># HELP hubble_dns_queries_total Number of DNS queries observed&lt;/span>
&lt;span class="c1"># TYPE hubble_dns_queries_total counter&lt;/span>
hubble_dns_queries_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1165&lt;/span>
hubble_dns_queries_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;AAAA&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1165&lt;/span>
&lt;span class="c1"># HELP hubble_dns_response_types_total Number of DNS queries observed&lt;/span>
&lt;span class="c1"># TYPE hubble_dns_response_types_total counter&lt;/span>
hubble_dns_response_types_total&lt;span class="o">{&lt;/span>&lt;span class="nv">qtypes&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>,type&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">233&lt;/span>
hubble_dns_response_types_total&lt;span class="o">{&lt;/span>&lt;span class="nv">qtypes&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;AAAA&amp;#34;&lt;/span>,type&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;AAAA&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">233&lt;/span>
&lt;span class="c1"># HELP hubble_dns_responses_total Number of DNS queries observed&lt;/span>
&lt;span class="c1"># TYPE hubble_dns_responses_total counter&lt;/span>
hubble_dns_responses_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Non-Existent Domain&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">932&lt;/span>
hubble_dns_responses_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;AAAA&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Non-Existent Domain&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">932&lt;/span>
hubble_dns_responses_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;No Error&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">233&lt;/span>
hubble_dns_responses_total&lt;span class="o">{&lt;/span>&lt;span class="nv">ips_returned&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>,qtypes&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;AAAA&amp;#34;&lt;/span>,rcode&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;No Error&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">233&lt;/span>
&lt;span class="c1"># HELP hubble_drop_total Number of drops&lt;/span>
&lt;span class="c1"># TYPE hubble_drop_total counter&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ICMPv4&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Policy denied&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">459&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ICMPv4&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Unsupported protocol for NAT masquerade&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">731&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ICMPv6&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Unsupported L3 protocol&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">213&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;TCP&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Policy denied&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1425&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;UDP&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Stale or unroutable IP&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">6&lt;/span>
hubble_drop_total&lt;span class="o">{&lt;/span>&lt;span class="nv">protocol&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Unknown flow&amp;#34;&lt;/span>,reason&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Policy denied&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1884&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="验证-ciliumnetworkpolicy-的效果">验证 CiliumNetworkPolicy 的效果&lt;/h3>
&lt;p>说了这么多，我们来验证下刚才部署的 CiliumNetworkPolicy 的实际效果吧。&lt;/p>
&lt;p>以下是刚才部署的测试 Pod， 我们通过这些 Pod 来访问 &lt;code>echo-a&lt;/code> 这个 svc 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get pods
NAME READY STATUS RESTARTS AGE
echo-a-8b6595b89-w9kt2 1/1 Running &lt;span class="m">0&lt;/span> 79m
pod-to-a-5567c85856-xsg5b 1/1 Running &lt;span class="m">0&lt;/span> 79m
pod-to-a-allowed-cnp-7b85c8db8-jrjhx 1/1 Running &lt;span class="m">0&lt;/span> 79m
pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm 1/1 Running &lt;span class="m">0&lt;/span> 79m
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>pod-to-a&lt;/code> 这是未配置任何 CiliumNetworkPolicy 规则的 Pod&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl &lt;span class="nb">exec&lt;/span> pod-to-a-5567c85856-xsg5b -- curl -sI --connect-timeout &lt;span class="m">5&lt;/span> echo-a
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
X-Powered-By: Express
Vary: Origin, Accept-Encoding
Access-Control-Allow-Credentials: &lt;span class="nb">true&lt;/span>
Accept-Ranges: bytes
Cache-Control: public, max-age&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
Last-Modified: Sat, &lt;span class="m">26&lt;/span> Oct &lt;span class="m">1985&lt;/span> 08:15:00 GMT
ETag: W/&lt;span class="s2">&amp;#34;83d-7438674ba0&amp;#34;&lt;/span>
Content-Type: text/html&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
Content-Length: &lt;span class="m">2109&lt;/span>
Date: Thu, &lt;span class="m">03&lt;/span> Sep &lt;span class="m">2020&lt;/span> 00:54:05 GMT
Connection: keep-alive
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>pod-to-a-allowed-cnp&lt;/code> 配置了允许通过 &lt;code>TCP&lt;/code> 访问 &lt;code>echo-a&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl &lt;span class="nb">exec&lt;/span> pod-to-a-allowed-cnp-7b85c8db8-jrjhx -- curl -sI --connect-timeout &lt;span class="m">5&lt;/span> echo-a
HTTP/1.1 &lt;span class="m">200&lt;/span> OK
X-Powered-By: Express
Vary: Origin, Accept-Encoding
Access-Control-Allow-Credentials: &lt;span class="nb">true&lt;/span>
Accept-Ranges: bytes
Cache-Control: public, max-age&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>
Last-Modified: Sat, &lt;span class="m">26&lt;/span> Oct &lt;span class="m">1985&lt;/span> 08:15:00 GMT
ETag: W/&lt;span class="s2">&amp;#34;83d-7438674ba0&amp;#34;&lt;/span>
Content-Type: text/html&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>UTF-8
Content-Length: &lt;span class="m">2109&lt;/span>
Date: Thu, &lt;span class="m">03&lt;/span> Sep &lt;span class="m">2020&lt;/span> 01:10:27 GMT
Connection: keep-alive
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>pod-to-a-l3-denied-cnp&lt;/code> 则是只配置了允许访问 DNS，而未配置允许对 &lt;code>echo-a&lt;/code> 的访问&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl exec pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm -- curl -sI --connect-timeout 5 echo-a
command terminated with exit code 28
&lt;/code>&lt;/pre>&lt;p>可以看到，如果对 Pod 应用了 CiliumNetworkPolicy , 但是未配置对应的允许规则的话，则代表不允许访问。&lt;/p>
&lt;p>比如，我们可以使用上面两个配置了 CiliumNetworkPolicy 的 Pod 来访问下公网域名：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl &lt;span class="nb">exec&lt;/span> pod-to-a-allowed-cnp-7b85c8db8-jrjhx -- curl -sI --connect-timeout &lt;span class="m">5&lt;/span> moelove.info
&lt;span class="nb">command&lt;/span> terminated with &lt;span class="nb">exit&lt;/span> code &lt;span class="m">28&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl &lt;span class="nb">exec&lt;/span> pod-to-a-l3-denied-cnp-7f64d7b7c4-fsxrm -- curl -sI --connect-timeout &lt;span class="m">5&lt;/span> moelove.info
&lt;span class="nb">command&lt;/span> terminated with &lt;span class="nb">exit&lt;/span> code &lt;span class="m">28&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，均不能正常访问。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本节，主要介绍了 Cilium 和 Hubble 等。&lt;/p>
&lt;p>通过使用 KIND 创建的 Kubernetes 集群，部署了 Cilium 及其相关组件，并通过一个实例，来展示了通过 &lt;code>hubble observe&lt;/code>，Hubble UI 及 Hubble metrics 等方式进行观测。&lt;/p>
&lt;p>也通过实际操作，验证了 CiliumNetworkPolicy 的实际效果。&lt;/p>
&lt;p>我主要是在为 Docker 写代码的过程中，会涉及到 &lt;code>LSM&lt;/code> 及 &lt;code>seccomp&lt;/code> 等部分，所以顺便去研究了 eBPF 及其相关技术（后续再分享这部分内容）。&lt;/p>
&lt;p>而 Cilium 则是我在 2019 年上半年开始学习和研究的，但正如我在去年的文章 &lt;a href="https://zhuanlan.zhihu.com/p/79757835" title="K8S 生态周报| cilium 1.6 发布 100% kube-proxy 的替代品">《K8S 生态周报| cilium 1.6 发布 100% kube-proxy 的替代品》&lt;/a> 中写的那样：&lt;/p>
&lt;blockquote>
&lt;p>这里稍微说几句我关于 Cilium 的看法：&lt;/p>
&lt;ul>
&lt;li>厉不厉害？厉害。&lt;/li>
&lt;li>值不值得研究？值得。&lt;/li>
&lt;li>会不会放到自己的集群替代 kube-proxy ？不会，最起码目前不会。&lt;/li>
&lt;/ul>
&lt;p>如果你想要通过 cilium 研究 eBPF 或者 XDP 我倒是建议你可以看看，是个很不错的项目，而且通过这个项目能加深很多网络方面的认识。这么说吧，如果把 cilium 的源码及所涉及原理都研究通透了，那就很厉害了。&lt;/p>
&lt;p>至于要不要替换 kube-proxy 在我看来，最起码目前我不会这样去做。解决问题的办法有很多种，而替换掉一个核心组件，却不一定是一个最值得的选择。&lt;/p>
&lt;/blockquote>
&lt;p>Cilium 是一个值得学习和研究的项目/技术，但我目前尚未将它放到生产环境中（这也是我少数花费很多精力研究，但未应用于生产的技术之一）。&lt;/p>
&lt;p>但现在看来， Cilium 也有了一定的市场/发展，是时候重新考量下了。后续我会继续分享 Cilium 及 eBPF 相关的技术文章，欢迎关注。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/eBPF/" term="eBPF" label="eBPF"/><category scheme="https://moelove.info/tags/cilium/" term="cilium" label="cilium"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.19 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.19-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/08/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.19-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-28T23:58:22+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.19 正式发布 本周 Kubernetes……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container" title="k8s生态">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v119-正式发布">Kubernetes v1.19 正式发布&lt;/h2>
&lt;p>本周 Kubernetes v1.19 正式发布，这是今年发布的第二个版本，也是耗时最长的一个版本。&lt;/p>
&lt;p>在此版本中有 34 个增强功能，其中 10 个GA，15 个 beta 以及 9 个 alpha。并且从 v1.19 开始，Kubernetes 每个版本的支持周期延长至 1 年。（感谢[ Long Term Support (LTS) working group ]（https://github.com/kubernetes/community/tree/master/wg-lts#readme &amp;quot;LTS WG&amp;quot;））&lt;/p>
&lt;p>关于此版本中重要的变更，可参考我每期周报中 “上游进展” 的部分。或者直接参考 &lt;a href="https://kubernetes.io/blog/2020/08/26/kubernetes-release-1.19-accentuate-the-paw-sitive/" title="v1.19 介绍">官方博客中 v1.19 的介绍文章&lt;/a> 。&lt;/p>
&lt;p>这里我来单独介绍一个更具体且实用的特性。&lt;/p>
&lt;h2 id="api-弃用规则">API 弃用规则&lt;/h2>
&lt;p>Kubernetes 是一个庞大的系统，当讨论它的 API 时，我们不得不提到常用的 4 个术语，即：group（组）, version（版本）, kind（类型）和 resource（资源）。&lt;/p>
&lt;p>一个 API group 是一组相关功能的集合，group + version 是确保 API 可随着时间推移，进行版本升级或功能更新的基础。&lt;/p>
&lt;p>这里我来介绍下 &lt;strong>自 Kubernetes v1.19 开始&lt;/strong> 针对 REST 资源（aka API 对象）在弃用策略相关的变更。&lt;/p>
&lt;p>当请求一个已标记为废弃的 REST API endpoint 时，会有如下行为：&lt;/p>
&lt;ul>
&lt;li>根据&lt;a href="https://tools.ietf.org/html/rfc7234#section-5.5" title="RFC7234"> RFC7234 &lt;/a> 会返回一个 &lt;code>Warning&lt;/code> header；&lt;/li>
&lt;li>添加一个 &lt;code>&amp;quot;k8s.io/deprecated&amp;quot;:&amp;quot;true&amp;quot;&lt;/code> annotation 到记录此次请求的 audit event 中；&lt;/li>
&lt;li>为 &lt;code>kube-apiserver&lt;/code> 进程设置一个类型为 Gauge 的 metric &lt;code>apiserver_requested_deprecated_apis&lt;/code> 的值为 &lt;code>1&lt;/code>。这个 metrics 有 &lt;code>group&lt;/code>, &lt;code>version&lt;/code>, &lt;code>resource&lt;/code>, &lt;code>subresource&lt;/code> 等标签。例如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">apiserver_requested_deprecated_apis&lt;span class="o">{&lt;/span>&lt;span class="nv">group&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;extensions&amp;#34;&lt;/span>,removed_release&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1.22&amp;#34;&lt;/span>,resource&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ingresses&amp;#34;&lt;/span>,subresource&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>,version&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;v1beta1&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这表示 &lt;code>extensions&lt;/code> 组 &lt;code>v1beta1&lt;/code> 版本的 &lt;code>ingresses&lt;/code> 资源将在 &lt;code>1.22&lt;/code> 版本移除。&lt;/p>
&lt;p>我们可以将这个指标和 &lt;code>apiserver_request_total&lt;/code> 这个指标进行组合查询，即可看到当前集群中有多少请求是在访问已废弃 API 的。&lt;/p>
&lt;p>例如使用如下查询条件，用来查询当前有多少请求将在 1.22 中移除的 API：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="n">apiserver_requested_deprecated_apis&lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="n">removed_release&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1.22&amp;#34;&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">version&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">resource&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">subresource&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">group_right&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">apiserver_request_total&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://moelove.info/img/k119-metrics-result.png" alt="K8S metrics - https://moelove.info">&lt;/p>
&lt;p>&lt;strong>使用场景&lt;/strong> 不知道你是否还记得 v1.18 中删除了很多已废弃的 API 版本，在集群版本升级时，我们需要确保已经更新/删除使用这些 API 版本的资源，以免在集群升级后，导致已部署资源的异常。&lt;/p>
&lt;p>当我们使用上面介绍的方法，直接组合 &lt;code>apiserver_requested_deprecated_apis&lt;/code> 指标和 &lt;code>apiserver_request_total&lt;/code> 指标进行查询，即可看到当前集群内是否有会受此影响的请求。&lt;/p>
&lt;p>关于此版本的详细变更请参考 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.19.md" title="v1.19 ReleaseNote">v1.19 的 ReleaseNote&lt;/a>。&lt;/p>
&lt;h2 id="prometheus-2210-rc0-发布">Prometheus 2.21.0-rc.0 发布&lt;/h2>
&lt;p>此版本使用 Go v1.15 构建，在 TLS 证书验证时，弃用了 &lt;a href="https://golang.org/doc/go1.15#commonname" title="X.509 CommonName">X.509 CommonName&lt;/a> 的支持。&lt;/p>
&lt;p>我们一起来看看此版本中值得注意的变更吧：&lt;/p>
&lt;ul>
&lt;li>新增的 Service Discovery：&lt;a href="https://github.com/prometheus/prometheus/pull/3369" title="Eureka SD">Eureka SD&lt;/a> 和 &lt;a href="https://github.com/prometheus/prometheus/pull/7822" title="Hetzner SD">Hetzner SD&lt;/a>;&lt;/li>
&lt;li>Kubernetes SD 现在已支持 &lt;a href="https://github.com/prometheus/prometheus/pull/6838" title="Kubernetes SD 支持 EndpointSlices">EndpointSlices&lt;/a>&lt;/li>
&lt;li>&lt;strong>新增 &lt;code>target_limit&lt;/code> 配置&lt;/strong> ，表示每次抓取能接受的 instance 数量。在 target relabel 之后，如果超过了此配置，则 Prometheus 会将其标记为失败。这是一项实验性功能，后续行为可能会有调整；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/7713">#7713&lt;/a> 在 PromQL 和 UI 中支持更易读的时间周期；&lt;/li>
&lt;li>&lt;a href="https://github.com/prometheus/prometheus/pull/7856">#7856&lt;/a> 修复了 &lt;code>chunks.HeadReadWriter: maxt of the files are not set&lt;/code> 的错误；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的变更，请参考其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.21.0-rc.0" title="Prometheus v2.21.0-rc.0 ReleaseNote">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="jaeger-v119-系列发布">jaeger v1.19 系列发布&lt;/h2>
&lt;p>本周连续发布了 v1.19.0 至 v1.19.2 版本，主要 bug 都集中在 UI 上。并且在 v1.19 中有一个已知的问题，&lt;a href="https://github.com/jaegertracing/jaeger/pull/2297">#2297&lt;/a> 是为 gRPC query 添加 TLS 支持，但未注册 flag ，所以此特性不能使用。计划是在 v1.20 中修复。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2336">#2336&lt;/a> 可配置的 UDP socket buffer size;&lt;/li>
&lt;li>&lt;a href="https://github.com/jaegertracing/jaeger/pull/2330">#2330&lt;/a> 默认支持批量且队列化的重试；&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>Kubernetes v1.16.15 将会是 Kubernetes v1.16 中的最后一个版本；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Google 选择 Cilium 作为 GKE 下一代数据面</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/23/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Google-%E9%80%89%E6%8B%A9-Cilium-%E4%BD%9C%E4%B8%BA-GKE-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E9%9D%A2/"/><id>https://moelove.info/2020/08/23/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Google-%E9%80%89%E6%8B%A9-Cilium-%E4%BD%9C%E4%B8%BA-GKE-%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E9%9D%A2/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-23T02:11:46+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Google 选择 Cilium 作为 GKE 网络……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="google-选择-cilium-作为-gke-网络的数据面">Google 选择 Cilium 作为 GKE 网络的数据面&lt;/h2>
&lt;p>&lt;img src="https://cilium.io/static/1a5e48f755419401103235a6a01de4fd/906b5/google_header.png" alt="GKE &amp; Cilium">&lt;/p>
&lt;p>Google &lt;a href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-ebpf-and-cilium-to-google-kubernetes-engine" title="GKE 使用 Cilium 的声明">声明&lt;/a>将选择 &lt;a href="https://cilium.io/" title="Cilium 主页">Cilium&lt;/a> 作为 GKE 网络的数据面 V2 以便增加其容器安全性和可观测性。&lt;/p>
&lt;p>Kubernetes 最强的能力之一便是其开发者优先的网络模型，可以提供简单易用的功能，比如： L3/L4 service 和 L7 ingress 以便将流量引入 Kubernetes 集群，以及多租户的网络隔离等。&lt;/p>
&lt;p>但随着越来越多的企业使用 Kubernetes , 用例范围越来越广，围绕多云，安全性，可观察性和可扩展性等方面均提出了新的要求。此外，诸如 service mesh 和 serverless 等技术，均需要来自底层 Kubernetes 的更多自定义。这些新要求最终汇聚到一起得出来的结论便是： &lt;strong>需要一个更具可编程性的数据平面&lt;/strong>，该平面可执行 Kubernetes 感知的数据包操作，并且还不会损失性能。&lt;/p>
&lt;p>Cilium 的出现恰恰满足了这些需求，它基于 eBPF 技术的实现，使 Linux 内核具备了 Kubernetes 的意识。它可以很好的满足现在新的对容器负载的可伸缩性，可观察性以及安全等方面相关的要求。此外， Cilium 所提供的功能也远超了传统 CNI 提供的功能，不仅有传统的 Network Policy， service 和 LB ，还有 Flow &amp;amp; Policy logging 以及内置运维和安全侧的 metrics 等。&lt;/p>
&lt;h3 id="背后的故事">背后的故事&lt;/h3>
&lt;p>Google 首次参与 Cilium 项目大概是去年 12 月，后来越来越多的 Google 工程师加入进来，也贡献了很多核心功能，比如上文中提到的 Policy Logging 等功能。此外还有很多，比如自动检测 EndpointSlices ，对 Pod IP 的 IPv6 邻居发现的支持，还有基于 socket cookie 的负载均衡等。&lt;/p>
&lt;p>当然，Google 是有实力可以直接基于 eBPF 来构建其数据平面的，但它选择了参与 Cilium 社区，这也是对 Cilium 社区多年来工作的认可，这也让社区成员非常开心。&lt;/p>
&lt;p>相信今后将会有更多有趣的特性被加入进来。&lt;/p>
&lt;p>以下是 Cilium 主要的功能：&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/714c5d777b0025dda66b46f14e28badc01e3e3360ef264be204f54846a7c9573/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f63696c69756d2f63696c69756d406d61737465722f446f63756d656e746174696f6e2f696d616765732f63696c69756d5f6f766572766965772e706e67" alt="Cilium 核心功能 - https://moelove.info">&lt;/p>
&lt;p>&lt;strong>在去年 8 月份的 &lt;a href="https://zhuanlan.zhihu.com/p/79757835" title="cilium 1.6 发布">《K8S 生态周报| cilium 1.6 发布 100% kube-proxy 的替代品》&lt;/a> 一文中，我就曾介绍过 Cilium 项目及其所用技术，也针对该项目写了自己的看法，感兴趣的朋友可以看看。&lt;/strong>&lt;/p>
&lt;p>另外一个比较有意思的信息是，2017 年 Google 与 Calico 背后的公司 Tigera 合作，为 GKE 引入了 Calico 。Cilium 是否会取代 Calico 呢？&lt;/p>
&lt;p>最后，如果你想要在 GKE 中使用 Cilium ，可以使用如下命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">gcloud beta container clusters create &amp;lt;cluster name&amp;gt; &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --enable-dataplane-v2 --release-channel rapid &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --cluster-version 1.17.9-gke.600 --zone &amp;lt;zone name&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="containerd-v140-发布">containerd v1.4.0 发布&lt;/h2>
&lt;p>本周 containerd 终于迎来了 v1.4.0 版本的正式发布，距离上一个正式大版本 v1.3.0 已经过去了近 10 个月，并且在正式发布之前，也先后经过了 3 个 beta 版本和 2 个 rc 版，可以看出此次发布还是很慎重的。&lt;/p>
&lt;p>我在&lt;a href="https://zhuanlan.zhihu.com/p/178227659" title="containerd v1.4.0-rc0 发布">之前的 《K8S 生态周报| runc v1.0-rc92 发布》&lt;/a> 一文中，介绍过 containerd v1.4.0-rc.0 相关的内容，有兴趣的朋友可以结合着看。&lt;/p>
&lt;p>以下是此 v1.4 中较为关键的特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>支持镜像的 lazy pull:&lt;/p>
&lt;ul>
&lt;li>主要适用场景：FaaS，Python/Ruby/Java/dotNet 等镜像环境；&lt;/li>
&lt;li>实现插件 &lt;a href="https://github.com/containerd/stargz-snapshotter" title="stargz-snapshotter">stargz-snapshotter&lt;/a>;&lt;/li>
&lt;li>基于 Stargz/CRFS 完成；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CRI 模式下支持 MCS 多类别的安全；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加 cgroup v2 的支持：&lt;/p>
&lt;ul>
&lt;li>支持 eBPF 集成；&lt;/li>
&lt;li>改善 OOM 控制；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>改善 rootless 模式的支持；&lt;/p>
&lt;ul>
&lt;li>资源控制需要 systemd 和 cgroup v2 的支持；&lt;/li>
&lt;li>overlayfs snapshotter 可通过 FUSE-overlayfs 完成，需要 4.18 及以上内核；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>支持不重启 daemon 的情况下，重加载 CNI 配置；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本中的变更，请查看其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.4.0" title="containerd v1.4 release note">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-v17-正式发布">Istio v1.7 正式发布&lt;/h2>
&lt;p>Istio v1.7 主要集中在易用性，安全性和可靠性上，并针对非 Kubernetes 环境做了一些优化。&lt;/p>
&lt;p>在易用性方面，新版本中提供了 &lt;a href="https://istio.io/latest/docs/ops/diagnostic-tools/istioctl-analyze/" title="Istio 分析工具">Istio 分析工具&lt;/a> 可通过 &lt;code>istioctl analyze --all-namespaces&lt;/code> 使用；&lt;/p>
&lt;p>在可靠性方面，你可以将&lt;a href="https://medium.com/@marko.luksa/delaying-application-start-until-sidecar-is-ready-2ec2d21a7b74" title="istio 延迟启动">应用程序的启动延迟到 sidecar 启动之后&lt;/a>；&lt;/p>
&lt;p>安全性方面，主要就是针对非 Kubernetes （VM） 环境的一些优化了。&lt;/p>
&lt;p>感兴趣的朋友可以参考其 &lt;a href="https://istio.io/latest/news/releases/1.7.x/announcing-1.7/" title="Istio v1.7">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="k3s-成为了-cncf-sandbox-项目">k3s 成为了 CNCF sandbox 项目&lt;/h2>
&lt;p>k3s 目标是提供一种通过 CNCF 一致性认证的生产级 Kubernetes 发行版，但相比 Kubernetes 而言更加轻量和易于配置。主要受众目标是：&lt;/p>
&lt;ul>
&lt;li>Edge&lt;/li>
&lt;li>IoT&lt;/li>
&lt;li>CI Pipeline&lt;/li>
&lt;li>开发到生产一致的环境&lt;/li>
&lt;li>ARM 设备&lt;/li>
&lt;/ul>
&lt;p>它主要依赖的组件如下：&lt;/p>
&lt;ul>
&lt;li>containerd 和 runc&lt;/li>
&lt;li>Flannel&lt;/li>
&lt;li>CoreDNS&lt;/li>
&lt;li>CNI&lt;/li>
&lt;li>Host utilities (iptables, socat, etc)&lt;/li>
&lt;li>Ingress controller (traefik)&lt;/li>
&lt;li>Embedded service loadbalancer&lt;/li>
&lt;li>Embedded network policy controller&lt;/li>
&lt;/ul>
&lt;p>就我个人而言，我对 k3s 的了解&amp;amp;兴致仅限于它刚发布之时，后续偶尔会稍微看下相关的信息，但未在生产中使用过。&lt;/p>
&lt;p>现在 k3s 的定位已经明确为 Kubernetes 的一种发行版，我觉得这个决定还是很明智的（相比 fork 而言）。之前听说国内有几个公司在搞 k3s on ARM 之类的，不过也没听到后续的结果，可能还是会面临一些问题吧。&lt;/p>
&lt;p>生产使用我个人还是建议选择 Kubernetes 或者可选择 OpenShift 之类的。（有特殊场景或需求的另说）&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>以上便是我觉得本周值得关注的内容了，上周发起的“关于使用 Helm v2 or v3 ”的投票结果出来了， 参与投票的朋友中有 7 成在用 Helm v3 。&lt;/p>
&lt;p>本期讨论内容： &lt;strong>你在用哪个网络插件呢？以及选择它的原因&lt;/strong> ， 欢迎留言参与讨论！&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v2 进入维护期倒计时</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E8%BF%9B%E5%85%A5%E7%BB%B4%E6%8A%A4%E6%9C%9F%E5%80%92%E8%AE%A1%E6%97%B6/"/><id>https://moelove.info/2020/08/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E8%BF%9B%E5%85%A5%E7%BB%B4%E6%8A%A4%E6%9C%9F%E5%80%92%E8%AE%A1%E6%97%B6/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-15T15:39:19+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v2 将正式废弃 本周……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v2-将正式废弃">Helm v2 将正式废弃&lt;/h2>
&lt;p>本周，Helm v2 系列发布了 v2.16.10 版本， &lt;strong>这是 Helm v2 的最后一个 bugfix 版本&lt;/strong>，此后不会再为 Helm v2 提供错误修复。并且在三个月后，将停止为 Helm v2 提供安全补丁。届时， Helm v2 也就完全废弃，不会再去维护了。&lt;/p>
&lt;p>如果有在使用 Helm v2 的小伙伴，请尽快升级至 Helm v3， 社区也提供了 &lt;a href="https://github.com/helm/helm-2to3" title="helm 2to3">Helm 2to3&lt;/a> 的工具，可以帮助迁移。&lt;/p>
&lt;p>另外，还有个别厂商绑定 Helm v2 提供应用安装/部署服务的，也建议尽快迁移了。&lt;/p>
&lt;p>我统计了下，我发布的文章中，有 25 篇与 Helm 相关。包括 &lt;a href="https://zhuanlan.zhihu.com/container">Helm v3 的尝试&lt;/a>，&lt;a href="https://zhuanlan.zhihu.com/container">Helm v2 的废弃计划&lt;/a>，&lt;a href="https://zhuanlan.zhihu.com/container">从 Helm v2 迁移到 v3&lt;/a> 等内容，感兴趣的小伙伴可以看看历史文章。&lt;/p>
&lt;h2 id="dockerhub-修改了定价和-tos">DockerHub 修改了定价和 TOS&lt;/h2>
&lt;p>DockerHub 本周对其服务收费以及 &lt;a href="https://www.docker.com/legal/docker-terms-service" title="Docker TOS">TOS（Terms of Service）&lt;/a>。我们重点来看看本次的修改对我们会有哪些影响吧。&lt;/p>
&lt;p>这里重点来看看对免费用户/（未登录）匿名用户的影响。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>流量限制&lt;/strong>&lt;/p>
&lt;p>未登录用户每 6 小时，允许 Pull 100 次；
已登录用户每 6 小时，允许 Pull 200 次；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>镜像保留策略变更&lt;/p>
&lt;p>非活跃镜像，保留周期为 6 个月。在清理之前，会发送通知告知会进行清理等操作。其中， &lt;strong>非活跃镜像&lt;/strong> 指的是无 push 或 pull 操作等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个影响有多大呢？首先是流量限制方面，如果你维护着一个包含 20 个 Node 的 Kubernetes 集群，并假设它们的公网出口一致。那你 6 个小时内，平均每个 Node 上只能从 DockerHub 拉取 5 次镜像。&lt;/p>
&lt;p>在镜像保留策略这里，如果你曾经构建过一个镜像，但没什么人用，且很久未更新，那就极有可能被清理掉了。你可以通过 DockerHub 页面上镜像的更新时间来查看下镜像的情况。当然，Docker 团队也宣称会在 DockerHub 上提供一个 Dashboard ，方便查看当前镜像的健康程度。&lt;/p>
&lt;p>这个镜像保留策略的生效时间，是从今年的 11 月 1 日开始实施，届时大家最好关注下自己的镜像。&lt;/p>
&lt;p>最后，说一下 Docker 为何要增加这个“镜像保留策略” 的条款，那是因为当前 DockerHub 保留的镜像数据超过了 15PB，但其中有 4.5PB 左右属于无效镜像，通过此次新的策略，应该可以为 DockerHub 节约不少的（S3）存储支出。&lt;/p>
&lt;h2 id="rook-v141-发布">Rook v1.4.1 发布&lt;/h2>
&lt;p>Rook 也迎来了其 v1.4 系列版本，此次版本中有一些非常值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不再支持来自 Ceph-CSI 驱动的 Alpha 快照，只支持 Beta 快照了；&lt;/p>
&lt;ul>
&lt;li>此版本中默认部署了 &lt;a href="https://github.com/ceph/ceph-csi/releases/tag/v3.0.0" title="ceph-csi 3.0">Ceph-CSI 3.0&lt;/a>;&lt;/li>
&lt;li>包括多架构的 Docker 镜像支持；&lt;/li>
&lt;li>可以为 RBD 创建或删除 Beta 快照，同时移除 Alpha 快照的支持；&lt;/li>
&lt;li>可以从 RBD 快照创建 PVC ；&lt;/li>
&lt;li>可以为 RDB 和 CephFS 支持 ROX 卷；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如果 dashboard 模块开启，则将会为 ceph 对象存储开启 dashboard；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实验性的增加了一个 admission controller ，可进行 CRD 校验，但是默认是不开启的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>CephObjectStore&lt;/code> CRD 将其健康状态展示在 &lt;code>Status&lt;/code> 字段中了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>OSD&lt;/code> 可以通过在 &lt;code>storageClassDeviceSet&lt;/code> 设置 &lt;code>encrypted: true&lt;/code> 进行加密了；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/93929" title="#93929">#93929&lt;/a> 对 Ingress TLS 的 secretName 增加了校验。当创建了一个 &lt;code>networking.k8s.io/v1&lt;/code> 的 Ingress 对象，会校验 &lt;code>spec.tls[*].secretName&lt;/code> 字段；&lt;/li>
&lt;li>Kubernetes v1.19 计划于 8 月 25 日发布，届时默认 Go 版本为 v1.15；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| runc v1.0-rc92 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0-rc92-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/08/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0-rc92-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-09T23:07:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 微软开源了 Open Service Mesh 微……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="微软开源了-open-service-mesh">微软开源了 Open Service Mesh&lt;/h2>
&lt;p>微软近期开源了一个新的名为 &lt;a href="https://github.com/openservicemesh/osm/" title="OSM">Open Service Mesh&lt;/a> 的项目并准备&lt;a href="https://github.com/cncf/toc/pull/507" title="捐赠提案">捐赠给 CNCF&lt;/a> 。&lt;/p>
&lt;p>OSM 主打轻量&amp;amp;可扩展，支持 &lt;a href="https://smi-spec.io/" title="SMI">Service Mesh Interface (SMI) 规范&lt;/a> 附带开箱即用的可观察性功能。截至目前，已经发布了v0.2.0 版本。&lt;/p>
&lt;p>主要特性如下：&lt;/p>
&lt;ul>
&lt;li>支持 Service Mesh Interface (SMI) 的规范，主要包括 &lt;code>Traffic Access Control&lt;/code>， &lt;code>Traffic Specs&lt;/code> 和 &lt;code>Traffic Split&lt;/code> 。剩下的 &lt;code>Traffic Metrics&lt;/code> 正在开发中；&lt;/li>
&lt;li>服务间的通信加密使用 mTLS ；&lt;/li>
&lt;li>定义和执行服务间的&lt;a href="https://github.com/servicemeshinterface/smi-spec/blob/v0.5.0/apis/traffic-access/v1alpha2/traffic-access.md" title="访问控制">访问控制&lt;/a>策略；&lt;/li>
&lt;li>通过 Prometheus 和 Grafana 完成其观察性；&lt;/li>
&lt;li>可与外部证书管理服务进行集成；&lt;/li>
&lt;li>&lt;a href="https://github.com/openservicemesh/osm/blob/main/docs/patterns/sidecar_injection.md" title="sidecar 注入">Envoy sidecar &lt;/a> 自动注入；&lt;/li>
&lt;/ul>
&lt;p>关于 Open Service Mesh 更详细的内容，请参考我上一篇文章 &lt;a href="https://zhuanlan.zhihu.com/p/171550414" title="初试 Open Service Mesh（OSM）">初试 Open Service Mesh（OSM）&lt;/a>&lt;/p>
&lt;h2 id="runc-v10-rc92-发布">runc v1.0-rc92 发布&lt;/h2>
&lt;p>这个版本在本周发布，主要是因为上个版本 v1.0-rc91 发布之后，我发现了它会导致 Docker 无法使用 &lt;code>--privileged&lt;/code> 参数运行一个容器，总是会提示 &lt;code>invalid argument&lt;/code> 这个错误。&lt;/p>
&lt;p>查看代码后，发现它来自于 Golang 中 &lt;code>golang.org/x/sys/unix&lt;/code> 的 &lt;code>unix.Mknod()&lt;/code> 这个方法，这其实是一个系统调用。本着求真务实的态度，我去检查了下这个函数的源码， glibc 以及 linux kernel 的源码，一番折腾后，也定位到了问题所在。&lt;/p>
&lt;p>发现问题来自于 runc 的某次修改，并联系到了 runc 的维护者 &lt;em>Aleksa Sarai&lt;/em> ，他在&lt;a href="https://github.com/opencontainers/runc/commit/24388be71e1aef7facd0d78dda22e696c1694272">一次更新中&lt;/a> 删除了一段用于检查设备类型的代码，所以才导致了隐藏在 runc 中的 bug 这次被暴露了出来。&lt;/p>
&lt;p>而这个 bug 目前只影响到了 Docker ，并未影响 runc 作为容器运行时自身的功能。&lt;/p>
&lt;p>随后 &lt;em>Aleksa Sarai&lt;/em> 提交代码进行了漏洞修复，我们来看看这段折腾了我好几天的代码：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- switch {
&lt;/span>&lt;span class="gd">- case mode&amp;amp;unix.S_IFBLK == unix.S_IFBLK:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ switch mode &amp;amp; unix.S_IFMT {
&lt;/span>&lt;span class="gi">+ case unix.S_IFBLK:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.BlockDevice
&lt;span class="gd">- case mode&amp;amp;unix.S_IFCHR == unix.S_IFCHR:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ case unix.S_IFCHR:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.CharDevice
&lt;span class="gd">- case mode&amp;amp;unix.S_IFIFO == unix.S_IFIFO:
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ case unix.S_IFIFO:
&lt;/span>&lt;span class="gi">&lt;/span> devType = configs.FifoDevice
default:
return nil, ErrNotADevice
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实就是一段用来判断系统设备类型的代码，但很遗憾，之前的类型判定一直都是错误的，用来判定设备类型，不能使用类似 &lt;code>mode&amp;amp;unix.S_IFBLK == unix.S_IFBLK&lt;/code> 这样的方法，而是需要使用 &lt;code>mode &amp;amp; unix.S_IFMT&lt;/code> 作为判定。&lt;/p>
&lt;p>这在 Linux 内核的源码中也早有体现 &lt;a href="https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/include/uapi/linux/stat.h#L21-L27">https://github.com/torvalds/linux/blob/bcf876870b95592b52519ed4aafcf9d95999bc9c/include/uapi/linux/stat.h#L21-L27&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/stat.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#define S_ISLNK(m) (((m) &amp;amp; S_IFMT) == S_IFLNK)
&lt;/span>&lt;span class="cp">#define S_ISREG(m) (((m) &amp;amp; S_IFMT) == S_IFREG)
&lt;/span>&lt;span class="cp">#define S_ISDIR(m) (((m) &amp;amp; S_IFMT) == S_IFDIR)
&lt;/span>&lt;span class="cp">#define S_ISCHR(m) (((m) &amp;amp; S_IFMT) == S_IFCHR)
&lt;/span>&lt;span class="cp">#define S_ISBLK(m) (((m) &amp;amp; S_IFMT) == S_IFBLK)
&lt;/span>&lt;span class="cp">#define S_ISFIFO(m) (((m) &amp;amp; S_IFMT) == S_IFIFO)
&lt;/span>&lt;span class="cp">#define S_ISSOCK(m) (((m) &amp;amp; S_IFMT) == S_IFSOCK)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终，这个修复被合并了，Docker 也可以继续和新版本的 runc 一起工作了。(个人体会就是，有些 bug 隐藏太深，这段代码我之前看过，但太像了，被我给忽略掉了 orz)&lt;/p>
&lt;h2 id="containerd-v140-rc0-发布">containerd v1.4.0-rc.0 发布&lt;/h2>
&lt;p>这是 containerd 的第 5 个主要版本，此版本中包含了大量的更新，比如对 CGroups v2 的支持，扩展的 SELinux 支持，通过 CRI 提供了 Kubernetes On Windows 的支持，共享远端存储的快照支持等。&lt;/p>
&lt;p>此版本中包含的重大 bug 的修复也会移植到当前还受支持的版本中。此外，在这个版本中，也包含了两个不向后兼容的 API 修改，需要注意。&lt;/p>
&lt;p>以下是我觉得值得关注的变更：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/3726," title="3726">#3726&lt;/a> 添加对 CGroups v2 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4384," title="4384">#4384&lt;/a> 标记 &lt;code>io.containerd.runtime.v1.*&lt;/code> 和 &lt;code>io.containerd.runc.v1&lt;/code> 这两个 runtime 为废弃。 &lt;strong>在当前 Docker v19.03.x 版本中，默认的 runtime 调用的 API 就是 io.containerd.runtime.v1.linux , 如果要升级 Docker 或者单独升级 containerd ， 需要格外注意&lt;/strong>;&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/3765," title="3765">#3765&lt;/a> 支持 FUSE 挂载；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/3972," title="3972">#3972&lt;/a> 修复了镜像并发下载的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/3925," title="3925">#3925&lt;/a> 为快照添加了 &lt;code>cleanup&lt;/code> 的 API；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4439," title="4439">#4439&lt;/a> 安装 containerd 的时候， 不需要在额外安装 &lt;code>libseccomp&lt;/code>， 内置了；&lt;/li>
&lt;/ul>
&lt;p>以上就是我认为 containerd v1.4.0-rc.0 中值得注意的变更，更多关于此版本的信息，请参考其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.4.0-rc.0," title="containerd v1.4 release note">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-v190313-beta2-发布">Docker v19.03.13-beta2 发布&lt;/h2>
&lt;p>本次版本主要是进行一些 bugfix，目前没什么太值得单独聊的，本期暂且跳过，等正式版本发布时再具体聊。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/93570," title="93570">#93570&lt;/a> componentstatus API 被标记废弃。&lt;/p>
&lt;p>有时，我们会通过 &lt;code>kubectl get componentstatus&lt;/code> 来查看集群组件是否健康。例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get componentstatus
NAME STATUS MESSAGE ERROR
controller-manager Healthy ok
scheduler Healthy ok
etcd-0 Healthy &lt;span class="o">{&lt;/span>&lt;span class="s2">&amp;#34;health&amp;#34;&lt;/span>:&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但随着 secure port 相继被启用，这个 API 已经不能很好的正常工作了。 所以现在将其标记为废弃，不建议再通过此 API 来获取集群组件的状态信息了。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">初试 Open Service Mesh（OSM）</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/07/%E5%88%9D%E8%AF%95-Open-Service-MeshOSM/"/><id>https://moelove.info/2020/08/07/%E5%88%9D%E8%AF%95-Open-Service-MeshOSM/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-07T00:19:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">微软近期开源了一个新的名为 Open Service Mesh 的项目并准备捐赠给 CNCF 。 基本介绍 Open Service Mesh (OSM) is a lightweight, extensible, Cloud Native service mesh that allows users to uniformly manage, secure, and get out-of-the-box observability features for highly dynamic microservice environments. Open Service Me……</summary><content type="html">&lt;p>微软近期开源了一个新的名为 &lt;a href="https://github.com/openservicemesh/osm/" title="OSM">Open Service Mesh&lt;/a> 的项目并准备&lt;a href="https://github.com/cncf/toc/pull/507" title="捐赠提案">捐赠给 CNCF&lt;/a> 。&lt;/p>
&lt;h2 id="基本介绍">基本介绍&lt;/h2>
&lt;blockquote>
&lt;p>Open Service Mesh (OSM) is a lightweight, extensible, Cloud Native service mesh that allows users to uniformly manage, secure, and get out-of-the-box observability features for highly dynamic microservice environments.&lt;/p>
&lt;/blockquote>
&lt;p>Open Service Mesh（OSM）是一个轻量级，可扩展的云原生服务网格，它使用户能够统一管理，保护和获得针对高度动态微服务环境的开箱即用的可观察性功能。&lt;/p>
&lt;p>OSM 在 Kubernetes 上运行基于 Envoy 的控制平面，可以使用 SMI API 进行配置。它通过以 sidecar 的形式注入 Envoy 代理来工作。&lt;/p>
&lt;p>控制面负责持续配置代理，以配置策略和路由规则等都保持最新。代理主要负责执行访问控制的规则，路由控制，采集 metrics 等。（这和目前我们常见到的 Service Mesh 方案基本都一样的）&lt;/p>
&lt;h2 id="显著特性">显著特性&lt;/h2>
&lt;ul>
&lt;li>基于 Service Mesh Interface (SMI) 的实现，主要包括 &lt;code>Traffic Access Control&lt;/code>， &lt;code>Traffic Specs&lt;/code> 和 &lt;code>Traffic Split&lt;/code> 。剩下的 &lt;code>Traffic Metrics&lt;/code> 正在开发中；&lt;/li>
&lt;li>服务间的通信加密使用 mTLS ；&lt;/li>
&lt;li>定义和执行服务间的&lt;a href="https://github.com/servicemeshinterface/smi-spec/blob/v0.5.0/apis/traffic-access/v1alpha2/traffic-access.md" title="访问控制">访问控制&lt;/a>策略；&lt;/li>
&lt;li>通过 Prometheus 和 Grafana 完成其观察性；&lt;/li>
&lt;li>可与外部证书管理服务进行集成；&lt;/li>
&lt;li>&lt;a href="https://github.com/openservicemesh/osm/blob/main/docs/patterns/sidecar_injection.md" title="sidecar 注入">Envoy sidecar &lt;/a> 自动注入；&lt;/li>
&lt;/ul>
&lt;h2 id="上手体验">上手体验&lt;/h2>
&lt;p>只做介绍未免太过无趣，而且说实话，这么多 service mesh 实现，不亲自上手试试看，感觉不出来太多差异的。&lt;/p>
&lt;p>这里我使用 &lt;a href="https://kind.sigs.k8s.io/" title="Kubernetes In Docker">KIND&lt;/a> 作为我本地的实验环境。&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>安装过程很简单，直接去 &lt;a href="https://github.com/openservicemesh/osm/releases" title="osm Release 页面">Release 页面&lt;/a> 下载预编译好的二进制文件。可将二进制文件加入到 &lt;code>$PATH&lt;/code> 中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ wget -q https://github.com/openservicemesh/osm/releases/download/v0.1.0/osm-v0.1.0-linux-amd64.tar.gz
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ tar -xzvf osm-v0.1.0-linux-amd64.tar.gz
linux-amd64/
linux-amd64/LICENSE
linux-amd64/README.md
linux-amd64/osm
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ &lt;span class="nb">cd&lt;/span> linux-amd64
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ linux-amd64 ls
LICENSE osm README.md
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在进行 osm 资源和服务的正式安装前，先做个必要的检查：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ linux-amd64 ./osm check --pre-install
ok: initialize Kubernetes client
ok: query Kubernetes API
ok: Kubernetes version
ok: can create namespaces
ok: can create customresourcedefinitions
ok: can create clusterroles
ok: can create clusterrolebindings
ok: can create mutatingwebhookconfigurations
ok: can create serviceaccounts
ok: can create services
ok: can create deployments
ok: can create configmaps
ok: can &lt;span class="nb">read&lt;/span> secrets
ok: can modify iptables
All checks successful!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到主要是和权限相关的一些检查。接下来就正式对 ocm 相关资源进行部署。&lt;/p>
&lt;p>默认使用的镜像，托管在 DockerHub 上，如果需要配置加速的小伙伴，可传递 &lt;code>--container-registry&lt;/code> 更改源地址，以便于加速安装进度。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ linux-amd64 ./osm install
OSM installed successfully in namespace &lt;span class="o">[&lt;/span>osm-system&lt;span class="o">]&lt;/span> with mesh name &lt;span class="o">[&lt;/span>osm&lt;span class="o">]&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ linux-amd64 kubectl -n osm-system get pods
NAME READY STATUS RESTARTS AGE
osm-controller-d499d6cc7-88659 0/1 ContainerCreating &lt;span class="m">0&lt;/span> 12s
osm-grafana-58ff65dfb7-svztv 0/1 ContainerCreating &lt;span class="m">0&lt;/span> 12s
osm-prometheus-5756769877-zj6f6 0/1 ContainerCreating &lt;span class="m">0&lt;/span> 12s
zipkin-6df4b57677-dcq8q 0/1 ContainerCreating &lt;span class="m">0&lt;/span> 12s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到默认安装完成后，都在 &lt;code>osm-system&lt;/code> 命名空间下，有 4 个 Pods&lt;/p>
&lt;ul>
&lt;li>osm-controller：控制谬&lt;/li>
&lt;li>osm-grafana：Dashboard 相关，可通过 &lt;code>osm dashboard&lt;/code> 命令唤起；&lt;/li>
&lt;li>osm-prometheus：采集 metrics ；&lt;/li>
&lt;li>zipkin：链路追踪&lt;/li>
&lt;/ul>
&lt;p>还有对应的 service 记录.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ linux-amd64 kubectl -n osm-system get svc
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT&lt;span class="o">(&lt;/span>S&lt;span class="o">)&lt;/span> AGE
osm-controller ClusterIP 10.97.115.1 &amp;lt;none&amp;gt; 15128/TCP,443/TCP 7m46s
osm-grafana ClusterIP 10.110.209.86 &amp;lt;none&amp;gt; 3000/TCP 7m46s
osm-prometheus ClusterIP 10.97.10.65 &amp;lt;none&amp;gt; 7070/TCP 7m46s
zipkin ClusterIP 10.103.150.158 &amp;lt;none&amp;gt; 9411/TCP 7m46s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以及一系列的 CRD&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ linux-amd64 kubectl -n osm-system get crd
NAME CREATED AT
backpressures.policy.openservicemesh.io 2020-08-06T16:14:03Z
httproutegroups.specs.smi-spec.io 2020-08-06T16:14:03Z
tcproutes.specs.smi-spec.io 2020-08-06T16:14:03Z
trafficsplits.split.smi-spec.io 2020-08-06T16:14:03Z
traffictargets.access.smi-spec.io 2020-08-06T16:14:03Z
&lt;/code>&lt;/pre>&lt;h2 id="实践">实践&lt;/h2>
&lt;ul>
&lt;li>创建实验用的 namespace, 并通过 &lt;code>osm namespace add&lt;/code> 将其纳入管理范围中：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create ns bookstore
namespace/bookstore created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create ns bookbuyer
namespace/bookbuyer created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create ns bookthief
namespace/bookthief created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create ns bookwarehouse
namespace/bookwarehouse created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ osm namespace add bookstore bookbuyer bookthief bookwarehouse
Namespace &lt;span class="o">[&lt;/span>bookstore&lt;span class="o">]&lt;/span> succesfully added to mesh &lt;span class="o">[&lt;/span>osm&lt;span class="o">]&lt;/span>
Namespace &lt;span class="o">[&lt;/span>bookbuyer&lt;span class="o">]&lt;/span> succesfully added to mesh &lt;span class="o">[&lt;/span>osm&lt;span class="o">]&lt;/span>
Namespace &lt;span class="o">[&lt;/span>bookthief&lt;span class="o">]&lt;/span> succesfully added to mesh &lt;span class="o">[&lt;/span>osm&lt;span class="o">]&lt;/span>
Namespace &lt;span class="o">[&lt;/span>bookwarehouse&lt;span class="o">]&lt;/span> succesfully added to mesh &lt;span class="o">[&lt;/span>osm&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>部署实验应用程序&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 在项目的代码目录中执行&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ osm git:&lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> kubectl apply -f docs/example/manifests/apps
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
namespace/bookbuyer configured
serviceaccount/bookbuyer created
service/bookbuyer created
deployment.apps/bookbuyer created
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
namespace/bookstore configured
service/bookstore created
service/bookstore-v1 created
serviceaccount/bookstore-v1 created
deployment.apps/bookstore-v1 created
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
namespace/bookthief configured
serviceaccount/bookthief created
service/bookthief created
deployment.apps/bookthief created
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
namespace/bookwarehouse configured
serviceaccount/bookwarehouse created
service/bookwarehouse created
deployment.apps/bookwarehouse created
trafficsplit.split.smi-spec.io/bookstore-split created
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>本地访问&lt;/li>
&lt;/ul>
&lt;p>你可以通过 &lt;code>kubectl port-foward&lt;/code> 在本地对刚才部署的应用进行访问。示例中也提供了相应的启动脚本 &lt;code>scripts/port-forward-all.sh&lt;/code> ，注意这里需要先安装 GNU parallel ，例如： &lt;code>dnf install parallel&lt;/code> .&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ osm git:&lt;span class="o">(&lt;/span>main&lt;span class="o">)&lt;/span> ✗ ./scripts/port-forward-all.sh
Academic tradition requires you to cite works you base your article on.
If you use programs that use GNU Parallel to process data &lt;span class="k">for&lt;/span> an article in a
scientific publication, please cite:
O. Tange &lt;span class="o">(&lt;/span>2018&lt;span class="o">)&lt;/span>: GNU Parallel 2018, Mar 2018, ISBN 9781387509881,
DOI https://doi.org/10.5281/zenodo.1146014
This helps funding further development&lt;span class="p">;&lt;/span> AND IT WON&lt;span class="s1">&amp;#39;T COST YOU A CENT.
&lt;/span>&lt;span class="s1">If you pay 10000 EUR you should feel free to use GNU Parallel without citing.
&lt;/span>&lt;span class="s1">
&lt;/span>&lt;span class="s1">More about funding GNU Parallel and the citation notice:
&lt;/span>&lt;span class="s1">https://www.gnu.org/software/parallel/parallel_design.html#Citation-notice
&lt;/span>&lt;span class="s1">
&lt;/span>&lt;span class="s1">To silence this citation notice: run &amp;#39;&lt;/span>parallel --citation&lt;span class="err">&amp;#39;&lt;/span> once.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>访问本地的 &lt;code>8080~8083&lt;/code> 端口即可看到示例项目。例如：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/osm-bookbuyer.png" alt="">&lt;/p>
&lt;p>&lt;em>备注：这里是因为我的应用程序已经运行一段时间了，如果是新部署的，所有数字皆为 0&lt;/em>&lt;/p>
&lt;ul>
&lt;li>访问控制策略&lt;/li>
&lt;/ul>
&lt;p>我们来看看如何调整访问控制的策略&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TrafficTarget&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">access.smi-spec.io/v1alpha2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore-v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">destination&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore-v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">HTTPRouteGroup&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore-service-routes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">buy-a-book&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">books-bought&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">sources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookbuyer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookbuyer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#- kind: ServiceAccount&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#name: bookthief&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#namespace: bookthief&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">specs.smi-spec.io/v1alpha3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">HTTPRouteGroup&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore-service-routes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bookstore&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">matches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">books-bought&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pathRegex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/books-bought&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">methods&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">GET&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;bookstore.bookstore&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;user-agent&amp;#34;: &lt;/span>&lt;span class="s2">&amp;#34;.*-http-client/*.*&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">&amp;#34;client-app&amp;#34;: &lt;/span>&lt;span class="s2">&amp;#34;bookbuyer&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">buy-a-book&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pathRegex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;.*a-book.*new&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">methods&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">GET&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">headers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;bookstore.bookstore&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里定义了两个 SMI 中的资源 &lt;code>TrafficTarget&lt;/code> 和 &lt;code>HTTPRouteGroup&lt;/code> ，用来控制入口流量。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ osm git:(main) ✗ kubectl apply -f docs/example/manifests/access/
&lt;/code>&lt;/pre>&lt;p>通过以上命令创建这两个资源。然后再次打开我们的示例应用程序，就会看到对应的计数正在逐步增加（因为请求被放行了） 。&lt;/p>
&lt;p>&lt;em>以上示例来自于&lt;a href="https://github.com/openservicemesh/osm">项目仓库&lt;/a> 中的示例。&lt;/em>&lt;/p>
&lt;h2 id="dashboard">Dashboard&lt;/h2>
&lt;p>通过 &lt;code>osm dashboard&lt;/code> 可直接唤起本地浏览器，并 port-foward 将 Grafana 打开。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/osm-dashboard.png" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Open Service Mesh 相对来说，确实很轻量。 所需要的访问控制，流量切割等功能通过自己创建 SMI 资源来控制。&lt;/p>
&lt;p>并且，在同一个集群内可存在多组 mesh ，osm 安装的时候，可指定 mesh 名称。&lt;/p>
&lt;p>此外，这个项目也是微软在 Service Mesh 方向的又一个大动作了。目标也许是 Istio 。让我们拭目以待。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Istio/" term="Istio" label="Istio"/><category scheme="https://moelove.info/tags/servicemesh/" term="servicemesh" label="servicemesh"/></entry><entry><title type="text">K8S 生态周报| Istio 已修复导致 Pod 崩溃的 bug</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/08/02/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%B7%B2%E4%BF%AE%E5%A4%8D%E5%AF%BC%E8%87%B4-Pod-%E5%B4%A9%E6%BA%83%E7%9A%84-bug/"/><id>https://moelove.info/2020/08/02/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-%E5%B7%B2%E4%BF%AE%E5%A4%8D%E5%AF%BC%E8%87%B4-Pod-%E5%B4%A9%E6%BA%83%E7%9A%84-bug/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-08-02T10:21:43+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Istio 1.6.7 发布 Istio 1.6.7 是为了……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="istio-167-发布">Istio 1.6.7 发布&lt;/h2>
&lt;p>Istio 1.6.7 是为了解决在 1.6.6 中引入的&lt;a href="https://github.com/istio/istio/commit/bae28dde42cf54e213d4c6bcd9c930f8d9ee60c4" title="bug">一个 bug&lt;/a>。&lt;/p>
&lt;p>该 bug 可能会导致 &lt;strong>在使用 Istio 1.6.6 时，某些 Pod 进入 &lt;code>CrashLoopBackOff&lt;/code> 状态，无法正常提供服务。&lt;/strong>&lt;/p>
&lt;p>修复后的核心代码如下，这里主要是增加另一个返回值 &lt;code>expectpod&lt;/code> 。&lt;/p>
&lt;p>通过此方法获取 Pod 时，Pod 有两种情况可能为空：&lt;/p>
&lt;ul>
&lt;li>该 endpoint 未关联 Pod，这时 expectpod 为 &lt;code>false&lt;/code>；&lt;/li>
&lt;li>该 endpoint 已关联 Pod，但未找到 Pod，这时 expectpod 为 &lt;code>true&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>而这种情况发生的最主要原因可能是由于最终一致性，或者乱序事件等。&lt;/p>
&lt;p>&lt;strong>建议如果打算升级 Istio 的读者，直接跳过 1.6.6 版本，以免影响到服务。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">getPod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Controller&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ip&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ep&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">metav1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectMeta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">targetRef&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjectReference&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">host&lt;/span> &lt;span class="nx">host&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">rpod&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">expectPod&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pod&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">getPodByIP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ip&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">pod&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">targetRef&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">targetRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kind&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;Pod&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">key&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kube&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">KeyFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">targetRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">targetRef&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">podFromInformer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">informer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">GetStore&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">GetByKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">f&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Debugf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Endpoint without pod %s %s.%s error: %v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ip&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ep&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ep&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">endpointsWithNoPods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Increment&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">metrics&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">metrics&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AddMetric&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">model&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EndpointNoPod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ip&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">epkey&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">kube&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">KeyFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ep&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ep&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">queueEndpointEventOnPodArrival&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">epkey&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ip&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">pod&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">podFromInformer&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Pod&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">pod&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="trivy-v0101-发布">Trivy v0.10.1 发布&lt;/h2>
&lt;p>本周 Trivy 相继发布了 v0.10.0 和 v0.10.1 版本，我们一起来看看有哪些值得关注的内容吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/559">#559&lt;/a>允许通过使用 &lt;code>--severity&lt;/code> 选项进行过滤，只查看特定级别的漏洞信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ trivy i --severity LOW alpine:3.10.2
2020-08-02T23:19:28.060+0800 INFO Detecting Alpine vulnerabilities...
alpine:3.10.2 &lt;span class="o">(&lt;/span>alpine 3.10.2&lt;span class="o">)&lt;/span>
&lt;span class="o">=============================&lt;/span>
Total: &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span>LOW: 1&lt;span class="o">)&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;span class="p">|&lt;/span> LIBRARY &lt;span class="p">|&lt;/span> VULNERABILITY ID &lt;span class="p">|&lt;/span> SEVERITY &lt;span class="p">|&lt;/span> INSTALLED VERSION &lt;span class="p">|&lt;/span> FIXED VERSION &lt;span class="p">|&lt;/span> TITLE &lt;span class="p">|&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;span class="p">|&lt;/span> openssl &lt;span class="p">|&lt;/span> CVE-2019-1547 &lt;span class="p">|&lt;/span> LOW &lt;span class="p">|&lt;/span> 1.1.1c-r0 &lt;span class="p">|&lt;/span> 1.1.1d-r0 &lt;span class="p">|&lt;/span> openssl: side-channel weak &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> encryption vulnerability &lt;span class="p">|&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/562">#562&lt;/a>支持通过 Open Policy Agent (OPA) 来进行过滤。&lt;/li>
&lt;/ul>
&lt;p>比方说，我们想要实现和上面使用 &lt;code>--severity LOW&lt;/code> 参数相同的效果，那我们可以定义如下 rego 规则文件。注意： &lt;strong>包名必须为 &lt;code>trivy&lt;/code>&lt;/strong> ，同时，它还必须包含一个名为 &lt;code>ignore&lt;/code> 的规则。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="p">(&lt;/span>&lt;span class="nx">MoeLove&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">➜&lt;/span> &lt;span class="err">~&lt;/span> &lt;span class="nx">cat&lt;/span> &lt;span class="nx">test_trivy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">rego&lt;/span>
&lt;span class="kn">package&lt;/span> &lt;span class="nx">trivy&lt;/span>
&lt;span class="nx">ignore&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Severity&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s">&amp;#34;UNKNOWN&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;MEDIUM&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;HIGH&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;CRITICAL&amp;#34;&lt;/span>&lt;span class="p">}[&lt;/span>&lt;span class="nx">_&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过给 &lt;code>trivy&lt;/code> 传递 &lt;code>--ignore-policy&lt;/code> 参数即可。（这里一定要注意搞清楚逻辑， &lt;strong>trivy 的参数为忽略掉匹配成功的规则&lt;/strong>。）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ trivy image --ignore-policy test_trivy.rego alpine:3.10.2
2020-08-02T23:54:40.843+0800 INFO Detecting Alpine vulnerabilities...
alpine:3.10.2 &lt;span class="o">(&lt;/span>alpine 3.10.2&lt;span class="o">)&lt;/span>
&lt;span class="o">=============================&lt;/span>
Total: &lt;span class="m">1&lt;/span> &lt;span class="o">(&lt;/span>UNKNOWN: 0, LOW: 1, MEDIUM: 0, HIGH: 0, CRITICAL: 0&lt;span class="o">)&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;span class="p">|&lt;/span> LIBRARY &lt;span class="p">|&lt;/span> VULNERABILITY ID &lt;span class="p">|&lt;/span> SEVERITY &lt;span class="p">|&lt;/span> INSTALLED VERSION &lt;span class="p">|&lt;/span> FIXED VERSION &lt;span class="p">|&lt;/span> TITLE &lt;span class="p">|&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;span class="p">|&lt;/span> openssl &lt;span class="p">|&lt;/span> CVE-2019-1547 &lt;span class="p">|&lt;/span> LOW &lt;span class="p">|&lt;/span> 1.1.1c-r0 &lt;span class="p">|&lt;/span> 1.1.1d-r0 &lt;span class="p">|&lt;/span> openssl: side-channel weak &lt;span class="p">|&lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> encryption vulnerability &lt;span class="p">|&lt;/span>
+---------+------------------+----------+-------------------+---------------+--------------------------------+
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/561">#561&lt;/a>在输出内容中新增加了 &lt;code>CweIDs&lt;/code> 字段。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ trivy image -f json --ignore-policy test_trivy.rego alpine:3.10.2
&lt;span class="o">[&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;Target&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;alpine:3.10.2 (alpine 3.10.2)&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;Type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;alpine&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;Vulnerabilities&amp;#34;&lt;/span>:
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;VulnerabilityID&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;CVE-2019-1547&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;PkgName&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;openssl&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;InstalledVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;1.1.1c-r0&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;FixedVersion&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;1.1.1d-r0&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;CweIDs&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;CWE-311&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
...
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/trivy/pull/574">#574&lt;/a> 增加了 &lt;code>--list-all-pkgs&lt;/code> 选项，允许输出被扫描系统中已经安装的包及其版本等。&lt;/li>
&lt;/ul>
&lt;p>而后续发布的 &lt;strong>v0.10.1 版本主要是为了修正 v0.10.0 中对 Dockerfile 中执行用户的修改，继续使用 root 用户作为容器镜像中的默认用户&lt;/strong> 。&lt;/p>
&lt;p>更多关于此版本的信息，请查看 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.10.1">Trivy ReleaseNote&lt;/a>, 欢迎下载使用。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/93248">#93248&lt;/a> 修改了 Kubelet 中 CFS shares 相关的逻辑，为其设置最大值为内核允许的最大值，即 2^18=262144 。&lt;/li>
&lt;/ul>
&lt;p>通过此次修改，Kubelet 使用 systemd 作为 cgroups 驱动时，能正常的处理 CPU 核数大于 512 的机器（如果使用 cgroupfs 作为 cgroup 驱动的话，一直都可以，因为内核会直接进行处理）&lt;/p>
&lt;p>有关 Linux 内核 CFS 相关内容，可以参考我之前写的文章 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">Docker 容器资源管理&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| NGINX Ingress Controller又添新特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/07/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-NGINX-Ingress-Controller%E5%8F%88%E6%B7%BB%E6%96%B0%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2020/07/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-NGINX-Ingress-Controller%E5%8F%88%E6%B7%BB%E6%96%B0%E7%89%B9%E6%80%A7/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-07-26T21:44:38+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Conftest 正式加入 Open Policy Agent 项……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="conftest-正式加入-open-policy-agent-项目">Conftest 正式加入 Open Policy Agent 项目&lt;/h2>
&lt;p>&lt;a href="https://www.conftest.dev/">conftest&lt;/a> 是一个非常实用的 CLI 工具，可以用于测试/验证配置文件是否符合预期。例如，可以通过如下内容来定义规则：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="nx">deny&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">kind&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Deployment&amp;#34;&lt;/span>
&lt;span class="nx">not&lt;/span> &lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">template&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">securityContext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runAsNonRoot&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="nx">msg&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Containers must not run as root&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">deny&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">msg&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">kind&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Deployment&amp;#34;&lt;/span>
&lt;span class="nx">not&lt;/span> &lt;span class="nx">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">selector&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">matchLabels&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">app&lt;/span>
&lt;span class="nx">msg&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;Containers must provide app label for pod selectors&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用此规则去检查一个未符合预期规则的 Deployment 的配置文件：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ conftest &lt;span class="nb">test&lt;/span> deployment.yaml
FAIL - deployment.yaml - Containers must not run as root
FAIL - deployment.yaml - Deployments are not allowed
&lt;span class="m">2&lt;/span> tests, &lt;span class="m">0&lt;/span> passed, &lt;span class="m">0&lt;/span> warnings, &lt;span class="m">2&lt;/span> failures
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就会看到有相应的检查结果了。&lt;/p>
&lt;p>至于 &lt;a href="https://www.openpolicyagent.org/">OPA&lt;/a> 它是一个策略引擎，提供了一种非常灵活的方式来声明策略。&lt;/p>
&lt;p>conftest 正式加入 OPA 项目，可以更好的让彼此进行集成和组合使用。并且，在 conftest 加入 OPA 项目后，会有部分功能从 conftest 移至 OPA，让 conftest 更间简便。期待后续的发展。&lt;/p>
&lt;h2 id="traefik-v227-发布">Traefik v2.2.7 发布&lt;/h2>
&lt;p>Traefik v2.2.6 中，修复了一个安全问题。
在校验使用域前置的 TLS 连接时，如果 &lt;code>Host&lt;/code> 头与 SNI 不同的话，则 Traefik 将会返回 &lt;code>421&lt;/code> 状态码。&lt;/p>
&lt;p>此次 Traefik 发布的 v2.2.7 版本，主要是为了解决上述在 v2.2.6 中由于修复此安全问题而引入的 bug 。&lt;/p>
&lt;p>现象是在 v2.2.6 版本中，如果为 Host 指定了非标准端口（443）的话，则 Traefik 会返回 &lt;code>421&lt;/code> 状态码，从而导致连接异常。&lt;/p>
&lt;p>v2.2.7 中解决办法也很简单，直接忽略掉 Host 中的端口，与 SNI 进行比较即可。&lt;/p>
&lt;p>建议如果打算升级的话，直接升至 v2.2.7 ，避开 v2.2.6 版本。可通过 &lt;a href="https://github.com/containous/traefik/releases/tag/v2.2.7">Release 页面&lt;/a> 下载使用。&lt;/p>
&lt;h2 id="nginx-ingress-controller-v180-发布">NGINX Ingress Controller v1.8.0 发布&lt;/h2>
&lt;p>这里介绍的是 NGINX 官方的 Ingress Controller 项目（避免和社区的 Kubernetes NGINX Ingress Controller 搞混） 。&lt;/p>
&lt;p>此次版本中有几个非常值得关注的特性。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nginxinc/kubernetes-ingress/pull/1028">#1028&lt;/a> 新增了一种资源 &lt;code>Policy&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Policy&lt;/code> 资源允许你为 VirtualServer 资源添加访问控制，可作用于 认证，限流和 WAF 之类的特性。由于此版本中是首次添加，目前只实现了基于 IP 的访问控制。例如，你可以通过下方的配置文件，来允许 &lt;code>10.0.0.0/8&lt;/code> 的访问：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.nginx.org/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Policy &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">allow-localhost&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">accessControl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">allow&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="m">10.0.0.0&lt;/span>&lt;span class="l">/8&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/nginxinc/kubernetes-ingress/pull/1019">#1019&lt;/a> 支持注入片段（ Snippets ）&lt;/li>
&lt;/ul>
&lt;p>使用 Snippets 允许你为 VirtualServer 配置注入一段原生的 NGINX 配置片段，用于覆盖默认配置。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s.nginx.org/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">VirtualServer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cafe&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cafe&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http-snippets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;
&lt;/span>&lt;span class="sd"> proxy_cache_path /tmp keys_zone=one:10m;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cafe.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secret&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cafe-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">server-snippets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">limit_req zone=mylimit burst=20;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">upstreams&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tea&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tea-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">coffee&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">coffee-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">routes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/tea&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">location-snippets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> proxy_cache one;
&lt;/span>&lt;span class="sd"> proxy_cache_valid 200 10m;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">action&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pass&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tea&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/coffee&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">action&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pass&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">coffee&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但要注意的是，如果你使用此特性，我建议你在使用之前，清楚的理解自己配置的含义。因为用这种方式配置，会绕过 Ingress Controller 的校验过程。会比较危险。并且使用此特性，不够直观。但，却可以让你对 NGINX 有更强的控制能力。&lt;/p>
&lt;p>更多关于此版本的信息，请参考其 &lt;a href="https://github.com/nginxinc/kubernetes-ingress/releases/tag/v1.8.0">RelaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/92986">#92986&lt;/a> 如果 CSI 驱动抛出 FailedPrecondition 错误，则停止重试对卷进行扩展；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/80917">#80917&lt;/a> 移植 deviceManager 到 Windows 容器管理中以支持 GPU 的访问。（这是一个很关键的特性）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Traefik v2.3.0-rc2 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/07/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Traefik-v2.3.0-rc2-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/07/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Traefik-v2.3.0-rc2-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-07-19T21:47:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Traefik v2.3.0-rc2 发布 关于 Traefik 的系……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="traefik-v230-rc2-发布">Traefik v2.3.0-rc2 发布&lt;/h2>
&lt;p>关于 Traefik 的系列介绍可以参考之前周报的内容：&lt;a href="https://zhuanlan.zhihu.com/p/111833886">Traefik v2.2.0-rc1 发布&lt;/a>。本周它又发布了 v2.3.0-rc2 版本，我们一起来看看有哪些值得关注的内容吧！&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/6696">#6696&lt;/a> 为 Traefik 在 terminating 时，添加自定义的 HTTP 状态码；&lt;/li>
&lt;/ul>
&lt;p>具体而言，可通过以下几种方式进行添加：&lt;/p>
&lt;p>&lt;strong>配置文件（YAML）&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">ping&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">terminatingStatusCode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">204&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>命令行参数&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">--ping.terminatingStatusCode&lt;span class="o">=&lt;/span>&lt;span class="m">204&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>环境变量&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="nv">TRAEFIK_PING_TERMINATINGSTATUSCODE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">204&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>现在默认的状态码是 503&lt;/strong>&lt;/p>
&lt;p>增加此配置的好处在于，当 Traefik 处于 terminating 状态时，可通过设置自定义的状态码来实现优雅终止。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/containous/traefik/pull/6875">#6875&lt;/a> 使用 parser 从文件中取动态配置; 值得注意的是： &lt;strong>如果从之前版本升级至 v2.3 那一定需要注意的是如果动态配置中存在未知的其他字段，则返回错误。&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/containous/traefik/pull/7041">#7041&lt;/a> Traefik 提供了 Plugins 特性的支持。可以通过此机制，让 Traefik Pilot 连接到 Traefik ，以此来将其 SaaS 能力暴露给用户。同时 Traefik Pilot 可以监控连接到它的任意 Traefik 实例，并支持发出报警。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的特性请参阅其 &lt;a href="https://github.com/containous/traefik/releases/tag/v2.3.0-rc2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="etcd-v3410-发布">etcd v3.4.10 发布&lt;/h2>
&lt;p>etcd 在本周发布了 v3.4.10 版本，我们一起来看看此版本中值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd/pull/11946">#11946&lt;/a> 在之前的 &lt;a href="https://zhuanlan.zhihu.com/p/146554894">K8S 生态周报| 几乎影响所有 k8s 集群的漏洞&lt;/a> 中，我就介绍过了，新增了 &lt;code>--unsafe-no-fsync&lt;/code> 选项，可以禁止所有的 fsync，这使得将 etcd 用于 CI 环节或本次测试都将非常高效；&lt;/li>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd/pull/11980">#11980&lt;/a> 添加了 &lt;code>--auth-token-ttl&lt;/code> 的选项，用于自定义 &lt;code>simpleTokenTTL&lt;/code> 设置；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的特性，请参考其 &lt;a href="https://github.com/etcd-io/etcd/releases/tag/v3.4.10">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="trivy-v092-发布">Trivy v0.9.2 发布&lt;/h2>
&lt;p>Trivy 在之前的周报中已经做了很多介绍。本周它发布了 v0.9.2 版本，我们一起看看有哪些值得关注的内容。&lt;/p>
&lt;p>&lt;strong>支持 JUnit XML&lt;/strong> 如果你的 CI 服务器支持 JUnit XML 那你就可以在 CI pipeline 中看到 Trivy 对应的检查结果了。&lt;/p>
&lt;p>比如，在 GitLab CI 中使用 Trivy 效果如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/trivy-in-gitlab-ci.png" alt="Trivy In GitLab CI">&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://github.com/aquasecurity/trivy/pull/530">#530&lt;/a> 在结果中支持 CVSS 评分信息了&lt;/strong>， 例如&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json"> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;VulnerabilityID&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;CVE-2019-1547&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;PkgName&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;openssl&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;InstalledVersion&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;1.1.1c-r0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;FixedVersion&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;1.1.1d-r0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;CVSS&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;nvd&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;V2Vector&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;AV:L/AC:M/Au:N/C:P/I:N/A:N&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;V3Vector&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;V2Score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">1.9&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;V3Score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">4.7&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="nt">&amp;#34;redhat&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;V3Vector&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;V3Score&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">5.5&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">},&lt;/span>
&lt;span class="err">...&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多关于此版本的信息，请查看其 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.9.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/92310">#92310&lt;/a> &lt;code>kubectl alpha debug&lt;/code> 现在支持主机级别的 debug 了， 通过启动容器并加入主机的 namespace 中，它会自动将主机的文件系统绑定到 &lt;code>/host&lt;/code> 下，以便调试使用。这种模式，有望替代传统的通过 SSH 登录机器 debug 的模式了。&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91946">#91946&lt;/a> 还记得 Kubernetes 新增的 &lt;code>.meta.managedFields&lt;/code> 吗？当你执行 &lt;code>kubectl edit&lt;/code> 的时候，是否觉得它很烦。 现在在 &lt;code>kubectl edit&lt;/code> 的时候，将会默认隐藏它 （ &lt;strong>太棒了！&lt;/strong> )&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/issues/92914">#92914&lt;/a> CVE-2020-8559 已经被新发布版本修复；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.3.0-rc.1 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/07/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.3.0-rc.1-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/07/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.3.0-rc.1-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-07-12T22:46:25+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.3.0-rc.1 发布 这是 Helm v3.3.0 的……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v330-rc1-发布">Helm v3.3.0-rc.1 发布&lt;/h2>
&lt;p>这是 Helm v3.3.0 的预发布版本，在此次版本中，重点在修复 &lt;code>helm lint&lt;/code> 相关的错误，以及提升整体的稳定性和其他一般性 bug 的修复。我主要介绍几个值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8277">#8277&lt;/a> 将 warning 信息从写入 &lt;code>stdout&lt;/code> 修改为写入 &lt;code>stderr&lt;/code> ，这样可大大方便将 helm 用于 pipeline 中。比如 &lt;code>helm template&lt;/code> 与 &lt;code>kubectl&lt;/code> 组合使用；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8220">#8220&lt;/a> 修复了当 chart 数量很多时，&lt;code>helm chart list&lt;/code> 可能报错的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8158">#8158&lt;/a> 修复了 &lt;code>--repository-cache&lt;/code> 不能被 &lt;code>repo add&lt;/code> 和 &lt;code>repo update&lt;/code> 识别的问题， 现在可以通过 &lt;code>repository-cache&lt;/code> 自行指定 cache 目录；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/issues/7875">#7875&lt;/a> 增加了 &lt;code>--insecure-skip-tls-verify&lt;/code> 参数，用于在 &lt;code>pull&lt;/code>/&lt;code>install&lt;/code> 等阶段，跳过证书校验；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/8011">#8011&lt;/a> 增加了 lint 规则，以便于检查资源名称是否符合 K8S 的要求。&lt;/li>
&lt;/ul>
&lt;p>以上便是我认为此版本中值得关注的内容，更多关于此版本的详细信息，请参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.3.0-rc.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="suse-宣布收购-rancher-labs">SUSE 宣布收购 Rancher Labs&lt;/h2>
&lt;p>本周想必大家已经被此消息刷屏，SUSE 将收购 Rancher Labs 。这里我稍微聊一点我个人的看法。&lt;/p>
&lt;p>SUSE 大家可能比较熟悉的是 openSUSE ，一个 Linux 发行版，LOGO 是一只绿蜥蜴。我早年也曾在个人电脑上装过 openSUSE，为了玩它的 3D 桌面特效（效果是蛮酷的）。&lt;/p>
&lt;p>但它背后的公司主业可不止 openSUSE ，它的一个重要产品是 SUSE Linux Enterprise ， 它俩之间比较像 Red Hat Enterprise Linux 和 Fedora 之间的关系。&lt;/p>
&lt;p>此外，还有围绕此构建出来的 SUSE Linux Enterprise Desktop 和 SUSE Linux Enterprise Server 以及 SUSE Linux Enterprise 高性能计算等。&lt;/p>
&lt;p>看起来很像是专注于搞系统层的公司对吧，它在近些年还搞了两个我认为是比较核心的产品， 1. 基于 Ceph 技术提供的 SUSE Enterprise Storage - 企业级存储系统 2. SUSE CaaS Platform - 企业级容器服务平台。&lt;/p>
&lt;p>其实我主要关注它的点，在于这两个产品运行环境是 SUSE Linux Enterprise 也就是说，买了服务那你还需要买基础设施，这样才能更好的达到企业级的可靠性保障。&lt;/p>
&lt;p>这里不说它的盈利模式了，主要是想要说， SUSE 其实挺早就想要切入到 K8S 生态（或者说云原生生态）中了，选择的方向也都很准。去年我在 Kube Con 上有和它们的工作人员聊了下关于它们的存储与 K8S 结合相关的内容，是个不错的切入点。&lt;/p>
&lt;p>现在 SUSE 收购 Rancher Labs ，对于 SUSE 而言是进一步增加了在云原生领域的覆盖面，对于 Rancher Labs 而言也是增加了一个强力的后盾。当然，在企业环境下，也更需要有 SUSE 这样可以提供技术和企业级服务的伙伴。&lt;/p>
&lt;p>不过我也看到了一些其他的声音，比如说看 &lt;strong>SUSE 现在的产品大多是部署在 SUSE Enterprise Linux 平台之上的，担心后续使用 Rancher 是否也需要特定在 SUSE 的平台之上。&lt;/strong> 不过 SUSE 已经做了回应，称会继续支持开源。&lt;/p>
&lt;p>整体而言，这是个好事儿，我们能看到有更多的公司愿意在 K8S 相关技术方面进行投入了，同时也可以看到众多的收购案例中，to B 才是目标。&lt;/p>
&lt;h2 id="google-将-istio-商标转移给-ouc">Google 将 Istio 商标转移给 OUC&lt;/h2>
&lt;p>谷歌近期宣布成立新组织 &lt;a href="https://openusage.org/">Open Usage Commons（OUC）&lt;/a> ，并将 Istio，Angular，Gerrit Code Review 三个项目的商标转移给它。&lt;/p>
&lt;p>这个事情对于云原生领域算是个大新闻了，甚至 IBM 等公司也专门发文声明反对 Google 的这一做法，认为应该交给 CNCF 管理。&lt;/p>
&lt;p>关于这一事情，我不发表太多意见。&lt;/p>
&lt;p>但我想说的是，无论 Google 是否更改这一决定， &lt;strong>短时间来看，并不会影响 Istio 的应用和发展。&lt;/strong>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91381">#91381&lt;/a> 在 Pod 和 Container 的 &lt;code>securityContext&lt;/code> 对象中增加另一个 &lt;code>seccompProfile&lt;/code> 字段，以便支持 Seccomp 。同时 &lt;code>seccomp.security.alpha.kubernetes.io/pod&lt;/code> 和 &lt;code>container.seccomp.security.alpha.kubernetes.io/...&lt;/code> 的 annotations 被标记为废弃，将在 v1.22 中移除；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91532">#91532&lt;/a> &lt;a href="https://github.com/kubernetes/kubernetes/pull/91522">#91522 &lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/pull/91521">#91521&lt;/a> 分别为 kubelet，scheduler 和 controller-manager 增加 &lt;code>--logging-format&lt;/code> 选项，以便支持结构化日志；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/92740">#92740&lt;/a> &lt;code>kubeadm config view&lt;/code> 被标记为废弃，请直接使用 &lt;code>kubectl get cm -o yaml -n kube-system kubeadm-config&lt;/code> 查看 configmap；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| runc v1.0.0-rc91 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/07/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc91-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/07/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc91-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-07-05T21:04:24+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 runc v1.0.0-rc91 发布 如果不出意……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="runc-v100-rc91-发布">runc v1.0.0-rc91 发布&lt;/h2>
&lt;p>如果不出意外的话，这将会是 runc v1.0 正式发布前的倒数第二个 rc 版。
本次有很多值得关注的变更。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先是期待已久的 hooks 的变更，这是少数与规范有关的变更，当然它也是一直没有发布 v1.0 的原因之一。现有的使用 hook 的用户不受影响，比如说 NVIDIA Docker 用户，但是 runc 提供了其他的 hook ，比如 &lt;code>createRuntime&lt;/code> 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其次是对 cgroup v2 的支持（我已经多次介绍过）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修复了一个小的&lt;a href="https://github.com/opencontainers/runc/security/advisories/GHSA-g54h-m393-cpwq">安全漏洞&lt;/a> 很早之前 runc 中默认将所有的设备都设置成了允许，这意味着需要用户自己去设置要去拒绝哪个设备访问。在 runc 的众多用户，均已经很早就修复了此问题。所以此问题在 runc 中被忽略掉了，直到现在才修复。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的信息，请参考其 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc91">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="envoy-v1143-发布">Envoy v1.14.3 发布&lt;/h2>
&lt;p>此次 v1.14.3 版本的主题是安全修复。本次修复了如下安全漏洞：&lt;/p>
&lt;ul>
&lt;li>CVE-2020-12603&lt;/li>
&lt;li>CVE-2020-12604&lt;/li>
&lt;li>CVE-2020-12605&lt;/li>
&lt;li>CVE-2020-8663&lt;/li>
&lt;li>CVE-2020-8663&lt;/li>
&lt;/ul>
&lt;p>这些安全漏洞基本都是通过发送特定数据包，引起服务端大量消耗资源。 同时，此次的这些安全修复，也都影响到了 Istio ，所以 Istio 在本周也发布了 v1.6.4 版本以包含这些漏洞修复。&lt;/p>
&lt;p>更多关于此版本信息，请参考其 &lt;a href="https://github.com/envoyproxy/envoy/releases/tag/v1.14.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-v137-发布">Rook v1.3.7 发布&lt;/h2>
&lt;p>这仍然是一个 bugfix 版本，其中有几个值得注意的修复：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/issues/5504">#5504&lt;/a> 修复了 OSD 创建过程中磁盘分区标签在 &lt;code>devicePathFilter&lt;/code> 过滤条件中失效的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5698">#5698&lt;/a> 在 monitor 故障转移的时候，删除与之关联的 PVC，这样可以避免其故障时， PVC 仍处于绑定的状态；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5720">#5720&lt;/a> 之前卡住的 monitor 只有在健康检查的时候才会被强制删除，现在在每次 reconcile 时，也会重启 monitor 了；&lt;/li>
&lt;/ul>
&lt;p>以上便是本次版本中值得关注的信息，更多关于此版本的变更，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.3.7">RleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/92407">#92407&lt;/a> 对 kubelet 暴露出的两个 metric 做了重命名，分别是将 &lt;code>kubelet_running_container_count&lt;/code> -&amp;gt; &lt;code>kubelet_running_containers&lt;/code> 和 &lt;code>kubelet_running_pod_count&lt;/code> -&amp;gt; &lt;code>kubelet_running_pods&lt;/code> &lt;strong>如果在升级后，发现自己的 Dashboard 或者报警不好用了，请即使检查 metric 是否匹配&lt;/strong>；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91980">#91980&lt;/a> &lt;code>kubeadm upgrade&lt;/code> 允许用户通过 &lt;code>--config&lt;/code> 手动提供集群组件的配置。旧有的 &lt;code>--config&lt;/code> 行为也将继续支持。相关的 KEP 请查看 &lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-cluster-lifecycle/kubeadm/20190925-component-configs.md">https://github.com/kubernetes/enhancements/blob/master/keps/sig-cluster-lifecycle/kubeadm/20190925-component-configs.md&lt;/a> （对于想要手动管理，或者规避一些版本问题的用户，非常有用）；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v19.03.12 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/06/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.12-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/06/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.12-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-06-28T19:31:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker CE v19.03.12 发布 在 Docker v19.03.11 发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-ce-v190312-发布">Docker CE v19.03.12 发布&lt;/h2>
&lt;p>在 Docker v19.03.11 发布时，我在&lt;a href="https://zhuanlan.zhihu.com/p/146554894">「K8S 生态周报| 几乎影响所有 k8s 集群的漏洞」&lt;/a> 一文中曾介绍过，该版本主要是为了修复一个通过使用 IPv6 RA 消息进行地址欺骗的安全漏洞 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13401">CVE-2020-13401&lt;/a>。&lt;/p>
&lt;p>解决办法也很简单，直接将 &lt;code>/proc/sys/net/ipv6/conf/*/accept_ra&lt;/code> 设置成 0 ，这样便可确保不接收 RA 消息，从而避免遭受攻击。&lt;/p>
&lt;p>但是，在 v19.03.11 的修复中，当无法禁用 RA 消息时，会直接报错，导致 docker daemon 无法启动 （比如在容器内的只读文件系统上）。所以此次 v19.03.12 的一个最主要修复，就是无法禁用 RA 消息时，只是会记录一条日志，而不是直接报错。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- return fmt.Errorf(&amp;#34;libnetwork: Unable to disable IPv6 router advertisement: %v&amp;#34;, err)
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ logrus.WithError(err).Warn(&amp;#34;unable to disable IPv6 router advertisement&amp;#34;)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对此版本感兴趣的小伙伴，可以直接更新。&lt;/p>
&lt;h2 id="containerd-v135-发布">containerd v1.3.5 发布&lt;/h2>
&lt;p>此次 v1.3.5 版本，有可能是 v1.3.x 系列的最后一个版本了。此版本中主要是把主线中的一些修正给移植过来。比如&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4276">#4276&lt;/a> 修正了镜像用量的计算错误；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4278">#4278&lt;/a> 当遇到一些错误时候，清理掉分配的资源；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4327/">#4327&lt;/a> shim v2 runc 传递了 &lt;code>options.Root&lt;/code>；&lt;/li>
&lt;/ul>
&lt;p>此版本也将很快集成进 Docker 中。&lt;/p>
&lt;p>更多信息请参考其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-v1410-发布">Istio v1.4.10 发布&lt;/h2>
&lt;p>Istio v1.4.10 中主要包含以下值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2020-006&lt;/strong>: 这个漏洞源自 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11080">CVE-2020-11080&lt;/a> nghttp2 在 v1.41.0 版本之前，存在 payload 过大导致拒绝服务的漏洞。当攻击者持续构造大型请求时，可能导致 CPU 飙到 100% 。这种请求可能会被发送到 Ingress Gateway 或者 Sidecar ，进而导致拒绝服务。&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/23770">#23770&lt;/a> 修复了 CNI 导致 POD 延迟 30~40s 启动的 bug ，主要是因为 &lt;code>istio-iptables.sh&lt;/code> 中 IPv6 相关的检查逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88649">#88649&lt;/a> 删除掉了自 v1.14 起，被废弃的 &lt;code>kubectl get&lt;/code> 的 &lt;code>--export&lt;/code> 参数；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89778">#89778&lt;/a> Ingress 已经 GA，当前使用的 API 版本为 &lt;code>networking.k8s.io/v1&lt;/code>;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| CoreDNS 发布 v1.7.0</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/06/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-CoreDNS-%E5%8F%91%E5%B8%83-v1.7.0/"/><id>https://moelove.info/2020/06/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-CoreDNS-%E5%8F%91%E5%B8%83-v1.7.0/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-06-21T15:00:50+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 CoreDNS v1.7.0 发布 CoreDNS 本周发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="coredns-v170-发布">CoreDNS v1.7.0 发布&lt;/h2>
&lt;p>CoreDNS 本周发布了 v1.7.0 版本， &lt;strong>这是一个向后不兼容的版本&lt;/strong>。 主要包含了以下几个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3776">#3776&lt;/a>更好的 metrics 名称，其修改了大量的 metrics 名称，Dashborad 之类的都需要修改了。 例如： &lt;code>coredns_request_block_count_total&lt;/code> -&amp;gt; &lt;code>coredns_dns_blocked_requests_total&lt;/code>&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3794">#3794&lt;/a> &lt;code>federation&lt;/code> 插件已经被移除 （v1 Kubernetes federation）;&lt;/li>
&lt;li>从 &lt;code>kubernetes&lt;/code> 插件中删除了一些代码， 所以它不会作为外部插件构建；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3534">#3534&lt;/a> 新的 &lt;code>dns64&lt;/code> 插件，由外部转为内置插件，该插件提供了 DNS64 IPv6 地址转换机制；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3737">#3737&lt;/a> &lt;code>plugin/kubernetes&lt;/code>: 移除了已经过期的 &lt;code>resyncperiod&lt;/code> 和 &lt;code>upstream&lt;/code> 选项；&lt;/li>
&lt;/ul>
&lt;p>以上便是此版本中值得注意的变更，更多详细内容请参看其 &lt;a href="https://coredns.io/2020/06/15/coredns-1.7.0-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v324-发布">Helm v3.2.4 发布&lt;/h2>
&lt;p>这是一个安全更新版本，主要是为了修正一个漏洞，该漏洞影响了 v3.2.4 之前所有 Helm v3 版本。漏洞号为 &lt;a href="https://github.com/helm/helm/security/advisories/GHSA-qq3j-xp49-j73f">CVE-2020-4053&lt;/a>&lt;/p>
&lt;p>此漏洞的具体影响范围是，当通过 HTTP 的方式从远程来安装一个 Plugin 的时候，可能会发生文件目录的遍历攻击。攻击者可能会在恶意插件中包含相对路径，以此来将攻击文件复制到预期的文件目录之外。&lt;/p>
&lt;p>这是一种很常见的攻击方法，在之前的「K8S 生态周报」文章中，我也介绍过类似的利用这种文件目录遍历的漏洞。&lt;/p>
&lt;p>修正方式也很简单，对于文件的解压操作，判断是否包含相对路径，如果有，则抛出异常（这里主要是为了警示用户，其安装的内容中可能有恶意行为）。&lt;/p>
&lt;p>对此版本感兴趣的朋友，可以直接&lt;a href="https://github.com/helm/helm/releases/tag/v3.2.4">下载&lt;/a> 使用。&lt;/p>
&lt;h2 id="istio-v163-发布">Istio v1.6.3 发布&lt;/h2>
&lt;p>本周 Istio 发布了 v1.6.3 ，此版本的主要变更如下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/24264">#24264&lt;/a> 修复了 istio 崩溃信息为 &lt;code>proto.Message is *client.QuotaSpecBinding, not *client.QuotaSpecBinding&lt;/code> 的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/pull/24365">#24365)&lt;/a> 修正了 &lt;code>SidecarInjectionSpec&lt;/code> CRD， 从 &lt;code>.Values.global&lt;/code> 阅读 &lt;code>imagePullSecret&lt;/code>；&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/24469">#24469)&lt;/a> 当 &lt;code>gateway.runAsRoot&lt;/code> 开启时，从 &lt;code>PodSecurityContext&lt;/code> 移除了无效的配置；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的信息，请参考其 &lt;a href="https://istio.io/latest/news/releases/1.6.x/announcing-1.6.3/">ReleaseNote&lt;/a> 。&lt;/p>
&lt;h2 id="rook-v136-发布">Rook v1.3.6 发布&lt;/h2>
&lt;p>Rook 已经提交了从 CNCF 托管项目中毕业的申请，可能还需要一段时间才能毕业吧。&lt;/p>
&lt;p>我们来看看本次 Rook v1.3.6 版本的更新内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5603">#5603&lt;/a> 将 CSI 驱动升级到了 v2.1.2；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/issues/5309">#5309&lt;/a> 修复了 template size 增加时，OSD PVC size 不增加的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5595">#5595&lt;/a> 修改了 svc port 的名称，需求主要来自想要将 rook 与 Istio 集成，其中 kiali 要求 port 名称必须有个协议前缀，具体信息请参考 &lt;a href="https://kiali.io/documentation/validations/#_kia0601_port_name_must_follow_protocol_suffix_form">https://kiali.io/documentation/validations/#_kia0601_port_name_must_follow_protocol_suffix_form&lt;/a> ；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5606">#5606&lt;/a> 修正了小集群（比如 OSD 为 3） 当 OSD 更新时，获取的 OSD 数量不准确的情况；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的详细信息，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.3.6">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90569">#90569&lt;/a> &lt;code>kubectl run&lt;/code> 增加了一个 &lt;code>--privileged&lt;/code> 的参数；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91952">#91952&lt;/a> 为 &lt;code>kubeadm join&lt;/code> 增加了一个重试的循环， 默认写超时是 40 s， 读超时是 15s ；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Trivy 发布新版本</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/06/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Trivy-%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%88%E6%9C%AC/"/><id>https://moelove.info/2020/06/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Trivy-%E5%8F%91%E5%B8%83%E6%96%B0%E7%89%88%E6%9C%AC/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-06-14T15:30:58+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Trivy 发布 v0.9.x 版本 Trivy 是一……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="trivy-发布-v09x-版本">Trivy 发布 v0.9.x 版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/aquasecurity/trivy">Trivy&lt;/a> 是一款由 Aqua Security 开源的镜像漏洞安全扫描程序，对 CI 友好。&lt;/p>
&lt;p>在之前的「K8S 生态周报」中，我曾介绍过这款工具。本周其发布了 v0.9.x 系列版本，以下是一些值得注意的变更：&lt;/p>
&lt;ul>
&lt;li>支持 &lt;a href="https://github.com/advisories">GitHub Advisory 数据库&lt;/a>了，相当于扩充了它的漏洞库，可以大幅提升 Trivy 的准确度；&lt;/li>
&lt;li>支持文件系统扫描，可以直接在已启动的容器中，扫描容器的文件系统；&lt;/li>
&lt;li>可内置在 Dockerfile 中，在构建镜像的过程中，直接进行漏洞扫描, 例如：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ cat Dockerfile
FROM alpine:3.7
RUN apk add --no-cache curl \
&amp;amp;&amp;amp; curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/master/contrib/install.sh | sh -s -- -b /usr/local/bin \
&amp;amp;&amp;amp; trivy filesystem --exit-code 1 --no-progress / \
&amp;amp;&amp;amp; trivy --reset &amp;amp;&amp;amp; rm -f /usr/loca/bin/trivy &amp;amp;&amp;amp; apk del curl
$ docker build -t vulnerable-image
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>支持直接扫描 Git 仓库（当前只允许扫描公开仓库）;&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，欢迎下载体验 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.9.1">https://github.com/aquasecurity/trivy/releases/tag/v0.9.1&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-nginx-ingress-发布-v033">Kubernetes NGINX Ingress 发布 v0.33&lt;/h2>
&lt;p>Kubernetes NGINX Ingress 想必大家不会太陌生，此项目也算是发版达人，更新频率较高。&lt;/p>
&lt;p>此次发布的 v0.33 中主要的变更如下：&lt;/p>
&lt;ul>
&lt;li>使用 NGINX v1.19.0；&lt;/li>
&lt;li>默认开启 TLSv1.3 ；&lt;/li>
&lt;li>&lt;code>access-log-path&lt;/code> 标记成了废弃，请使用 &lt;code>http-access-log-path&lt;/code> 和 &lt;code>stream-access-log-path&lt;/code> 进行替代；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，欢迎下载体验 &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/controller-0.33.0">https://github.com/kubernetes/ingress-nginx/releases/tag/controller-0.33.0&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90191">#90191&lt;/a> CertificateSigningRequest v1beta1 API 和 &lt;a href="https://github.com/kubernetes/kubernetes/pull/91685">#91685&lt;/a> CertificateSigningRequest v1 API 。首先完成了 v1beta1 API，增加了一些字段和其他必要的内容，为后续版本做准备。 其次增加了 v1 API，添加了一些向后兼容的改进。整体而言是 CSR API 的一大重要改进；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91275">#91275&lt;/a> kubelet 的 &lt;code>--node-status-max-images&lt;/code> 参数已移动至配置文件中；&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>整体而言，本周社区相对安静，主要可能和大的环境有关。各类技术社区也都纷纷加入其中了。&lt;/p>
&lt;p>另外，看现在国内相关的报道，还是需要注意身体，保护好自己和家人。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 几乎影响所有 k8s 集群的漏洞</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/06/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E5%87%A0%E4%B9%8E%E5%BD%B1%E5%93%8D%E6%89%80%E6%9C%89-k8s-%E9%9B%86%E7%BE%A4%E7%9A%84%E6%BC%8F%E6%B4%9E/"/><id>https://moelove.info/2020/06/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E5%87%A0%E4%B9%8E%E5%BD%B1%E5%93%8D%E6%89%80%E6%9C%89-k8s-%E9%9B%86%E7%BE%A4%E7%9A%84%E6%BC%8F%E6%B4%9E/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-06-07T19:50:52+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v19.03.11 发布 距离 v19.03.10 发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v190311-发布">Docker v19.03.11 发布&lt;/h2>
&lt;p>距离 v19.03.10 发布仅一周时间，Docker 又发布了新版本 v19.03.11 。此版本是一个安全修复版本，通过禁用了 IPv6 路由地址广播（RA）从而防止地址欺骗，对应的漏洞为 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13401">CVE-2020-13401&lt;/a> 。&lt;/p>
&lt;p>在 Docker 的默认配置中，容器网络接口是指向主机（veth 接口）的虚拟以太网链接，在此配置下，如果一个攻击者可以在容器中以 root 身份运行进程的话，那么他是可以使用 &lt;code>CAP_NET_RAW&lt;/code> 能力，向主机任意发送和接收数据包的。&lt;/p>
&lt;p>例如： 在容器内使用 root 用户，可以正常执行 &lt;code>ping&lt;/code> 命令&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker run --rm -it -u root redis:alpine sh
/data # whoami
root
/data # ping -c 1 moelove.info
PING moelove.info (185.199.108.153): 56 data bytes
64 bytes from 185.199.108.153: seq=0 ttl=49 time=54.389 ms
--- moelove.info ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 54.389/54.389/54.389 ms
&lt;/code>&lt;/pre>&lt;p>在容器内使用非 root 用户，执行 &lt;code>ping&lt;/code> 命令会提示无权限&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker run --rm -it -u redis redis:alpine sh
/data # whoami
redis
/data $ ping -c 1 moelove.info
PING moelove.info (185.199.109.153): 56 data bytes
ping: permission denied (are you root?)
&lt;/code>&lt;/pre>&lt;p>如果没有在主机上完全禁用 IPv6 （通过内核参数 &lt;code>ipv6.disable=1&lt;/code>）, 那么主机上的网络接口可以自己进行配置。如果配置项为 &lt;code>/proc/sys/net/ipv6/conf/*/forwarding == 0&lt;/code> 那表示该接口禁用了 IPv6 转发。全局的静态配置可以在以下位置看到：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ cat /proc/sys/net/ipv6/conf/all/forwarding
1
&lt;/code>&lt;/pre>&lt;p>另外，还有一个默认配置是关于是否接收 RA 消息的，如果配置项为 &lt;code>/proc/sys/net/ipv6/conf/*/accept_ra == 1&lt;/code>，则表示该接口默认接收 RA 消息。全局的静态配置可以在以下位置看到：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ cat /proc/sys/net/ipv6/conf/all/accept_ra
1
&lt;/code>&lt;/pre>&lt;p>上述的两个系统默认配置的组合，表示系统接受路由广播（RA）消息，并且使用它配置 IPv6 网络栈（SLAAC）。如果熟悉 IETF RFC 4861 的小伙伴应该知道，ICMPv6 RA 虽然本意是好的，但它确实存在安全风险。&lt;/p>
&lt;p>在尚未使用 IPv6 的网络中，双栈主机处于休眠状态，并等待最终的 RA 消息来唤醒其 IPv6 连接。攻击者可以制作恶意的 RA 消息，获取网络中的双协议节点以配置其 IPv6 地址，并利用攻击者的系统作为其默认的网关。这样便可很简单的实施中间人攻击了。在 RFC 6104 中其实早就记录过这个问题，也有很多相关的解决方案，此处就不展开了，涉及的东西太多了。&lt;/p>
&lt;p>对应到此次漏洞中，如果攻击者通过容器发送恶意 RA 消息（rogue RA），则可以重新配置主机，将主机的部分或者全部 IPv6 通信都重定向到攻击者控制的容器。&lt;/p>
&lt;p>即使之前没有 IPv6 流量，如果 DNS 服务器返回 A（IPv4）和 AAAA（IPv6）记录的话，很多 HTTP 库将会首先尝试进行 IPv6 连接，然后再回退到 IPv4 。这就为攻击者提供了制造响应的机会。&lt;/p>
&lt;p>如果主机恰好有类似去年 apt 的 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2019-3462">CVE-2019-3462&lt;/a> 这种漏洞的话，则攻击者便可能获取主机权限。&lt;/p>
&lt;p>总体而言，Docker 容器默认没有配置 &lt;code>CAP_NET_ADMIN&lt;/code> 能力，所以攻击者无法直接将其配置为中间人攻击的 IP，无法使用 iptables 进行 &lt;code>NAT&lt;/code> 或者 &lt;code>REDIRECT&lt;/code> 流量，也不能使用 &lt;code>IP_TRANSPARENT&lt;/code>。但是攻击者仍然可以使用 &lt;code>CAP_NET_RAW&lt;/code> 能力，并在用户空间实现 TCP/IP 堆栈。&lt;/p>
&lt;p>聊完 Docker 相关的这个漏洞，这里就顺便展开聊聊相关的一些其他问题吧。&lt;/p>
&lt;p>与此漏洞类似的，受影响的还有 &lt;strong>Kubernetes&lt;/strong> ， 但并不是 Kubernetes 自身的漏洞，而是官方安装源仓库中，kubelet 依赖的 &lt;code>kubernetes-cni&lt;/code> CNI 包，也存在漏洞 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2020-10749">CVE-2020-10749&lt;/a>&lt;/p>
&lt;p>受影响版本为：&lt;/p>
&lt;ul>
&lt;li>kubelet v1.18.0-v1.18.3&lt;/li>
&lt;li>kubelet v1.17.0-v1.17.6&lt;/li>
&lt;li>kubelet v1.16.11 之前版本&lt;/li>
&lt;/ul>
&lt;p>第三方组件相关的漏洞信息：&lt;/p>
&lt;ul>
&lt;li>Calico 和 Calico Enterprise (CVE-2020-13597) 漏洞信息 TTA-2020-001 可在此处 &lt;a href="https://www.projectcalico.org/security-bulletins/">https://www.projectcalico.org/security-bulletins/&lt;/a> 查看；&lt;/li>
&lt;li>CNI Plugins v0.8.6 之前版本 （CVE-2020-10749），详情见 &lt;a href="https://github.com/containernetworking/plugins/pull/484">https://github.com/containernetworking/plugins/pull/484&lt;/a>；&lt;/li>
&lt;li>Flannel 全部版本；&lt;/li>
&lt;li>Weave Net v2.6.3 之前版本；&lt;/li>
&lt;/ul>
&lt;p>以下第三方组件目前未受此次漏洞影响：&lt;/p>
&lt;ul>
&lt;li>Cilium&lt;/li>
&lt;li>Juniper Contrail Networking&lt;/li>
&lt;li>OpenShift SDN&lt;/li>
&lt;li>OVN-Kubernetes&lt;/li>
&lt;li>Tungsten Fabric&lt;/li>
&lt;/ul>
&lt;p>结合前面我对此漏洞的说明，想必你也看到了，解决此漏洞最简单的方法是：&lt;/p>
&lt;ul>
&lt;li>更新相关组件到最新（包含修复内容）的版本（截至目前，相关受影响组件中，除 Flannel 外，均已发布新版本来解决此漏洞）；&lt;/li>
&lt;li>可以在系统中禁止接收 RA 消息（如果你不需要 RA 消息的话）；&lt;/li>
&lt;li>也可以禁用容器的 &lt;code>CAP_NET_RAW&lt;/code> 能力，例如：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker run --cap-drop CAP_NET_RAW --rm -it -u root redis:alpine sh
/data # ping -c 1 moelove.info
PING moelove.info (185.199.108.153): 56 data bytes
ping: permission denied (are you root?)
&lt;/code>&lt;/pre>&lt;h2 id="docker-compose-v1260-发布">Docker Compose v1.26.0 发布&lt;/h2>
&lt;p>Docker Compose 是一个很方便灵活的工具，大家应该不会陌生。前段时间 Docker 将 Compose 规范开源后，社区在逐步成长中。&lt;/p>
&lt;p>本次发布的 v1.26.0 中，包含了很多值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>添加了对 &lt;code>doker context&lt;/code> 的支持，&lt;code>context&lt;/code> 非常好用！Docker Inc. 在今年的 Docker Con 之前还和 Azure 达成了合作，加速从本地到云的开发/部署等，具体操作上也都是通过 context 实现的；&lt;/li>
&lt;li>支持通过 &lt;code>COMPOSE_COMPATIBILITY&lt;/code> 环境变量配置其能力；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友请参考其 &lt;a href="https://docs.docker.com/compose/release-notes/#1260">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kube-ovn-v12-发布">Kube-OVN v1.2 发布&lt;/h2>
&lt;p>Kube-OVN 是首次出现在「K8S 生态周报」中的项目，稍微做下介绍。它是一款基于 OVN 的 Kubernetes 网络组件，通过将OpenStack领域成熟的网络功能平移到Kubernetes，来应对更加复杂的基础环境和应用合规性要求。&lt;/p>
&lt;p>Kube-OVN主要具备五大主要功能：Namespace 和子网的绑定，以及子网间访问控制，静态IP分配，动态QoS，分布式和集中式网关，内嵌 LoadBalancer。&lt;/p>
&lt;p>本次发布的 v1.2 中包含了以下重要更新：&lt;/p>
&lt;ul>
&lt;li>开始支持 OVS-DPDK 以便于支持高性能 dpdk 应用；&lt;/li>
&lt;li>支持使用 BGP 将 Pod IP 路由宣告到外部网络；&lt;/li>
&lt;li>在创建后，支持修改子网 CIDR （我个人觉得这个功能特别有用，网络规划也有动态调整的实际需求）；&lt;/li>
&lt;li>当子网网关修改后，路由可以自动更改；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友请参考其 &lt;a href="https://github.com/alauda/kube-ovn/releases/tag/v1.2.0">RelaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>本周 Kubernetes v1.19.0-beta1 已经发布！&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91113">#91113&lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/pull/91481">#91481&lt;/a> 在 &lt;code>kubectl create deployment&lt;/code> 时，增加了 &lt;code>--port&lt;/code> 的选项；&lt;/li>
&lt;/ul>
&lt;p>另一个值得开心的变更来自 etcd :&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd/pull/11946">#11946&lt;/a> 为 etcd 添加了一个 &lt;code>--unsafe-no-fsync&lt;/code> 的选项，可以禁止文件同步。这对于本地开发/CI 测试都是非常好的！&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/IPv6/" term="IPv6" label="IPv6"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v19.03.10 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/05/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/05/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-05-31T23:18:33+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Node Exporter v1.0.0 正式发布 Prometheus 是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="node-exporter-v100-正式发布">Node Exporter v1.0.0 正式发布&lt;/h2>
&lt;p>&lt;a href="https://prometheus.io/">Prometheus&lt;/a> 是最早由 SoundCloud 开源的监控告警解决方案。并已经成长为继 Kubernetes 之后，第二个从 CNCF 毕业的项目。伴随着云原生理念的普及和 Kubernetes 等技术的发展， Prometheus 在监控领域也有了长足的发展。&lt;/p>
&lt;p>其主要组件包括 Prometheus，Alertmanager，Node Exporter，Blackbox Exporter 和 Pushgateway 等。&lt;/p>
&lt;p>Promethues 采取 Pull 的模式，所采集的 metrics 需要由对应的 Exporter 暴露出来。我们最常用的用于收集系统 metrics 的组件便是 Node Exporter 了。&lt;/p>
&lt;p>本周，Node Exporter 终于迎来了 v1.0.0 版本，标志着它更加稳定，更加通用。&lt;/p>
&lt;p>我在本周专门写了一篇文章来介绍它这个版本中我最关注的特性： &lt;a href="https://zhuanlan.zhihu.com/p/144048025">为 Prometheus Node Exporter 加上认证&lt;/a>, 我们可以让监控变得更加安全。&lt;/p>
&lt;p>当然这个版本中也包含了众多变更和 bugfix， 这里暂且跳过，有兴趣的小伙伴可直接参阅其 &lt;a href="https://github.com/prometheus/node_exporter/releases/tag/v1.0.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-v190310-发布">Docker v19.03.10 发布&lt;/h2>
&lt;p>Docker 在本周发布了 v19.03.10 版本，距离上个版本 v19.03.9 仅过了两周的时间，如果在使用 Docker v19.03.x 版本的小伙伴，我个人还是建议你更新到此版本。&lt;/p>
&lt;p>此版本中最主要的一个修复是网络相关的，具体而言是与内置 DNS （embedded DNS） 有关的问题，在特定场景下，如果你创建了自定义网络，当解析外部域名时，可能会出现解析失败的情况。&lt;/p>
&lt;p>这个问题的根因最早是今年 3 月份我在参与 Docker 开发时遇到的，当内置 DNS 服务器域名解析失败时，可能会触发 panic 导致 Docker daemon 异常退出。随后 &lt;em>Sam Whited&lt;/em> 在 &lt;code>moby/libnetwork&lt;/code> 中快速的对其进行了修正。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- if err != nil &amp;amp;&amp;amp; !resp.Truncated {
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ if err != nil &amp;amp;&amp;amp; (resp != nil &amp;amp;&amp;amp; !resp.Truncated) {
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改的内容看起来很简单，在异常处理时，增加了 &lt;code>resp != nil&lt;/code> 的条件，这确实修正了我当时遇到的情况。&lt;/p>
&lt;p>但这个修正却会忽略返回错误但无响应的情况，比如 DNS 服务器异常之类的情况。但由于后续 Docker 中的逻辑处理中，需要依赖于此处的错误处理，所以会错误的认为 DNS 服务器已连接成功，只是没有响应罢了。这也就带来了问题。&lt;/p>
&lt;p>所以这次的修正，也还是在这个位置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-diff" data-lang="diff">&lt;span class="gd">- if err != nil &amp;amp;&amp;amp; (resp != nil &amp;amp;&amp;amp; !resp.Truncated) {
&lt;/span>&lt;span class="gd">&lt;/span>&lt;span class="gi">+ if err != nil &amp;amp;&amp;amp; (resp == nil || !resp.Truncated) {
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>处理了两种情况：&lt;/p>
&lt;ul>
&lt;li>如果返回了错误，并且响应为空；&lt;/li>
&lt;li>如果返回了错误，并且和截断的响应无关；&lt;/li>
&lt;/ul>
&lt;p>经过这次的修正，那就基本覆盖了目前能考虑到的所有情况了。希望大家能尽早升级版本。&lt;/p>
&lt;h2 id="trivy-发布-v08-版本">trivy 发布 v0.8 版本&lt;/h2>
&lt;p>在之前的 「K8S 生态周报」中已经介绍过 trivy 工具了，是一款很方便的镜像安全扫描工具。 本周它发布了 v0.8 的版本，带来了几个值得关注的变更。&lt;/p>
&lt;ul>
&lt;li>增加了新的子命令 &lt;code>trivy image $IMAGE_NAME&lt;/code> ，同时废弃了之前的 &lt;code>trivy $IMAGE_NAME&lt;/code> 的格式；&lt;/li>
&lt;li>增加 &lt;code>--format=json&lt;/code> 用于以 JSON 形式输出结果，更便于与其他系统进行集成；&lt;/li>
&lt;li>通过设置 &lt;code>TRIVY_REGISTRY_TOKEN&lt;/code> 环境变量，可设置 registry token 便于直接拉取镜像进行扫描；&lt;/li>
&lt;/ul>
&lt;p>可直接访问 &lt;a href="https://github.com/aquasecurity/trivy/releases/tag/v0.8.0">Release 页面&lt;/a> 下载使用新版本。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90960">#90960&lt;/a> 修正了 &lt;code>kubectl create secret docker-registry --from-file&lt;/code> 不可用的问题；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91182">#91182&lt;/a> kubelet 的 &lt;code>--seccomp-profile-root&lt;/code> 选项移动到了配置文件中；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91171">#91171&lt;/a> 将 etcd 的镜像换成了基于 distroless 的镜像，之前已经把其他的一些镜像都换掉了，主要考虑的点可能是安全和体积相关的问题吧。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">为 Prometheus Node Exporter 加上认证</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/05/26/%E4%B8%BA-Prometheus-Node-Exporter-%E5%8A%A0%E4%B8%8A%E8%AE%A4%E8%AF%81/"/><id>https://moelove.info/2020/05/26/%E4%B8%BA-Prometheus-Node-Exporter-%E5%8A%A0%E4%B8%8A%E8%AE%A4%E8%AF%81/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-05-26T23:21:58+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这篇文章主要是为了庆祝 Node Exporter 终于迎来了 v1.0.0 版本。 Prometheus 是最早由 SoundCloud 开源的监控告警解决方案。并已经成长为继 Kubernetes 之后，第二个从 CNCF 毕业的项目。伴随……</summary><content type="html">&lt;blockquote>
&lt;p>这篇文章主要是为了庆祝 Node Exporter 终于迎来了 v1.0.0 版本。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://prometheus.io/">Prometheus&lt;/a> 是最早由 SoundCloud 开源的监控告警解决方案。并已经成长为继 Kubernetes 之后，第二个从 CNCF 毕业的项目。伴随着云原生理念的普及和 Kubernetes 等技术的发展， Prometheus 在监控领域也有了长足的发展。&lt;/p>
&lt;p>其主要组件包括 Prometheus，Alertmanager，Node Exporter，Blackbox Exporter 和 Pushgateway 等。&lt;/p>
&lt;p>本文主要是为了庆祝 Node Exporter 终于迎来了 v1.0.0 版本， 所以重点主要放在一直被人诟病的安全性相关上，具体而言就是利用 TLS 和 Basic Auth 提升其安全性。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>Node Exporter 是 Prometheus 官方发布的，用于采集节点的系统信息，比如 CPU，内存，磁盘和网络等信息。
通常情况下，如果我们在使用 Prometheus 作为监控方案，那 Node Exporter 基本都会用到的。&lt;/p>
&lt;p>在 Promethues 的监控体系中，社区中一直存在的一个观点是，Metrics 不包含过于私密的信息。所以你可以看到，大多数的 &lt;code>/metrics&lt;/code> 接口都是直接暴露出来的，没什么特别的安全措施。&lt;/p>
&lt;p>但随着 Prometheus 在生产中的大量应用，安全问题变得更加重要。&lt;/p>
&lt;p>大家最先想到的解决办法就是，为 Prometheus 与监控目标之间的连接启用 TLS。 但由于各类 exporter 并不原生支持 TLS 连接，所以通常情况下我们会选择&lt;a href="https://prometheus.io/docs/guides/tls-encryption/">配合反向代理&lt;/a>来完成。&lt;/p>
&lt;p>这种方式能满足需求，但未免复杂了些。近期 &lt;strong>Prometheus 对其安全模型做了修改&lt;/strong> ， 从 Node Exporter 开始到后续其他的组件，都将支持 TLS 和 basic auth， 同时也列出了最新的安全基准（默认情况下都支持 TLS v1.2 及以上）&lt;/p>
&lt;h2 id="使用-tls">使用 TLS&lt;/h2>
&lt;p>这里我们直接实践下看看如何启用 TLS 。&lt;/p>
&lt;h3 id="准备证书">准备证书&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ mkdir -p prometheus-tls
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ &lt;span class="nb">cd&lt;/span> prometheus-tls
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls openssl req -new -newkey rsa:2048 -days &lt;span class="m">365&lt;/span> -nodes -x509 -keyout node_exporter.key -out node_exporter.crt -subj &lt;span class="s2">&amp;#34;/C=CN/ST=Beijing/L=Beijing/O=Moelove.info/CN=localhost&amp;#34;&lt;/span>
Generating a RSA private key
...........................................+++++
..+++++
writing new private key to &lt;span class="s1">&amp;#39;node_exporter.key&amp;#39;&lt;/span>
-----
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls ls
node_exporter.crt node_exporter.key
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上面的步骤，我们得到了 &lt;code>node_exporter.crt&lt;/code> 和&lt;code> node_exporter.key&lt;/code> 这两个文件。&lt;/p>
&lt;h3 id="node-exporter-使用-tls">Node Exporter 使用 TLS&lt;/h3>
&lt;p>&lt;a href="https://github.com/prometheus/node_exporter/releases/tag/v1.0.0">下载 v1.0.0 版本的 Node Exporter&lt;/a>， 并对其进行解压等操作&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ /tmp tar -zxvf node_exporter-1.0.0.linux-amd64.tar.gz
node_exporter-1.0.0.linux-amd64/
node_exporter-1.0.0.linux-amd64/node_exporter
node_exporter-1.0.0.linux-amd64/NOTICE
node_exporter-1.0.0.linux-amd64/LICENSE
(MoeLove) ➜ /tmp cd node_exporter-1.0.0.linux-amd64
(MoeLove) ➜ node_exporter-1.0.0.linux-amd64 ls
LICENSE node_exporter NOTICE
&lt;/code>&lt;/pre>&lt;p>复制前面生成的 &lt;code>node_exporter.crt&lt;/code> 和&lt;code> node_exporter.key&lt;/code> 这两个文件到当前目录下。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ node_exporter-1.0.0.linux-amd64 cp ~/prometheus-tls/node_exporter.* .
(MoeLove) ➜ node_exporter-1.0.0.linux-amd64 ls
LICENSE node_exporter node_exporter.crt node_exporter.key NOTICE
&lt;/code>&lt;/pre>&lt;p>编写配置文件，并保存为 &lt;code>config.yaml&lt;/code> （命名随意）：&lt;/p>
&lt;pre>&lt;code>tls_server_config:
cert_file: node_exporter.crt
key_file: node_exporter.key
&lt;/code>&lt;/pre>&lt;p>接下来就使用 &lt;code>--web.config&lt;/code> 将配置文件传递给 Node Exporter&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ node_exporter-1.0.0.linux-amd64 ./node_exporter --web.config=config.yaml
level=info ts=2020-05-26T17:50:12.123Z caller=node_exporter.go:177 msg=&amp;quot;Starting node_exporter&amp;quot; version=&amp;quot;(version=1.0.0, branch=HEAD, revision=b9c96706a7425383902b6143d097cf6d7cfd1960)&amp;quot;
level=info ts=2020-05-26T17:50:12.124Z caller=node_exporter.go:178 msg=&amp;quot;Build context&amp;quot; build_context=&amp;quot;(go=go1.14.3, user=root@3e55cc20ccc0, date=20200526-06:01:48)&amp;quot;
level=info ts=2020-05-26T17:50:12.130Z caller=node_exporter.go:105 msg=&amp;quot;Enabled collectors&amp;quot;
...
level=info ts=2020-05-26T17:50:12.135Z caller=tls_config.go:200 msg=&amp;quot;TLS is enabled and it cannot be disabled on the fly.&amp;quot; http2=true
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当你看到最后这句日志时，就说明你的 Node Exporter 已经启用了 TLS 连接。&lt;/strong>&lt;/p>
&lt;p>当然，我们也可以选择手动验证下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 直接 curl 请求&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls curl localhost:9100/metrics
Client sent an HTTP request to an HTTPS server.
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls curl https://localhost:9100/metrics
curl: &lt;span class="o">(&lt;/span>60&lt;span class="o">)&lt;/span> SSL certificate problem: self signed certificate
More details here: https://curl.haxx.se/docs/sslcerts.html
curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到不能直接 curl 进行请求了，我们可以将证书传递给 curl ，用来验证刚才的配置是否正确。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls curl -s --cacert node_exporter.crt https://localhost:9100/metrics &lt;span class="p">|&lt;/span>grep node_exporter_build_info
&lt;span class="c1"># HELP node_exporter_build_info A metric with a constant &amp;#39;1&amp;#39; value labeled by version, revision, branch, and goversion from which node_exporter was built.&lt;/span>
&lt;span class="c1"># TYPE node_exporter_build_info gauge&lt;/span>
node_exporter_build_info&lt;span class="o">{&lt;/span>&lt;span class="nv">branch&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;HEAD&amp;#34;&lt;/span>,goversion&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;go1.14.3&amp;#34;&lt;/span>,revision&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;b9c96706a7425383902b6143d097cf6d7cfd1960&amp;#34;&lt;/span>,version&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1.0.0&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，除了通过 &lt;code>--cacert&lt;/code> 参数将证书传递给 curl 外，也可以通过 &lt;code>-k&lt;/code> 参数来忽略证书检查。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls curl -s -k https://localhost:9100/metrics &lt;span class="p">|&lt;/span>grep node_exporter_build_info
&lt;span class="c1"># HELP node_exporter_build_info A metric with a constant &amp;#39;1&amp;#39; value labeled by version, revision, branch, and goversion from which node_exporter was built.&lt;/span>
&lt;span class="c1"># TYPE node_exporter_build_info gauge&lt;/span>
node_exporter_build_info&lt;span class="o">{&lt;/span>&lt;span class="nv">branch&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;HEAD&amp;#34;&lt;/span>,goversion&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;go1.14.3&amp;#34;&lt;/span>,revision&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;b9c96706a7425383902b6143d097cf6d7cfd1960&amp;#34;&lt;/span>,version&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1.0.0&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-prometheus-使用-tls">配置 Prometheus 使用 TLS&lt;/h3>
&lt;p>接下来，我们就要配置 Prometheus 通过 HTTPS 从 Node Exporter 获取指标了。安装过程很简单，无论直接下载最新的二进制版本，或是直接使用 Docker 镜像均可。&lt;/p>
&lt;p>注意，我这里把上文中签发的证书复制到了当前目录中。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-2.18.1.linux-amd64 cp ~/prometheus-tls/node_exporter.crt .
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-2.18.1.linux-amd64 ls
console_libraries consoles LICENSE node_exporter.crt NOTICE prometheus prometheus.yml promtool tsdb
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，需要修改下配置文件，让 Prometheus 可以抓取 Node Exporter 暴露的 metrics 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">global&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scrape_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">15s &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">evaluation_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">15s &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">scrape_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;prometheus&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;localhost:9090&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;node_exporter&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls_config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ca_file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node_exporter.crt&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;localhost:9100&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里额外增加了 &lt;code>scheme: https&lt;/code> 表示通过 HTTPS 建立连接，&lt;code>tls_config&lt;/code> 中指定了所用的证书文件。完整的配置可以参考 &lt;a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tls_config">官方文档中对 tls_config 的说明&lt;/a> 。&lt;/p>
&lt;p>最后，启动 Prometheus 并在浏览器中访问 &lt;a href="http://127.0.0.1:9090/targets">&lt;code>/targets&lt;/code>&lt;/a> ，如果你在 endpoint 中看到 &lt;code>https://localhost:9100/metrics&lt;/code> 了，那么恭喜你，Prometheus 和 Node Exporter 已经通过 TLS 连接了。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/prometheus-tls-target.png" alt="Prometheus TLS - https://moelove.info">&lt;/p>
&lt;h2 id="添加-basic-auth">添加 Basic Auth&lt;/h2>
&lt;p>上文中，我已经为你介绍了如何使用让 Prometheus 和 Node Exporter 间使用 TLS 连接了，接下来，我为你介绍如何增加 Basic Auth 。&lt;/p>
&lt;p>这里需要注意的是，Basic Auth 和 TLS 并不是强依赖的。你可以在不开启 TLS 的情况下使用 Basic Auth ，但我个人建议，要做就做彻底点，同时启用好了。&lt;/p>
&lt;h3 id="为-node-exporter-配置密码">为 Node Exporter 配置密码&lt;/h3>
&lt;p>我们直接可以使用 &lt;code>htpasswd&lt;/code> 来生成 bcrypt 密码 hash （这个工具想必大家不会太陌生）。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls htpasswd -nBC &lt;span class="m">12&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> tr -d &lt;span class="s1">&amp;#39;:\n&amp;#39;&lt;/span>
New password:
Re-type new password:
&lt;span class="nv">$2&lt;/span>y&lt;span class="nv">$12$WLw2sYa&lt;/span>.NYZoBVoCOE84qe3xNm7kbSoKVIBXP.PvqNDna60vnZhEW
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我只用它来生成了密码 hash ， 没有传递用户名。&lt;/p>
&lt;p>接下来，修改上文中提到的 Node Exporter 所用的配置文件，如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">tls_server_config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cert_file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node_exporter.crt&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key_file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node_exporter.key&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">basic_auth_users&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 当前设置的用户名为 prometheus ， 可以设置多个&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">prometheus&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">$2y$12$WLw2sYa.NYZoBVoCOE84qe3xNm7kbSoKVIBXP.PvqNDna60vnZhEW&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次启动 Node Exporter，并使用 curl 请求 metrics 接口，可以看到当前返回 401 。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ prometheus-tls curl -Ik https://127.0.0.1:9100/metrics
HTTP/1.1 &lt;span class="m">401&lt;/span> Unauthorized
Content-Type: text/plain&lt;span class="p">;&lt;/span> &lt;span class="nv">charset&lt;/span>&lt;span class="o">=&lt;/span>utf-8
Www-Authenticate: Basic
X-Content-Type-Options: nosniff
Date: Wed, &lt;span class="m">27&lt;/span> May &lt;span class="m">2020&lt;/span> 11:45:16 GMT
Content-Length: &lt;span class="m">13&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>打开 Prometheus 的 Targets 页面，也会看到当前提示 401 ，无法抓取 metrics 。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/prometheus-tls-target-401.png" alt="Prometheus Basic Auth - https://moelove.info">&lt;/p>
&lt;h3 id="配置-prometheus-使用-basic-auth">配置 Prometheus 使用 Basic Auth&lt;/h3>
&lt;p>接下来，只要修改 Prometheus 的配置文件，为其增加 &lt;code>basic_auth&lt;/code> 的配置项即可。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">global&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scrape_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">15s &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">evaluation_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">15s &lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">scrape_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;prometheus&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;localhost:9090&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;node_exporter&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">scheme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls_config&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ca_file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">node_exporter.crt&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">basic_auth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">username&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">prometheus&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">moelove.info&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">static_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">targets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;localhost:9100&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改配置文件后，只要让 Prometheus 重新加载配置文件即可：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ killall -HUP prometheus
&lt;/code>&lt;/pre>&lt;p>现在刷新 Prometheus 的 Targets 页面，就可以看到已经正常抓取 metrics 了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了如何开启 Prometheus 和 Node Exporter 之间的 TLS 连接， 以及开启 Node Exporter 的 Basic Auth 认证。 在此之前，可能有小伙伴是通过加反代来完成的，比如： &lt;a href="https://blog.fleeto.us/post/node_exp_basic_auth/">给 Node Exporter 加上 Basic 认证&lt;/a>&lt;/p>
&lt;p>在生产中使用时，建议更加规范化操作，比如 CA 的选择，密码的管理等，比如 Node Exporter 的 Basic Auth 其实支持配置多个用户名密码的。&lt;/p>
&lt;p>接下来，在 Prometheus 官方提供的基础组件中，都将逐步推进本文中所提到的这类安全特性的支持，包括 Prometheus，Alertmanager， Pushgateway 和官方 exporter ，后续社区提供的 exporter 大概率也会逐步跟进的。&lt;/p>
&lt;p>最后，再次恭喜 Node Exporter 迎来了 v1.0.0 版本。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Prometheus/" term="Prometheus" label="Prometheus"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v19.03.9 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/05/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.9-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/05/24/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.9-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-05-24T17:56:36+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v19.03.9 发布 Docker 在本周发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v19039-发布">Docker v19.03.9 发布&lt;/h2>
&lt;p>Docker 在本周发布了 v19.03.9 版本，如果有在使用 Docker v19.03.x 版本的小伙伴，我个人强烈建议你更新到此版本。&lt;/p>
&lt;p>在之前的&lt;a href="https://zhuanlan.zhihu.com/p/111833886">「K8S 生态周报」中&lt;/a>，我曾介绍过，自 Docker v19.03.7 开始，其 &lt;code>Backing Filesystem&lt;/code> 的检查逻辑存在问题。&lt;/p>
&lt;p>这会导致在执行 &lt;code>docker info&lt;/code> 的时候，得到如下输出：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker info --format '{{ index .DriverStatus 0 }}'
[Backing Filesystem ]
&lt;/code>&lt;/pre>&lt;p>另外，由于不能正确识别 &lt;code>Backing Filesystem&lt;/code> 也会导致设置 storage quota 时报错。这个问题我早已在上游进行了修复，原计划是在 v19.03.8 中发布，不过由于 v19.03.8 是为安全修复版本发布的， 所以延迟到本次 v19.03.9 中了。&lt;/p>
&lt;p>除了上面提到的这个 bug 以外，本次版本中还有些重要的修复：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/moby/moby/pull/40780">#40780&lt;/a> 修正了 BuildKit 中并发构建多个镜像时，可能引发的 panic；&lt;/li>
&lt;li>&lt;a href="https://github.com/docker/cli/pull/2471">#2471&lt;/a> 修正了 Docker CLI 使用单个数字作为卷时，可能引发的 panic， 举例而言就是：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 修正前&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ docker run -it --rm -v 1:/1 alpine
panic: runtime error: index out of range
...
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 修正后&lt;/span>
docker run -it --rm -v 1:/1 alpine
docker: Error response from daemon: create 1: volume name is too short, names should be at least two alphanumeric characters.
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>修复了为 Docker 通过 &lt;code>--bip&lt;/code> 设置 bridge network 时， IP 地址池计算不一致的问题。&lt;/li>
&lt;/ul>
&lt;p>以上便是 Docker v19.03.9 中比较值得注意的变更，对此版本感兴趣的小伙伴可查看其&lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.9">完整的 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="containerd-140-beta0-发布">containerd 1.4.0-beta.0 发布&lt;/h2>
&lt;p>这是 containerd 的第 5 个大版本（预发布版本），此版本中包含了大量的新特性和漏洞修复，我们一起来看看吧。&lt;/p>
&lt;ul>
&lt;li>增加了对 CGroups v2 的支持；&lt;/li>
&lt;li>改善了对 SELinux 的支持；&lt;/li>
&lt;li>增加 FUSE 挂载支持；&lt;/li>
&lt;li>代理快照插件支持清理行为；&lt;/li>
&lt;li>为快照 API 增加筛选条件；&lt;/li>
&lt;li>添加在 Windows 系统上 CRI 插件的支持；&lt;/li>
&lt;/ul>
&lt;p>在 CRI 方面，同样也做了不少的变更：&lt;/p>
&lt;ul>
&lt;li>添加 Windows 容器进程的隔离；&lt;/li>
&lt;li>&lt;strong>更新默认的运行时为 &lt;code>io.containerd.runc.v2&lt;/code>&lt;/strong> ；&lt;/li>
&lt;li>修正创建特权容器的支持；&lt;/li>
&lt;li>当监听到文件变化事件发生时，重启 CNI 网络配置；&lt;/li>
&lt;li>添加 CGroups v2 的支持；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的小伙伴，可以查看其&lt;a href="https://github.com/containerd/containerd/releases/tag/v1.4.0-beta.0">完整的 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-16-正式发布">Istio 1.6 正式发布&lt;/h2>
&lt;p>Istio 也发布了 v1.6 版本，此版本中继续进行简化， Istiod 变得更加重要，与此同时，Citadel, Sidecar Injector 和 Galley 等在 v1.5 中已经被默认禁用的组件也被移除了。也移除了旧的 &lt;code>istio-pilot&lt;/code> 配置等。&lt;/p>
&lt;p>当然，除了移除一些不再需要的内容外，本次版本也提供了不少新的特性支持，比如增加了 &lt;code>istioctl install&lt;/code> 等命令， &lt;strong>也添加对 Istio 自身的金丝雀更新支持&lt;/strong>（我个人认为这个特性非常好，能为大家提供更多的保障）。&lt;/p>
&lt;p>对此版本感兴趣的小伙伴，可以查看其&lt;a href="https://istio.io/news/releases/1.6.x/announcing-1.6/change-notes/">完整的 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/91046">#91046&lt;/a> Kubelet 不再注册 &lt;code>beta.kubernetes.io/os&lt;/code> 和 &lt;code>beta.kubernetes.io/arch&lt;/code> 节点标签到 api-server 中了。 这俩标签其实从 v1.14 开始就标记废弃了， 本次进行移除罢了；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90061">#90061&lt;/a> 为 CRI &lt;code>ImageSpec&lt;/code> 对象添加 annotation 支持，主要是处于对 Windows 平台的考虑；&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>上周我儿子出生了，我一直在医院陪护来着，所以「K8S 生态周报」停更了一期，感谢大家的理解和支持~本周恢复正常更新。&lt;/p>
&lt;p>（新手奶爸练级中~&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.2.1 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/05/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.2.1-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/05/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.2.1-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-05-10T23:53:49+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.2.1 版本发布 本周 Helm……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v321-版本发布">Helm v3.2.1 版本发布&lt;/h2>
&lt;p>本周 Helm 发布了 v3.2.1 版本，这是 v3.2 系列的第一个 patch 版本。此次包含一些值得关注的内容：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/7959">#7959&lt;/a> 修复了一个 Helm v3 从 3.0-rc 版一直存在的一个 bug ，详情见 &lt;a href="https://github.com/helm/helm/issues/6899">#6899&lt;/a>, 但 &lt;code>--reuse-values&lt;/code> 这个参数用的人可能不多，实际上影响没那么大；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/7653">#7653&lt;/a> 修改了 &lt;code>helm upgrade&lt;/code> 的行为，允许对一个失败的 Release 执行 &lt;code>helm upgrade&lt;/code> 进行重新部署，而不需要先删除掉旧的 Release；（方便了很多！）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其实本周 Helm 还发布了 v2.16.7 ，虽然 Helm 2 已经进入了维护期，但不得不说，维护团队还是很靠谱的，一直在持续打 patch 中。&lt;/p>
&lt;p>继续建议大家升级至 Helm v3 。&lt;/p>
&lt;p>对此版本感兴趣的朋友可查看其完整的 &lt;a href="https://github.com/helm/helm/releases/tag/v3.2.1">ReleaseNote&lt;/a> 。&lt;/p>
&lt;h2 id="rancher-v243-发布">Rancher v2.4.3 发布&lt;/h2>
&lt;p>Rancher v2.4 是个大版本，本次发布的 v2.4.3 中包含了其不少更新和修复，一起来看看吧！&lt;/p>
&lt;ul>
&lt;li>对于使用 RHEL/CentOS 节点池的用户，默认的 Docker 存储驱动已经修改成了 &lt;code>overlay2&lt;/code>，这里需要尤其注意。 原本的 &lt;code>devicemapper&lt;/code> 存储驱动已经在 Docker 中被标记为废弃，之前的周报中也有做过相关解释，此处不再赘述；&lt;/li>
&lt;li>实验性新功能的 Feature Flags 选项，你可以通过启动参数指定，或者直接通过 UI 来进行选择，使用文档参考 &lt;a href="https://rancher.com/docs/rancher/v2.x/en/admin-settings/feature-flags/">https://rancher.com/docs/rancher/v2.x/en/admin-settings/feature-flags/&lt;/a> ；&lt;/li>
&lt;li>&lt;a href="https://github.com/rancher/rancher/issues/21361">#21361&lt;/a> &lt;strong>修复了 Rancher 内存泄漏，可能导致系统 OOM 的问题&lt;/strong>；&lt;/li>
&lt;li>&lt;a href="https://github.com/rancher/rancher/issues/26061">#26061&lt;/a> 修复了当有大量 LDAP group 的时候，登录慢的情况；&lt;/li>
&lt;/ul>
&lt;p>还有一些其他的修正和改进，有兴趣的朋友可参考其 &lt;a href="https://github.com/rancher/rancher/releases/tag/v2.4.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88915">#88915&lt;/a> 修正了一个 kubelet image manager 中可能会导致 static pod workers 停止工作的问题。这个问题看记录是从 1.10 引入的，但我还尚未在生产环境中遇到此问题。不过还是建议尽快升级；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89660">#89660&lt;/a> kubectl 的输出格式中，将会提供一个 将 JSONPATH 输出为 JSON 的选项，&lt;/li>
&lt;/ul>
&lt;p>示例输出如下：&lt;/p>
&lt;pre>&lt;code>old:
$ /old/kubectl get pod -o=jsonpath='{ ..'ip' }'
10.42.0.50 10.42.0.48 10.42.0.49
new/unchanged:
$ kubectl get pod -o=jsonpath='{ ..'ip' }'
10.42.0.50 10.42.0.49 10.42.0.48
new:
$ kubectl get pod -o=jsonpath-as-json='{ ..'ip' }'
[
&amp;quot;10.42.0.50&amp;quot;,
&amp;quot;10.42.0.49&amp;quot;,
&amp;quot;10.42.0.48&amp;quot;
]
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88723">#88723&lt;/a> &lt;code>kubectl taint&lt;/code> 变得更加灵活，不再需要指定全部的资源名了；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| KIND v0.8 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/05/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-KIND-v0.8-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/05/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-KIND-v0.8-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-05-03T21:34:30+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KIND v0.8 正式发布 本周 K……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v08-正式发布">KIND v0.8 正式发布&lt;/h2>
&lt;p>本周 &lt;a href="https://kind.sigs.k8s.io/">KIND（Kubernetes In Docker）&lt;/a> 正式发布了 v0.8 版本，此次最主要的是为大家带来了 &lt;strong>持久化集群&lt;/strong>，当主机或者 dockerd 重启后，集群可自动恢复。&lt;/p>
&lt;h3 id="breaking-changes">Breaking Changes&lt;/h3>
&lt;ul>
&lt;li>此次默认的集群镜像是 Kubernetes &lt;code>v1.18.2&lt;/code> : &lt;code>kindest/node:v1.18.2@sha256:7b27a6d0f2517ff88ba444025beae41491b016bc6af573ba467b70c5e8e0d85f&lt;/code> ;&lt;/li>
&lt;li>当使用 KIND v0.8+ 启动集群时，必须使用通过 KIND v0.8+ 构建的 node 镜像，否则无法按预期工作；&lt;/li>
&lt;li>新版本中， KIND 创建出来的所有 Node ，都使用自定义的 bridge 网络（默认名称为 &lt;code>kind&lt;/code>，可通过环境变量 &lt;code>KIND_EXPERIMENTAL_DOCKER_NETWORK&lt;/code> 修改）；&lt;/li>
&lt;li>你可以在启动任意容器时，增加 &lt;code>--network=kind&lt;/code>，以便让它和 KIND 创建的集群网络互通；&lt;/li>
&lt;/ul>
&lt;p>这里需要特别说一下关于持久化集群的特性。在之前版本中，如果你的 dockerd 进行了重启操作，或者是重启了系统，那可能会导致集群 IP 重新分配，进而导致集群状态异常。&lt;/p>
&lt;p>在之前版本中，我们建议所有的用户，不要依赖集群持久化。但鉴于有不少用户的反馈，所以我先实现了第一版。&lt;/p>
&lt;p>具体做法其实也简单，原先的痛点在于重启后，容器 IP 的重新分配，所以全部以域名的方式进行替代，另外就是借助于 Docker 的 embedded DNS 来完成 LB 层对 master 的代理。&lt;/p>
&lt;p>但这个实现，会产生一个 DNS 查询异常的问题，我在专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a> 网络篇中深入介绍过其原理。之前我考虑过通过 &lt;code>--resolv-conf&lt;/code> 参数，将主机的 resolver 提供给 kubelet 使用，但这种方式并不够优雅，而且排查问题的话，由于不与 kubelet 使用相同 &lt;code>resolv.conf&lt;/code> ，也会带来一些麻烦；之后考虑将主机和 Node 中的 resolver 进行合并，但合并的话，也会带来一些隐患。&lt;/p>
&lt;p>本次版本中的实现，其实是对 Docker embedded DNS 做了很多 hack，主动对网络做了管理，以此来完成此需求。&lt;/p>
&lt;h3 id="features">Features&lt;/h3>
&lt;ul>
&lt;li>&lt;code>kind delete clusters --all&lt;/code> 可用于删除所有集群；&lt;/li>
&lt;li>配置文件中新增了顶级 &lt;code>featureGates&lt;/code> 字段，来开启相关特性；&lt;/li>
&lt;li>&lt;code>NO_COLOR&lt;/code> 的支持；&lt;/li>
&lt;li>实验性的对 &lt;code>podman&lt;/code> 提供了支持；&lt;/li>
&lt;li>支持通过 &lt;code>KIND_CLUSTER_NAME&lt;/code> 环境变量来指定集群名称；&lt;/li>
&lt;li>支持动态 PV 在 k8s v.11.x；&lt;/li>
&lt;/ul>
&lt;p>以上就是此次 KIND v0.8 中值得注意的内容，欢迎大家下载使用！使用方式可参考&lt;a href="https://zhuanlan.zhihu.com/p/105173589">《使用 Kind 在离线环境创建 K8S 集群》&lt;/a>&lt;/p>
&lt;h2 id="nginx-ingress-controller-170-发布">NGINX Ingress Controller 1.7.0 发布&lt;/h2>
&lt;p>本周 &lt;a href="https://github.com/nginxinc/kubernetes-ingress">NGINX Ingress Controller&lt;/a> 1.7.0 发布了，包含了众多更新：&lt;/p>
&lt;ul>
&lt;li>支持通过新的资源 &lt;code>TransportServer&lt;/code> 和 &lt;code>GlobalConfiguration&lt;/code> 配置 TCP/UDP/TLS 的负载均衡，这样便可通过 NGINX Ingress Controller 在 Kubernetes 上交付非基于 HTTP 的应用程序；&lt;/li>
&lt;li>支持在 &lt;code>VirtualServer&lt;/code> 和 &lt;code>VirtualServerRoute&lt;/code> 资源中配置错误页；&lt;/li>
&lt;li>支持在 Kubernetes 或 OpenShift 上，通过 &lt;a href="https://github.com/nginxinc/nginx-ingress-operator">NGINX Ingress Operator&lt;/a> 管理 Ingress 的生命周期；&lt;/li>
&lt;/ul>
&lt;p>关于此版本的更详细内容，请参考其 &lt;a href="https://github.com/nginxinc/kubernetes-ingress/releases/tag/v1.7.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89285">#89285&lt;/a> 移除了 k/k 中对上游 prometheus client 库的依赖，全部替换成了 kubernetes 实现的 metrics 框架。这是为了实施早先的一个 &lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-instrumentation/20190605-metrics-stability-migration.md">指标稳定性迁移（Metrics Stability Migration）的 KEP&lt;/a> ；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90394">#90394&lt;/a> 修正了 kubeadm 中对 &lt;code>resolvConf&lt;/code> 的行为。kubeadm 将不会在 &lt;code>/var/lib/kubelet/kubeadm-flags.env&lt;/code> 中设置 &lt;code>--resolv-conf&lt;/code> 的值，而是使用 &lt;code>KubeletConfiguration&lt;/code> 对其进行配置；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90463">#90463&lt;/a> &lt;code>autoscaling/v2beta1&lt;/code> 已废弃，推荐使用 &lt;code>autoscaling/v2beta2&lt;/code> ；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89594">#89594&lt;/a> 将不可变 Secrets/ConfigMaps 提升至 Beta 阶段，并且 &lt;strong>默认打开&lt;/strong> ，用户可通过设置 &lt;code>Immutable&lt;/code> 字段来标记其内容为不可变；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/90449">#90449&lt;/a> 移除了 events API 中未使用的 &lt;code>series.state&lt;/code> 字段；&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/weaveworks/kured">kured&lt;/a> 是一个用于节点安全重启的 Daemonset 。它包含以下特性：&lt;/p>
&lt;ul>
&lt;li>监听重启标志，例如 &lt;code>/var/run/reboot-required&lt;/code>；&lt;/li>
&lt;li>利用 API server 中的锁来保障每次只重启一个节点；&lt;/li>
&lt;li>（可选）根据 Prometheus 报警或者选定 Pod 的情况下，延迟重启；&lt;/li>
&lt;li>在重启节点前会自动执行 &lt;code>cordon&lt;/code> 和 &lt;code>drain&lt;/code> ，在节点重启完成后执行 &lt;code>uncordon&lt;/code> ；&lt;/li>
&lt;/ul>
&lt;p>这在系统需要定期维护时候，是非常有用的。同时也可自己手动进行触发，而不需每次重复操作。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.2 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/04/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/04/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-04-26T15:49:33+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.2.0 正式发布 经过两……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v320-正式发布">Helm v3.2.0 正式发布&lt;/h2>
&lt;p>经过两个多月的时间，Helm v3.2 终于在本周正式发布了！&lt;/p>
&lt;p>这个版本带来了很多值得关注的内容，我们一起来看看吧。&lt;/p>
&lt;h3 id="postgres-存储支持">postgres 存储支持&lt;/h3>
&lt;p>Helm v2 时候，Release 默认是以 &lt;code>configmap&lt;/code> 存储的，此外还支持存储为 &lt;code>memory&lt;/code>, &lt;code>secret&lt;/code> 或 &lt;code>sql&lt;/code> 。在 Helm v3 时，社区对此做出了调整，提供了 &lt;code>configmap&lt;/code>, &lt;code>secret&lt;/code> 和 &lt;code>memory&lt;/code> 等三种存储模式，并且默认的存储方式也变成了以 &lt;code>secret&lt;/code> 进行存储。所以你可以直接通过 &lt;code>kubectl get secret&lt;/code> 看到你部署的 release 。&lt;/p>
&lt;p>本次发布的 Helm v3.2 中，对此有了个重大变更！&lt;/p>
&lt;p>本次 v3.2 中，Helm v3 中移植了 Helm v2 版本时，对 &lt;code>sql&lt;/code> 存储的支持，即：第四种 &lt;code>postgres&lt;/code>, 通过组合 &lt;code>$HELM_DRIVER&lt;/code> 和 &lt;code>$HELM_DRIVER_SQL_CONNECTION_STRING&lt;/code> 环境变量，便可达到效果。&lt;/p>
&lt;p>&lt;em>需要注意的是，这还是个实验中的特性，尚未正式 GA。尝鲜可以，但尽量别放在生产环境中使用。&lt;/em>&lt;/p>
&lt;h3 id="其他变更">其他变更&lt;/h3>
&lt;ul>
&lt;li>在添加 repo 的时候，增加了 &lt;code>--insecure-skip-tls-verify&lt;/code> 参数，可跳过 TLS 检查：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>(MoeLove) ➜ ~ helm3 repo add -h |grep 'insecure-skip-tls-verify'
--insecure-skip-tls-verify skip tls certificate checks for the repository
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>修复了一个&lt;a href="https://github.com/helm/helm/security/advisories/GHSA-q8q8-93cv-v6h8">重要漏洞&lt;/a>，虽然 Helm 社区也发布了 v3.1.3 来解决此安全问题，但建议还是直接升级到 v3.2 (毕竟它还有 40+ 项 bugfix)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>helm3 completion&lt;/code> 有了显著改进，自动补全效果变好了；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>还有其他很多小的 bugfix 这里就不再介绍了，感兴趣的朋友请参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.2.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="prometheus-2180-rc0-发布">Prometheus 2.18.0-rc.0 发布&lt;/h2>
&lt;p>这是 Prometheus v2.18.0 的首个 rc 版，这里介绍它，主要是由于本次新增了一个有趣的特性。 &lt;a href="https://github.com/prometheus/prometheus/pull/7148">&lt;strong>增加了 Jaeger 的支持&lt;/strong>&lt;/a>&lt;/p>
&lt;p>在之前的文章中，已经多次介绍过 &lt;a href="https://www.jaegertracing.io/">Jaeger&lt;/a> 了，它是一个端对端的分布式 trace 系统，同样也是 CNCF 的毕业项目。&lt;/p>
&lt;p>此次增加的对 Jaeger 支持，可帮助我们了解 Prometheus 中每个查询的执行情况。&lt;/p>
&lt;p>但也请注意：添加 Jaeger 支持算是一个临时的解决办法，最终目标是转向 OpenTelemetry 。(此状态可能会持续很长一段时间)&lt;/p>
&lt;p>可直接下载二进制文件或使用 Docker 镜像进行体验 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.18.0-rc.0">https://github.com/prometheus/prometheus/releases/tag/v2.18.0-rc.0&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-nginx-ingress-v0310-发布">Kubernetes NGINX Ingress v0.31.0 发布&lt;/h2>
&lt;p>本次发布的主要变化如下：&lt;/p>
&lt;ul>
&lt;li>NGINX 升级至 1.17.10&lt;/li>
&lt;li>OpenSSL 升级至 1.1.1g ， 主要是为了避免受 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1967">CVE-2020-1967&lt;/a> 漏洞的影响；&lt;/li>
&lt;li>支持使用 comfigmap 配置 lua plugin；&lt;/li>
&lt;/ul>
&lt;p>完整变更请参考其 &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/Changelog.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88480">#88480&lt;/a> Kubelet 的 &lt;code>--volume-plugin-dir&lt;/code> 选项，现在可通过配置文件中的 &lt;code>VolumePluginDir&lt;/code> 参数进行配置了；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89861">#89861&lt;/a> 修正了 &lt;code>kubectl get&lt;/code> 未找到非命名空间资源时候的输出提示。例如：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code># 修改前
(MoeLove) ➜ ~ kubectl get pv
No resources found in default namespace.
# 修改后
(MoeLove) ➜ ~ kubectl get pv
No resources found
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Docker 还需要学习吗？</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/04/24/Docker-%E8%BF%98%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%90%97/"/><id>https://moelove.info/2020/04/24/Docker-%E8%BF%98%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%90%97/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-04-24T07:12:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">去年中在 Hacker News 上有篇热帖 “Goodbye Docker: Purging is Such Sweet Sorrow” 这篇文章内容其实很常规，无非是自己使用 Docker 的时候遇到了一些问题，最后……</summary><content type="html">&lt;p>去年中在 Hacker News 上有篇热帖 &lt;a href="https://zwischenzugs.com/2019/07/27/goodbye-docker-purging-is-such-sweet-sorrow/">“Goodbye Docker: Purging is Such Sweet Sorrow”&lt;/a> 这篇文章内容其实很常规，无非是自己使用 Docker 的时候遇到了一些问题，最后切换到了 &lt;code>Podman&lt;/code> &lt;code>buildah&lt;/code> 和 &lt;code>Skopeo&lt;/code> 组合的工具集，以作为 Docker 的一种替代方案。&lt;/p>
&lt;p>这样的文章在近一年左右应该算是比较常见了，但为何会成为 Hacker News 上的热帖呢？主要有两方面的原因： 1. 还是因为此文的作者是 Ian Miell 他是 Docker in Practice (中译本叫做 《Docker 实践》)的作者，一个 Docker 相关技术书籍的作者将自己的 Docker 给替换掉，会让人比较好奇；2. 替换 Docker 貌似是一种方向，多数人也想要了解这种技术变迁会带来什么优势或者有什么样的坑。&lt;/p>
&lt;p>背景介绍完了，我们来开始正文。&lt;/p>
&lt;h2 id="容器时代">容器时代&lt;/h2>
&lt;p>Docker 在 2013 年 PyCon 上首次亮相，随后开源。由于其简单易用，以及切实解决了因环境不一致导致的问题，迅速获得到一大批粉丝。&lt;/p>
&lt;p>接下来的几年中，Docker 改变了软件的交付方式，更多的人为之着迷。随之而来的是 Docker 生态的蓬勃发展。&lt;/p>
&lt;p>Docker 在大多数人眼中几乎是容器（container）的代名词，即使是现在我也会常听到有人说“我有几个 docker 跑 xx 服务” 类似这样的话，无疑 &lt;strong>Docker 引领了容器的时代&lt;/strong>。&lt;/p>
&lt;h3 id="容器是什么">容器是什么&lt;/h3>
&lt;p>一直在提容器，我们不如深入点先来探究下容器到底是什么？&lt;/p>
&lt;p>在 &lt;a href="https://www.docker.com/resources/what-container">Docker 官网&lt;/a>上对容器的描述是： &lt;em>“A standardized unit of software”&lt;/em> -- 软件的标准单元，并没有什么更详细的内容了。多数人对容器的看法也都停留在很浅显的认识：认为容器是轻量级的虚拟机，所以后来也就有一段时间有人推“富容器”技术。&lt;/p>
&lt;p>这里我想更深入一些，可能会涉及一些容器的历史，但我认为这些内容有助于读者理解我的角度和观点。&lt;/p>
&lt;p>说白了 &lt;strong>容器其实是在某台机器上的“一组”进程，当然这组进程可能只有一个；它们有相同的特性，当然所受的限制也是相同的；既然叫做容器，很自然的我们认为它们与外界可以进行隔离/应该有一个分界线。&lt;/strong>&lt;/p>
&lt;p>谈完了它的基本特性，那我们来看看如何来创建一个容器。&lt;/p>
&lt;h4 id="chroot">chroot&lt;/h4>
&lt;p>如果你对 Linux 相对熟悉的话，你可能知道 &lt;code>chroot&lt;/code> ，我们有时会使用 &lt;code>chroot&lt;/code> 改变某进程的根目录，并且它不能访问该目录之外的其他目录。&lt;/p>
&lt;p>这个和我们在一个容器内的感觉很像了。事实上在几年前确实有人用一百多行的 bash shell 利用 &lt;code>chroot&lt;/code> 写了一个模拟 Docker 创建容器的实现，称之为 &lt;a href="https://github.com/p8952/bocker">bocker&lt;/a> , 有兴趣的朋友可以去看看该项目的代码。&lt;/p>
&lt;p>接下来我们使用 &lt;code>chroot&lt;/code> 创建一个隔离环境：&lt;/p>
&lt;p>首先它需要有一个 &lt;code>rootfs&lt;/code> 的根文件系统，我们可以很简单的使用 Docker 获得我们需要的内容。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ mkdir chroot-dir
(MoeLove) ➜ ~ cd chroot-dir
(MoeLove) ➜ chroot-dir docker save -o debian.tar debian:buster
(MoeLove) ➜ chroot-dir ls
debian.tar
(MoeLove) ➜ chroot-dir tar -xf debian.tar
(MoeLove) ➜ chroot-dir ls
098963abf3c3b87b8114ff67d164097dfac2d5659e39f9beb5604db91585f375.json debian.tar repositories
0f28619fe69181d3af529d56692f1362b7a7c8a6bf8dc9ab0d6d4f9ef9b0004d manifest.json
(MoeLove) ➜ chroot-dir mkdir -p debian
(MoeLove) ➜ chroot-dir tar -C debian -xf 0f28619fe69181d3af529d56692f1362b7a7c8a6bf8dc9ab0d6d4f9ef9b0004d/layer.tar
(MoeLove) ➜ chroot-dir ls debian
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
&lt;/code>&lt;/pre>&lt;p>可以看到我们通过对镜像文件的解压，得到了我们所需的 &lt;code>rootfs&lt;/code> 的全部内容，接下来我们看看 &lt;code>chroot&lt;/code> 的能力：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ chroot sudo chroot debian /bin/bash -i
[sudo] tao 的密码：
root@localhost:/# whoami
root
root@localhost:/# cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 10 (buster)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;10&amp;quot;
VERSION=&amp;quot;10 (buster)&amp;quot;
VERSION_CODENAME=buster
ID=debian
HOME_URL=&amp;quot;https://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;https://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
&lt;/code>&lt;/pre>&lt;p>我们目前就已经在一个 &amp;quot;容器&amp;quot; 内了，我们来看下使用这个容器我们能做些什么。&lt;/p>
&lt;p>首先我们看看当前“容器”内的路由表：&lt;/p>
&lt;pre>&lt;code>root@localhost:/# mkdir -p /sys
root@localhost:/# mount -t sysfs sys /sys
root@localhost:/# ip r
default via 192.168.0.1 dev wlp2s0 proto dhcp metric 600
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
192.168.0.0/24 dev wlp2s0 proto kernel scope link src 192.168.0.108 metric 600
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown
&lt;/code>&lt;/pre>&lt;p>很自然的，我们发现它可以访问所有的网络设备&lt;/p>
&lt;pre>&lt;code>root@localhost:/# ls /sys/class/net/
docker0 enp1s0 lo vboxnet0 virbr0 virbr0-nic wlp2s0
&lt;/code>&lt;/pre>&lt;p>另外，我们还可以将 &lt;code>/proc&lt;/code> 也挂载进去&lt;/p>
&lt;pre>&lt;code>root@localhost:/# mkdir -p /proc
root@localhost:/# mount -t proc proc /proc
root@localhost:/# ls -al /proc/31730/ns/pid
lrwxrwxrwx. 1 1000 1000 0 Jul 29 16:47 /proc/31730/ns/pid -&amp;gt; 'pid:[4026531836]'
&lt;/code>&lt;/pre>&lt;p>可以看到我们在这个“容器”内，可以访问到主机上的进程及网络等信息，这表示没有任何的进程或者网络隔离，这带来的危险是我们甚至可以在容器内杀掉容器外的进程，或者通过容器来攻击主机。&lt;/p>
&lt;p>为了能更好的解决这个问题，接下来出现了另一个技术：namespace 。&lt;/p>
&lt;h4 id="namespace">namespace&lt;/h4>
&lt;p>Namespace 是在 2002 年由 Linux 2.4.19 开始加入内核的特性，它主要的作用就做了一层抽象和隔离，使得在 namespace 中的进程/进程组可以看起来拥有自己的独立资源，具体的“资源”表现形式取决于给它赋予了哪些 namespace 。&lt;/p>
&lt;p>随着 2013 年 Linux 3.8 中 user namespace 的引入，对于我们现在所熟知的容器所需的全部 namespace 就都实现了：&lt;code>mnt&lt;/code> &lt;code>pid&lt;/code> &lt;code>net&lt;/code> &lt;code>ipc&lt;/code> &lt;code>uts&lt;/code> &lt;code>user&lt;/code> 和 &lt;code>cgroup&lt;/code> 对于这些 namespace 和 Docker 的关系，我们稍后会逐步来看，这里先对 namespace 做下介绍，然后继续前面&amp;quot;容器&amp;quot;的内容。&lt;/p>
&lt;p>我们可以通过三个系统调用直接操作 namespace ，这三个系统调用分别是：&lt;/p>
&lt;ul>
&lt;li>clone: 可以通过传递不同 namespace 的标志来为新的(子)进程指定其所属的 namespace;&lt;/li>
&lt;li>unshare: 允许一个进程(或线程)取消当前与其他进程(或线程)共享的执行上下文；&lt;/li>
&lt;li>setns: 进入文件描述符指定的 namespace;&lt;/li>
&lt;/ul>
&lt;p>知道了这些基础知识后，我们回到前面&amp;quot;容器&amp;quot;的内容中。&lt;/p>
&lt;p>我们在前面 &lt;code>chroot&lt;/code> 的例子中看到没能做到进程或网络隔离，现在我们来试试看用 namespace 完成该需求。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ sudo unshare -fp --mount-proc -n
[sudo] tao 的密码：
[root@localhost]/home/tao# ip l
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
[root@localhost]/home/tao# ps -a
PID TTY TIME CMD
1 pts/15 00:00:00 zsh
33 pts/15 00:00:00 ps
[root@localhost]/home/tao#
&lt;/code>&lt;/pre>&lt;p>这里很明显，我们当前所在进程的 PID 为 1 并且看不到宿主机上的其他进程，我们达到了基础的隔离效果。网络也同样，现在只包含一个 &lt;code>lo&lt;/code> 接口。关于网络部分的内容其实能聊的东西还有很多，我在专栏&lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>中，用 8 节内容来深入的聊了聊 Docker 容器网络相关的内容，感兴趣的读者可以看看。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>上面聊了这么多，无非是想说明容器的发展历程，以及它是什么。它其实就是用了各种 Linux 内核提供的特性/功能协同实现的对进程组的资源隔离。用 Docker 或者 namespace 或者 chroot 之类的都可以造出来一个 “容器” ，那我们为什么要用 Docker 呢？&lt;/p>
&lt;h2 id="docker-崛起之路">Docker 崛起之路&lt;/h2>
&lt;p>想必大家对 cgroups 不会太陌生，它在 2008 年进入 Linux 2.6.24 后，基于它并且瞄准容器世界的一个项目诞生了。&lt;/p>
&lt;p>Linux Container （LXC）结合了 namespace 和 cgroups 等技术，目标就是要创造出运行在 Linux 系统中，并且隔离性良好的容器环境。&lt;/p>
&lt;p>LXC 的事情发生在 2008 年，但值得注意的是 cgroups 最初是由 Google 的工程师开发的，最早的记录是在 2006 年，事实上当时 Google 确实也在做类似的容器化项目。&lt;/p>
&lt;p>时间一晃而过，就到了 2013 年的 PyCon 上，在这次大会上 Docker 正式面世。而它当时其实也只是构建在 LXC 之上的一个工具，屏蔽掉了 LXC 的使用细节，让用户可以一句 &lt;code>docker run&lt;/code> 便创建出自己的容器环境。 &lt;strong>同时，它允许用户将容器环境打包成为一个 Docker 镜像进行分发，这也大大降低了用户使用的门槛。&lt;/strong> Docker 镜像分发可以说是 Docker 成功的一个关键要素了。&lt;/p>
&lt;p>2014 年 Docker 发布 1.0 正式进入生产就绪的状态。在此之前它也将 LXC 逐步从它的底层移除，换成了自己实现的 &lt;code>libcontainer&lt;/code> ，幸运的是我也在 0.9 版本时开始了我的 Docker 之路。&lt;/p>
&lt;p>此后 Docker 便成为了风靡技术界的新热潮。&lt;/p>
&lt;p>&lt;strong>了解了 Docker 的发展背景后，我们来看看前面我们提到的问题：为什么要用 Docker 呢？&lt;/strong>&lt;/p>
&lt;p>2008 年到 2013 年这之间大约 5 年左右的时间，以 LXC 为首的容器技术并没有得到类似 Docker 出现后那么广泛的普及，我在之前的线下演讲中也提到过这个点，最主要的原因在于 LXC 太偏向技术了，使用 LXC 有一定的门槛，导致了好多人的退却。&lt;/p>
&lt;p>Docker 则提供了简单易用的 CLI , 优雅灵活的容器生命周期管理，以及镜像的构建，分发等配套设施，这为后期的推进提供了很多的便利。&lt;/p>
&lt;p>再加上 Docker 的策略很好，以及在 Docker 公司内部也有大量的实践经验，所以这些事情做起来也都很顺畅了。（关于 Docker 公司的实践经验可以说是信息量巨大了，以后再看机会分享吧）&lt;/p>
&lt;h2 id="使用-docker-面临的问题">使用 Docker 面临的问题&lt;/h2>
&lt;p>前面分别聊了容器的发展历程，以及 Docker 的发展历程。我们要正视 Docker 是一个已经 7 岁的项目，自它 1.0 发布以来已经 6 年之久了，它在生产环境中已经得到了大量的实践和验证。当然不可避免的它也会存在一些历史遗留问题或者是软件 bug 。&lt;/p>
&lt;p>尤其是随着 K8S 的发展，国内外大量公司都在落地 K8S。其中有超过半数的公司都是使用 Docker 作为容器运行的。&lt;/p>
&lt;p>当发生故障或者异常时，有些人可能会束手无策，或是只从上层进行问题的排查，殊不知问题很可能发生在底层的容器运行时。比较典型的例子：比如说容器 Hang 住，或者是无法创建容器等。&lt;/p>
&lt;p>或者有人由于对 Docker 网络相关的方面不了解，所以在学习和使用 K8S 时，也会走不少的弯路。比较典型的例子：不理解 K8S 中数据包的流向。&lt;/p>
&lt;p>最后一个很重要的方面就是安全相关的了。在企业中使用 Docker 尤其需要注意。这里包含着很多信息：比如容器运行时安全，镜像安全，容器策略安全等，我在专栏的安全篇也都进行了介绍。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Docker 的上手使用非常简单，这是 Docker 的一大优势，旨在降低开发者的使用门槛。尤其是 Docker Desktop 提供了交互式 UI，用户可以通过鼠标点击就完成容器的相关操作和管理。&lt;/p>
&lt;p>但是 Docker 作为一个正在被大量使用，且往后会被应用更多的技术，如果要用在生产环境中，我建议读者去更深入的学习和掌握它。&lt;/p>
&lt;p>以便在遇到问题时，可以更快速的定位和解决；构建镜像时，可以更加高效；使用 Docker 时，能为企业提供更适宜的安全策略。&lt;/p>
&lt;p>当然，还有一个最重要的，当你对 Docker 的了解越深入时，你也会越开心，你能接触到更多有趣的知识和技能。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/></entry><entry><title type="text">K8S 生态周报| containerd v1.3.4 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/04/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/04/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-04-19T23:38:40+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd v1.3.4 正式发布 本周 containerd……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="containerd-v134-正式发布">containerd v1.3.4 正式发布&lt;/h2>
&lt;p>本周 containerd v1.3.4 正式发布了，距离上次 v1.3.3 大约 2 个月左右的时间。本次仍然是 v1.3.x 系列的 patch 版本，但本次值得注意的内容并不少，我们一起来看看：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4007">containerd/containerd#4007&lt;/a> 改善了 docker remote 中镜像主机失败回退的行为。&lt;/li>
&lt;/ul>
&lt;p>这个变更是非常有用的，比如当我们想要为某个镜像仓库提供多个可用的镜像源（或者主机）的时候，在 v1.3.4 之前，如果第一个源（或者主机） 返回错误的时候，那默认就会回退，直接请求源站了。这种情况下，相当于我们设置的多个镜像源（或主机）就没什么实际意义了。&lt;/p>
&lt;p>经过此次变更后，请求会逐个尝试设置的镜像源，可大大保障拉取的成功率。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4104">containerd/containerd#4104&lt;/a> 添加了对 &lt;code>NOTIFY_SOCKET&lt;/code> 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containerd/containerd/pull/4150">containerd/containerd#4150&lt;/a> 修正了 FIFO 的清理逻辑；&lt;/li>
&lt;/ul>
&lt;p>这个变更是为了修正早先引入的一段对 FIFO 的清理逻辑，再此次修正之前，如果将 stdin/stdout/stderr 等使用 /dev/null 删除，则在任务关闭时，可能会导致清空 &lt;code>/dev&lt;/code> 目录，这就非常危险了。&lt;/p>
&lt;p>关于此版本的其他变更，可参考其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.4">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v2166-和-v320-rc1-发布">Helm v2.16.6 和 v3.2.0-rc.1 发布&lt;/h2>
&lt;p>这是 Helm v2 的一个 bugfix 版本，修正了一处空指针的错误 &lt;a href="https://github.com/helm/helm/issues/7812">#7812&lt;/a> ，如果还有小伙伴未升级使用 Helm v3 ，还是使用 Helm v2 的话，可以考虑升级至此版本。&lt;/p>
&lt;p>Helm v3 在本周也发布了 v3.2.0-rc.1 版本，此版本中有很多值得注意的内容，我此处只说一个，其他的变更等正式版发布后再做介绍。&lt;/p>
&lt;p>&lt;a href="https://github.com/helm/helm/pull/7635">#7635&lt;/a> 为 Helm v3 添加 SQL 存储驱动的支持。&lt;/p>
&lt;p>你可以通过 &lt;code>HELM_DRIVER&lt;/code> 和 &lt;code>HELM_DRIVER_SQL_CONNECTION_STRING&lt;/code> 变量进行数据库连接的配置。&lt;/p>
&lt;p>不就后 v3.2 就会正常发布了，届时可以先体验看看。&lt;/p>
&lt;h2 id="kubernetes-多个版本相继发布">Kubernetes 多个版本相继发布&lt;/h2>
&lt;p>本周 Kubernetes v1.16.9，v1.17.5 和 v1.18.2 等版本相继发布。&lt;/p>
&lt;p>对于 v1.18.2 而言，比较值得注意的是： &lt;a href="https://github.com/kubernetes/kubernetes/pull/89908">#89908&lt;/a> 修复了一个在节点删除后，当删除在其上部署的 Pod 触发调度时，可能导致 Kubernetes crash 的问题；（主要是因为它的缓存）&lt;/p>
&lt;p>在一般情况下，我们很少会在删除 Node 后，再触发相关的调度，这个问题可能不太容易遇到。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89666">#89666&lt;/a> &lt;code>kubectl scale&lt;/code> 现在支持使用参数 &lt;code>--dry-run=server|client&lt;/code> 了！&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89551">#89551&lt;/a> 恢复了 &lt;code>kubectl apply --prune&lt;/code> 不指定 namespace 时的能力；&lt;/li>
&lt;/ul>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kubernetes.io/blog/2020/04/16/monitoring-kubernetes-sidecar-pattern/">https://kubernetes.io/blog/2020/04/16/monitoring-kubernetes-sidecar-pattern/&lt;/a> 介绍了使用 Sidecar 来监控 Kubernetes 中部署的业务。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker 开源 Compose 规范</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/04/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-%E5%BC%80%E6%BA%90-Compose-%E8%A7%84%E8%8C%83/"/><id>https://moelove.info/2020/04/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-%E5%BC%80%E6%BA%90-Compose-%E8%A7%84%E8%8C%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-04-12T22:01:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker 开源 Compose 规范, 助力……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-开源-compose-规范-助力云原生应用开发">Docker 开源 Compose 规范, 助力云原生应用开发&lt;/h2>
&lt;p>本周 Docker 宣布将 Compose 规范开源，并作为独立组织进行治理。&lt;/p>
&lt;p>由于 Compose 可以简单的定义基于多容器的应用程序堆栈的工作方式，并且可以通过一条命令启动应用程序，而不需要手动构建镜像和逐个启动容器，这可以大大节省开发团队的时间。&lt;/p>
&lt;p>当前 Compose 已经被数百万开发人员使用，在 GitHub 上有超过 650,000 个 Compose 配置文件。&lt;/p>
&lt;p>Docker 也在 GitHub 上创建了一个 &lt;a href="https://github.com/docker/awesome-compose">awesome-compose&lt;/a> 的仓库，其中包含了 Compose 在多种应用场景下的使用示例。&lt;/p>
&lt;p>本次开源 Compose 规范，旨在能利用开源社区的力量，并与微软等合作伙伴，共同进行协作创新，为 Compose 规范提供更多活力，并以此帮助建立从桌面到云构建和部署容器应用程序通用开放标准。&lt;/p>
&lt;p>另外，Compose 规范计划是捐助给中立的基金会，我个人认为大概率是捐给 CNCF 了（目前没看到正式消息）。扩展后的 Compose 规范必将会大大提升开发者体验。&lt;/p>
&lt;p>同时，社区在计划使用 Go 对 docker-compose 工具进行重写（或者是重新实现 Compose 规范），整体而言也是好事儿，值得关注。&lt;/p>
&lt;p>详情可查看：http://www.compose-spec.io/&lt;/p>
&lt;h2 id="smi-正式加入-cncf">SMI 正式加入 CNCF&lt;/h2>
&lt;p>SMI（Service Mesh Interface）于本周正式加入 CNCF ，成为其 sandbox 级别的项目。&lt;/p>
&lt;p>我在去年 5 月份的 &lt;a href="https://zhuanlan.zhihu.com/p/67079625">K8S 生态周报| 2019-05-20~2019-05-26&lt;/a> 中曾介绍过微软宣布推出的 SMI，本质是为了能为服务网格提供通用接口，以便能让 Service Mesh 有更加通用的规范 （就像当初 CNI/CRI 那样子）。&lt;/p>
&lt;p>经过了将近一年时间的发展，SMI 的社区有了显著的发展，当前社区列出的生态信息如下：&lt;/p>
&lt;ul>
&lt;li>Consul Connect*: service segmentation (consul.io/docs/connect)&lt;/li>
&lt;li>Flagger: progressive delivery operator (flagger.app)&lt;/li>
&lt;li>Istio*: connect, secure, control, observe (servicemeshinterface/smi-adapter-istio)&lt;/li>
&lt;li>Linkerd: ultralight service mesh (linkerd.io)&lt;/li>
&lt;li>Maesh: simpler service mesh (mae.sh)&lt;/li>
&lt;li>Meshery: the service mesh management plane (layer5.io/meshery)&lt;/li>
&lt;li>Rio: application deployment engine (rio.io)&lt;/li>
&lt;li>Service Mesh Hub: unified dashboard (solo.io/products/service-mesh-hub)&lt;/li>
&lt;/ul>
&lt;p>我印象中最早跟进 SMI 的大概是 19 年 6 月份 Linkerd 增加了对 SMI 的支持。&lt;/p>
&lt;p>不过也可以看到，对于 Istio 而言，是社区提供了一个对 Istio 的适配（这里就不展开了）。&lt;/p>
&lt;p>详情可查看：https://smi-spec.io/blog/smi-joins-cncf/&lt;/p>
&lt;h2 id="kubernetes-v1181-发布">Kubernetes v1.18.1 发布&lt;/h2>
&lt;p>Kubernetes v1.18.1 发布，带来了一些 bugfix，这里主要就介绍一个关于使用 kubeadm 升级的问题。&lt;/p>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89537">#89537&lt;/a> 修复了在使用 kubeadm 从 v1.17 升级至 v1.18 时，node 无法加入集群的问题。主要是因为之前在 node 加入集群时，增加了对是否有同名节点存在的检查。而 kubeadm 中漏掉了相应的 RBAC 规则。&lt;/p>
&lt;p>修正代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Create RBAC rules that makes the bootstrap tokens able to get nodes
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">nodebootstraptoken&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">AllowBoostrapTokensToGetNodes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">errs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">errs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89151">#89151&lt;/a> 新增了一个 &lt;code>etcd_db_total_size_in_bytes&lt;/code> 的 metric ，可用于暴露 etcd 文件大小；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89848">#89848&lt;/a> &lt;code>kubectl apply&lt;/code> 即使 build 异常，也会应用其他已验证资源。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| NGINX Ingress Controller 新版本发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/04/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-NGINX-Ingress-Controller-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/04/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-NGINX-Ingress-Controller-%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-04-05T20:59:26+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 NGINX Ingress Controller 1.7.0-rc1 发布 NGINX Ingress Controller……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="nginx-ingress-controller-170-rc1-发布">NGINX Ingress Controller 1.7.0-rc1 发布&lt;/h2>
&lt;p>NGINX Ingress Controller 本次发布的 1.7.0-rc1 有一些比较值得注意的更新：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nginxinc/kubernetes-ingress/pull/827">#827&lt;/a> 为其暴露出的所有 metrics 添加了一个 class 标签。&lt;/li>
&lt;/ul>
&lt;p>比如如果原先的 metrics 是 &lt;code>nginx_ingress_controller_ingress_resources_total{type=&amp;quot;regular&amp;quot;} 1&lt;/code> 那么现在将变成 &lt;code>nginx_ingress_controller_ingress_resources_total{class=&amp;quot;nginx&amp;quot;,type=&amp;quot;regular&amp;quot;} 1&lt;/code> 。这个标签的值，可以通过 &lt;code>-ingress-class&lt;/code> 进行设置。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/nginxinc/kubernetes-ingress/pull/852">#852&lt;/a> 在 configmap 中增加了一个 &lt;code>default-server-access-log-off&lt;/code> 的配置项，用于配置是否关闭默认 server 的 access log 。&lt;/li>
&lt;li>&lt;a href="https://github.com/nginxinc/kubernetes-ingress/pull/902">#902&lt;/a> 添加了两个新的资源 &lt;code>TransportServer&lt;/code> 和 &lt;code>GlobalConfiguration&lt;/code>，用来支持 TCP/UDP 和 TLS 的负载均衡。&lt;/li>
&lt;/ul>
&lt;p>此版本的变更整体而言是比较多的，其余变更请参考其 &lt;a href="https://github.com/nginxinc/kubernetes-ingress/blob/v1.7.0-rc1/CHANGELOG.md#170---release-candidate-1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-v127-发布">rook v1.2.7 发布&lt;/h2>
&lt;p>本次 rook 的 v1.2.7 版本，仍然是个 bugfix 版本，其中包含多项改进，这里说两个值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/rook/rook/pull/5089">#5089&lt;/a> 这个 PR 的目的是当配置磁盘设备作为 OSD 时，如果该磁盘/分区的容量小于 5 G 则会被直接拒绝。最直接的影响就是，如果有人分区不合理/分区容量过小，那便无法作为 OSD 了（只不过目前选择的是 5 G，并不保证之后不会发生改变）；&lt;/li>
&lt;li>&lt;a href="https://github.com/rook/rook/issues/5022">#5022&lt;/a> 添加了对文件系统的额外校验，以便于在 OSD 的配置中，可以跳过 boot 分区；&lt;/li>
&lt;/ul>
&lt;p>其他变更，请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.2.7">ReleaseNote&lt;/a>。 另外， rook 目前正在准备从 CNCF 毕业，整体而言，它也在逐步变得更加稳定和易用。&lt;/p>
&lt;h2 id="traefik-v220-正式发布">Traefik v2.2.0 正式发布&lt;/h2>
&lt;p>在上个月的 &lt;a href="https://zhuanlan.zhihu.com/p/111833886">《K8S 生态周报| Docker v19.03.7 发布》&lt;/a> 中，我曾介绍过 Traefik v2.2.0-rc1 更新的内容，到现在 v2.2.0 终于正式发布了。&lt;/p>
&lt;p>相比与 v2.2.0-rc1 时，正式版中没有太多变更，只有一些小的修复，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/6504">#6504&lt;/a> 修复了 Ingress TLS 的支持，现在可以通过 &lt;code>traefik.ingress.kubernetes.io/router.tls: &amp;quot;true&amp;quot;&lt;/code> 的 annotation 进行启用了。&lt;/li>
&lt;/ul>
&lt;p>其他重要内容，我在之前的文章中就已经基本介绍过了，感兴趣的可以查看之前的文章，或参考该项目的 [ReleaseNote]https://github.com/containous/traefik/releases/tag/v2.2.0()&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>最近在 Kubernetes 项目中，比较重大的一个变更就是 kubelet 对 cgroupv2 的支持了。&lt;a href="https://github.com/kubernetes/kubernetes/pull/85218">#85218&lt;/a>&lt;/p>
&lt;p>这个 PR 从去年 11 月开始，直到最近才刚被合并进去。这个 PR 的合并，对 cgroupv2 的推进非常重要。截至目前，Docker，containerd，runc 等都已经相继增加了对 cgroupv2 的支持。我预计 cgroupv2 代替 v1 至少还需要两三年的时间。但整体而言，是在逐步向前推进的。&lt;/p>
&lt;p>还有一个需要注意的是 &lt;a href="https://github.com/kubernetes/kubernetes/pull/89401">#89401&lt;/a> 修复了 &lt;code>kubectl port-forward&lt;/code> 时，忽略到了本地 port 的问题（受影响版本是 v1.18+）&lt;/p>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubenav/kubenav">kubenav&lt;/a> 是一个包含桌面版和手机版的应用程序，可以帮助你来管理 Kubernetes 集群。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kubenav/kubenav/master/utils/assets/github-screenshot.png" alt="kubenav - https://moelove.info">&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| K8S 移除对 basic auth 的支持</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-K8S-%E7%A7%BB%E9%99%A4%E5%AF%B9-basic-auth-%E7%9A%84%E6%94%AF%E6%8C%81/"/><id>https://moelove.info/2020/03/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-K8S-%E7%A7%BB%E9%99%A4%E5%AF%B9-basic-auth-%E7%9A%84%E6%94%AF%E6%8C%81/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-29T21:26:45+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v2.16.5 发布 鉴于还有不……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v2165-发布">Helm v2.16.5 发布&lt;/h2>
&lt;p>鉴于还有不少人尚未升级至 Helm v3，虽然 Helm v2 目前在维护期，但仍然在频繁在发布版本。&lt;/p>
&lt;p>本周 Helm v2 相继发布了 v2.16.5 和 v2.16.4， &lt;strong>如果打算升级的话，建议直接升级至 v2.16.5&lt;/strong> 。&lt;/p>
&lt;p>因为 v2.16.4 版本中在 &lt;code>Validate()&lt;/code> 中误添加了一个 &lt;code>Latest()&lt;/code> ，会导致在安装或升级 Release 时，出现资源找不到的错误。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;pre>&lt;code>Release &amp;quot;moelove-release&amp;quot; does not exist. Installing it now.
Error: namespaces &amp;quot;moelove-namespace&amp;quot; not found
&lt;/code>&lt;/pre>&lt;p>更多详情请参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v2.16.5">ReleaseNote&lt;/a> 。&lt;/p>
&lt;h2 id="kubernetes-v118-正式发布">Kubernetes v1.18 正式发布&lt;/h2>
&lt;p>这是 Kubernetes 今年第一个正式发布的版本，v1.18 包含了 38 个增强功能，其中包含 15 个 stable 状态的，11 个在 beta ，最后剩余 12 个还是 alpha 阶段。&lt;/p>
&lt;p>这个版本在改善用户体验，以及稳定性方面做了大量的工作。 至于具体的变化，请参考我上周发布的文章 &lt;a href="https://zhuanlan.zhihu.com/p/116177002">《Kubernetes v1.18 正式发布！抢先一览》&lt;/a> 。&lt;/p>
&lt;p>对此版本感兴趣的小伙伴，可以直接使用 Kind 进行安装体验。示例如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ wget -q -O kind https://github.com/kubernetes-sigs/kind/releases/download/v0.7.0/kind-linux-amd64
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ chmod +x kind
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ /tmp ./kind create cluster --image&lt;span class="o">=&lt;/span>kindest/node:v1.18.0@sha256:0e20578828edd939d25eb98496a685c76c98d54084932f76069f886ec315d694 --name&lt;span class="o">=&lt;/span>v1.18
Creating cluster &lt;span class="s2">&amp;#34;v1.18&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.18.0&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing CNI 🔌
✓ Installing StorageClass 💾
Set kubectl context to &lt;span class="s2">&amp;#34;kind-v1.18&amp;#34;&lt;/span>
You can now use your cluster with:
kubectl cluster-info --context kind-v1.18
Not sure what to &lt;span class="k">do&lt;/span> next? 😅 Check out https://kind.sigs.k8s.io/docs/user/quick-start/
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get nodes
NAME STATUS ROLES AGE VERSION
v1.18-control-plane Ready master 109s v1.18.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更详细内容请参考其 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md#whats-new-major-themes">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="coredns-v169-发布">CoreDNS v1.6.9 发布&lt;/h2>
&lt;p>CoreDNS 发布了 v1.6.9 版本，这个版本的发布主要是由于在发布 v1.6.8 时，自动化发布工具遇到了点问题。如果你仔细去看 ReleaseNote 你会发现两个版本的 ReleaseNote 基本是一样的内容。本次发布其实就是为了修正自动化发布工具。&lt;/p>
&lt;p>所以，我们一起看看 CoreDNS v1.6.9 （或者说 v1.6.8） 中，有哪些值得注意的内容吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3640">#3640&lt;/a> plugins/forward: 增加了一个 &lt;code>max_concurrent&lt;/code> 的配置项，可通过这个配置项做并发控制。同时也在 metrics 中增加了 &lt;code>max_concurrent_reject_count_total{}&lt;/code> 用于统计由于达到最大并发限制而被拒绝的请求；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3687">#3687&lt;/a> plugin/kubernetes：在 PTR 类型的请求中，返回查找到的所有的 IP 而不是只返回第一个；&lt;/li>
&lt;li>&lt;a href="https://github.com/coredns/coredns/pull/3643">#3643&lt;/a> plugin/forward：通过添加健康检查来避免创建新的 TLS 连接。当 forward 检查到错误的时候，健康检查将会在一个循环中运行，初始间隔是 0.5s，之后会持续增长至 60s，报告上游不健康。当上游恢复健康时，健康检查将会停止。&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/pull/89069">#89069&lt;/a> 终止对 basic authentication 的支持，&lt;code>--basic-auth-file&lt;/code> 被彻底移除，这个特性其实在 v1.16 中就已经被弃用了，如果有用到该特性的朋友，请尽快更换其他方式。另外，对 basic authentication 的支持，大概是从 2015 年加入的，至今将近 5 年左右的时间，也算是很辉煌了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/kubernetes/kubernetes/issues/89377">#89377&lt;/a> CVE-2020-8551: Kubelet DoS via API 和 &lt;a href="https://github.com/kubernetes/kubernetes/issues/89378">#89378&lt;/a> CVE-2020-8552: apiserver DoS (oom) 是近期的两个非常值得关注的漏洞。几乎是所有版本均会收到漏洞的影响，请及时将小版本更新至 v1.17.3 ，v1.16.7 和 v1.15.10 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Docker 7 周年，生日快乐！</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/26/Docker-7-%E5%91%A8%E5%B9%B4%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/><id>https://moelove.info/2020/03/26/Docker-7-%E5%91%A8%E5%B9%B4%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-26T22:32:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker 7 岁啦！文末有活动链接~ 2013 年 Docker 首次在 PyCon 上亮相，随后在 Hacker News 上引起了强烈的反响。之后在 GitHub 上正式开源，从此正式开启了 Docker 的时代。 时至今……</summary><content type="html">&lt;blockquote>
&lt;p>Docker 7 岁啦！文末有活动链接~&lt;/p>
&lt;/blockquote>
&lt;p>2013 年 Docker 首次在 PyCon 上亮相，随后在 Hacker News 上引起了强烈的反响。之后在 GitHub 上正式开源，从此正式开启了 Docker 的时代。&lt;/p>
&lt;p>时至今日，无论我们在谈论容器，Kubernetes 或是这整个生态中的其他产品和技术，不可避免的都会用到与 Docker 相关的知识。&lt;/p>
&lt;p>毫不夸张的说，Docker 改变了世界开发部署应用程序的方式！&lt;/p>
&lt;p>3 月是 Docker 的生日月，按照 Docker 社区的传统，在本月会举办一次活动来庆祝 Docker 的生日。&lt;/p>
&lt;h2 id="活动信息">活动信息&lt;/h2>
&lt;p>&lt;strong>本次的活动通过 3 小时的在线直播来完成，将于北京时间 3 月 27 日 00:00 开始。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>直播地址是：https://youtu.be/3UZ0TUPP0ks&lt;/strong>&lt;/p>
&lt;h2 id="简单分享点-docker-目前的进展">简单分享点 Docker 目前的进展&lt;/h2>
&lt;p>我自 Docker v0.9 版本开始了自己的 Docker 之路，它是我使用最频繁的工具之一。&lt;/p>
&lt;p>除了是 Docker 的重度用户外，我也一直参与着 Docker 社区的上游贡献。目前在 Docker 的核心仓库贡献者排行榜中在 top90 。（很早以前我一度以为这个排行榜不会更新 hhh），以下是 Docker 的核心上游仓库本月的概览：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-march-overview.png" alt="Docker 3 月份核心仓库概览 - https://moelove.info">&lt;/p>
&lt;p>可以看到社区还是很活跃的，而且 Docker 目前将重点放在提升开发者体验上，今年相继推出了 Docker Desktop 新版本， Docker 首个官方 GitHub Action， 以及开源了 &lt;a href="https://github.com/docker/awesome-compose">awesome-compose&lt;/a> 提供了众多精选的 compose 示例，帮助开发者更快的部署容器化应用。&lt;/p>
&lt;h2 id="活动内容">活动内容&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/docker-7th-event-info.png" alt="Docker 活动信息 - https://moelove.info">&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-7th-event-speakers.png" alt="Docker 活动 speakers - https://moelove.info">&lt;/p>
&lt;p>感兴趣的话，欢迎来参加活动！可在线互动哦~&lt;/p>
&lt;p>&lt;strong>本次的活动通过 3 小时的在线直播来完成，将于北京时间 3 月 27 日 00:00 开始。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>直播地址是：https://youtu.be/3UZ0TUPP0ks&lt;/strong>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">Kubernetes v1.18 正式发布！抢先一览</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/25/Kubernetes-v1.18-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%8A%A2%E5%85%88%E4%B8%80%E8%A7%88/"/><id>https://moelove.info/2020/03/25/Kubernetes-v1.18-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%8A%A2%E5%85%88%E4%B8%80%E8%A7%88/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-25T00:11:28+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">持续关注 「K8S 生态周报」的小伙伴们，在每周的上游进展中，应该已经了解到了大多数新的特性和修复，这里来一并总结下。 Kubernetes 即将发布，截……</summary><content type="html">&lt;blockquote>
&lt;p>持续关注 &lt;a href="https://zhuanlan.zhihu.com/container">「K8S 生态周报」&lt;/a>的小伙伴们，在每周的上游进展中，应该已经了解到了大多数新的特性和修复，这里来一并总结下。&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes 即将发布，截至发文时，v1.18.0 尚未正式 Release 。不过已经在进行中了，
让我们抢先看看 Kubernetes v1.18 为我们带来了哪些新内容吧！&lt;/p>
&lt;p>v1.18 中的主要变更集中在 &lt;code>deprecations&lt;/code>, &lt;code>metrics&lt;/code> , &lt;code>kubectl&lt;/code> 和 &lt;code>node&lt;/code> 方面。我们逐个来看看：&lt;/p>
&lt;h2 id="kubectl-相关变更">kubectl 相关变更&lt;/h2>
&lt;p>引用我在&lt;a href="https://zhuanlan.zhihu.com/p/113449314">K8S 生态周报| Helm v3.1.2 发布&lt;/a>中的介绍：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88004">#88004&lt;/a> 正式添加了 &lt;code>kubectl alpha debug&lt;/code> 命令，可通过此命令来调试 Kubernetes 中的资源，不过也请注意，此命令尚在 alpha 阶段，后续还会有变动。&lt;/li>
&lt;/ul>
&lt;p>引用我在&lt;a href="https://zhuanlan.zhihu.com/p/108700105">K8S 生态周报| containerd v1.2.13 发布&lt;/a> 中的介绍：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/87714">#87714&lt;/a> kubectl 的 &lt;code>--server-dry-run&lt;/code> 被标记为废弃，并且可以通过使用 &lt;code>--dry-run=server&lt;/code> 替代。并且 kubectl 的 &lt;code>--dry-run&lt;/code> 参数接收的值，也变成了 &lt;code>client&lt;/code>, &lt;code>server&lt;/code> 以及 &lt;code>none&lt;/code>。示例如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create deploy moelove --image&lt;span class="o">=&lt;/span>redis --dry-run&lt;span class="o">=&lt;/span>client
deployment.apps/moelove created &lt;span class="o">(&lt;/span>dry run&lt;span class="o">)&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create deploy moelove --image&lt;span class="o">=&lt;/span>redis --dry-run&lt;span class="o">=&lt;/span>server
deployment.apps/moelove created &lt;span class="o">(&lt;/span>server dry run&lt;span class="o">)&lt;/span>
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl create deploy moelove --image&lt;span class="o">=&lt;/span>redis --dry-run&lt;span class="o">=&lt;/span>none
deployment.apps/moelove created
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，kubectl 还有些其他值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/87776">#87776&lt;/a> 当你使用 &lt;code>kubectl delete --force&lt;/code> 删除资源的时候，不再需要添加 &lt;code>--grace-period=0&lt;/code> 了。示例如下：&lt;/li>
&lt;/ul>
&lt;p>在 v1.18 中:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get pods
NAME READY STATUS RESTARTS AGE
redis-65d8df48cf-2rcqq 1/1 Running &lt;span class="m">0&lt;/span> 48s
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl delete pods redis-65d8df48cf-2rcqq --force
warning: Immediate deletion does not &lt;span class="nb">wait&lt;/span> &lt;span class="k">for&lt;/span> confirmation that the running resource has been terminated. The resource may &lt;span class="k">continue&lt;/span> to run on the cluster indefinitely.
pod &lt;span class="s2">&amp;#34;redis-65d8df48cf-2rcqq&amp;#34;&lt;/span> force deleted
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 v1.18 之前:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get pods
kNAME READY STATUS RESTARTS AGE
redis-65d8df48cf-qrd4h 1/1 Running &lt;span class="m">0&lt;/span> 53s
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl delete pods redis-65d8df48cf-qrd4h --force
warning: --force is ignored because --grace-period is not 0.
pod &lt;span class="s2">&amp;#34;redis-65d8df48cf-qrd4h&amp;#34;&lt;/span> deleted
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="相关废弃">相关废弃&lt;/h2>
&lt;h3 id="85903httpsgithubcomkuberneteskubernetespull85903-kube-apiserver">&lt;a href="https://github.com/kubernetes/kubernetes/pull/85903">#85903&lt;/a> kube-apiserver&lt;/h3>
&lt;ul>
&lt;li>所有资源的 API &lt;code>apps/v1beta1&lt;/code> 和 &lt;code>apps/v1beta2&lt;/code> 都将废弃，请使用 &lt;code>apps/v1&lt;/code> 代替；&lt;/li>
&lt;li>&lt;code>daemonsets&lt;/code>, &lt;code>deployments&lt;/code>, &lt;code>replicasets&lt;/code> 资源的 API &lt;code>extensions/v1beta1&lt;/code> 将被废弃，请使用 &lt;code>apps/v1&lt;/code> 代替;&lt;/li>
&lt;li>&lt;code>networkpolicies&lt;/code> 资源的 API &lt;code>extensions/v1beta1&lt;/code> 将被废弃，请使用 &lt;code>networking.k8s.io/v1&lt;/code> 代替；&lt;/li>
&lt;li>&lt;code>podsecuritypolicies&lt;/code> 资源的 API &lt;code>extensions/v1beta1&lt;/code> 将被废弃，请使用 &lt;code>policy/v1beta1&lt;/code> 代替；&lt;/li>
&lt;/ul>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/86282">#86282&lt;/a> kubelet 的 &lt;code>/metrics/resource/v1alpha1&lt;/code> 接口被废弃。其实每次版本发布，都会有很多 metrics 被废弃，v1.17 也同样。&lt;/li>
&lt;/ul>
&lt;h3 id="kube-proxy">kube-proxy&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88512">#88512&lt;/a> &lt;code>--healthz-port&lt;/code> 和 &lt;code>--metrics-port&lt;/code> 选项被废弃，请使用 &lt;code>--healthz-bind-address&lt;/code> 和 &lt;code>--metrics-bind-address&lt;/code> 代替。&lt;/li>
&lt;/ul>
&lt;h3 id="kubeadm">kubeadm&lt;/h3>
&lt;p>引用 &lt;a href="https://zhuanlan.zhihu.com/p/111833886">K8S 生态周报| Docker v19.03.7 发布&lt;/a> 中的介绍&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88827">#88827&lt;/a> kubeadm 废弃了 &lt;code>kubeadm alpha certs renew&lt;/code> 下的 &lt;code>--use-api&lt;/code> 参数，目前预期在 v1.19 将其移除，如有用到相关功能的，请注意。&lt;/li>
&lt;/ul>
&lt;h3 id="kubectl">kubectl&lt;/h3>
&lt;p>引用 &lt;a href="https://zhuanlan.zhihu.com/p/105974404">K8S 生态周报| Docker v19.03.6-rc2 发布&lt;/a> 中的介绍：&lt;/p>
&lt;p>&lt;strong>在 Kubernetes v1.18 中，会将之前已标注过期的各类 generator 都移除掉。&lt;/strong> 也就是说，自 v1.18 起使用 &lt;code>kubectl run&lt;/code> 命令主要就是创建 Pod 了，而不会创建多余的 deploy 之类的。&lt;/p>
&lt;p>至于像 &lt;code>service&lt;/code> 加了 &lt;code>--expose&lt;/code> 倒也还可以创建，只不过类似 &lt;code>--service-generator&lt;/code> 这类参数就也都标记废弃了。&lt;/p>
&lt;p>v1.18 之前版本的执行结果是这样：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl run redis --image&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;redis:alpine&amp;#34;&lt;/span>
kubectl run --generator&lt;span class="o">=&lt;/span>deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator&lt;span class="o">=&lt;/span>run-pod/v1 or kubectl create instead.
deployment.apps/redis created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ ~ kubectl get all -l &lt;span class="nv">run&lt;/span>&lt;span class="o">=&lt;/span>redis
NAME READY STATUS RESTARTS AGE
pod/redis-8544698fd7-tvz5q 1/1 Running &lt;span class="m">0&lt;/span> 14s
NAME READY UP-TO-DATE AVAILABLE AGE
deployment.apps/redis 1/1 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 14s
NAME DESIRED CURRENT READY AGE
replicaset.apps/redis-8544698fd7 &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> 14s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>v1.18 版本：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ bin ./kubectl run redis-new --image&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;redis:alpine&amp;#34;&lt;/span>
pod/redis-new created
&lt;span class="o">(&lt;/span>MoeLove&lt;span class="o">)&lt;/span> ➜ bin ./kubectl get all -l &lt;span class="nv">run&lt;/span>&lt;span class="o">=&lt;/span>redis-new
NAME READY STATUS RESTARTS AGE
pod/redis-new 1/1 Running &lt;span class="m">0&lt;/span> 12s
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上内容是我认为在 Kubernetes v1.18 中比较值得关注的部分。待 v1.18.0 正式发布时，可再参考官方的 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md">ReleaseNote&lt;/a> 获取更加详尽的内容。&lt;/p>
&lt;hr>
&lt;p>欢迎通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 首个 Docker 官方 Action 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E9%A6%96%E4%B8%AA-Docker-%E5%AE%98%E6%96%B9-Action-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/03/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E9%A6%96%E4%B8%AA-Docker-%E5%AE%98%E6%96%B9-Action-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-22T15:45:06+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 首个 Docker 官方 GitHub Action 发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="首个-docker-官方-github-action-发布了">首个 Docker 官方 GitHub Action 发布了&lt;/h2>
&lt;p>从去年 Docker 将企业服务相关的业务出售给 Mirantis 之后，Docker 将重心放在助力开发者体验上，并为此做了一系列的努力。
包括 1 月份发布了 &lt;a href="https://www.docker.com/blog/docker-desktop-release-2-2-is-here/">Docker Desktop v2.2&lt;/a> ，提供了 WSL2 的新架构，以及新的交互式 Desktop Dashboard 等特性。&lt;/p>
&lt;p>本周又发布了首个 Docker GitHub Action，简化了 CI/CD 的流程。&lt;/p>
&lt;p>这其实也是从另一个角度来推进 DockerHub 的普及（比预期的晚了一些）。DockerHub 上一直都有构建 Docker 镜像的功能，但我个人感觉体验并不够好，从一般意义上来说，它不够灵活；另外我感觉它的调度略慢了一点（虽然现在在优化中了）。&lt;/p>
&lt;p>但本次发布的 Docker GitHub Action 可以让用户可以更灵活的通过 GitHub Action 来定义自己的 workflow，并将镜像推送至镜像仓库。这里的镜像仓库并没有和 DockerHub 强制绑定，用户可以自定义镜像仓库的地址。&lt;/p>
&lt;p>使用示例如下，完整的项目可参考 &lt;a href="https://github.com/tao12345666333/docker-github-action">docker-github-action&lt;/a> 。
需要额外注意的是， &lt;strong>如果你的仓库是公开的，请注意将自己的用户名密码等设置为 secrets ，可参考下方示例，以防泄漏&lt;/strong>。&lt;/p>
&lt;pre>&lt;code>- name: Build and push Docker images
uses: docker/build-push-action@v1.0
with:
# Username used to log in to a Docker registry. If not set then no login will occur
username: ${{ secrets.DOCKER_USERNAME }}
# Password or personal access token used to log in to a Docker registry. If not set then no login will occur
password: ${{ secrets.DOCKER_TOKEN }}
# Docker repository to tag the image with
repository: ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKER_PROJECT }}
# Automatically tags the built image with the git reference as per the readme
tag_with_ref: true
# Automatically tags the built image with the git short SHA as per the readme
tag_with_sha: true
# Path to run docker build from
path: .
# Name of the Dockerfile (Default is 'path/Dockerfile')
dockerfile: Dockerfile
# Always attempt to pull a newer version of the image
always_pull: true
# Adds labels with git repository information to the built image
add_git_labels: true
# Whether to push the image
push: true
&lt;/code>&lt;/pre>&lt;p>此外 &lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-code-docker-extension-1-0-better-than-ever/">Visual Studio Code Docker extension 1.0&lt;/a> 也在本周发布了！据说比之前版本的都好用，使用 vsc 的小伙伴可以尝试下。&lt;/p>
&lt;h2 id="etcd-v345-发布">etcd v3.4.5 发布&lt;/h2>
&lt;p>etcd 本周发布的 v3.4.5 包含了一些：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd/pull/11704">#11704&lt;/a> 在 server 端的日志中记录了 &lt;code>/health&lt;/code> 的检查结果，主要是为了便于在 etcd 挂掉时分析根因；&lt;/li>
&lt;li>&lt;a href="https://github.com/etcd-io/etcd/pull/11694">#11694&lt;/a> 修复了一个在处理 metrics 可能引起的异常;&lt;/li>
&lt;/ul>
&lt;p>其他变更，请参考其 &lt;a href="https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.4.md#v345-2020-03-18">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="trivy-授权协议变更为-apache-20">Trivy 授权协议变更为 Apache-2.0&lt;/h2>
&lt;p>Aqua Security 开源的 &lt;a href="https://github.com/aquasecurity/trivy">trivy&lt;/a> 是一款镜像漏洞安全扫描程序，对 CI 友好。&lt;/p>
&lt;p>可能有些小伙伴不太了解 &lt;a href="https://www.aquasec.com/">Aqua Security&lt;/a> 这家公司，但大多数人都或多或少用过或者了解过它的一些开源项目：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/aquasecurity/kubectl-who-can">kubectl-who-can&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/aquasecurity/kube-bench">kube-bench&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/aquasecurity/kube-hunter">kube-hunter&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>近期，trivy 的授权协议&lt;a href="https://github.com/aquasecurity/trivy/pull/434">从 &lt;code>AGPL v3&lt;/code> 修改成了 &lt;code>Apache-2.0&lt;/code>&lt;/a>，这个事情的意义在于，更多的厂商或者公司可以不用担心 trivy 自身的授权协议，可以在自己的产品或者环境中集成使用 trivy 了！&lt;/p>
&lt;p>目前包括 Harbor，Docker 及 Mirantis Docker Enterprise 等正在或者将使用 trivy 作为其默认镜像安全扫描工具。&lt;/p>
&lt;p>但需要注意的是，trivy 使用的数据源有些是还是禁止商用来着。&lt;/p>
&lt;p>推荐阅读：&lt;a href="https://blog.fleeto.us/post/introducing-trivy/">全面易用的镜像漏洞检测工具：Trivy&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>这是一个对 Kubernetes v1.16 的修复，将一系列主线中的修复都合并到了 v1.16 。这里专门提到它，是因为如果你集群中有很多节点变 NotReady 时，可能会导致 control plane 超载，出现不可用的情况。主要的修正都在 NodeLifecycleController 上，建议想要使用或者正在 v1.16 版本的用户关注下此问题（如果集群规模不大，那受此问题影响的可能性比较小），详情请查看 &lt;a href="https://github.com/kubernetes/kubernetes/pull/88959">#88959&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/stakater/Reloader">Reloader&lt;/a> 是一个 Kubernetes controller ，它会 watch &lt;code>ConfigMap&lt;/code> 或 &lt;code>Secrets&lt;/code>，然后对使用这些资源的 Pod 执行滚动升级。&lt;/p>
&lt;p>注意它只兼容 Kubernetes v1.9 及以上。如果有相关需求的小伙伴可以进行尝试。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">「K8S 生态周报」一周年了！</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5%E4%B8%80%E5%91%A8%E5%B9%B4%E4%BA%86/"/><id>https://moelove.info/2020/03/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5%E4%B8%80%E5%91%A8%E5%B9%B4%E4%BA%86/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-21T08:10:21+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」已经整整一年啦！感谢大家的关注和支持！ 从 2019 年 3 月 25 日发布第一篇「K8S 生态周报」到今天已正好一年，已经发布了 52……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」已经整整一年啦！感谢大家的关注和支持！&lt;/p>
&lt;/blockquote>
&lt;p>从 2019 年 3 月 25 日发布第一篇「K8S 生态周报」到今天已正好一年，已经发布了 52 篇内容。在这个特殊的日子里，很想与大家分享下我的感受,以及「K8S 生态周报」的初衷和发展。&lt;/p>
&lt;h2 id="缘起">缘起&lt;/h2>
&lt;p>凡是接触 K8S 生态或者容器生态的小伙伴都不难发现，整个生态中涉及的东西很多，每天有无数的新消息，新变化，稍不留神就会错过很多有价值的内容。&lt;/p>
&lt;p>这是一个信息爆炸的时代，同时大多数人包括我在内应该也都会存在着一定的“焦虑”，所以面对着海量的信息总是希望能更快的筛选出有价值的内容。&lt;/p>
&lt;p>在去年年初，我在做个人总结时发现，虽然我每天接触到的信息很多，但真正有价值的，或者说值得我花很多精力持续去关注的内容并没有那么多。&lt;/p>
&lt;p>并且由于没有归档，光靠自己记忆的话，有些事情可能就忘记了。之后也许还会再次花费时间了解或学习相关的内容，这也是另一种形式的浪费。&lt;/p>
&lt;p>于是「K8S 生态周报」就以这个思路开始发布了第一篇 &lt;a href="https://juejin.im/post/5c98db12518825702d3bdb8d">K8S 生态周报| 2019.03.25~2019.03.31&lt;/a>。&lt;/p>
&lt;h2 id="过程改进">过程改进&lt;/h2>
&lt;p>第一篇「K8S 生态周报」发布后，我觉得这个事情是值得做的。同时为了能提升效率，简化一些人工操作（自动化才是第一生产力），所以周末抽空写了个工具，把周报加到了我的 TODO 中。&lt;/p>
&lt;p>具体而言，由于多年参与开源项目，我比较习惯使用 GitHub 的 issue 来管理个人的 TODO，加上 GitHub 提供了 Project 管理的功能，所以它现在看起来是这个样子：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/weekly-cards.png" alt="「K8S 生态周报」- https://moelove.info">&lt;/p>
&lt;p>每周有自动执行的任务来帮助我管理这些 issue，并将其加入我的每周计划便于跟踪进度。每周「K8S 生态周报」的草稿也是在 issue 中完成的，到周末时，再将内容筛选整理并发布。&lt;/p>
&lt;p>用于管理这类 issue 的任务，是托管在 &lt;a href="https://gitlab.com">GitLab&lt;/a> 上的。执行情况如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/todo-pipeline.png" alt="「K8S 生态周报」Pipeline - https://moelove.info">&lt;/p>
&lt;p>这组工具已经稳定运行一年了，基本没做过什么调整，还是比较能提升我的效率的。&lt;/p>
&lt;h2 id="发展阶段">发展阶段&lt;/h2>
&lt;p>「K8S 生态周报」一开始只发布在&lt;a href="https://moelove.info">我的博客&lt;/a>，公众号（MoeLove）、&lt;a href="https://zhuanlan.zhihu.com/container">知乎专栏&lt;/a>和&lt;a href="https://juejin.im/user/570eef23ebcb7d0055844663/posts">掘金&lt;/a>上，后来增加了&lt;a href="https://segmentfault.com/blog/moelove">SegmentFault&lt;/a>和微博。也收获了很多小伙伴的支持和反馈。&lt;/p>
&lt;p>上个月考虑到文字版不够详尽，所以在我家小可爱的支持下，增加了 &lt;strong>内容更详细的视频版&lt;/strong>，同步发布在 &lt;a href="https://search.bilibili.com/video?keyword=k8s%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5">BiliBili&lt;/a>，西瓜视频和微信视频号上。感谢我的小可爱~&lt;/p>
&lt;h2 id="收获">收获&lt;/h2>
&lt;p>简单的分享下现在的「K8S 生态周报」的数据，基本情况如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/weekly-count.png" alt="阅读统计- https://moelove.info">&lt;/p>
&lt;p>可以看到非常符合我周报的更新频率，每周有明显的波动。我一直保持在周一的早上在公众号进行推送。&lt;/p>
&lt;p>这些数据意义不大，只不过看着数据上涨，知道自己写的内容被更多人看到了，也会有些开心，所以我这里也就只是分享个趋势。&lt;/p>
&lt;p>真正的收获有以下几项：&lt;/p>
&lt;ul>
&lt;li>周报我一直坚持没有断更，所以算是用另一种方式强迫我解决了之前信息没有「归档」的这个问题；&lt;/li>
&lt;li>另外，由于要把内容讲清楚明白，所以也更加深了对信息印象和理解；&lt;/li>
&lt;li>个人时间比较少，要抽时间写完整的文章会比较麻烦，通过周报的形式，也可以顺便把自己想说的内容稍微加进去，也方便了很多；&lt;/li>
&lt;li>去年参加 KubeCon 的时候，还有小伙伴说每周都在坚持看我的「K8S 生态周报」，嘿嘿~；&lt;/li>
&lt;li>开了交流群，也有不少小伙伴的加入；&lt;/li>
&lt;li>在大量信息中能快速的筛选出有效信息，并对其持续关注，对个人成长有很大好处；&lt;/li>
&lt;/ul>
&lt;h2 id="展望">展望&lt;/h2>
&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>这是写在每篇「K8S 生态周报」中固定的内容，同时也介绍了「K8S 生态周报」的定位。每周的内容中包含的都是我所接触到的值得推荐的一些信息。&lt;/p>
&lt;p>如果有持续关注「K8S 生态周报」的小伙伴应该发现了，有时可能更新的内容很少，这主要会有两个原因 1. 我太忙了没关注到 2. 确实没什么太值得关注的内容。「K8S 生态周报」的定位短时间内不会变更，内容也全都是我来产出，可能我会把一些没时间写篇完整文章的内容，也一并加进来；如果大家有什么值得推荐的内容，比如技术文章/开源项目等，欢迎联系~&lt;/p>
&lt;p>接下来我还是会继续坚持更新，另外就像公众号介绍中写的，“不只限于 Container，Docker 和 Kubernetes 等技术，与你分享更多使用且具有前景的技术” 欢迎关注！&lt;/p>
&lt;p>感谢大家的支持！&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.1.2 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.1.2-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/03/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.1.2-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-15T22:49:12+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker CE v19.03.8 发布 这是一个……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-ce-v19038-发布">Docker CE v19.03.8 发布&lt;/h2>
&lt;p>这是一个临时增加的安全更新版本，主要用于改进之前版本中对 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271&lt;/a> 的修复措施。&lt;/p>
&lt;p>在去年 9 月份，我发布的 &lt;a href="https://zhuanlan.zhihu.com/p/81736488">K8S 生态周报| Harbor v1.9 带来众多新特性&lt;/a> 一文中，我曾介绍过 Docker v19.03.1 的发布主要也是为了修复 CVE-2019-14271 漏洞。&lt;/p>
&lt;p>尽管这是一个安全更新版本，但我并不建议你立马升级到此 v19.03.8 版本，除非你并没有用到 Docker 对文件系统识别相关的功能。详情请参考我上周发布的周报 &lt;a href="https://zhuanlan.zhihu.com/p/111833886">K8S 生态周报| Docker v19.03.7 发布&lt;/a>。&lt;/p>
&lt;p>简单来说就是在 v19.03.7 中，执行 &lt;code>docker info&lt;/code> 命令的时候，会看到 &lt;code>Backing Filesystem&lt;/code> 显示为 &lt;code>unknown&lt;/code> 的情况。&lt;/p>
&lt;p>该问题我已经修复，原计划在 v19.03.8 中发布，不过恰逢此安全更新版本，所以现在推迟到了 v19.03.9 版本中发布，敬请期待。&lt;/p>
&lt;h2 id="helm-v312-发布">Helm v3.1.2 发布&lt;/h2>
&lt;p>Helm 于本周发布了 v3.1.2 版本，此版本是 Helm v3.1 的第二个 bugfix 版本。在此版本中有两个值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/7674">#7674&lt;/a> 当使用 &lt;code>APIVersionV2&lt;/code> 时，执行 &lt;code>helm package&lt;/code> 会将 &lt;code>Chart.lock&lt;/code> 也一并打包。这将使得 Helm 包更易于分发，依赖版本的问题变的更简单了；&lt;/li>
&lt;li>&lt;a href="https://github.com/helm/helm/pull/7661">#7661&lt;/a> 为 &lt;code>helm upgrade&lt;/code> 增加了一个 &lt;code>--skip-crds&lt;/code> 的选项，允许跳过 CRDs；&lt;/li>
&lt;/ul>
&lt;p>另外就是一些小的修正和改动了，感兴趣的朋友可参考其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.1.2">ReleaseNote&lt;/a>，也可直接升级体验。&lt;/p>
&lt;h2 id="kubernetes-多个版本发布">Kubernetes 多个版本发布&lt;/h2>
&lt;p>本周发布了 Kubernetes v1.15.11、v1.16.8 和 v1.17.4 等几个版本。和之前情况类似，主要都是 SIG Cloud Provider 相关的内容，此处暂且不谈。我个人认为，有两个值得注意的内容是：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88079">#88079&lt;/a> 修复了一个 kubelet 在客户端证书轮转时可能崩溃的问题。&lt;/li>
&lt;/ul>
&lt;p>这个问题主要也就是代码中在连接的处理上有个 bug。实际影响的话，当遇到这个情况时 kubelet 会异常崩溃。而我们通常会使用 &lt;code>systemd&lt;/code> 之类的管理 kubelet，并添加自动重启，会把它再拉起来。&lt;/p>
&lt;p>所以综合来看的话，受这个 bug 影响的可能性不算大，但建议升级。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88505">#88505&lt;/a> 修正了一个 kubelet 修改 Pod 状态时候的逻辑；&lt;/li>
&lt;/ul>
&lt;p>感兴趣的朋友请参考各版本的 ReleaseNote &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.15.md#changelog-since-v11510">v1.15.11&lt;/a> &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.16.md#changelog-since-v1167">v1.16.8&lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.17.md#changelog-since-v1173">v1.17.4&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88004">#88004&lt;/a> 正式添加了 &lt;code>kubectl alpha debug&lt;/code> 命令，可通过此命令来调试 Kubernetes 中的资源，不过也请注意，此命令尚在 alpha 阶段，后续还会有变动；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88758">#88758&lt;/a> 隐藏了在 &lt;code>kubectl describe&lt;/code> 中 &lt;code>kubectl.kubernetes.io/last-applied-configuration&lt;/code> 相关的输出，能有效缩短 &lt;code>kubectl describe&lt;/code> 的输出内容，很有用；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88240">#88240&lt;/a> 在执行 &lt;code>kubectl get pods&lt;/code> 的时候， Pod 有了 &lt;code>NotReady&lt;/code> 的状态。其实说起来就是将原先 &lt;code>Running&lt;/code> 状态细化了下，如果是 Pod 已经启动，但是未符合条件的，就会显示为 &lt;code>NotReady&lt;/code> 的状态了。&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>做个小调研，对于当前 Docker 在 Linux/macOS/Windows 上的体验是否有不满意的地方？如果都提供统一的 GUI 是否能提升使用体验或降低操作门槛？ 欢迎留言讨论&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v19.03.7 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/03/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.7-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/03/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.7-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-03-08T22:47:41+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v19.03.7 发布 我在之前的……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v19037-发布">Docker v19.03.7 发布&lt;/h2>
&lt;p>我在之前的两次周报 &lt;a href="https://zhuanlan.zhihu.com/p/107328855">《K8S 生态周报| Docker CE v19.03.6 正式发布》&lt;/a> 和&lt;a href="https://zhuanlan.zhihu.com/p/108700105">《K8S 生态周报| containerd v1.2.13 发布》&lt;/a> 中已经介绍过了 Docker CE v19.03.6 &lt;strong>在单核机器上&lt;/strong> 会由于 containerd 中的一个 bug 导致任务 hang 住。本周发布的 v19.03.7 已经将默认的 containerd 版本升级至 v1.2.13 ，该版本中包含了对此 bug 的修复。&lt;/p>
&lt;p>此外这个版本中还包含了一个小的优化，可以让 &lt;code>docker stats&lt;/code> 比之前的启动速度更快一点，直观上的感受目前可能还不是很明显。但如果是针对于某些特殊需求，需要采集使用量分析的时候，那就会比较明显了。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong> 升级到此版本后, 如果你在使用 &lt;code>overlay2&lt;/code> 存储驱动时，可能会有人在执行 &lt;code>docker info&lt;/code> 时，&lt;code>Backing Filesystem&lt;/code> 那一栏显示会有点问题，这是因为代码里面移除了一些文件系统的检查逻辑，导致赋值也有些问题，之后会做修复。&lt;/p>
&lt;p>你可能会得到类似下面的输出，不用太紧张。（如果你没有使用 Storage 相关配置的话，没太大影响的）&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker info --format '{{ index .DriverStatus 0 }}'
[Backing Filesystem &amp;lt;unknown&amp;gt;]
&lt;/code>&lt;/pre>&lt;p>更新：我已经将它进行了修复，会包含在 Docker v19.03.8 版本中。&lt;/p>
&lt;p>更多信息请参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.7">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-v150-正式发布">Istio v1.5.0 正式发布&lt;/h2>
&lt;p>Istio v1.5.0 是个重要的版本，在此版本中引入了 &lt;code>Istiod&lt;/code> 二进制文件，通过引入它大大简化了 Istio 的架构体系，也改善了操作体验。&lt;/p>
&lt;p>本次官方文档和社区很多的文章也都有此版本特性的介绍，我就不过多赘述了，下面用两张图来直观的感受下差别：&lt;/p>
&lt;p>&lt;img src="https://developer.ibm.com/developer/blogs/istio-15-release/images/istio14.jpg" alt="Istio v1.4 - https://moelove.info">&lt;/p>
&lt;p>&lt;img src="https://developer.ibm.com/developer/blogs/istio-15-release/images/istio15.jpg" alt="Istio v1.5 - https://moelove.info">&lt;/p>
&lt;p>此版本的详细变更，请查看其 &lt;a href="https://istio.io/news/releases/1.5.x/announcing-1.5/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="traefik-v220-rc1-发布">Traefik v2.2.0-rc1 发布&lt;/h2>
&lt;p>Traefik 想必大家不会太过陌生，本周发布了 v2.2.0-rc1 版本，这次版本变动还是比较大的，我们来看看有哪些值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>增强 Kubernetes Ingress 的支持，比如 &lt;a href="https://github.com/containous/traefik/pull/6171">#6171&lt;/a> 支持了 &lt;code>networking.k8s.io/v1beta1&lt;/code> Ingress API 版本，&lt;a href="https://github.com/containous/traefik/pull/6160">#6160&lt;/a> 增加了 annotations 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/5899">#5899&lt;/a> 添加了 KV store providers：现在支持 Consul/etcd/Redis/ZooKeeper 等；&lt;/li>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/6348">#6348&lt;/a> 增加了对 UDP 的支持；&lt;/li>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/5870">#5870&lt;/a> 增加了对 Elastic APM tracer 的支持，这个功能可以说是很实用了；&lt;/li>
&lt;li>&lt;a href="https://github.com/containous/traefik/pull/6036">#6036&lt;/a> UI 增加了深色模式；&lt;/li>
&lt;/ul>
&lt;p>此版本更详细的变更，请查看其 &lt;a href="https://github.com/containous/traefik/blob/master/CHANGELOG.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>先来聊一个社区进展：&lt;/p>
&lt;p>&lt;strong>&lt;code>k8s.gcr.io&lt;/code> 将会从 &lt;code>gcr.io/google-containers&lt;/code> 迁移至 &lt;code>gcr.io/k8s-artifacts-prod&lt;/code>&lt;/strong> ，本次迁移是由于 &lt;code>gcr.io/google-containers&lt;/code> 是由 Google 经营的，之前只能让 Google 员工写入。现在迁移到的新的存储仓库 &lt;code>gcr.io/k8s-artifacts-prod&lt;/code> 它是由 K8S 社区进行运营，也就是说社区成员也可以推送镜像了，不再依赖于 Google 员工的操作。&lt;/p>
&lt;p>本次迁移为了保障数据一致性，迁移前会将 &lt;code>gcr.io/google-containers&lt;/code> 设置为只读，迁移时间暂定 4 月初。&lt;/p>
&lt;p>对于国内用户而言，很多镜像站需要修改一下数据源了；另外，由于新的镜像仓库仍然在 &lt;code>gcr.io&lt;/code> 所以并不需要对其网络有什么特殊的期待~&lt;/p>
&lt;p>具体讨论请参考 &lt;a href="https://groups.google.com/forum/#!topic/kubernetes-dev/MkXnkTSJ_vs/discussion">k8s.gcr.io moving from gcr.io/google-containers to gcr.io/k8s-artifacts-prod in early April &lt;/a>&lt;/p>
&lt;p>下周就要进入代码冻结期了，近期合并的代码很多，我个人比较关注的有以下部分：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/84814">#84814&lt;/a> &lt;code>storage.k8s.io/CSIDriver&lt;/code> 正式 GA 了，它从 v1.14 进入 Beta 状态，如今终于 GA，在 Kubernetes v1.18 的 ReleaseNote 中想必也会额外说明的；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88827">#88827&lt;/a> kubeadm 废弃了 &lt;code>kubeadm alpha certs renew&lt;/code> 下的 &lt;code>--use-api&lt;/code> 参数，目前预期在 v1.19 将其移除，如有用到相关功能的，请注意。&lt;/li>
&lt;/ul>
&lt;h3 id="ref">ref&lt;/h3>
&lt;p>图源：&lt;a href="https://developer.ibm.com/blogs/istio-15-release/#">istio-15-release&lt;/a>&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| rkt 项目正式归档并宣布终止</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-rkt-%E9%A1%B9%E7%9B%AE%E6%AD%A3%E5%BC%8F%E5%BD%92%E6%A1%A3%E5%B9%B6%E5%AE%A3%E5%B8%83%E7%BB%88%E6%AD%A2/"/><id>https://moelove.info/2020/02/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-rkt-%E9%A1%B9%E7%9B%AE%E6%AD%A3%E5%BC%8F%E5%BD%92%E6%A1%A3%E5%B9%B6%E5%AE%A3%E5%B8%83%E7%BB%88%E6%AD%A2/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-29T12:45:36+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 rkt 项目正式归档并宣……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rkt-项目正式归档并宣布终止">rkt 项目正式归档并宣布终止&lt;/h2>
&lt;p>&lt;a href="https://github.com/rkt/rkt">rkt&lt;/a> 项目我在之前的周报&lt;a href="https://zhuanlan.zhihu.com/p/78730840">《K8S 生态周报| rkt 项目正式被 CNCF 归档》&lt;/a> 就已经详细介绍过了，这里不再赘述。&lt;/p>
&lt;p>从去年 rkt 项目正式被 CNCF 归档后，直到现在 rkt 项目的维护者们也终于在 GitHub 上归档该项目，并宣布此项目正式终止。&lt;/p>
&lt;p>公告信息请参考 &lt;a href="https://github.com/rkt/rkt/commit/bbd90a1d1e57d0f6d4598de2b62ae0b6ead94ec5">rkt/rkt@bbd90a1&lt;/a> 。&lt;/p>
&lt;p>再次感谢 rkt 在容器生态领域做出的贡献！（大概以后也不会再提到 rkt 了）&lt;/p>
&lt;h2 id="kubernetes-nginx-ingress-发布-v0300">Kubernetes NGINX Ingress 发布 v0.30.0&lt;/h2>
&lt;p>Kuberentes NGINX Ingress 近期相继发布了 v0.29 和 v0.30 两个版本，变更较频繁。主要值得注意的内容如下：&lt;/p>
&lt;ul>
&lt;li>NGINX 升级到了 v1.17.8 版本；&lt;/li>
&lt;li>允许 &lt;code>ExternalName&lt;/code> 类型的 service 有不同的 &lt;code>port&lt;/code> 和 &lt;code>targetPort&lt;/code>（这是一个 bugfix）;&lt;/li>
&lt;/ul>
&lt;p>顺便聊个无关紧要的内容，这个版本中有一个 commit 比较有趣，请看 &lt;a href="https://github.com/kubernetes/ingress-nginx/pull/5041">#5041&lt;/a> 。这个 commit 其实是由一个 bot 生成的，专门用来做图片优化的应用， 通过这个 ImgBot 使得该项目中图片资源的体积减少了 36.94%， 感兴趣的朋友可以尝试下这个 ImgBot &lt;a href="https://github.com/marketplace/imgbot">https://github.com/marketplace/imgbot&lt;/a>&lt;/p>
&lt;p>对 Kubernetes NGINX Ingress 新版本感兴趣的朋友请参考其 &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/Changelog.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-v125-发布">rook v1.2.5 发布&lt;/h2>
&lt;p>这个版本是一个 bugfix 版本， 有些值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>将 Ceph 版本升级至 v14.2.7；&lt;/li>
&lt;li>修复了 Chart 中 RBAC 的配置，允许了 &lt;code>patch&lt;/code> 动作；&lt;/li>
&lt;li>operator 中 CSI 的配置可通过 configmap 进行配置了；&lt;/li>
&lt;/ul>
&lt;p>关于 rook 此版本感兴趣的朋友请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.2.5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/87906">#87906&lt;/a> 当 pod, container 或者 emptyDir 触发驱逐时，kubelet_evictions 可记录。个人认为此功能很有用，集群管理员也可增加对应监控和告警；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88057">#88057&lt;/a> &lt;code>kubectl rolling-update&lt;/code> 被正式移除，这个命令早在两年前（2018 年 4 月）就已经被标记为废弃，请使用 &lt;code>kubectl rollout&lt;/code> 代替；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/88324">#88324&lt;/a> 为 cluster-info dump 增加 init-container 的日志记录；&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/devopsprodigy/kubegraf">kubegraf&lt;/a> - 一款为 K8S 监控而准备的 Grafana 插件。感兴趣的小伙伴可以尝试下，截图如下：&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/1437242a5337a94a6ecb432df65f7599de74589f/68747470733a2f2f6465766f707370726f646967792e636f6d2f696d672f646f702d6b756265677261662f763132302f6170706c69636174696f6e735f6f766572766965775f322e706e67" alt="kubegraf - https://moelove.info">&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/6153e1cb75dad07119ee6f47ca96266eadf23fea/68747470733a2f2f6465766f707370726f646967792e636f6d2f696d672f646f702d6b756265677261662f763132302f6e6f64655f6f766572766965772e706e67" alt="kubegraf - https://moelove.info">&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| containerd v1.2.13 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/23/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.2.13-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/02/23/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.2.13-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-23T11:56:55+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd v1.2.13 发布 上周的 K8S 生……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="containerd-v1213-发布">containerd v1.2.13 发布&lt;/h2>
&lt;p>上周的 &lt;a href="https://zhuanlan.zhihu.com/p/107328855">K8S 生态周报&lt;/a> 中，我在 &lt;a href="https://zhuanlan.zhihu.com/p/107328855">Docker CE v19.03.6 正式发布&lt;/a> 的部分，介绍了 Docker v19.03.6 在单核的机器/虚拟机中，可能会由于 containerd 的一个 bug 导致任务 hang 住。&lt;/p>
&lt;p>本周 containerd v1.2.13 发布了，此版本中已经包含了对该内容的修复。&lt;/p>
&lt;p>如果受到此问题影响的用户， &lt;strong>可直接下载安装使用 containerd v1.2.13&lt;/strong> 以修复此问题。&lt;/p>
&lt;p>近期 Docker v19.03.7 也将发布，将会默认使用 containerd v1.2.13 ，届时直接重装/升级均可规避此问题。&lt;/p>
&lt;h2 id="helm-v311-发布">Helm v3.1.1 发布&lt;/h2>
&lt;p>上周 Helm 3.1.0 刚发布便马上迎来了 v3.1.1 版本，这是一个 bugfix 版本，包含了几个主要的修复：&lt;/p>
&lt;ul>
&lt;li>修复了 &lt;code>helm list&lt;/code> 不能正确抛出错误信息的问题，原因是代码中有个&lt;a href="https://github.com/helm/helm/commit/3fa62f4da11862c03742fa4306c8dacbaf9ded41">错误未被捕获&lt;/a>；&lt;/li>
&lt;li>现在，如果设置了 &lt;code>--wait&lt;/code> 参数时，service 不会等待 externalIPs 便可以返回了，可规避一些类似 &lt;code>helm upgrade --wait&lt;/code> 时可能超时的问题；&lt;/li>
&lt;/ul>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/87714">#87714&lt;/a> kubectl 的 &lt;code>--server-dry-run&lt;/code> 被标记为废弃，并且可以通过使用 &lt;code>--dry-run=server&lt;/code> 替代。并且 kubectl 的 &lt;code>--dry-run&lt;/code> 参数接收的值，也变成了 &lt;code>client&lt;/code>, &lt;code>server&lt;/code> 以及 &lt;code>none&lt;/code>；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/86810">#86810&lt;/a> &lt;code>kubeadm config images list&lt;/code> 实现了结构化输出，支持文本，JSON，YAML 和 GO 模板等。（我个人认为，这个功能不错的，但目前我还没想到什么情况下我会需要它）；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/87975">#87975&lt;/a> &lt;code>kubeadm upgrade node config&lt;/code> 从 v1.15 起标记废弃，现在正式移除，请使用 &lt;code>kubeadm upgrade node phase kubelet-config&lt;/code> 代替。&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>最近尝试为 「K8S 生态周报」增加了视频版，欢迎观看及反馈。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/av89983893">K8S 生态周报| Helm v3.1.0 正式发布&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av88082603">K8S 生态周报| Docker v19.03.6-rc2 发布&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.1.0 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.1.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/02/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.1.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-15T23:12:46+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker CE v19.03.6 正式发布 在上……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-ce-v19036-正式发布">Docker CE v19.03.6 正式发布&lt;/h2>
&lt;p>在上次的周报 &lt;a href="https://zhuanlan.zhihu.com/p/105974404">K8S 生态周报| Docker v19.03.6-rc2 发布&lt;/a> 中，我已经介绍了 Docker v19.03.6 中包含的主要更新了。&lt;/p>
&lt;p>这里我要额外增加一点提醒：&lt;/p>
&lt;p>&lt;strong>如果你在使用单核的机器/虚拟机，在升级 v19.03.6 后，可能会由于 containerd 中的一个 bug 而导致任务 hang 住&lt;/strong>&lt;/p>
&lt;p>比较常见的一个可能出错的地方就是使用 GitLab.com 的共享 runner （单核的 vm），如果你没有将 dind（Docker In Docker）镜像指定为具体的版本号，而是使用类似 &lt;code>docker:dind&lt;/code> 这样的 tag 时，你可能已经遇到相关的问题了。推荐当前固定为 &lt;code>docker:19.03.5-dind&lt;/code> ，待后续修正。&lt;/p>
&lt;p>containerd v1.2.13 中将会包含此修复（尚未发布），或者临时解决办法可以是暂时降级 containerd 。&lt;/p>
&lt;p>当 container 发布新版本后，可以通过重新安装/升级 containerd 来解决此问题。&lt;/p>
&lt;h2 id="helm-v310-正式发布">Helm v3.1.0 正式发布&lt;/h2>
&lt;p>自 2019 年 11 月 13 日 Helm 正式发布 v3.0.0 至今已过了三个月，Helm 终于迎来了新的特性版本， v3.1.0 本周正式发布了。其中包含了大量的更新和修复，比较值得注意的内容如下：&lt;/p>
&lt;ul>
&lt;li>为 &lt;code>--all-namespaces&lt;/code> 添加了一个别名，可使用 &lt;code>-A&lt;/code> 替代；&lt;/li>
&lt;li>&lt;code>helm lint&lt;/code> 可以直接对一个 &lt;code>tar.gz&lt;/code> 的压缩包做检查了；&lt;/li>
&lt;li>增加了一个 &lt;code>--post-renderer&lt;/code> 的 hook ，支持使用可执行文件对渲染后的文件做修改；&lt;/li>
&lt;li>支持渲染 CRD 到 &lt;code>--output-dir&lt;/code> 指定的目录了；&lt;/li>
&lt;/ul>
&lt;p>其他就是大量的 bugfix 了，
如果你对此版本感兴趣，请参看 &lt;a href="https://github.com/helm/helm/releases/tag/v3.1.0">ReleaseNote&lt;/a>.&lt;/p>
&lt;h2 id="kubernetes-相继发布多个版本">Kubernetes 相继发布多个版本&lt;/h2>
&lt;p>Kubernetes v1.17.3、v1.16.7、v1.15.10 等相继发布，主要都是修复一些 bug，其中 SIG Cloud Provider 类的较多。&lt;/p>
&lt;p>我大致看了看，这里就不一一介绍了，感兴趣的朋友可以参考 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.17.3">v1.17.3&lt;/a> &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.16.7">v1.16.7&lt;/a> &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.15.10">v1.15.10 的 ReleaseNote&lt;/a> 。&lt;/p>
&lt;h2 id="istio-v144-发布">Istio v1.4.4 发布&lt;/h2>
&lt;p>Istio 本周也发布了 v1.4.4 版本， 其中有个值得注意的点：&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a>：Istio 的 AuthenticationPolicy 中路径精确匹配的逻辑中有一处漏洞，允许未经授权的 JWT token 对资源进行未经授权的访问。&lt;/strong>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>实现了一个 &lt;code>backoff&lt;/code> manager &lt;a href="https://github.com/kubernetes/kubernetes/pull/87829">#87829&lt;/a>;&lt;/li>
&lt;li>修复了 &lt;code>kubectl drain&lt;/code> 时的一处逻辑错误 &lt;a href="https://github.com/kubernetes/kubectl/issues/803">kubernetes/kubectl#803&lt;/a>;&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker v19.03.6-rc2 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.6-rc2-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/02/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-v19.03.6-rc2-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-09T17:14:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker v19.03.6-rc2 发布 自 2019 年 11 月……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-v19036-rc2-发布">Docker v19.03.6-rc2 发布&lt;/h2>
&lt;p>自 2019 年 11 月 15 日 Docker v19.03.5 发布后，Docker Inc. 包括社区都发生了不少的变化。&lt;/p>
&lt;p>v19.03.6 将会是 v19.03 系列的下一个 bugfix 版本。在此版本中，有几个比较值得注意的内容：&lt;/p>
&lt;ul>
&lt;li>buildkit: 修复了在触发 &lt;code>ONBUILD&lt;/code> 规则之后，未清理掉 &lt;code>ONBUILD&lt;/code> 规则的问题。对于依赖 &lt;code>ONBUILD&lt;/code> 指令，且使用 buildkit 的用户而言是个重要修复；&lt;/li>
&lt;li>buildkit: 修复了启用了 userns 时，可能导致权限错误的问题；&lt;/li>
&lt;li>&lt;strong>使用了 libnetwork 的短 ID, 以避免遇到 &lt;code>UNIX_PATH_MAX&lt;/code> 的错误&lt;/strong>;&lt;/li>
&lt;/ul>
&lt;p>说到这个问题，其实也蛮有趣的，可能不少人都遇到过类似的问题。当然我也想在这个 &lt;code>UNIX_PATH_MAX&lt;/code> 的问题上稍微多聊一点。&lt;/p>
&lt;p>这个问题其实在四五年前我在 Docker 项目中其他的部分就遇到过，解决起来也简单就是缩短路径长度即可。但你可能会好奇，要缩短到什么程度呢？多长是合理值呢？&lt;/p>
&lt;p>其实这个问题要深究的话，背后有蛮多历史的，这里我先跳过。我主要说下目前的限制是什么，这个限制可以在 &lt;a href="https://github.com/torvalds/linux.git">Linux 的源码&lt;/a>中找到的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// include/uapi/linux/un.h
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#ifndef _LINUX_UN_H
&lt;/span>&lt;span class="cp">#define _LINUX_UN_H
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/socket.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#define UNIX_PATH_MAX 108
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">sockaddr_un&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">__kernel_sa_family_t&lt;/span> &lt;span class="n">sun_family&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* AF_UNIX */&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">sun_path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">UNIX_PATH_MAX&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="cm">/* pathname */&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="cp">#define SIOCUNIXFILE (SIOCPROTOPRIVATE + 0) &lt;/span>&lt;span class="cm">/* open a socket file with O_PATH */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="cp">#endif &lt;/span>&lt;span class="cm">/* _LINUX_UN_H */&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到现在头文件中定义的是 &lt;code>108&lt;/code> 。（ &lt;strong>注意我此处使用的是 Linux 5.4 版本的内核&lt;/strong> ）&lt;/p>
&lt;p>另外，这个头文件定义在 &lt;code>include/uapi/linux/un.h&lt;/code> 这个 &lt;code>uapi&lt;/code> 目录可能有些人会觉得陌生，其实它是在 Linux 3.x 新增的，其中包含的内容基本就是原本散落在各处的头文件。这也是为了解决 Linux 中循环引用的问题。&lt;/p>
&lt;p>有点跑题了，回到 Docker v19.03.6 版本上，如果你对此版本有所期待，可以抢先尝试下当前的 rc 版。如果追求稳定，可以再稍微等几天，等正式版本发布（大概在两周内）。&lt;/p>
&lt;p>此处破例推荐下我的专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>，当前内容已经更新了一半以上，以 Docker 的最新版本为基础，对比旧版本及 Docker 上游发展的差异，并对每个核心知识点进行由浅入深、从实践到内部原理的讲解，其中也包含了一些 Linux 内核相关的知识。感谢订阅。&lt;/p>
&lt;h2 id="containerd-v133-发布">containerd v1.3.3 发布&lt;/h2>
&lt;p>本周 containerd v1.3.3 发布，带来了一些重要的修复和更新：&lt;/p>
&lt;ul>
&lt;li>runtime v2 方面，将 runc shim 中 &lt;code>platform&lt;/code> 的关闭流程移到了 &lt;code>Shutdown&lt;/code> 方法中，这样可以确保 &lt;code>platform&lt;/code> 只关闭一次；&lt;/li>
&lt;li>&lt;strong>修复了一个 containerd v1.3.0+ 版本及以上 exec 时存在的 eventfd 泄漏的 bug ；&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>另外，本周 &lt;strong>containerd 也发布了 v1.2.12 版本&lt;/strong> 。&lt;/p>
&lt;p>这两个版本中均包含了一系列重要的安全更新 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19921">CVE-2019-19921&lt;/a> 、&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16884">CVE-2019-16884&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0601">CVE-2020-0601&lt;/a>&lt;/p>
&lt;p>建议，如果有在使用 containerd 的朋友请尽早更新。这两个版本更详细的变更，请参考 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.2.12">containerd v1.2.12 的 ReleaseNote&lt;/a> 和 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.3">containerd v1.3.3 的 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="cncf-发布了-containerd-项目的旅程报告">CNCF 发布了 containerd 项目的旅程报告&lt;/h2>
&lt;p>CNCF 对 containerd 自创建到毕业后项目的活跃度及社区发展等维度进行了调研，并给出了相应的报告。&lt;/p>
&lt;p>整体来看，containerd 自打从 Docker 中诞生开始，截至目前项目及社区发展都挺不错。&lt;/p>
&lt;p>对此报告感兴趣的朋友可以参考 &lt;a href="https://www.cncf.io/cncf-containerd-project-journey/">CNCF 的报告: CNCF containerd Project Journey Report&lt;/a> 。&lt;/p>
&lt;h2 id="docker-将关闭旧的-apt-和-yum-仓库">Docker 将关闭旧的 APT 和 YUM 仓库&lt;/h2>
&lt;p>Docker project 于 2013 年在 PyCon 上首次正式亮相，并逐步成长为社区项目，所以当时就注册了 &lt;code>dockerproject.org&lt;/code> 和 &lt;code>dockerproject.com&lt;/code> 的域名，并且后来在这两个域名之下托管了 APT 和 YUM 仓库。&lt;/p>
&lt;p>后期随着 Docker Inc. 的成立，为了更好的专注于 Docker 的产品 （CE 和 EE），所以就注册了 &lt;code>docker.com&lt;/code> 的域名。并且正式将 APT 和 YUM 仓库托管到了 &lt;a href="https://download.docker.com/">&lt;code>download.docker.com&lt;/code>&lt;/a>。&lt;/p>
&lt;p>现在几乎所有人都已经在使用新的 &lt;code>download.docker.com&lt;/code> 的仓库了（如果你还没有使用，请尽快更新）。&lt;/p>
&lt;p>重点： &lt;strong>Docker Inc 计划在 2020 年 3 月 31 日停止老旧的 &lt;code>dockerproject.org&lt;/code> 和 &lt;code>dockerproject.com&lt;/code> 域名下托管的 APT 和 YUM 仓库了！&lt;/strong>&lt;/p>
&lt;p>请大家尽早&lt;a href="https://docs.docker.com/install/">按 Docker 官方文档中的安装说明&lt;/a> 安装 Docker，并停止使用老旧的仓库域名。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>&lt;code>kubectl run&lt;/code> 想必大家都不陌生吧，可以用它来手动创建各种资源。&lt;/p>
&lt;p>&lt;strong>在 Kubernetes v1.18 中，会将之前已标注过期的各类 generator 都移除掉。&lt;/strong> 也就是说，自 v1.18 起使用 &lt;code>kubectl run&lt;/code> 命令主要就是创建 Pod 了，而不会创建多余的 deploy 之类的。&lt;/p>
&lt;p>至于像 &lt;code>service&lt;/code> 加了 &lt;code>--expose&lt;/code> 倒也还可以创建，只不过类似 &lt;code>--service-generator&lt;/code> 这类参数就也都标记废弃了。&lt;/p>
&lt;p>v1.18 之前版本的执行结果是这样：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl run redis --image=&amp;quot;redis:alpine&amp;quot;
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/redis created
(MoeLove) ➜ ~ kubectl get all -l run=redis
NAME READY STATUS RESTARTS AGE
pod/redis-8544698fd7-tvz5q 1/1 Running 0 14s
NAME READY UP-TO-DATE AVAILABLE AGE
deployment.apps/redis 1/1 1 1 14s
NAME DESIRED CURRENT READY AGE
replicaset.apps/redis-8544698fd7 1 1 1 14s
&lt;/code>&lt;/pre>&lt;p>v1.18 版本：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ bin ./kubectl run redis-new --image=&amp;quot;redis:alpine&amp;quot;
pod/redis-new created
(MoeLove) ➜ bin ./kubectl get all -l run=redis-new
NAME READY STATUS RESTARTS AGE
pod/redis-new 1/1 Running 0 12s
&lt;/code>&lt;/pre>&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>还是那句老话，注意勤洗手，多喝水，注意休息，照顾好家人。&lt;/p>
&lt;p>在家宅着也别忘记学习，再次推荐我的专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">使用 Kind 在离线环境创建 K8S 集群</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/05/%E4%BD%BF%E7%94%A8-Kind-%E5%9C%A8%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA-K8S-%E9%9B%86%E7%BE%A4/"/><id>https://moelove.info/2020/02/05/%E4%BD%BF%E7%94%A8-Kind-%E5%9C%A8%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA-K8S-%E9%9B%86%E7%BE%A4/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-05T12:14:04+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Kind 是我很喜欢也一直在参与的项目，我计划将 Kind 相关的文章写成一个系列。这是第二篇。 背景 Kind 是 Kubernetes In Docker 的缩写，顾名思义是使用 Docker 容器作为 Node 并……</summary><content type="html">&lt;blockquote>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kind">Kind&lt;/a> 是我很喜欢也一直在参与的项目，我计划将 Kind 相关的文章写成一个系列。这是第二篇。&lt;/p>
&lt;/blockquote>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kind">Kind&lt;/a> 是 Kubernetes In Docker 的缩写，顾名思义是使用 Docker 容器作为 Node 并将 Kubernetes 部署至其中的一个工具。现在包括 Kubernetes 自身在内的很多云原生基础项目都将 Kind 应用于自身的 e2e 测试或项目的入门示例中。&lt;/p>
&lt;p>默认情况下使用 Kind 创建 Kubernetes 集群，只需要&lt;a href="https://kind.sigs.k8s.io/#installation-and-usage">先安装好 Kind 执行 &lt;code>kind create cluster&lt;/code> 便可&lt;/a>， Kind 会自动下载所需的 Docker 镜像，并启动集群。&lt;/p>
&lt;p>但是，在某些情况下，我们也会有需要在离线环境中启动 Kubernetes 集群的需求。本篇文章我来为你介绍两种使用 Kind 在离线环境创建 Kubernetes 集群的方式。&lt;/p>
&lt;h2 id="使用预构建镜像">使用预构建镜像&lt;/h2>
&lt;p>Kind 在每次发布版本时，会同时构建并发布默认使用的镜像，目前&lt;a href="https://hub.docker.com/r/kindest/node/tags">托管在 Docker Hub &lt;/a>上。建议你使用在每次 &lt;a href="https://github.com/kubernetes-sigs/kind/releases">ReleaseNote&lt;/a> 中指定了 shasum 的镜像。&lt;/p>
&lt;p>当你在离线环境中想要使用 Kind 预构建的镜像创建集群时，你可以在任意可联网的机器上或目标机器上有网络的情况下，提前下载该镜像，并拷贝至需要创建集群的目标机器上。&lt;/p>
&lt;p>如果你的机器上已经&lt;a href="https://docs.docker.com/install/">安装了 Docker&lt;/a>，那可以直接使用 &lt;code>docker pull&lt;/code> 命令下载镜像：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker pull kindest/node:v1.17.0@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62: Pulling from kindest/node
cc5a81c29aab: Pull complete
81c62728355f: Pull complete
ed9cffdd962a: Pull complete
6a46f000fce2: Pull complete
6bd890da28be: Pull complete
0d88bd219ffe: Pull complete
af5240f230f0: Pull complete
Digest: sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
Status: Downloaded newer image for kindest/node@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
docker.io/kindest/node:v1.17.0@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
&lt;/code>&lt;/pre>&lt;p>接下来，你可以使用 &lt;code>docker save&lt;/code> 命令，将镜像保存为一个 tar 包：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker save -o kind.v1.17.0.tar kindest/node:v1.17.0@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
&lt;/code>&lt;/pre>&lt;p>如果你觉得镜像体积太大，并且你也已经安装了 gzip 的话，可以使用以下命令，将镜像保存为经 gzip 格式的压缩包。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker save kindest/node:v1.17.0@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62 | gzip &amp;gt; kind.v1.17.0.tar.gz
&lt;/code>&lt;/pre>&lt;p>在目标机器上，你可以使用 &lt;code>docker load&lt;/code> 命令将镜像加载至 docker daemon 的存储中：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker load -i kind.v1.17.0.tar
Loaded image ID: sha256:ec6ab22d89efc045f4da4fc862f6a13c64c0670fa7656fbecdec5307380f9cb0
# 或者
➜ ~ docker load -i kind.v1.17.0.tar.gz
Loaded image ID: sha256:ec6ab22d89efc045f4da4fc862f6a13c64c0670fa7656fbecdec5307380f9cb0
&lt;/code>&lt;/pre>&lt;p>至此，你便可以通过以下命令，使用已经导入的镜像来创建集群：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kind create cluster --image kindest/node:v1.17.0@sha256:9512edae126da271b66b990b6fff768fbb7cd786c7d39e86bdf55906352fdf62
Creating cluster &amp;quot;kind&amp;quot; ...
✓ Ensuring node image (kindest/node:v1.17.0) 🖼
✓ Preparing nodes 📦
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing CNI 🔌
✓ Installing StorageClass 💾
Set kubectl context to &amp;quot;kind-kind&amp;quot;
You can now use your cluster with:
kubectl cluster-info --context kind-kind
Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
&lt;/code>&lt;/pre>&lt;p>PS：在下载 Docker 镜像的步骤中，如果你没有安装 Docker，那你也可以有其他选择，比如使用 &lt;a href="https://github.com/containers/skopeo">skopeo&lt;/a> 之类的工具。&lt;/p>
&lt;h2 id="自行构建镜像">自行构建镜像&lt;/h2>
&lt;p>如果你在对 Kubernetes 进行开发，或是 Kind 维护团队没有发布特定 Kubernetes 版本的预构建的镜像，那你可以自行构建镜像。&lt;/p>
&lt;p>需要注意的是，构建镜像时需要网络和一定的磁盘空间。你可以在构建完镜像后，使用上一节提到的办法在离线环境使用。&lt;/p>
&lt;h3 id="构建-base-镜像">构建 base 镜像&lt;/h3>
&lt;p>需要提前准备好 &lt;a href="https://github.com/kubernetes-sigs/kind">kind 的源代码&lt;/a>&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ mkdir -p $GOPATH/src/sigs.k8s.io
(MoeLove) ➜ ~ cd $GOPATH/src/sigs.k8s.io
(MoeLove) ➜ ~ git clone https://github.com/kubernetes-sigs/kind
&lt;/code>&lt;/pre>&lt;p>接下来便可使用以下命令构建 base 镜像了。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kind build base-image --image kindest/base:latest --source $GOPATH/src/sigs.k8s.io/kind/images/base
Building base image in: /tmp/kind-base-image147474678
Starting Docker build ...
...
Successfully tagged kindest/base:latest
Docker build completed.
&lt;/code>&lt;/pre>&lt;p>构建完 base 镜像，还需要以此镜像作为基础构建 node 镜像。&lt;/p>
&lt;h3 id="构建-node-镜像">构建 node 镜像&lt;/h3>
&lt;p>使用此方法，需要你提前准备好 Kubernetes 源代码，你可以&lt;a href="https://github.com/kubernetes/kubernetes#you-have-a-working-go-environment">参考 Kubernetes 项目的说明&lt;/a>下载 Kubernetes 源代码，或者将源代码拷贝至目标机器的对应位置。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ mkdir -p $GOPATH/src/k8s.io
(MoeLove) ➜ ~ cd $GOPATH/src/k8s.io
(MoeLove) ➜ ~ git clone https://github.com/kubernetes/kubernetes
&lt;/code>&lt;/pre>&lt;p>接下来你便可以使用以下命令构建 node 镜像了&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kind build node-image --base-image kindest/base:latest --image kindest/node:latest --kube-root $GOPATH/src/k8s.io/kubernetes
Starting to build Kubernetes
+++ [0205 11:21:38] Verifying Prerequisites....
...
Image build completed.
&lt;/code>&lt;/pre>&lt;p>镜像构建成功后，便可使用此镜像来创建集群了。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kind create cluster --image kindest/node:latest
Creating cluster &amp;quot;kind&amp;quot; ...
✓ Ensuring node image (kindest/node:latest) 🖼
✓ Preparing nodes 📦
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing CNI 🔌
✓ Installing StorageClass 💾
Set kubectl context to &amp;quot;kind-kind&amp;quot;
You can now use your cluster with:
kubectl cluster-info --context kind-kind
Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
&lt;/code>&lt;/pre>&lt;p>检查集群节点信息&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl get node
NAME STATUS ROLES AGE VERSION
kind-control-plane Ready master 40s v1.18.0-alpha.0.3222+4b294079458a72
&lt;/code>&lt;/pre>&lt;p>可以看到集群版本是当前 kubernetes 源码的版本了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了两类使用 Kind 创建 Kubernetes 集群的方法，分别是使用 Kind 预发布的镜像和使用 Kubernetes 源代码构建镜像。&lt;/p>
&lt;p>以上两种方法，镜像中均已包含创建 Kubernetes 集群所需的全部资源，无需再额外下载。(这也是和之前版本最大的区别)&lt;/p>
&lt;h3 id="系列文章">系列文章&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/60464867">《使用 Kind 搭建你的本地 Kubernetes 集群》&lt;/a> (使用了 0.2.0 版本，部分内容已过期)&lt;/li>
&lt;/ul>
&lt;h3 id="推荐阅读">推荐阅读&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://mauilion.dev/posts/kind-k8s-testing/">How to Test a Kubernetes PR with KIND&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Kind/" term="Kind" label="Kind"/></entry><entry><title type="text">K8S 生态周报| Rook v1.2.3 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/02/02/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rook-v1.2.3-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/02/02/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rook-v1.2.3-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-02-02T17:45:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Rook v1.2.3 发布 Rook 昨天发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rook-v123-发布">Rook v1.2.3 发布&lt;/h2>
&lt;p>Rook 昨天发布了 v1.2.3 版本，此版本中仍然重点是对 Ceph 相关的内容做了改进。值得关注的内容如下：&lt;/p>
&lt;ul>
&lt;li>允许使用 &lt;a href="https://rook.io/docs/rook/v1.2/ceph-upgrade.html#enabling-the-csi-v20-driver">Ceph-CSI v2.0.0&lt;/a> 驱动了，不过默认还是使用 CSI v1.2.2 ；&lt;/li>
&lt;li>修正了 prepare job 资源配额的处理逻辑；&lt;/li>
&lt;li>改善 ceph-volume 的日志输出，暴露每个 pvc ceph-volume 日志；&lt;/li>
&lt;li>修正了 CSI 驱动的垃圾回收机制，这个问题根本原因是资源的 OwnerReference 所使用的 API 错了。可能导致的情况是，某些情况下 CSI 相关的 Pod 被清掉了；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友可参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.2.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="coredns-v167-发布">CoreDNS v1.6.7 发布&lt;/h2>
&lt;p>本周 CoreDNS v1.6.7 发布了，是个小版本的更新，需要注意的更新如下：&lt;/p>
&lt;ul>
&lt;li>plugin/{kubernetes, etcd}：允许通过 CNAME 解析 TXT 记录。这个更新是为 &lt;code>backend_lookup.go&lt;/code> 中的 &lt;code>TXT&lt;/code> 方法增加了一个参数，需要注意的是当前已经更新了 &lt;code>kubernetes&lt;/code> 和 &lt;code>etcd&lt;/code> 插件的相关调用，如果有自己实现或者使用其他第三方 plugin 的话，需要注意。&lt;/li>
&lt;/ul>
&lt;p>其他更新请参考 &lt;a href="https://coredns.io/2020/01/28/coredns-1.6.7-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rancher-v235-发布">Rancher v2.3.5 发布&lt;/h2>
&lt;p>这个版本中最主要的修复是一堆和使用 Istio 相关的内容。以下内容是从 ReleaseNote 摘录的，我没太关注，就不展开了。&lt;/p>
&lt;ul>
&lt;li>Fixed a UI issue where Istio wasn't able to edit the Istio configuration after deployment [#25114]&lt;/li>
&lt;li>Fixed an issues around Istio being able to work in air gap setups [#25028]&lt;/li>
&lt;li>Fixed an issue where enabling SDS gateway in Istio failed [#25051]&lt;/li>
&lt;li>Fixed an issue where updates in Istio 1.4.3 requires new role data [#25077]&lt;/li>
&lt;li>Fixed a UI issue where member roles were unable to removed from clusters after creation [#24934]&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友请参阅 &lt;a href="https://github.com/rancher/rancher/releases/tag/v2.3.5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="推荐阅读">推荐阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.docker.com/blog/solving-docker-compose-performance-on-macos-catalina/">How We Solved a Report on docker-compose Performance on macOS Catalina&lt;/a> 这篇文章介绍了 docker-compose 的维护者解决了在 docker-compose 在 macOS Catalina 上的性能问题，并建议升级至 v1.25.1 版本以上。&lt;/li>
&lt;li>&lt;a href="https://www.docker.com/blog/faster-builds-in-compose-thanks-to-buildkit-support/">Faster builds in Docker Compose 1.25.1 thanks to BuildKit Support&lt;/a> 这篇文章介绍了 docker-compose v1.25.1 版本开始可通过设置 &lt;code>COMPOSE_DOCKER_CLI_BUILD=1&lt;/code> 环境变量来启用 buildkit 的支持。（需同时设置 &lt;code>DOCKER_BUILDKIT=1&lt;/code>）&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>近期大家可能都还在家休息，注意勤洗手，多喝水，注意休息，照顾好家人。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| runc v1.0.0-rc10 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/01/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/01/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-01-26T10:21:24+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes 发布 v1.18.0-alpha.2 版本 这个版……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-发布-v1180-alpha2-版本">Kubernetes 发布 v1.18.0-alpha.2 版本&lt;/h2>
&lt;p>这个版本包含了不少变更，这里列一些我个人感觉比较重要的内容：&lt;/p>
&lt;ul>
&lt;li>修复了一个 &lt;code>kubectl apply --prune&lt;/code> 时，未接收 kubectl 指定 namespace 的问题 &lt;a href="https://github.com/kubernetes/kubernetes/pull/85613">#85357&lt;/a>;&lt;/li>
&lt;li>为 kubeadm 在 pull image 时增加了自动重试，默认是 5 次；&lt;/li>
&lt;li>kubelet 的一些 metrics 标记过期；&lt;/li>
&lt;li>可以为 kubelet 传递 &lt;code>--node-ip ::&lt;/code> 默认设置 IPv6 地址为主地址了；&lt;/li>
&lt;/ul>
&lt;p>关于此版本的其他变更，请查看 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.18.0-alpha.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="runc-v100-rc10-正式发布">runc v1.0.0-rc10 正式发布&lt;/h2>
&lt;p>runc 想必大家不会太陌生，关注我的朋友大多都看到过我之前几篇关于 runc 的文章，这里不再赘述。&lt;/p>
&lt;p>本次发布的版本最主要的目的是修复 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19921">CVE-2019-19921&lt;/a> ，由于 runc 是个基础软件，目前也已经将 containerd 和 Docker 做了相应的更新升级以应对此漏洞。&lt;/p>
&lt;p>关于这个漏洞的修复主要就是避免挂载 /proc 到非目录，以避免攻击者利用软链的方式利用 runc 将 /proc 挂载到其他的地方实现攻击。&lt;/p>
&lt;p>另一个重要变更是在 runc 中增加了 cgroups2 的支持。&lt;/p>
&lt;p>想必之后 cgroups2 推进步伐能加快一些。更多关于此版本的信息请查看 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc10">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>在&lt;a href="https://zhuanlan.zhihu.com/p/103509475">上周的 K8S 周报&lt;/a>中，Kubernetes 上游相继发布了 v1.15.8，v1.16.5 以及 v1.17.1 三个版本，但这几个版本的构建信息有误，如果你更新到这些版本会发现 &lt;code>version&lt;/code> 命令的结果是错误的。&lt;/p>
&lt;p>&lt;strong>所以在本周又紧急发布了 v1.15.9, v1.16.6 以及 v1.17.2 版本。如果你还没有升级，那么请直接升级到本次发布的这些新版本, 跳过上周发布的版本。如果你已经升级的话，那更加建议你立刻升级到本次发布的最新版本！&lt;/strong>&lt;/p>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/strimzi/strimzi-kafka-operator">strimzi-kafka-operator&lt;/a> 是一个托管于 CNCF sandbox 级别的项目，致力于更方便的将 kafka 运行在 Kubernetes 之上。&lt;/p>
&lt;p>Strimzi 提供的 operator 架构图如下&lt;/p>
&lt;p>&lt;img src="https://strimzi.io/docs/quickstart/latest/images/operators.png" alt="strimzi-kafka-operator - https://moelove.info">&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>祝大家平安喜乐，注意身体。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kind v0.7.0 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/01/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kind-v0.7.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/01/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kind-v0.7.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-01-19T08:24:28+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kind (Kubernetes in Docker) 正式发布 v0.7.0……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-kubernetes-in-docker-正式发布-v070">Kind (Kubernetes in Docker) 正式发布 v0.7.0&lt;/h2>
&lt;p>Kind (Kubernetes in Docker) 是我很喜欢也一直在参与的项目，现在在 GitHub 上有 4.3k 的 star ，本周正式发布了 v0.7.0 我们一起来看看在此版本中增加了哪些有用的特性。&lt;/p>
&lt;h3 id="重大变更">重大变更&lt;/h3>
&lt;ul>
&lt;li>Kubernetes 版本升级，现在默认的 Kubernetes 版本升级为 v1.17.0 , 在 kind v0.6+ 时候默认的 Kubernetes 版本是 v1.16.3;&lt;/li>
&lt;li>使用 kind v0.7.0 构建的镜像有很多改进，需要至少 v0.5+ 版本才能保持兼容，如果是想要使用在 v0.7 版本中新增的全部特性，建议同时升级 kind 二进制文件以及更新 node 镜像;&lt;/li>
&lt;/ul>
&lt;h3 id="新特性增加">新特性增加&lt;/h3>
&lt;ul>
&lt;li>通过集成 &lt;a href="https://github.com/rancher/local-path-provisioner">rancher.io/localhost-path&lt;/a> 提供了开箱即用的动态存储卷的支持；&lt;/li>
&lt;li>提供了使用 Ingress 暴露部署在 Kind 中服务的多种方式的文档，包括 &lt;strong>Contour&lt;/strong> 和 &lt;strong>NGINX Ingress&lt;/strong> ;&lt;/li>
&lt;li>更新了相关的依赖，包括修复 CNI portmap 插件以提高稳定性；&lt;/li>
&lt;/ul>
&lt;h3 id="修复问题">修复问题&lt;/h3>
&lt;ul>
&lt;li>提升日志消息的可读性;&lt;/li>
&lt;li>修正 &lt;code>kind load&lt;/code> 镜像到 node 节点上之后的检查逻辑；&lt;/li>
&lt;li>当默认的 &lt;code>$HOME/.kube/config&lt;/code> 文件不存在时，在 &lt;code>kind create cluster&lt;/code> 之后，会自动根据 kubeadm 的信息补充其他字段，比如 &lt;code>kind&lt;/code> 和 &lt;code>apiVersion&lt;/code> ；&lt;/li>
&lt;li>减小镜像的体积；&lt;/li>
&lt;/ul>
&lt;p>在我的电脑上如果忽略掉镜像下载耗时，使用 kind v0.6+ 版本，创建一个单节点集群耗时是 52 秒，而升级至 v0.7 后耗时可缩短到 46 秒。&lt;/p>
&lt;p>在创建集群后，默认有一个名为 &lt;code>standard&lt;/code> 的 StorageClass 可直接使用。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl get nodes
NAME STATUS ROLES AGE VERSION
117-control-plane Ready master 66s v1.17.0
(MoeLove) ➜ ~ kubectl get sc
NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE
standard (default) rancher.io/local-path Delete WaitForFirstConsumer false 65s
&lt;/code>&lt;/pre>&lt;p>欢迎大家下载使用 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.7.0">https://github.com/kubernetes-sigs/kind/releases/tag/v0.7.0&lt;/a>&lt;/p>
&lt;h2 id="rancher-发布-v234-版本">Rancher 发布 v2.3.4 版本&lt;/h2>
&lt;p>大致需要注意的内容如下：&lt;/p>
&lt;ul>
&lt;li>Kubernetes v1.17 成为了默认的版本；&lt;/li>
&lt;li>Istio 升级至 v1.4.3;&lt;/li>
&lt;li>修复了一些比如 label 无法添加之类的问题；&lt;/li>
&lt;/ul>
&lt;p>其实修复的内容还比较多，感兴趣的朋友可以看看其 &lt;a href="https://github.com/rancher/rancher/releases/tag/v2.3.4">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rook-发布-v122-版本">Rook 发布 v1.2.2 版本&lt;/h2>
&lt;p>Rook 发布的 v1.2.2 主要是进行 bugfix 。这个版本最主要的内容都集中在 Ceph 上，其中有些值得关注的点：&lt;/p>
&lt;ul>
&lt;li>支持多个集群设置 &lt;code>useAllDevices&lt;/code> 选项，其最主要的需求来自于当创建集群失败，想要重新创建集群时，之前版本中只允许有一个集群能设置为 &lt;code>useAllDevices&lt;/code>，所以就会报错了。更新至此 v1.2.2 版本后，就允许多个集群都可以设置 &lt;code>useAllDevices&lt;/code> 选项了；&lt;/li>
&lt;li>将 example 中 Ceph 版本设置为 v14.2.6；&lt;/li>
&lt;li>修复了 &lt;code>CephMonHighNumberOfLeaderChanges&lt;/code> 中错误的 Pod 名称和主机名；&lt;/li>
&lt;/ul>
&lt;p>更多详细的内容请参考其 &lt;a href="https://github.com/rook/rook/releases/tag/v1.2.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>Kubernetes 本周相继发布了 v1.15.8，v1.16.5 以及 v1.17.1 ，这其中包含了两个很重要的 bugfix， 需要注意。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/84951">84951&lt;/a> 修复了 kubelet 对 static pod 状态的同步；&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/86320">86320&lt;/a> 为 kubelet patch pod 状态时，增加了一个 uid 以避免出现更新错误的情况；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Istio v1.4.3 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/01/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-v1.4.3-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2020/01/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-v1.4.3-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-01-12T20:18:09+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Prometheus v2.15.2 发布 本周 Prometheus 发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="prometheus-v2152-发布">Prometheus v2.15.2 发布&lt;/h2>
&lt;p>本周 Prometheus 发布了 v2.15.2 版本，其修复了两个 TSDB 相关的问题。&lt;/p>
&lt;ul>
&lt;li>修复对 2.1.0 之前版本构建的 TSDB 块的支持，这个问题直接影响的是那些直接从 2.1.0 版本之前直接升级到 2.15 的用户，根本原因是在 2.1.0 版本加入的一个对 key 排序的特性；&lt;/li>
&lt;li>修复了 TSDB 在 Windows 下的压缩问题；&lt;/li>
&lt;/ul>
&lt;p>其他变化，感兴趣的朋友可以参看其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.15.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-v143-发布">Istio v1.4.3 发布&lt;/h2>
&lt;p>Istio 发布了 v1.4.3 版本，带来了众多 bugfix 和改进，我们来具体看看：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>修复了 Mixer 为 secret 创建大量 watcher 可能导致 Kubernetes api-server OOM 的问题 &lt;a href="https://github.com/istio/istio/issues/19481">#19481&lt;/a> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修复了注入相关的模板。当 POD 有多个 container 但 container 未暴露端口时，istio-proxy 无法启动的问题。&lt;a href="https://github.com/istio/istio/issues/18594">#18594&lt;/a>；&lt;/p>
&lt;p>如果只是想要修复这个问题的话，你可以直接手动修改注入相关的模板。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为所有注入容器添加了 PSP 相关的配置和支持 &lt;a href="https://github.com/istio/istio/pull/17427">#17427&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其他变化，感兴趣的朋友可以参看其 &lt;a href="https://istio.io/news/releases/1.4.x/announcing-1.4.3/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="falco-晋级为-cncf-孵化项目">Falco 晋级为 CNCF 孵化项目&lt;/h2>
&lt;p>&lt;strong>&lt;a href="https://falco.org/">Falco&lt;/a> 是首个进入 CNCF 孵化级的运行时安全项目。&lt;/strong>&lt;/p>
&lt;p>Falco 最初由 Sysdig 在 2016 年创建，在 2018 年 10 月份正式成为 CNCF sandbox 级别的项目。&lt;/p>
&lt;p>Falco 是一个非常有用且有趣的项目，使用它可以很方便的做容器安全相关的事情，比如：入侵检测之类的。只需要编写对应的规则文件即可完成。&lt;/p>
&lt;p>现在容器化和 Kubernetes 愈发火热，但安全相关的问题还不够重视，Falco 现在晋级成为 CNCF 的孵化项目，无疑能在此方面填补一些空缺。&lt;/p>
&lt;h2 id="kubernetes-nginx-ingress-v0270-发布">Kubernetes NGINX Ingress v0.27.0 发布&lt;/h2>
&lt;p>主要变更如下：&lt;/p>
&lt;ul>
&lt;li>升级至 NGINX 1.17.7；&lt;/li>
&lt;li>允许为 Ingress 开启或关闭 opentrace;&lt;/li>
&lt;li>&lt;code>lua-resty-waf&lt;/code> 被移除，删除它的主要原因是构建镜像的关系，且项目不够活跃；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>破坏性变更&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>本次版本中，将 OpenResty 再次替换为 NGINX， 且基础镜像使用了 Alpine Linux， 由此镜像体积减少了 90M 左右，且漏洞均已修正。&lt;/li>
&lt;/ul>
&lt;p>Kubernetes NGINX Ingress 在 NGINX 和 OpenResty 中来回切换，如果有依赖于 OpenResty 的朋友，需要格外注意。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>API Server 现在需要 client 声明其协议版本 &lt;a href="https://github.com/kubernetes/kubernetes/pull/86646">#86646&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>Grafana 开源了一个项目，名为 &lt;a href="https://github.com/grafana/tanka">Tanka&lt;/a> 主要是为了更灵活的配置和重用。&lt;/p>
&lt;p>具体来说就是它使用 jsonnet 作为配置语言，并且提供了参数及抽象，以及一个自带的 Kubernetes 库，可以更加方便的进行灵活配置。&lt;/p>
&lt;p>在我个人看来，当前可用的这类工具太多，大致也可以与 Helm 或 kustomize 进行类比。但至于如何选择，还是看个人习惯以及需求，Tanka 的优势及便利性感兴趣的朋友可以自行发掘下，我就不过多介绍了。&lt;/p>
&lt;p>(我更觉得这是 jsonnet 的一次重生，值得推荐一下)&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。点击阅读原文有更好的阅读体验。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 终端下的 K8S 资源树查看器</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/01/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E7%BB%88%E7%AB%AF%E4%B8%8B%E7%9A%84-K8S-%E8%B5%84%E6%BA%90%E6%A0%91%E6%9F%A5%E7%9C%8B%E5%99%A8/"/><id>https://moelove.info/2020/01/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-%E7%BB%88%E7%AB%AF%E4%B8%8B%E7%9A%84-K8S-%E8%B5%84%E6%BA%90%E6%A0%91%E6%9F%A5%E7%9C%8B%E5%99%A8/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-01-05T09:52:30+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 上游进展 Kubernetes v1.17.0 中，如……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>Kubernetes v1.17.0 中，如果将 CIDR 设置为低于 &lt;code>/16&lt;/code> 位，则 IP 分配器可能会报错。这个问题当前已经在 &lt;a href="http://issue.k8s.io/86534">#86534&lt;/a>中修复，将随着 v1.17.1 发布，如果尚未升级至 v1.17.0 的朋友可以稍后；&lt;/li>
&lt;li>api-server 的 &lt;code>bind-address&lt;/code> 最近稍作了调整，如果未指定或者使用 &lt;code>0.0.0.0&lt;/code> 或 &lt;code>::&lt;/code> 则会监听本地的所有可用的地址。&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/ahmetb/kubectl-tree">kubectl-tree&lt;/a> 是一个用于在终端内以树形结构展示 Kubernetes 资源的 Kubectl 插件。（已经登上了 GitHub 的趋势榜）&lt;/p>
&lt;p>使用效果如图：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kubectl-tree.png" alt="kubectl-tree - https://moelove.info">&lt;/p>
&lt;p>在我的终端下，它不能对齐，不过我还没来得及具体去看原因。&lt;/p>
&lt;h2 id="新项目apisix-ingress-controller">新项目：APISIX-ingress-controller&lt;/h2>
&lt;p>最近看到一个为 &lt;a href="https://github.com/apache/incubator-apisix">Apache APISIX&lt;/a> 实现 Ingress Controller 的项目 &lt;a href="https://github.com/iresty/ingress-controller">APISIX-ingress-controller&lt;/a>&lt;/p>
&lt;p>同时也看到了&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI1MDU3NjQ5OA==&amp;amp;mid=2247483714&amp;amp;idx=1&amp;amp;sn=9981994db87bdeb4e9e9f32ef0903197&amp;amp;chksm=e9816a5fdef6e349cf7c53edfd358cafc1f4055cefa9b88875417a43b89d777f42488db63b4f&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1577773615386&amp;amp;sharer_shareid=f168231ea32e9fe3764a5ba7337ed0f7#rd">一篇文章: 为什么我们重新写了一个 k8s ingress controller &lt;/a> 文章的作者解释了为何要重新写一个 Ingress Controller。&lt;/p>
&lt;p>在我个人看来，多实现一种 Ingress Controller 对社区而言是好事儿，让大家有了&lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers">更多的选择&lt;/a>，另一方面，这个项目刚起步不久，如果有对实现 APISIX Ingress Controller 感兴趣的朋友可以尽早加入。&lt;/p>
&lt;p>( &lt;em>抛开此项目不谈，单纯谈写一个简单的自定义 Ingress Controller 其实比较简单，倒也挺有趣的，只不过在处理一些高级特性及处理大量请求时，不同的实现会有些区别。&lt;/em> 推荐大家都尝试下&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>最近恰逢新年，上游的变更不太频繁（大多都休假了），多数的变更也都是一些小的修复和清理工作。&lt;/p>
&lt;p>再次祝大家新年快乐&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">2019 小回顾</title><link rel="alternate" type="text/html" href="https://moelove.info/2020/01/01/2019-%E5%B0%8F%E5%9B%9E%E9%A1%BE/"/><id>https://moelove.info/2020/01/01/2019-%E5%B0%8F%E5%9B%9E%E9%A1%BE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2020-01-01T22:01:00+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这篇文章起笔于上周（年底），不过工作比较忙，一直耽搁到今天（1 月 1 日）才抽出时间，索性就重写了。算是一篇岁岁念，想到什么就写点。……</summary><content type="html">&lt;blockquote>
&lt;p>这篇文章起笔于上周（年底），不过工作比较忙，一直耽搁到今天（1 月 1 日）才抽出时间，索性就重写了。算是一篇岁岁念，想到什么就写点。&lt;/p>
&lt;/blockquote>
&lt;p>转眼已是 2020 年 1 月 1 日了，惯例做个小回顾。
2019 年发生了太多事情，非常值得好好回顾一下。每年的回顾不仅是对过去一年的总结，也是对新的一年做个计划。
依旧按照我每年的习惯，分别从工作和生活来聊聊。&lt;/p>
&lt;h2 id="工作">工作&lt;/h2>
&lt;p>2019 年我做的事情，主要涉及以下几个方面：&lt;/p>
&lt;ul>
&lt;li>Docker 容器化和 Kubernetes&lt;/li>
&lt;li>API Gateway&lt;/li>
&lt;li>CI/CD&lt;/li>
&lt;li>存储&lt;/li>
&lt;li>监控&lt;/li>
&lt;li>告警信息收敛&lt;/li>
&lt;/ul>
&lt;p>也算是比较典型的云原生工程师的工作内容了，感谢同事们的支持和配合。&lt;/p>
&lt;p>2019 年是云原生形势大好的一年，这一年整个行业内都发生了不小的变动，关注我每周推送的&lt;a href="https://zhuanlan.zhihu.com/container">「k8s 生态周报」&lt;/a>的小伙伴可能已经发现，周报中最多的内容是 K8S 生态中比较核心的软件的版本发布及功能变更或漏洞相关的信息。&lt;/p>
&lt;p>为什么这类信息会这么多呢？主要还是因为 2019 年云原生或者说 Kubernetes 的普及越来越广泛，需求增多，场景愈发复杂，相应的像 Docker, Kubernetes, Prometheus 这类基础软件也就需要提供更多的特性支持，或者 bugfix 。所以我在这方面投入的时间也就更多一些。&lt;/p>
&lt;p>此外，从 19 年 3 月底，我开始了每周 &lt;a href="https://zhuanlan.zhihu.com/container">「k8s 生态周报」&lt;/a> 的推送，直到今天共计推送了 41 篇周报，未曾落下，也积累了不少读者，感谢大家关注。&lt;/p>
&lt;p>今年在 PyCon China 的角色从讲师变成了出品人，原本计划会有一个主题演讲，但是由于跟我的婚礼时间冲突了，所以未能参加。感谢 PyCon China 的一众小伙伴的谅解和支持。&lt;/p>
&lt;p>在国庆假期结束后，我在 GitChat 上发布的专栏&lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>正式上线了，至今专栏内容已经更新了一半，按照 GitChat 的字数统计现在写了大概是 9w 字左右（这个统计包括了我之前发布的五篇 Chat 文章）。感谢我的小可爱一直督促我，感谢编辑们的辛苦，感谢读者的信任和支持。&lt;/p>
&lt;p>与工作相关的内容主要就这些吧，之前&lt;a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;amp;mid=2247491168&amp;amp;idx=4&amp;amp;sn=99c75223a96c3f0a4ba4802162a7176b&amp;amp;chksm=e82bff71df5c7667eeeabc6a12c1ed5d7e2589dd6d81c015a9fdf4896af0d99019c71182ab27&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1577896952072&amp;amp;sharer_shareid=ca2e51094588e06bf753d47ce6ce6894&amp;amp;exportkey=AeBs7IZvP2YDdO0PAERxHsc%3D&amp;amp;pass_ticket=sUqDG7gi77aHI1AzhT8QG4acbC2iGtoHfL5dhjaRgAIB%2BMOsBIpQ8jHnQ671eH1e#rd">GitChat 的访谈中&lt;/a>我有大概聊了下 2020 年的容器技术趋势，整体而言是稳定性和性能会占据主体地位，架构在 k8s 等基础设施之上的 serverless 和 service mesh 等将会愈发火热，不过这些不是本篇的重点，之后有空会专门补一篇关于我所预见的技术趋势的文章。&lt;/p>
&lt;h2 id="生活">生活&lt;/h2>
&lt;p>2019 年对我而言是意义非凡的一年，这一年我和我的小可爱结婚啦！而且现在也有了宝宝（虽然要等到 2020 年出生）。&lt;/p>
&lt;p>婚礼是在老家办的，要非常感谢家人朋友们对我们的帮助和支持。&lt;/p>
&lt;p>经常听朋友们说“一胎看书养” 果然没错，自从小可爱怀孕后，我家里书架上的书就换成《睡前胎教》《孕期百科》之类的书，买了胎心仪，时常听听宝宝的胎心之类的。&lt;/p>
&lt;p>虽然比较紧张，但整体而言，更多的是欣喜和期待，期待有个健康的宝宝，期待和我的小可爱把我们的生活过的更加幸福美好！&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我在去年的总结 &lt;a href="https://zhuanlan.zhihu.com/p/53641783">2018 小回顾&lt;/a> 中定了几个目标（按文章内容的先后顺序）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>花更多时间建设知乎专栏 &lt;a href="https://zhuanlan.zhihu.com/container">『k8s生态』&lt;/a>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>社区中主要活跃在 Docker 和 Kubernetes 生态方向。维护一些官方镜像，做测试，解决问题，提交代码之类的，明年希望做的更多；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>继续在云原生领域的深耕；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>希望能越来越好，能跟小可爱越来越幸福。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>现在看来，完成度还不错：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如上文所言，知乎专栏 &lt;a href="https://zhuanlan.zhihu.com/container">『k8s生态』&lt;/a> 更新了 41 篇「k8s 生态周报」，现在共计 61 篇文章，有 846 个关注。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>社区活动方面，年初做过一次演讲，6 月份参加了 KubeCon ，见了一些朋友；再后来 PyCon China 那次未能成行。这方面略有遗憾吧。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>至于社区贡献，贴一张图：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://moelove.info/img/2019-oss.png" alt="2019 overview - https://moelove.info">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在云原生领域当然是在继续深入探索和实践，整体而言也还算满意；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>跟小可爱也更加幸福，非常开心；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>接下来，还是为 2020 年定些小目标吧：&lt;/p>
&lt;ul>
&lt;li>工作方面希望能推动更多业务的改造和接入，算是个长线计划；&lt;/li>
&lt;li>社区活动方面，今年希望多参与一些，把一些理念和实践经验 push 到社区，也能从中学习到社区的一些经验；&lt;/li>
&lt;li>社区贡献方面，会继续投入更多精力来做，但与 2019 年的重点可能会稍有不同；&lt;/li>
&lt;li>生活方面，希望宝宝健康的出生，和我的小可爱共同经营好我们的家庭。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">K8S 生态周报| Prometheus v2.15.0 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/12/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-v2.15.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/12/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Prometheus-v2.15.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-12-29T16:55:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Prometheus v2.15.0 正式发布 本周 Prometheus……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="prometheus-v2150-正式发布">Prometheus v2.15.0 正式发布&lt;/h2>
&lt;p>本周 Prometheus 发布了 v2.15.0 版本，这个版本在 TSDB 方面有诸多改进，以及提升了 PromQL 解析器的性能。&lt;/p>
&lt;p>TSDB 方面主要是对内存使用相关的优化。&lt;/p>
&lt;p>按照此版本中 &lt;a href="https://github.com/prometheus/prometheus/pull/6356">对 PromQL 解析器相关变更的 PR&lt;/a>，本次解析器性能的提升能达到之前的 7 倍。&lt;/p>
&lt;p>同时，此版本中也存在一个 bug，可能会导致并发查询数据时，出现 checksum 不匹配的情况，最直接的影响就是 Grafana 的图表会显示不出来。&lt;/p>
&lt;p>所以之后也快速发布了 v2.15.1 版本。建议如果使用 v2.15.0 的朋友可以快速升级至 v2.15.1 以规避此问题。&lt;/p>
&lt;p>更多关于此版本的变更，请查看其 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.15.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="rancher-v240-alpha1-发布">Rancher v2.4.0-alpha1 发布&lt;/h2>
&lt;p>Rancher 本周发布了 v2.4.0-alpha1 , 此版本中在用户角色方面有两个挺不错的改进。&lt;/p>
&lt;ul>
&lt;li>管理员可以自定义全局范围内的角色，并且可以让用户登录后默认使用该角色。&lt;/li>
&lt;li>在使用外部认证方式时，管理员也可以默认设置属于某个组的用户，默认授予的权限。（比较类似于 Grafana 使用 LDAP 认证时，默认给用户设置的权限，但更灵活一些。)&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的信息，可参考其 &lt;a href="https://github.com/rancher/rancher/releases/tag/v2.4.0-alpha1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>这是今年 &lt;a href="https://zhuanlan.zhihu.com/container">「K8S 生态周报」&lt;/a>的最后一篇了，本篇中没有上游进展，上游最近的变更并不频繁，(大概是年底休假的原因）&lt;/p>
&lt;p>从 2019 年 3 月份开始，便一直保持着每周更新。新的一年，我也将继续保持更新，与你分享我所接触到的 K8S 生态相关的每周值得推荐的一些信息。&lt;/p>
&lt;p>&lt;strong>感谢关注！&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| TUF 正式从 CNCF 毕业</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/12/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-TUF-%E6%AD%A3%E5%BC%8F%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/"/><id>https://moelove.info/2019/12/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-TUF-%E6%AD%A3%E5%BC%8F%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-12-21T16:55:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 TUF 正式从 CNCF 毕业 本周……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="tuf-正式从-cncf-毕业">TUF 正式从 CNCF 毕业&lt;/h2>
&lt;p>本周 &lt;a href="https://theupdateframework.github.io/">The Update Framework (TUF)&lt;/a> 正式&lt;a href="https://www.cncf.io/announcement/2019/12/18/cloud-native-computing-foundation-announces-tuf-graduation/">从 CNCF 毕业&lt;/a>，现在 TUF 的官方 Python 实现有 954 个 star ，142 个 fork 以及 43 位贡献者和 3525 次 commit 记录。&lt;/p>
&lt;p>TUF 是从 CNCF 正式毕业的第 9 个项目，没记错的话也是至今为止唯一一个 star 数未上千就正式毕业的项目。不过 TUF 项目本身与其他项目不同，star 数也说明不了项目状态。&lt;/p>
&lt;p>可能不少人觉得 TUF 项目的存在感很低，或是没有了解或使用过 TUF 项目，我姑且对它做一点介绍。&lt;/p>
&lt;p>TUF 项目大概是十年前启动，并于 2017 年开始托管于 CNCF，它的主要目标正如它的名字一般，提供用于更新的框架，但它更重要的点在于它的安全性设计上。&lt;/p>
&lt;p>它充分考虑到了各个环节可能出现的攻击，在提供更新功能的同时，也可以很好的保护现有程序或者是验证待更新版本的安全和可靠性。你可能想问它是如何做到这一点的，其实它主要是提供了一套标准规范，并在各个环节中增加了更多的元数据和相关的检查，包括签名信息，文件 hash ，元数据签名和过期时间等。&lt;/p>
&lt;p>至于它的存在感嘛，不知道你是否有使用过 Docker Content Trust(DCT) 相关的功能，简单来说你可以当作就是 &lt;code>docker trust&lt;/code> 所涉及到的相关功能，这其中的部分功能是构建在 &lt;a href="https://github.com/docker/notary/releases">Docker Notary&lt;/a> 之上的，而 Docker Notary 则是使用 TUF 作为其基础安全框架的。(PS：Docker Inc 也已经将 Docker Notary 捐献给了 CNCF)&lt;/p>
&lt;p>现在多数公有云（比如 IBM，Azure 等）提供可信镜像仓库服务时，基本也都间接的依赖于 Docker Notary 和 TUF 了，这也是 TUF 被广泛使用的方面。 除了容器生态外，一些语言的包管理器也都在探索基于 TUF 实现其安全更新，包括 &lt;a href="https://github.com/pypa/interoperability-peps/blob/master/pep-0458-tuf-online-keys.rst">Python 的 pip&lt;/a>, &lt;a href="http://www.well-typed.com/blog/2015/04/improving-hackage-security/">Haskell 的 hackage&lt;/a> 以及 &lt;a href="https://opam.ocaml.org/blog/Signing-the-opam-repository/">OCaml 的 opam&lt;/a> 等。&lt;/p>
&lt;p>不过相关扩展内容不是本篇的重点，暂且跳过。最后再次恭喜 TUF 顺利毕业！&lt;/p>
&lt;h2 id="linkerd-v261-发布">Linkerd v2.6.1 发布&lt;/h2>
&lt;p>Linkerd 本周发布了 v2.6.1 版本，这是一个非常小的 bugfix 版本。在这里提到是因为这个小版本主要是改善 Proxy 的稳定性，通过修复了 Proxy 可能停止接收服务发现更新，导致 503 的 bug 。&lt;/p>
&lt;p>对此问题感兴趣的朋友可以参考 &lt;a href="https://github.com/linkerd/linkerd2-proxy">linkerd2-proxy&lt;/a> 的更新记录。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>Kubernetes v1.17 已经发布了，现在上游也进入了 v1.18 的开发阶段，本周发布了 v1.18.0-alpha.1 , 其中有个很有用的变更。&lt;/p>
&lt;p>&lt;code>kubectl drain&lt;/code> 在 &lt;code>--dry-run&lt;/code> 的时候，可以显示会驱逐掉的 &lt;code>pod&lt;/code> 信息了。 示例如下：&lt;/p>
&lt;pre>&lt;code># kubectl v1.18.0-alpha.1
(MoeLove) ➜ bin ./kubectl.v1.18 drain --dry-run=true 10.19.47.253
node/10.19.47.253 cordoned (dry run)
evicting pod infra/redis-7c647bfd97-fdk2r (dry run)
evicting pod kube-system/coredns-65b546d87d-6jmfp (dry run)
evicting pod kube-system/coredns-65b546d87d-pwqvh (dry run)
node/10.19.47.253 drained (dry run)
&lt;/code>&lt;/pre>&lt;p>而之前版本中是没有展示被驱逐 &lt;code>pod&lt;/code> 信息的：&lt;/p>
&lt;pre>&lt;code># kubectl below v1.18.0-alpha.1
(MoeLove) ➜ bin ./kubectl.v1.17 drain --dry-run=true 10.19.47.253
node/10.19.47.253 cordoned (dry run)
node/10.19.47.253 drained (dry run)
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.17 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/12/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.17-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/12/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.17-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-12-15T23:16:14+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.17 正式发布 本周 Kubernetes……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v117-正式发布">Kubernetes v1.17 正式发布&lt;/h2>
&lt;p>本周 Kubernetes v1.17 正式发布了，这是 2019 年的第四次发布，当然也是今年最后一次了。Kubernetes v1.17 包含 22 个增强功能，其中 14 个已经 stable ，4 个 beta 以及剩余 4 个 alpha 。&lt;/p>
&lt;p>本次版本的主题是 Stability，在发布之时 Kubernetes 官方博客上已经有了一篇 &lt;a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-release-announcement/">Kubernetes 1.17: Stability&lt;/a> 文章介绍，加上每周的周报中也都有上游进展的介绍，我在这里就不赘述了，稍微聊两三个我个人认为比较有用的内容。&lt;/p>
&lt;ul>
&lt;li>&lt;code>rbac.authorization.k8s.io/v1alpha1&lt;/code> 和 &lt;code>rbac.authorization.k8s.io/v1beta1&lt;/code> 在 v1.17 被标记为废弃，并且在 v1.20 将被废弃；&lt;/li>
&lt;li>&lt;code>kubectl logs&lt;/code> 增加了一个 &lt;code>--prefix&lt;/code> 的选项，使用此选项可以在输出日志的时候展示一个前缀，格式是 &lt;code>[pod/name/containerName] &lt;/code>&lt;/li>
&lt;li>废弃和添加了一大堆 metrics， 感兴趣的朋友可以参考下 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md#metrics-changes">ReleaseNote 中 metrics 的部分&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>其余内容建议参考下完整的 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md#changes">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="harbor-v110-正式发布">Harbor v1.10 正式发布&lt;/h2>
&lt;p>Harbor 目前在 GitHub 有 10.3k 的 star ，而且目前在国内被使用的也很广泛。我之前在 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f/topic/5d72052861c92c7091bd4bb1">Docker 的认证流程和原理&lt;/a> 中也介绍过 Harbor （当然也包括 Quay，GitHub registy 和 GitLab registry 等）。我们来看看本次版本中一些亮点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>支持插件化配置的扫描器，现在可支持的扫描器包括：&lt;/p>
&lt;ul>
&lt;li>Clair&lt;/li>
&lt;li>Anchore&lt;/li>
&lt;li>Trivy&lt;/li>
&lt;li>CSP&lt;/li>
&lt;li>DoSec&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Tag 的不可变性，允许管理员配置指定的 Tag 为不允许变更（或者覆盖）;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制功能的增强：将Gitlab，Quay.io 和 Jfrog Artifactory 添加到了受支持列表；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加了个 &lt;code>Limited Guest&lt;/code> 的权限，允许 Pull 镜像，但是不允许查看日志之类的操作；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>整体而言，本次版本还是很不错的，也更符合 “企业级” 的定位。现在 Harbor 也在计划从 CNCF 毕业，大概明年能正式毕业吧。
更多关于此版本的更新请查看 &lt;a href="https://github.com/goharbor/harbor/releases/tag/v1.10.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>&lt;a href="https://github.com/salesforce/sloop">Sloop - Kubernetes History Visualization&lt;/a> 是一个可用于 Kubernetes 中历史记录可视化的项目。&lt;/p>
&lt;p>&lt;img src="https://github.com/salesforce/sloop/blob/master/other/architecture.png?raw=true" alt="Sloop - https://moelove.info">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| containerd v1.3.2 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/12/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.2-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/12/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.2-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-12-09T01:09:07+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kind v0.6.1 发布 本周 Kind Kubernetes In……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v061-发布">Kind v0.6.1 发布&lt;/h2>
&lt;p>本周 Kind &lt;a href="https://github.com/kubernetes-sigs/kind">Kubernetes In Docker&lt;/a> 发布了 v0.6.1 版本，这是对 v0.6.0 的一个小 patch 版本，主要变更如下：&lt;/p>
&lt;ul>
&lt;li>修复 containerd 在多 control plane 节点集群下的配置；&lt;/li>
&lt;li>修正了 v1alpha4 API 中的 &lt;code>protocol&lt;/code> 和 &lt;code>propagation&lt;/code> 配置；&lt;/li>
&lt;li>重新推送了镜像，v0.6.0 发布的时候忘记把 CNI 的镜像给预加载到 Node 镜像中了。现在的默认镜像是 &lt;code>kindest/node:v1.16.3@sha256:70ce6ce09bee5c34ab14aec2b84d6edb260473a60638b1b095470a3a0f95ebec&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>另外：Kind 的 Node 镜像在 DockerHub 上的下载量超过了 500K+ ，也说明其正在被广泛使用。（查看了下我自己发布的镜像中，下载量最多的也才只有 50K+）恭喜 Kind ！&lt;/p>
&lt;h2 id="containerd-v132-发布">containerd v1.3.2 发布&lt;/h2>
&lt;p>这是 containerd 在 v1.3 系列的第二个 patch 版本。 此版本主要的修复内容如下：&lt;/p>
&lt;ul>
&lt;li>修复了一个容器 pid 的问题，会导致 Docker 卡住；&lt;/li>
&lt;li>使用已缓存的状态而不是每次都执行 &lt;code>runc state&lt;/code> 获取容器状态，相关影响是 Kubernetes 启用 liveness 和 readiness 探针会造成 CPU 飙高以及 Docker 容器使用健康检查也会造成 CPU 飙高；&lt;/li>
&lt;/ul>
&lt;p>综合来看，建议更新到此版本。&lt;/p>
&lt;h2 id="helm-v301-发布">Helm v3.0.1 发布&lt;/h2>
&lt;p>这是 Helm v3 系列的第一个 patch 版本，这次包含了不少修复，但都是一些比较小的修复，我大致翻了翻，就不再展开介绍了。&lt;/p>
&lt;p>为了更好的体验，建议升级到最新的版本。当然从中也可以看到 Helm v3 还是有不少需要完善的细节。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>授权 webhook 的 LRU 缓存被调大了 8 倍 &lt;a href="https://github.com/kubernetes/kubernetes/pull/85957">#85957&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="文章推荐">文章推荐&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/debug-for-k8s.png" alt="troubleshooting-kubernetes - https://moelove.info">&lt;/p>
&lt;p>via. &lt;a href="https://learnk8s.io/troubleshooting-deployments">A visual guide on troubleshooting Kubernetes deployments&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Rancher v2.3.3 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/12/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rancher-v2.3.3-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/12/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Rancher-v2.3.3-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-12-01T10:15:15+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Rancher v2.3.3 发布 本周 Rancher v2.3.3 发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rancher-v233-发布">Rancher v2.3.3 发布&lt;/h2>
&lt;p>本周 Rancher v2.3.3 发布，正式支持 Kubernetes v1.16，并将 v1.16.3 设置为 Rancher 默认的 Kubernetes 版本。&lt;/p>
&lt;p>在此版本中，值得关注的修复如下：&lt;/p>
&lt;ul>
&lt;li>修复了其不支持 kube-proxy 使用 IPVS 模式的问题;&lt;/li>
&lt;/ul>
&lt;p>已知问题：&lt;/p>
&lt;ul>
&lt;li>Rancher v2.3.3 在开启 SELinux 的 RHEL 7.7 上使用 RHEL Docker 1.13 时，部署集群将导致失败；&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的特性及已知问题，请关注 &lt;a href="https://github.com/rancher/rancher/releases/tag/v2.3.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>api-server 的 &lt;code>--runtime-config&lt;/code> 可使用 &lt;code>api/beta=false&lt;/code> 参数禁用所有内置的符合 &lt;code>v[0-9]+beta[0-9]+&lt;/code> 版本的 REST API；同时 &lt;code>--feature-gates&lt;/code> 可使用 &lt;code>AllBeta=false&lt;/code> 禁用所有内置的 beta 特性。&lt;a href="https://github.com/kubernetes/kubernetes/pull/84304">#84304&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>downward API 为 Dualstack 增加了支持，参数名为 &lt;code>status.podIPs&lt;/code>。&lt;a href="https://github.com/kubernetes/kubernetes/pull/83123">#83123&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>介绍一个项目 &lt;a href="https://github.com/kubernetes-sigs/kube-storage-version-migrator">kube-storage-version-migrator&lt;/a> 可帮助你将 Kubernetes 存储在 etcd 中数据迁移至最新的存储版本。&lt;/p>
&lt;p>相关的 KEP 在：https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/0030-storage-migration.md&lt;/p>
&lt;p>&lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/storage-migration-auto-trigger.md">https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/storage-migration-auto-trigger.md&lt;/a>&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>本周整体来看，没有特别多的内容，在接下来的两周内，如果进度正常 Kubernetes v1.17 也就会正式发布了。至此，今年 Kubernetes 的最后一个版本也就正式完成。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| containerd v1.3.1 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/11/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.1-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/11/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3.1-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-11-25T04:52:31+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd v1.3.1 发布 本周 containerd v1.3.1 发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="containerd-v131-发布">containerd v1.3.1 发布&lt;/h2>
&lt;p>本周 containerd v1.3.1 发布了，我们一起看看其中值得注意的变化：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将 runc 更新至 v1.0.0-rc9 ， 其中包含了对 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16884">CVE-2019-16884&lt;/a> 的修复，关于此漏洞的更多细节也可参考 &lt;a href="https://github.com/opencontainers/runc/issues/2128">https://github.com/opencontainers/runc/issues/2128&lt;/a> ；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修复了一个 v1.3.0 在拉取镜像遇到错误时，解包过程中的死锁问题 &lt;a href="https://github.com/containerd/containerd/issues/3816">#3816&lt;/a> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定位了一个 containerd 在主机意外重启时，可能无法恢复损坏的镜像的问题，这个问题是比较有意思的，可能遇到这种情况的环境主要是 containerd 数据目录挂载至非根目录所在的盘中（多数环境中，系统盘的空间并不会很大，所以这种安装情况也算比较常见）。发生此问题的根本原因就在于重启后启动的时机不对（我倾向于这样表述，虽然实际的逻辑是 gc 删除了一些元数据，但它本身的行为是正常的）。所以修复的办法也比较简单， &lt;strong>如果你的 containerd 是使用 systemd 进行管理的，那么可以在 service 的配置文件的 After 块中增加 &lt;code>local-fs.target&lt;/code> 的配置&lt;/strong>&lt;/p>
&lt;p>&lt;code>local-fs.target&lt;/code> 是 systemd 中一个特殊的单元，和 &lt;code>dbus.service&lt;/code> 之类的很多单元类似，都属于特殊的那一类。具体来说它是用来集合本地文件系统挂载点的目标单元，听起来可能比较抽象。实际上就是 &lt;code>systemd-fstab-generator&lt;/code> 会在所有本地文件系统挂载单元中添加 &lt;code>Before=local-fs.target&lt;/code> 这一条，所以呢，当在 &lt;code>local-fs.target&lt;/code> 之后执行的，就表示现在机器上的所有本地文件系统均已经正确挂载。(这也是我认为这个问题有意思的地方）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上就是我认为在此版本中比较值得注意的点了，对此版本有兴趣的朋友可参阅 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-v1170-rc1-发布">Kubernetes v1.17.0-rc.1 发布&lt;/h2>
&lt;p>虽然本周在举行 KubeCon 但 Kubernetes 的发布进度也没受太多影响，本周顺利发布了 v1.17.0-rc.1 版本，这个版本相比于上次发布的 v1.17.0-beta.2 而言，值得关注的变化如下：&lt;/p>
&lt;ul>
&lt;li>修复了 kubeadm 中未对 &lt;code>KubeProxy.FeatureGates&lt;/code> 进行初始化可能导致的 panic ，稍微来看下修复后的代码:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// DefaultKubeProxyConfiguration assigns default values for the kube-proxy ComponentConfig
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">DefaultKubeProxyConfiguration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">internalcfg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">kubeadmapi&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClusterConfiguration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">kind&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">&amp;#34;KubeProxyConfiguration&amp;#34;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfigs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxy&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfigs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxy&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">kubeproxyconfigv1alpha1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxyConfiguration&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">FeatureGates&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">{},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfigs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FeatureGates&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfigs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FeatureGates&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">externalproxycfg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ComponentConfigs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">KubeProxy&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClusterCIDR&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSubnet&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClusterCIDR&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSubnet&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSubnet&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClusterCIDR&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSubnet&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">warnDefaultComponentConfigValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kind&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;clusterCIDR&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Networking&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PodSubnet&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClusterCIDR&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClientConnection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kubeconfig&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClientConnection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kubeconfig&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">kubeproxyKubeConfigFileName&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClientConnection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kubeconfig&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">kubeproxyKubeConfigFileName&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">warnDefaultComponentConfigValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kind&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;clientConnection.kubeconfig&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kubeproxyKubeConfigFileName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ClientConnection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Kubeconfig&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">enabled&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">present&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">internalcfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FeatureGates&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">IPv6DualStack&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="nx">present&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">externalproxycfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">FeatureGates&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">features&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">IPv6DualStack&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">enabled&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>导致 panic 的地方也就是最后那处判断，换言之，这个问题影响的是启用了 dual-stack feature 的用户。&lt;/p>
&lt;p>关于此版本有兴趣的朋友可以参考 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.17.0-rc.1">ReleaseNote&lt;/a>，不过按照发布计划，近期 v1.17 正式版也就要发布了。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>近期在举行 KubeCon 加上也在 v1.17 的发布周期中，上游最近没有太多变化，本次就暂且跳过好了。&lt;/p>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>介绍一个项目，stash 可以帮助你备份 Kubernetes 集群中的 Stateful 的应用。&lt;/p>
&lt;p>&lt;img src="https://appscode.com/products/stash/v0.9.0-rc.2/images/concepts/stash_architecture.svg" alt="stash - https://moelove.info">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3.0.0 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/11/17/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.0.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/11/17/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3.0.0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-11-17T22:15:01+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.0.0 正式发布 本周 Helm……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v300-正式发布">Helm v3.0.0 正式发布&lt;/h2>
&lt;p>本周 Helm v3.0.0 正式发布了。在 Helm v3 发布第一个 alpha 版时，我就写了一篇 &lt;a href="https://zhuanlan.zhihu.com/p/66058355">《初试 Helm 3》&lt;/a> 在那篇文章中，我介绍了一些 Helm 3 的变化及特性。 现在正式版发布了，我们来正式的看看这个版本带来了哪些值得期待的内容。（PS：我不会在本文中介绍其全部特性，只会聊聊我感兴趣的，对全部特性感兴趣的朋友可以参考其&lt;a href="https://helm.sh/docs/">官方文档 https://helm.sh/docs/&lt;/a> ）&lt;/p>
&lt;h3 id="移除-tiller">移除 Tiller&lt;/h3>
&lt;p>这个特性想必在任何介绍 Helm 3 的文章中都会有提到，当然在我之前的文章中也有提到。在 Helm 2 时，对于启动了 RBAC 的 Kubernetes 集群而言，在生产环境中想要安全的管理 Tiller 的权限是比较麻烦的。&lt;/p>
&lt;p>如果使用默认配置（简单来说也就是没啥特别的限制），那么上手很容易，但对于多租户的集群而言，就没那么安全了。&lt;/p>
&lt;p>在 Helm 2 时期，为了简单或者说为了安全，我们可以使用 Tillerless 的方式，来避免在集群中安装 Tiller， 同时还可以正常的使用 Helm 的功能。（很早前计划写篇文章介绍一下这个经验来着，结果至今也还没有腾出时间写，现在 Helm 3 发布，也就不用写了，这里大概聊一下）&lt;/p>
&lt;p>Tillerless 是什么含义呢？ 也就是在本地启动一个 Tiller 的服务，让它使用你本地的 KUBECONFIG 的配置文件与集群进行交互，而 Helm 在初始化时，只需要初始化 client 即可， 然后可通过 &lt;code>$HELM_HOST&lt;/code> 变量控制连接到本地所启动的 Tiller， 之后便可以正常使用了。(每次部署完成后，将 Tiller 关闭即可)&lt;/p>
&lt;p>Helm 3 中移除 Tiller 之后，那安全模型也就都符合 Kubernetes 自身的设计标准了，使用 KUBECONFIG 来控制即可。&lt;/p>
&lt;h3 id="release-名称可在不同-ns-间重用">Release 名称可在不同 ns 间重用&lt;/h3>
&lt;p>这个功能，在我之前写《初试 Helm 3》这篇文章时，该功能还不可用，不过后来就修复了。这个功能换句话说就是，Release 作用域可以是 namespace 级别的了。&lt;/p>
&lt;p>这个使得 Release 变的更易管理了，可以很方便的知道此 namespace 下到底有哪些 Release 。&lt;/p>
&lt;h3 id="推送镜像到-oci-registry">推送镜像到 OCI Registry&lt;/h3>
&lt;p>这个功能默认没有启用，我们可以通过设置 &lt;code>HELM_EXPERIMENTAL_OCI=1&lt;/code> 环境变量启用此特性。这个功能的好处就是可以最大限度的利用现有技术基础，同时又能够有效的减少资源的浪费。&lt;/p>
&lt;h3 id="开始支持使用基于-xdg-的目录">开始支持使用基于 XDG 的目录&lt;/h3>
&lt;p>前几天我还正解决了个 XDG 相关的问题来着，使用基于 XDG 的目录算是一种通用的规范。&lt;/p>
&lt;ul>
&lt;li>&lt;code>$HELM_PATH_CONFIG&lt;/code> ：配置目录&lt;/li>
&lt;li>&lt;code>$HELM_PATH_CACHE&lt;/code> ：缓存目录&lt;/li>
&lt;li>&lt;code>$HELM_PATH_DATA&lt;/code> ：数据目录&lt;/li>
&lt;/ul>
&lt;p>如果数据或者配置之类的出问题，可以尝试检查下是否目录设置有误。&lt;/p>
&lt;p>以上便是我对 Helm 3 中一些我认为值得关注的功能的介绍，对此版本感兴趣的朋友可参阅 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-ce-19035-发布">Docker CE 19.03.5 发布&lt;/h2>
&lt;p>经过两个 beta 和一个 rc 版的迭代， Docker CE 19.03.5 正式发布了。 此版本我最关注的特性是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>修正了对 OCI image 的支持&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>// 其实没多少人关注这个特性， 也从侧面反映还是用 Docker Image 的用户更多。&lt;/p>
&lt;h2 id="istio-140-正式发布">Istio 1.4.0 正式发布&lt;/h2>
&lt;p>这个版本集中于改进用户体验和性能上。我比较感兴趣的两个特性是：&lt;/p>
&lt;ul>
&lt;li>支持了流量镜像百分比的功能；&lt;/li>
&lt;li>实验性的支持了 DNS 证书的支持；&lt;/li>
&lt;/ul>
&lt;p>其实本次的更新内容还比较多，对其他特性感兴趣的朋友可以参考其 &lt;a href="https://istio.io/news/2019/announcing-1.4/change-notes/">ReleaseNote&lt;/a>&lt;/p>
&lt;h1 id="red-hat-宣布-quay-开源">Red Hat 宣布 Quay 开源&lt;/h1>
&lt;p>&lt;a href="https://github.com/quay/quay">Quay&lt;/a> 项目是一个开源的镜像存储仓库，包含多种登录认证能，及镜像扫描，构建等功能。&lt;/p>
&lt;p>就我个人使用经验而言，Quay 仅作为一个镜像仓库而言，是足够的。但操作体验上却比较一般。&lt;/p>
&lt;p>Quay.io 和 Docker Hub 相比，功能弱了很多，所以我个人对于公开镜像而言，更倾向于使用 Docker Hub。
对于私有镜像的话，我会使用自己的私有仓库。&lt;/p>
&lt;p>对 Quay 感兴趣的朋友，可以访问&lt;a href="https://github.com/quay/quay">项目主页&lt;/a>进行了解。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://events19.linuxfoundation.org/events/kubecon-cloudnativecon-north-america-2019">KubeCon North America 2019&lt;/a> 即将召开；&lt;/li>
&lt;li>上游进入代码冻结阶段，正好可以安心的参加 KubeCon；&lt;/li>
&lt;li>Kubernetes v1.17.0-beta.2 即将发布；&lt;/li>
&lt;li>Kubernets v1.14.9、v1.15.6、v1.16.3 相继发布，v1.13 EOL ;&lt;/li>
&lt;li>Kubeadm 中 kube-scheduler 和 kube-controller-manager 开始使用安全端口了，需要注意 &lt;a href="https://github.com/kubernetes/kubernetes/pull/85043">#85043&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>介绍一个项目，kubeview 可以可视化的查看 Kubernetes 集群内的状态。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/14982936/53411103-87b68a00-39bd-11e9-81b2-df2fb9cd7b28.png" alt="kubeview - https://moelove.info">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">2019 容器使用量报告</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/11/17/2019-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E9%87%8F%E6%8A%A5%E5%91%8A/"/><id>https://moelove.info/2019/11/17/2019-%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E9%87%8F%E6%8A%A5%E5%91%8A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-11-17T16:18:15+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近 sysdig 发布了 2019 容器使用报告，内容还比较有趣，特别来介绍一下。 关注公众号「Moelove」回复 docker2019 即可获取完整 PDF 报告。 关键信息 容器运……</summary><content type="html">&lt;p>最近 &lt;a href="https://sysdig.com/">sysdig&lt;/a> 发布了 &lt;a href="https://sysdig.com/resources/papers/2019-container-usage-report/">2019 容器使用报告&lt;/a>，内容还比较有趣，特别来介绍一下。 关注公众号「Moelove」回复 &lt;strong>docker2019&lt;/strong> 即可获取完整 PDF 报告。&lt;/p>
&lt;h2 id="关键信息">关键信息&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-key.png" alt="keyinfo - https://moelove.info">&lt;/p>
&lt;h2 id="容器运行时">容器运行时&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-runtime.png" alt="container-runtime - https://moelove.info">&lt;/p>
&lt;p>Docker 仍然是占据市场规模最大的容器运行时 （79%），而其他的，类似 rkt，lxc，podman 之类的市场占比微乎其微，甚至没有在报告中出现。&lt;/p>
&lt;p>containerd 源自 Docker，现在也占据了一席之地；而对于 cri-o 报告中指出，之后市场份额可能会增加。&lt;/p>
&lt;p>在我个人看来，近一年内 Docker 在企业生产环境的使用规模仍然会保持最大。&lt;/p>
&lt;h2 id="编排">编排&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-orchestrator.png" alt="container orchestrators - https://moelove.info">&lt;/p>
&lt;p>可以看到 Kubernetes 遥遥领先，加上构建在 Kubernetes 之上的 OpenShift 和 Rancher ，这个霸主地位是非常稳了。&lt;/p>
&lt;p>个人看来，近一年内，Kubernetes 的地位是不可能被撼动了，越来越多的企业也都会将技术栈迁移上去或者调研基于 Kubernetes 的云原生解决方案。&lt;/p>
&lt;h2 id="metrics">metrics&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-metrics.png" alt="custom metrics - https://moelove.info">&lt;/p>
&lt;p>Prometheus 已经成为事实标准，加上 Prometheus 作为 CNCF 毕业项目，以及围绕 CNCF 及云原生相关的各类基础软件等，都增加了各类 metrics，以及各类 exporter 越来越多，几乎可以涵盖生产中所需的各类 metrics 的需求了。&lt;/p>
&lt;h2 id="报警">报警&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-alert.png" alt="alerts - https://moelove.info">&lt;/p>
&lt;p>这个图也可以从侧面反映出，节点的稳定性是大多数用户所关注的焦点。(无论上层如何调度，底层的稳定性依然很重要)&lt;/p>
&lt;h2 id="pods-规模">Pods 规模&lt;/h2>
&lt;p>&lt;img src="https://moelove.info/img/2019-sisdig-report-pods.png" alt="Pods - https://moelove.info">&lt;/p>
&lt;p>多数集群属于中小规模的（也说明是个正在发展的阶段）&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>容器仍然在应用交付上发挥着重要的作用，从去年发布报告（在公众号后台回复 &lt;strong>docker2018&lt;/strong> 获取）以来，容器技术的采用率仍在加速，容器密度翻了一番，并且随着技术的成熟，也有了越来越多的成熟案例。&lt;/p>
&lt;p>Prometheus 已经成为了云原生应用指标的标准化方案，容器编排技术 Kubernetes 成为了事实的标准，企业应该在 Kubernetes 上进行投资，以跟上技术潮流的步伐。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】， 在公众号后台回复 &lt;strong>docker2019&lt;/strong> 可下载完整报告。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/></entry><entry><title type="text">K8S 生态周报| Vitess 正式从 CNCF 毕业</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/11/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Vitess-%E6%AD%A3%E5%BC%8F%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/"/><id>https://moelove.info/2019/11/10/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Vitess-%E6%AD%A3%E5%BC%8F%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-11-10T23:17:45+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Vitess 正式从 CNCF 毕业 CN……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="vitess-正式从-cncf-毕业">Vitess 正式从 CNCF 毕业&lt;/h2>
&lt;p>CNCF（云原生计算基金会）在美国时间 2019 年 11 月 5 日宣布 &lt;a href="https://vitess.io/">Vitess&lt;/a> 正式毕业了。&lt;/p>
&lt;p>这是 CNCF 中第 8 个正式毕业的项目，最近的几次周报中，基本都会谈到关于 CNCF 项目毕业相关的信息（忙碌的 Q4 啊）&lt;/p>
&lt;p>Vitess 最初由 YouTube 在 2010 年创建， 主要是用于 MySQL 横向扩展的数据库系统。据说 Vitess 一直为 YouTube 的所有数据库提供服务，国内貌似是京东使用比较多。&lt;/p>
&lt;p>补一张 Vitess 的架构图：&lt;/p>
&lt;p>&lt;img src="https://vitess.io/docs/overview/img/VitessOverview.png" alt="Vitess - https://moelove.info">&lt;/p>
&lt;p>最后，再次 &lt;a href="https://www.cncf.io/announcement/2019/11/05/cloud-native-computing-foundation-announces-vitess-graduation/">恭喜 Vitess 顺利毕业&lt;/a>!&lt;/p>
&lt;h2 id="helm-v2160-正式发布">Helm v2.16.0 正式发布&lt;/h2>
&lt;p>在之前的 &lt;a href="https://zhuanlan.zhihu.com/p/87696049">K8S 生态周报| Helm v2 最后一个特性版本发布&lt;/a>中，我介绍了 Helm 正式发布了 v2.15.0 作为 v2 版本的最后一个特性版本。&lt;/p>
&lt;p>而本次发布的 v2.16.0 也确实没有主要的特性更新，都是一些问题修复和安全更新等；（在这次版本中是 13 个独立 committers 之一 :) ）&lt;/p>
&lt;p>当然，本次版本中 &lt;strong>增加了对 Kubernetes v1.16 的支持&lt;/strong> 。&lt;/p>
&lt;p>对此版本感兴趣的朋友可参考 &lt;a href="https://github.com/helm/helm/releases/tag/v2.16.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="jaeger-v115-正式发布">Jaeger v1.15 正式发布&lt;/h2>
&lt;p>Jaeger 在从 CNCF 毕业后，正式发布了 v1.15 版本，本次版本中我认为值得注意的内容是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ingester.deadlockInterval&lt;/code> 的默认值从 1 分钟设置为了 0， 这是一个破坏性变更，如果由依赖此参数的默认行为，则需要注意；&lt;/li>
&lt;li>&lt;code>--collector.grpc.tls.client.ca&lt;/code> 参数由 &lt;code>collector.grpc.tls.client-ca&lt;/code> 代替；&lt;/li>
&lt;li>支持通过 TLS 连接 Kafka；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友可参考 &lt;a href="https://github.com/jaegertracing/jaeger/releases/tag/v1.15.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="talos-发布-v030-alpha6">Talos 发布 v0.3.0-alpha.6&lt;/h2>
&lt;p>在 7 月份的 K8S 周报中，我为你介绍过 Talos 项目，一款着重于 Kubernetes 的安全的现代化操作系统，所有系统管理都通过 API 完成。&lt;/p>
&lt;p>经过一段时间的发展，Talos 已经通过了 CNCF 的 Kubernetes 一致性认证。&lt;/p>
&lt;p>在本周 Talos 发布了 v0.3.0-alpha 版本，之后 Talos 会增加一些企业级关注的功能，比如审计，RBAC 还有日志等。同时，也考虑到了一个常规的需求 - 证书有效期。&lt;/p>
&lt;p>对此项目感兴趣的朋友，可以参考官网进行体验。https://www.talos.dev/&lt;/p>
&lt;h2 id="kubernetes-v1170-beta1-发布">Kubernetes v1.17.0-beta.1 发布&lt;/h2>
&lt;p>Kubernetes v1.17.0-beta.1 于本周发布，按照发布计划，很快我们也将会迎来正式版了。&lt;/p>
&lt;p>而在本周， Kubernetes 正常情况下将会统一发布一批 patch 版本，与此同时 v1.13 也将正式的 EOL。如果还有在使用 v1.13 版本的，推荐进行升级。&lt;/p>
&lt;p>另外，在 v1.17 中，&lt;code>NodeStatusReportFrequency&lt;/code> 将被减少至 5 分钟，也可以算作是一个不错的优化点了。&lt;/p>
&lt;p>&lt;code>TaintNodesByCondition&lt;/code> 和 &lt;code>ScheduleDaemonSetPods&lt;/code> 等特性已 GA，&lt;/p>
&lt;p>至于其他变更，每次周报的 “上游进展” 部分都有所提及，本次暂且跳过，等正式版出来再讨论。&lt;/p>
&lt;p>对此次版本变更的内容有兴趣的朋友，可参阅其 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.17.md#downloads-for-v1170-beta1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>Alpha 特性 &lt;code>MountContainers&lt;/code> 已删除 &lt;a href="https://github.com/kubernetes/kubernetes/pull/84365">#84365&lt;/a>&lt;/li>
&lt;li>kube-proxy 的 &lt;code>cleanup-ipvs&lt;/code> 参数已过期，可直接使用 &lt;code>--cleanup&lt;/code> 删除 ipvs 的规则 &lt;a href="https://github.com/kubernetes/kubernetes/pull/83832">#83832&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>双十一了，推荐一下自己的专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>，已有 1000+ 伙伴订阅！&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-course-all.jpg" alt="Docker 核心知识必知必会">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v2 爆出全版本漏洞</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/11/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E7%88%86%E5%87%BA%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/><id>https://moelove.info/2019/11/03/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E7%88%86%E5%87%BA%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-11-03T23:17:05+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Jaeger 顺利从 CNCF 毕业 CN……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="jaeger-顺利从-cncf-毕业">Jaeger 顺利从 CNCF 毕业&lt;/h2>
&lt;p>CNCF（云原生计算基金会）在美国时间 2019 年 10 月 31 日宣布 &lt;a href="https://www.jaegertracing.io/">Jaeger&lt;/a> 正式毕业了。&lt;/p>
&lt;p>这是 CNCF 中第 7 个正式毕业的项目，在&lt;a href="https://zhuanlan.zhihu.com/p/88777350">上次周报的最后&lt;/a> 我才刚提过一些项目提交了毕业申请，也同时以 Jaeger 为时一年的毕业申请申请举了个例子，没想到本周就毕业了。:)&lt;/p>
&lt;p>Jaeger 最初是由 Uber 受 Dapper 和 OpenZipkin 启发，开源出来的一套分布式追踪系统。它主要可用于微服务架构下的分布式系统的根因分析，性能/延迟优化，服务依赖等方面。截至目前，它在 GitHub 上有 9.4k 的 star ，986 个 fork 以及 115 位贡献者。&lt;/p>
&lt;p>它现在的存储后端主要就支持两种 Cassandra 3.4+ 和 Elasticsearch 5.x/6.x ，在这种系统中，随着服务规模的扩大，对后端存储的要求也会很高。另外，它有一套比较现代化的 UI，是基于 react 开发的。&lt;/p>
&lt;p>整体来看的话，在使用上基本技术栈就会成为下面这样：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/jaeger-apm.png" alt="Jaeger APM - https://moelove.info">&lt;/p>
&lt;p>当然实际的架构也可能会因为基础设施而改变，比如说如果已经使用了 SkyWalking 的话，两者倒是也可以结合，大概就会变成下面这样：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/jaeger-skywalking.png" alt="Jaeger with SkyWalking - https://moelove.info">&lt;/p>
&lt;p>不过，对于技术方案的选择，我个人建议是考虑实际需求，以及对各方案进行理性的权衡，否则的话，说不定什么时候就演变成了下面这样：（这个调用链虽然是可以走通的，但此处我是开个玩笑的， &lt;strong>请勿当真&lt;/strong>）&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/jaeger-with-all.png" alt="Jaeger with All - https://moelove.info">&lt;/p>
&lt;p>最后，再次&lt;a href="https://www.cncf.io/announcement/2019/10/31/cloud-native-computing-foundation-announces-jaeger-graduation/">恭喜 Jaeger 顺利毕业&lt;/a>！&lt;/p>
&lt;h2 id="helm-2-爆出全版本受影响的漏洞">Helm 2 爆出全版本受影响的漏洞&lt;/h2>
&lt;p>本周 Helm 官方披露出来一个全版本 (Helm 在 2.0.0 到 2.15.2 之间) 受影响的漏洞，是由 Cure53 公司发现的。不过这个问题是仅存在于客户端上的，Tiller 并无影响。&lt;/p>
&lt;p>漏洞的具体内容是 Chart 中可能会包含一些符号链接，但是没能正确处理。&lt;/p>
&lt;p>解决办法就是升级到 Helm 2.15.2 版本。&lt;/p>
&lt;p>详细内容请参考 &lt;a href="https://helm.sh/blog/2019-10-30-helm-symlink-security-notice/">Helm 官方公告&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>CSI 的 RBAC roles &lt;code>system:csi-external-provisioner&lt;/code> 和 &lt;code>system:csi-external-attacher&lt;/code> 已被废弃 &lt;a href="https://github.com/kubernetes/kubernetes/pull/84282">#84282&lt;/a>&lt;/li>
&lt;li>K8S 1.17 中会把 etcd client 更新至 v3.4.3 ，但需要注意的是在 1.16 中 etcd client 现在被更新到了 v3.3.17，用于解决 IPv6 地址解析错误的问题。 &lt;a href="https://github.com/kubernetes/kubernetes/pull/83968">#83968&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v3 最后一个beta版本发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/10/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAbeta%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/10/27/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v3-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAbeta%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-10-27T23:01:41+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm v3.0.0-beta.5 发布 这将是最后……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-v300-beta5-发布">Helm v3.0.0-beta.5 发布&lt;/h2>
&lt;p>这将是最后一个 beta 版本，下一个版本将会是 Helm v3.0.0-rc.1 。现在主要精力都集中在一些 bugfix 上，也会有一些设计方面的事情还需要最终确认。&lt;/p>
&lt;p>快速的看一下在此版本中新增的内容：&lt;/p>
&lt;ul>
&lt;li>为了能提供更多子命令，现在 &lt;code>helm get&lt;/code> 和 &lt;code>helm show&lt;/code> 分别移动到了 &lt;code>helm get all&lt;/code> 和 &lt;code>helm show all&lt;/code>， &lt;strong>这是一个破坏性变更&lt;/strong>;&lt;/li>
&lt;li>对 &lt;code>helm get values&lt;/code> 增加了一个 &lt;code>--output&lt;/code> 的选项，现在支持三种格式 &lt;code>table&lt;/code>, &lt;code>json&lt;/code>, &lt;code>yaml&lt;/code>；&lt;/li>
&lt;li>&lt;code>helm test&lt;/code> 新增了一个 &lt;code>--logs&lt;/code> 的参数，这是在 Helm 2 中新增的；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友可以参考 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-beta.5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-hub-新增双因素认证功能">Docker Hub 新增双因素认证功能&lt;/h2>
&lt;p>最近 Docker Hub 上线了 &lt;strong>双因素认证&lt;/strong> 的功能。这个事情主要有两个方面的考虑：&lt;/p>
&lt;ul>
&lt;li>DockerHub 希望能给用户更多的安全性，以及提供更完善的功能，以此来吸引个人用户/开源项目/组织/企业等使用；&lt;/li>
&lt;li>这个事情其实也算是 4 月份被攻击事件的后续，在上个月的周报中，我也介绍了 Docker Hub 上线了 Access Token 的功能。而这次上线 2FA 更是进一步提高了其安全性！&lt;/li>
&lt;/ul>
&lt;p>关于如何启用 2FA 可直接参考 Docker Hub 的文档 &lt;a href="https://docs.docker.com/docker-hub/2fa/">https://docs.docker.com/docker-hub/2fa/&lt;/a>&lt;/p>
&lt;h2 id="istio-140-beta0-发布">Istio 1.4.0-beta.0 发布&lt;/h2>
&lt;p>Istio 今年版本发布可以说是非常频繁了，其 &lt;a href="https://github.com/istio/istio/releases/tag/1.3.0">1.3.0 版本&lt;/a>是在今年 9 月份发布的。&lt;/p>
&lt;p>本周发布了 Istio 1.4.0-beta.0 版本，正式版本也就不会太远了。在这个版本中包含了一些 bugfix 当然也有些其他改动，比如说把 DNS 证书和其他证书分开之类的，还有一些遥测方面的改动。当然现在还有不少需要完善的地方，敬请期待正式版的到来吧。&lt;/p>
&lt;p>有意尝鲜的朋友，可直接访问&lt;a href="https://github.com/istio/istio/releases/tag/1.4.0-beta.0">此版本的 Release 地址&lt;/a>。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>kube-scheduler 的 &lt;code>ScheduleDaemonSetPods&lt;/code> 转向 GA，并在 1.18 中将从 feature gate 配置中移除。#82795&lt;/li>
&lt;/ul>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>最近一些 CNCF 托管的项目，包括 gRPC, Harbor (镜像仓库) 等都在准备申请从 CNCF 毕业了，不过现在尚未正式通过。整个过程周期可能会比较长，比如 Jaeger 的毕业申请，已经差不多快一年了吧。&lt;/p>
&lt;p>不过这也从侧面反映了这些项目发展的还不错，预祝顺利毕业。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Helm v2 最后一个特性版本发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/10/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E6%80%A7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/10/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Helm-v2-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E6%80%A7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-10-21T10:01:23+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 文末有活动，欢迎参……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。 文末有活动，欢迎参与。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-19034-正式发布">Docker 19.03.4 正式发布&lt;/h2>
&lt;p>在本周 Docker 发布了 19.03.4 版本，这个版本主要是为了修复上周周报中介绍的 &lt;code>DOCKER-USER&lt;/code> iptables 链丢失的问题。&lt;/p>
&lt;p>如果要升级 Docker 版本的话，可选择升级到此版本。&lt;/p>
&lt;h2 id="kubernetes-修复全版本影响漏洞">Kubernetes 修复全版本影响漏洞&lt;/h2>
&lt;p>上周周报中的 &lt;strong>上游进展&lt;/strong> 部分，介绍了对 CVE-2019-11253 的修复，限制 YAML/JSON 的解码大小为 3M 。本周相继发布了以下版本，包含了对此漏洞的修复。&lt;/p>
&lt;ul>
&lt;li>v1.13.12&lt;/li>
&lt;li>v1.14.8&lt;/li>
&lt;li>v1.15.5&lt;/li>
&lt;li>v1.16.2&lt;/li>
&lt;/ul>
&lt;p>实际受此漏洞影响的版本是：&lt;/p>
&lt;ul>
&lt;li>Kubernetes v1.0.0-1.12.x&lt;/li>
&lt;li>Kubernetes v1.13.0-1.13.11 (修复于 v1.13.12)&lt;/li>
&lt;li>Kubernetes v1.14.0-1.14.7 (修复于 v1.14.8)&lt;/li>
&lt;li>Kubernetes v1.15.0-1.15.4 (修复于 v1.15.5)&lt;/li>
&lt;li>Kubernetes v1.16.0-1.16.1 (修复于 v1.16.2)&lt;/li>
&lt;/ul>
&lt;p>建议对集群进行升级。 &lt;strong>但是升级前，请务必先阅读完 &lt;a href="https://github.com/kubernetes/kubernetes/issues/83253">https://github.com/kubernetes/kubernetes/issues/83253&lt;/a> 的内容&lt;/strong> 在清楚了解不同版本的行为后，再做升级。&lt;/p>
&lt;p>对此漏洞感兴趣的朋友，也可参阅&lt;a href="https://discuss.kubernetes.io/t/announce-cve-2019-11253-denial-of-service-vulnerability-from-malicious-yaml-or-json-payloads/8349">社区公告&lt;/a>&lt;/p>
&lt;h2 id="prometheus-pushgateway-v10-正式发布">Prometheus Pushgateway v1.0 正式发布&lt;/h2>
&lt;p>Prometheus Pushgateway v1.0 在本周正式发布了，作为 Prometheus 工具链中的一环，Pushgateway 能很方便的作为服务级别的 metrics cache 我在生产环境中也有使用它来收集一些 Cassandra 集群额外的指标。&lt;/p>
&lt;p>对于此版本，需要 &lt;strong>注意它不再支持 v0.5~v0.9 的存储格式；仅支持由 v0.10+ 创建的持久化文件，所以如果有这种需求的话，需要先升级到 v0.10 来转换文件格式。&lt;/strong>&lt;/p>
&lt;p>对此版本感兴趣的朋友可以参考 &lt;a href="https://github.com/prometheus/pushgateway/releases/tag/v1.0.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v2150-正式发布">Helm v2.15.0 正式发布&lt;/h2>
&lt;p>本周 Helm v2.15.0 正式发布，这是 &lt;strong>Helm v2 的最后一个特性版本&lt;/strong> ，之后 Helm v2 开始进入维护期，只接收 bugfix 和安全更新。&lt;/p>
&lt;p>此版本中包含了 71 个独立 committer 的 195 个 commit ，也是至今为止最大的一次 release 。(很荣幸我是其中之一，贡献了两个 commit 嘿嘿~)&lt;/p>
&lt;p>自 2016 年开始 Helm v2 至今已经走过了 3 年左右的时间，截至今天 Helm 仓库有 14.4k 的 star 和 4.7k 的 fork 以及 533 位贡献者。非常感谢社区的贡献，在此期间 Helm 也为我们带来了很多的便利。&lt;/p>
&lt;p>关于此版本的功能性介绍，本篇就先不谈了，有兴趣的朋友请参考 &lt;a href="https://github.com/helm/helm/releases/tag/v2.15.0">ReleaseNote&lt;/a>&lt;/p>
&lt;p>&lt;strong>Helm 3 预计会在本月底发布，现在还没有了解 Helm 3 的朋友，推荐看看 Helm 3 的文档，以便为之后升级做些准备。&lt;/strong>&lt;/p>
&lt;h2 id="个人推荐">个人推荐&lt;/h2>
&lt;p>现在 GitChat 在搞 1024 专属活动，我的专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a> &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f&lt;/a> 正在参加活动， &lt;strong>限时半价&lt;/strong>优惠！&lt;/p>
&lt;h2 id="活动结果">活动结果&lt;/h2>
&lt;p>在&lt;a href="https://zhuanlan.zhihu.com/p/86502209">上篇文章&lt;/a>文末有个免费增加兑换码的活动，我已经统计出来了结果，恭喜 &lt;strong>煎鱼&lt;/strong> 同学获得了此兑换码。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Docker 19.03.3 DNS 不再区分大小写</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/10/13/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-19.03.3-DNS-%E4%B8%8D%E5%86%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99/"/><id>https://moelove.info/2019/10/13/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Docker-19.03.3-DNS-%E4%B8%8D%E5%86%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-10-13T22:42:59+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 文末有活动，欢迎参……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。 文末有活动，欢迎参与。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-19033-正式发布">Docker 19.03.3 正式发布&lt;/h2>
&lt;p>在本周 Docker 发布了 19.03.3 版本，这个版本的变更内容 &lt;strong>很重要&lt;/strong>，我会将主要内容都列出来。(上周周报介绍了 19.03.3-rc1 的一些情况)&lt;/p>
&lt;h3 id="已知问题">已知问题&lt;/h3>
&lt;p>&lt;strong>&lt;code>DOCKER-USER&lt;/code> iptables 链丢失；如果你并不需要在 &lt;code>DOCKER-USER&lt;/code> 链上定义规则的话，那你也并不会受此问题的影响。&lt;/strong>&lt;/p>
&lt;p>临时解决办法：手动添加丢失的链，操作如下：&lt;/p>
&lt;pre>&lt;code>iptables -N DOCKER-USER
iptables -I FORWARD -j DOCKER-USER
iptables -A DOCKER-USER -j RETURN
&lt;/code>&lt;/pre>&lt;p>&lt;strong>这个问题会在 19.03.4 中进行修复, 很快会进行发布；&lt;/strong> 实际会把 libnetwork 中有问题的那段代码先去掉。 如果已经升级了此版本的用户，受到此问题影响的话，可以使用上述方式进行临时解决。&lt;/p>
&lt;h3 id="安全问题">安全问题&lt;/h3>
&lt;ul>
&lt;li>将 runc 更新到了 v1.0.0-rc8-92-g84373aaa 这其中包含了 runc 中对 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-18367">CVE-2017-18367&lt;/a> 的修复，该漏洞的根本原因在于 &lt;code>libseccomp-golang&lt;/code> 中&lt;a href="https://github.com/seccomp/libseccomp-golang/commit/06e7a29f36a34b8cf419aeb87b979ee508e58f9e">一个错误的逻辑运算&lt;/a> ，有兴趣的朋友可以点开链接看看实际的修复代码，并且也可以发现该代码其实在 2017 年 4 月就已经合并进 libseccomp-golang 的主干中了，但实际上在今年 6 月在 runc 中才真正修复。&lt;/li>
&lt;/ul>
&lt;p>这个问题其实反映出来的是当我们在维护项目时，对自己所用的各种依赖需要有所了解和把握，整体来讲，尽可能避免依赖项过旧是个好事儿；并且安全问题非常值得关注。&lt;/p>
&lt;h3 id="常规更新">常规更新&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>修改了仍使用 &lt;code>schema1&lt;/code> 进行镜像 push/pull 操作时的通知逻辑，早在今年 6 月份我推送的周报中就已经提到过建议升级至 &lt;code>schema2&lt;/code> 来获得长久的支持，以及更好的兼容性。具体的升级版本之一就是使用最新版的 Docker， 将镜像 pull 后再重新 push 即可（适用于大多数情况）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据 &lt;a href="https://tools.ietf.org/html/rfc4343">&lt;code>RFC4343&lt;/code>&lt;/a> Docker 修改了内部 DNS 的逻辑，使其符合了 RFC4343 的规范， &lt;strong>DNS 开始不再区分大小写了&lt;/strong> 。如果在实际使用中有依赖大小写解析的情况，请及时修改逻辑。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友可以参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v300-beta4-发布">Helm v3.0.0-beta.4 发布&lt;/h2>
&lt;p>Helm 3 已经进入发布了 beta4 的版本，现在计划下个版本是 beta5，仍然将继续修复 bug 和提升稳定性。&lt;/p>
&lt;p>这里也有一个安全问题： 修复了 &lt;a href="https://helm.sh/blog/helm-security-notice-2019/">CVE-2019-1000008&lt;/a> 这个问题一开始是为 Helm 2 而报告的，但实际上在 Helm 3 中也存在，所以此次 beta4 中包含了修复代码, 建议升级。&lt;/p>
&lt;p>这次的 break change 就 4 个，对于处于 beta 期的 Helm 3 也还可以理解。&lt;/p>
&lt;p>以下是一些值得注意的点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>--recreate-pods&lt;/code> 参数被废弃；&lt;/li>
&lt;li>&lt;code>app version&lt;/code> 字段被添加到了 &lt;code>helm list&lt;/code> 和 &lt;code>helm history&lt;/code> 中；&lt;/li>
&lt;/ul>
&lt;p>对此版本感兴趣的朋友可以参考 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-beta.4">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>K8S 文档工作组将会对 K8S 文档中引用的第三方内容进行清理和组织，以避免文档中出现过多的 “使用 xx 工具部署 Kubernetes” 之类的内容。（比如“使用 Kind 来部署 Kubernetes 本地集群” 就是允许存在的内容）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同样的为了修复安全漏洞 CVE-2019-11253 ，现在限制 YAML/JSON 的解码大小为 3M ， &lt;a href="https://github.com/kubernetes/kubernetes/pull/83261">#83261&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="活动">活动&lt;/h2>
&lt;p>本周我在 GitChat 上的新专栏 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">Docker 核心知识必知必会&lt;/a> &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f&lt;/a> 正式上线了！ （我也来宣传一波~ 感谢大家支持~&lt;/p>
&lt;p>这个专栏涵盖了 Docker 的核心知识，但是又不仅仅是 Docker；我认为想要真正掌握 Docker 容器知识，必须通过系统性的学习，很多东西其实依赖于内核实现的功能，如果不能很好的理解这些基础功能，那以后在生产环境中使用 Docker 容器技术就会比较吃力了。&lt;/p>
&lt;p>现在多数公司正在往容器化和 Kubernetes 的环境上迁移，如果能很好的掌握 Docker 容器技术，那无论是在做容器化，还是在使用或者定位 k8s 的问题时，都会游刃有余。&lt;/p>
&lt;p>现在我将这个专栏推荐给你，万丈高楼平地起，希望能有所帮助。（扫描下方二维码或者使用链接 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f&lt;/a> 皆可访问）&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-course.jpg" alt="Docker 核心知识必知必会">&lt;/p>
&lt;p>&lt;strong>另外，为了感谢大家的关注和支持，即日起至 10 月 19 日晚 21 点整，在本文下方留言，得到点赞最多的朋友，我会送出一个免费的兑换码，用于兑换此专栏。欢迎参与。&lt;/strong>&lt;/p>
&lt;p>（我会在下周周报时，公布结果。所有渠道共同参与此活动。）&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Docker 核心知识必知必会</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/10/08/Docker-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/><id>https://moelove.info/2019/10/08/Docker-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-10-08T23:58:14+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">自 2013 年起，随着 Docker 的正式面世，容器技术迅速成为了基础技术领域中的热门。而在近两三年中，随着容器编排领域的混战结束，Kubernet……</summary><content type="html">&lt;p>自 2013 年起，随着 Docker 的正式面世，容器技术迅速成为了基础技术领域中的热门。而在近两三年中，随着容器编排领域的混战结束，Kubernetes 已经成为了容器编排领域事实上的标准。&lt;/p>
&lt;p>有一些人存在误解，认为 Kubernetes 的出现取代了 Docker。但事实上，Docker 与 Kubernetes 是相辅相成的。Kubernetes 使用 Docker 作为容器运行时，用来启动应用；当 Docker 容器规模变大时，自然是需要有容器编排工具进行管理的。引用最近一次的网络研讨会后的文章内容：&lt;/p>
&lt;blockquote>
&lt;p>In fact, Kubernetes is better with Docker. And Docker is better with Kubernetes.&lt;/p>
&lt;/blockquote>
&lt;p>无论在使用 Docker 或是 Kubernetes 亦或者是使用基于这些技术的其他衍生技术时，都有可能会遇到一些意料之外的情况，当问题发生时，我们总是希望可以快速定位问题，并且从根本上解决问题。&lt;/p>
&lt;p>一般情况下，上层的问题比较容易解决，但如果问题发生在运行时/Docker 或容器上时，如果没有系统性的知识，很难从根本上解决问题；当然，有些时候通过搜索引擎可以帮我们找到一些问题的解决办法，但如果不将其彻底搞懂，以后遇到类似问题可能还是没法快速解决。&lt;/p>
&lt;p>我自 Docker 0.9 版本时开始学习和使用，自己踩过了很多坑，活跃在社区中，也帮别人解决了很多问题。现在我的新专栏&lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">《Docker 核心知识必知必会》&lt;/a>正式上线了，共 51 节，从 7 个核心维度来 &lt;strong>系统性&lt;/strong> 的讲解 Docker 容器技术的核心特性及原理，实践与源码相结合；部分内容会深入到 Linux 内核源码，以此来建立起从内核到 Docker 容器技术的知识体系。&lt;/p>
&lt;p>我希望借由这个课程，&lt;strong>将 Docker 容器技术的本质和思想与我在开发和运维 Docker 过程中对其原理和实践经验的总结讲清楚，并将结合着实践和核心特性的原理，加深对 Docker 容器技术的理解&lt;/strong>。&lt;/p>
&lt;p>因此，我把课程划分成了三大模块：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Docker 入门&lt;/strong>: 这个模块分成了三篇内容，通过第一篇，带你了解 Docker 容器技术生态的发展脉络；第二篇，是为刚入门 Docker 的读者准备的，也是为后续章节进行铺垫；第三篇是很多读者或公司都常会困惑的问题，Docker 与 Linux 内核兼容性如何，要上生产环境该选择哪个版本？我会在这一篇中与你分享，让你不再困惑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Docker 核心特性&lt;/strong>：这个大模块围绕 Docker 的核心知识点，拆分成了 7 大部分，分别是容器、镜像、CI/CD、架构、存储、安全和网络。这些是该课程的核心内容，在这部分内容中，我将基本按照从实践到原理的方式进行组织，让你从根儿上知道如何用，以及为什么这么用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在容器篇，我会先给你介绍容器生命周期管理相关的内容，那你对容器的使用有个基本认识；之后会对容器资源进行管理；并对容器的核心进行深入剖析；最后动手来自己写容器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在镜像篇，我会给你介绍镜像完整的生命周期管理；镜像是如何构建与分发的；如何使用 Dockerfile 进行镜像构建；并介绍 Docker 的下一代构建系统是如何提速近 10 倍的；接下来结合我的实际镜像为你介绍 Dockerfile 的优化和最佳实践；最后分别深入源码为你介绍镜像构建、分发的原理，以及认证流程和原理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 CI/CD 篇，我会为你介绍如何将 Docker 与 CI/CD 结合，并为你介绍适用于生产环境使用的 CI/CD pipeline,希望能为你建设 CI/CD 提供一些启发。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>架构篇中我会结合源码给你介绍 Docker 的核心架构，以及其是如何协作的；Docker 提供了一种可扩展的 Plugin 机制，在特定场景下使用 Plugin 扩展 Docker 也是一种不错的选择；接下来会结合实际经验为你介绍容器监控和日志方面的具体实践方案，希望能为你在实际使用中提供一个参考；最后会 &lt;strong>与你分享我所总结的 Docker 相关问题的定位及调试手段&lt;/strong> 正确的方法能让你排查问题的效率翻倍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存储篇主要介绍 Docker 中 volume 的使用；以及如何进行数据备份和恢复；最后会深入内部为你介绍现在 Docker 最推荐的 Overlay2 存储驱动的工作原理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安全篇会涉及镜像和容器运行时的安全；以及会涉及一些的 Linux 内核安全相关的知识，为你详细介绍如何利用 Linux 内核的安全模块为 Docker 保驾护航。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络篇除了介绍基础网络知识外，还会为你介绍如何定制 bridge 网络；iptables 始终是一个很核心的知识点，我会为你将 Docker 与 iptables 梳理清楚，以及如何自定义的进行网络管理；最后会为你详细介绍 docker-proxy ，Docker 内部 DNS 以及 Docker 的核心网络知识，让网络不再成为一个拦路虎。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>生态扩展&lt;/strong>：不得不说“开源”是 Docker 成长迅速的关键，在这个模块中，我将为你介绍 Docker 与 Kubernetes 间的联系，以及容器生态中的其他组件；与你分享如何参与到 Docker 容器生态内，当然这里也会涉及到 Docker 现在的代码组织相关的内容；最后将与你探讨 Docker 生态未来的走向。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>专栏新上线，限时优惠！可直接访问链接 &lt;a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f">https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f&lt;/a> 参与学习，或扫描下方图片二维码参与：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-course.jpg" alt="Docker 核心知识必知必会">&lt;/p>
&lt;p>PS：可以生成自己的分享海报，得 24.75&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| runc v1.0.0-rc9 发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/10/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc9-%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/10/06/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-runc-v1.0.0-rc9-%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-10-06T23:07:49+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 runc v1.0.0-rc9 发布 不知不觉，……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="runc-v100-rc9-发布">runc v1.0.0-rc9 发布&lt;/h2>
&lt;p>不知不觉，runc v1.0.0-rc9 于近日发布了。早先关注过我文章的朋友们应该看到过我从去年开始每次在 runc 新版本发布时都有专门写一篇文章进行介绍。这次版本的定位主要是修复 CVE-2019-16884 所以我也就不再单独写文章介绍了（另一个原因是现在在假期，还是多抽空陪陪家人）&lt;/p>
&lt;p>先对 &lt;a href="https://access.redhat.com/security/cve/cve-2019-16884">CVE-2019-16884&lt;/a> 做个简单的介绍。这是一个中等级别的漏洞，其主要影响是 runc 源码中的 &lt;code>libcontainer/rootfs_linux.go&lt;/code> 在文件挂载至 &lt;code>/proc&lt;/code> 时，少做了一些检查，可绕过 AppArmor 的限制，所以可能导致被一些恶意镜像所利用。&lt;/p>
&lt;p>主要的修复方式是将原先的 &lt;code>checkMountDestination&lt;/code> 函数改写为 &lt;code>checkProcMount&lt;/code>，并在其中添加了对源文件类型的判断，只允许 procfs 类型的文件挂载至 &lt;code>/proc&lt;/code> 。&lt;/p>
&lt;p>此漏洞影响到的范围是 runc 以及一些使用 runc 作为基础组件的容器管理软件。请尽快进行升级。&lt;/p>
&lt;p>此版本的地址是：https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc9&lt;/p>
&lt;h2 id="docker-v19033-rc1-发布">Docker v19.03.3-rc1 发布&lt;/h2>
&lt;p>自从 Docker 修改维护周期后，Docker 对软件的质量要求有了显著提高，每次版本发布前会经历多阶段的测试和回归，确保软件没有什么问题后才会发布正式版。&lt;/p>
&lt;p>按现在的进度来看 v19.03.3 应该会在一两周内放出。新版本会将 containerd 升级至最新的 1.2.10 ，并修复了一个在 5.2 版本内核上 overlay2 文件系统挂载时的错误。&lt;/p>
&lt;p>关于此版本感兴趣的朋友可以参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.3-rc1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>Kubernetes v1.17 已经进入发布周期，这个版本的发布周期会比较短，现在已经发布了 v1.17.0-alpha 版本，计划是在 12 月 9 日可以最终发布。(想想看，距现在也就两个月的时间，你的集群现在是哪个版本呢？)&lt;/p>
&lt;p>另外，在近期将会发布 v1.13.12 版本，这将是 v1.13 分支的最后一个版本，如果还是使用此版本的朋友，请尽快进行升级了。（当然，与它同时发布的也还有 1.16.2，1.15.5 和 1.14.8 如果要升级可以等这几个版本发布后再进行升级，免得还得重复升级）&lt;/p>
&lt;p>k8s.io/klog 升级到了 v1.0 &lt;a href="https://github.com/kubernetes/kubernetes/pull/83014">#83014&lt;/a>&lt;/p>
&lt;p>另外一个有趣的事情是 Kubernetes v1.17 现在把 golang 版本更新到了 1.12.10 ，不出意外的话， v1.17 将会一直使用 go 1.12.x 版本，直到下个版本才可能会升级至 go 1.13.x (这里最主要的原因是在 go 1.13.0 发布后，经过大量回归测试后发现， Kubernetes 在 go 1.13.0 上的表现不如 go 1.12.x 而依据 golang 的维护周期，以及 kubernetes 的维护周期来看的话，使用 go 1.12.x 看起来没什么风险，所以可能就会一直保持这个决定吧。&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>假期马上就要结束了，大家休息的怎么样呢？&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| containerd v1.3 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/09/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/09/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-containerd-v1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-09-29T21:44:09+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd v1.3.0 正式发布 在上个……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="containerd-v130-正式发布">containerd v1.3.0 正式发布&lt;/h2>
&lt;p>在上个主版本（v1.2.0）后经过 11 个月，我们终于迎来了 containerd v1.3.0 的发布，当然这个版本也是 containerd 自 CNCF 毕业后的首个主版本。（关于 containerd 毕业的信息可参考我&lt;a href="https://zhuanlan.zhihu.com/p/58003521">之前的文章&lt;/a>）&lt;/p>
&lt;p>在三周前 containerd v1.3.0-rc.0 发布时，我也提到过一些，现在我们来整体看一下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>增加了 Windows v2 的 runtime API， 同时移除了 Windows v1 API；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为修复 CVE-2019-16884 更新了 runc 依赖；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可配置的插件目录；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许插件注册为一个 TCP Server ，通过这种机制其实可以做到很多的事情了；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加了流式处理的插件，允许在解包的时候处理自定义资源类型（设计上考虑可使用此功能进行加解密相关的逻辑）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持跨仓库推送镜像；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新增了 devicemapper 的快照支持，然而需要注意的是 Docker 已经将 devicemapper 的存储驱动标记为了过期，推荐大家使用 Overlay2 的存储驱动；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 CRI 方面 &lt;code>io.containerd.runtime.v1.linux&lt;/code> 仍然是默认的运行时，可选配置为新的 &lt;code>io.containerd.runc.v2&lt;/code>，新的版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>经过了一些测试，但生产环境使用的话，我个人建议还需大量测试，谨慎一些；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外就是有些配置已经过期了，比如 &lt;code>plugins.cri.registry.auths&lt;/code> 需要修改为 &lt;code>plugins.cri.registry.configs&lt;/code> 进行配置；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加了 &lt;code>pod_annotations&lt;/code> 的运行时选项，这将会传递给运行时，可以通过这个特性来做一些基于 annotation 的实验性功能；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPv4/IPv6 双栈支持；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从整体上来看，一方面是为了扩展其功能，包括对 Windows runtime 的支持和 Plugin 相关的支持；另一方面还是在尽量保持 API 的兼容性，以及适配 CRI 等。&lt;/p>
&lt;p>如果生产环境想要升级的话，建议尽量多测试下；此外 Docker 也正在积极的发布新版本，不久之后也可一同进行升级。。&lt;/p>
&lt;p>更多内容请参阅 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-v19033-beta2-发布">Docker v19.03.3-beta2 发布&lt;/h2>
&lt;p>此版本中，更新了 containerd 相关的依赖，以及修复了两个后端 API 如果传递错误的 platform 参数时，可能引起的 500 错误。&lt;/p>
&lt;p>不出意外的话，下周会发布正式版，对此版本感兴趣的朋友可参阅 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.3-beta2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-131-发布包含众多更新">Istio 1.3.1 发布包含众多更新&lt;/h2>
&lt;p>常规的 bugfix 版本，这个版本中包含的主要都是一些错误修复。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>修复了一个自 Istio 1.2.4 以来，可能出现的 Envoy 崩溃的问题。 &lt;a href="https://github.com/istio/istio/issues/16357">#16357&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加了 &lt;code>istioctl experimental analyze&lt;/code> 用于多资源的分析和验证&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上是我认为值得关注的修复和小的新特性，对此版本感兴趣的朋友可以参阅 &lt;a href="https://istio.io/news/2019/announcing-1.3.1/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>明天就是国庆假期了，希望大家玩的开心。&lt;/p>
&lt;p>之后便是下一季度了，整个社区以及周边生态的各类组件的开发团队也都在梳理遗留的问题，以及加速进行开发和发版了，预计下一季度还是会有很多值得期待的消息的。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Kubernetes v1.16 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/09/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.16-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/09/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Kubernetes-v1.16-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-09-22T23:45:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.16 正式发布 正如我……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v116-正式发布">Kubernetes v1.16 正式发布&lt;/h2>
&lt;p>正如我在上次周报中所说，本周 Kubernetes v1.16 正式发布了。此版本中共包含 31 项功能增强：其中 8 项处于 stable 阶段，8 项处于 beta 阶段，剩下的 15 项处于 alpha 阶段。&lt;/p>
&lt;p>如果一直关注本周报系列文章的话，这个版本中比较重要的功能我基本都已经提到过了（这里划个重点）。&lt;/p>
&lt;ul>
&lt;li>CRD 达到 GA ，这是当前社区最为推崇的一种扩展 Kubernetes 的方式，并且自从 1.7 加入后，也被越来越广泛的使用了；&lt;/li>
&lt;li>准入控制 webhooks 达到 GA ，准入控制在 Kubernetes 中太过于重要了，自 1.9 该功能加入以来，被广泛用于扩展 Kubernetes 相关功能；&lt;/li>
&lt;li>现在 CSI 规范中支持调整卷大小，当前正在迁移至 Beta 阶段；&lt;/li>
&lt;li>IPv4/IPv6 双栈支持；&lt;/li>
&lt;li>为了更好的控制 kube-apiserver 的网络流量，正在尝试给它增加一个&lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/20190226-network-proxy.md">代理&lt;/a>，详情可点击链接查看；&lt;/li>
&lt;/ul>
&lt;p>其余还有一些比较重要的内容：&lt;/p>
&lt;ul>
&lt;li>现在 kubeadm 在 TLS bootstrap 之后，将会删除 &lt;code>bootstrap-kubelet.conf&lt;/code>，如果有依赖此文件的小伙伴，请尽快迁移使用 &lt;code>kubelet.conf&lt;/code> ，此外也建议先看看 RBAC 相关的内容，了解下切换的意义；&lt;/li>
&lt;li>&lt;code>beta.kubernetes.io/metadata-proxy-ready&lt;/code> 和 &lt;code>beta.kubernetes.io/kube-proxy-ds-ready&lt;/code> 都被移除了；&lt;/li>
&lt;li>还有之前提到过的 &lt;code>pps/v1beta1&lt;/code> 和 &lt;code>apps/v1beta2&lt;/code> 已经被 &lt;code>apps/v1&lt;/code> 取代等，这里不再一一列举了，有兴趣可参考之前的周报内容。&lt;/li>
&lt;/ul>
&lt;p>整体来说 Kubernetes 1.16 是个很不错的版本，当然上面的内容也并不是其更新功能的全部，建议阅读 &lt;a href="https://relnotes.k8s.io">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-上线-releasenote-专用网站">Kubernetes 上线 ReleaseNote 专用网站&lt;/h2>
&lt;p>Kubernetes 上线了专用的 ReleaseNote 的网站 &lt;a href="https://relnotes.k8s.io">https://relnotes.k8s.io&lt;/a> 直接利用标签划分了相关领域的功能，可以更加清晰的让大家了解到自己想知道的功能变更相关的内容。&lt;/p>
&lt;h2 id="dockerhub-新功能personal-access-tokens">DockerHub 新功能：Personal Access Tokens&lt;/h2>
&lt;p>在上个季度，我曾在 k8s 生态周报中有提到过关于 DockerHub 被攻击事件。经过这段时间的努力，现在 DockerHub 上线了新功能，允许用户创建自己的 Access Token 。&lt;/p>
&lt;p>通过这一方式，用户可以更加灵活的控制认证逻辑。当与其他工具进行集成的时候，也可避免暴露自己的密码信息等。&lt;/p>
&lt;p>当然今后这一功能还可以用于发展多因素身份验证或者做基于团队的访问控制。 另外我尝试过了多次，Token 的更新还是很及时的。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/dockerhub-token.png" alt="DockerHub Access Token - moelove.info">&lt;/p>
&lt;h3 id="题外话">题外话&lt;/h3>
&lt;p>本周我主要忙着举办婚礼，这篇内容篇幅较短，就只包含了我本周所关注到的信息。
感谢我的小可爱，感谢亲朋好友们的支持，感谢所有关注的读者朋友们的支持，谢谢你们。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Istio 1.3 正式发布</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/09/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/><id>https://moelove.info/2019/09/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Istio-1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-09-15T23:45:23+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Istio 1.3.0 正式发布 上周 k8s……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="istio-130-正式发布">Istio 1.3.0 正式发布&lt;/h2>
&lt;p>上周 k8s 生态周报中，我推送了关于 Istio 1.3.0-rc2 发布的消息后，有小伙伴专门私聊我，说想问问 Istio 1.3 到底有什么新特性；以及为何上次没有对 Istio 1.3 的新特性进行介绍。&lt;/p>
&lt;p>这里我来做下说明，首先关于为何上次没有对 Istio 1.3 新特性进行介绍。有两个主要原因：1. 上周时，正式版尚未发布；2. 对 1.3 这个版本而言没有太多新特性，此版本主要在于改善用户体验。&lt;/p>
&lt;p>对 Istio 而言，今年是个很重要的节点，而且自从 3 月份发布 1.1 版本以来， Istio 的更新频率基本稳定在了 3 个月发布一个版本。1.1 版本专注于企业就绪，在此版本中一方面是提升系统的稳定性，另一方面则是解决企业落地时，可能遇到的一些问题，所以 1.1 中有大量的新特性。而 1.2 版本其实也类似，虽然花费了很多精力在保证质量上，但其中也有不少功能从 Beta 到了 Stable 阶段。&lt;/p>
&lt;p>其次是关于 1.3 版本到底有哪些新特性：&lt;/p>
&lt;ul>
&lt;li>出站流量自动确定协议：之前版本中，Istio 要求 Service 需要按照指定的规则进行命名才可以自动确认其协议，而在此版本中则可以自动确认其是 HTTP 或 HTTP/2 流量，如果无法自动确认，则认为其是纯 TCP 流量，如果是通过 Helm 安装的话，可以使用 &lt;code>--set pilot.enableProtocolSniffing=false&lt;/code> 关闭此功能；&lt;/li>
&lt;li>Pod spec 中不再需要定义 &lt;code>containerPort&lt;/code>，默认情况下会捕获所有端口，当然你也可以通过 &lt;code>traffic.sidecar.istio.io/includeInboundPorts&lt;/code> 覆盖此行为或者通过 &lt;code>traffic.sidecar.istio.io/excludeOutboundPorts&lt;/code> 绕过要捕获的端口；&lt;/li>
&lt;li>当使用 Redis proxy 时，现在默认的负载均衡器是 Envoy 的 &lt;a href="https://www.envoyproxy.io/docs/envoy/v1.6.0/intro/arch_overview/load_balancing#maglev">MAGLEV&lt;/a>；&lt;/li>
&lt;li>改善了 &lt;code>EnvoyFilter&lt;/code> API 现在你可以添加或更新所有配置；&lt;/li>
&lt;li>实验性的使用 Prometheus 为代理内生成服务指标的支持；&lt;/li>
&lt;li>废弃了 Mixer adapters 两个版本后移除；&lt;/li>
&lt;li>istioctl 命令有了一些变化： &lt;code>istioctl experimental dashboard&lt;/code> 晋升为了 &lt;code>istioctl dashboard&lt;/code> ，&lt;code>istioctl experimental convert-ingress&lt;/code> 晋升为了 &lt;code>istioctl convert-ingress&lt;/code>，以及增加了一些便于调试使用的 &lt;code>metrics&lt;/code> 或者 &lt;code>describe pod&lt;/code> 之类的实验性命令；&lt;/li>
&lt;/ul>
&lt;p>以上便是我个人看来 1.3 中值得关注的内容，但其实很明显，这个版本的主题确实还都在改善用户体验上，如果对此版本有兴趣的小伙伴，可自行参看 &lt;a href="https://istio.io/about/notes/1.3/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="从-helm-v2-迁移至-helm-v3">从 Helm v2 迁移至 Helm v3&lt;/h2>
&lt;p>&lt;a href="https://helm.sh/blog/migrate-from-helm-v2-to-helm-v3/">这是来自 Helm 官方博客的一篇文章&lt;/a> 先来一张图：&lt;/p>
&lt;p>&lt;img src="https://helm.sh/blog/images/helm-2to3.png" alt="helm-2to3-moelove.info">&lt;/p>
&lt;p>其实这篇文章主旨就是介绍一个 Helm 的插件 &lt;a href="https://github.com/helm/helm-2to3">helm-2to3&lt;/a> 这也是“官方工具”，推荐需要从 Helm v2 迁移至 v3 的小伙伴使用。&lt;/p>
&lt;p>另外，看 Helm v3 现在的状态，虽然正式版仍未发布，但也应该不会太久了。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>Kubernetes v1.16.0 正式版即将发布，不出意外的话，应该也就是最后一周了。当然，需要注意的是，当 Kubernetes 发布新版本后，意味着旧版本将有一个 EOL 请及时升级。&lt;/p>
&lt;p>因为现在是 Code Freeze 阶段，所以上游的开发进展没有很多。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/kubernetes/pull/82199">#82199&lt;/a> 将 etcd server 从 3.3.10 更新到了 3.3.15 ，实际上这个变更可能是个遗漏 hah&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| Harbor v1.9 带来众多新特性</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/09/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Harbor-v1.9-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/"/><id>https://moelove.info/2019/09/08/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-Harbor-v1.9-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%96%B0%E7%89%B9%E6%80%A7/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-09-08T22:43:44+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker CE 19.03.2 发布 Docker CE 19.03.2 已……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-ce-19032-发布">Docker CE 19.03.2 发布&lt;/h2>
&lt;p>Docker CE 19.03.2 已于近日发布，事实上此版本内更新的内容本该在 19.03.1 中发布的，不过 19.03.1 主要是为了修正 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271&lt;/a> 如果你正在使用 19.03.0 那我建议你进行升级。&lt;/p>
&lt;p>为了保证尽可能快的修复问题，所以专程发布了 19.03.1 版本，而把原先预期的功能转移至 19.03.2 中进行发布。这其实也是 Docker 做的比较好的一个事情，Docker 的版本发布很有原则。&lt;/p>
&lt;p>我们来看看 19.03.2 中带来了哪些变化：&lt;/p>
&lt;ul>
&lt;li>修正了Docker CLI 对 HTTP Proxy 环境变量的支持；&lt;/li>
&lt;li>修正了一个为容器使用 XFS 磁盘配额可能产生的 panic；&lt;/li>
&lt;/ul>
&lt;p>其他变化，感兴趣的朋友可以参看其 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="containerd-130-rc0-发布">containerd 1.3.0-rc.0 发布&lt;/h2>
&lt;p>1.3 将会是 containerd 的下一个主版本；而自 containerd 1.2 发布以来已经过去了近 9 个月。我们来大致看看 1.3 中有哪些值得期待的功能。&lt;/p>
&lt;ul>
&lt;li>增加了 Windows v2 的 runtime API， 同时移除了 Windows v1 API；&lt;/li>
&lt;li>新增了 devicemapper 的快照支持，然而需要注意的是 Docker 已经将 devicemapper 的存储驱动标记为了过期，推荐大家使用 Overlay2 的存储驱动；&lt;/li>
&lt;li>允许插件注册为一个 TCP Server ，通过这种机制其实可以做到很多的事情了；&lt;/li>
&lt;li>可配置的插件目录；&lt;/li>
&lt;li>在 CRI 方面 &lt;code>io.containerd.runtime.v1.linux&lt;/code> 仍然是默认的运行时，可选配置为新的 &lt;code>io.containerd.runc.v2&lt;/code>，新的版本经过了一些测试，但生产环境使用的话，我个人建议还需大量测试，谨慎一些；&lt;/li>
&lt;li>另外就是有些配置已经过期了，比如 &lt;code>plugins.cri.registry.auths&lt;/code> 需要修改为 &lt;code>plugins.cri.registry.configs&lt;/code> 进行配置；&lt;/li>
&lt;/ul>
&lt;p>以上是我个人觉得需要关注的点，当然作为一个主版本的发布，实际包含的内容还是很多的。若是对此版本感兴趣，可以参看其 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.0-rc.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="harbor-v190-rc1-发布">Harbor v1.9.0-rc1 发布&lt;/h2>
&lt;p>Harbor 是由 VMware 开源的一款镜像仓库，现在 GitHub 上有 9k star 也算是个比较热门的项目，我知道国内很多公司都在用 Harbor ，包括我也同样有在用。&lt;/p>
&lt;p>在这个新版本中，增加了一些有趣的特性，我们一起看下：&lt;/p>
&lt;ul>
&lt;li>允许系统管理员限制项目资源配额；&lt;/li>
&lt;li>可以自行定制 Tag 的保留策略，无论是这个特性，还是上面的那个特定，都属于比较呼声比较高的需求，有了这两个功能，可以很方便的来对资源进行管理；&lt;/li>
&lt;li>安全漏洞白名单，在系统中可以配置全局或者项目的漏洞白名单，这个功能估计最终使用的用户不会很多，为什么这么说呢？如果对安全漏洞增加白名单，那前提是你需要真的去了解该漏洞的起因，细则，以及最终的影响范围。贸然加入白名单的话，很容易造成一些意料之外的情况了。&lt;/li>
&lt;li>增加了 Webhook 的支持，要让项目更有活力，当然是需要让它更易与其他系统集成或开放接口；&lt;/li>
&lt;li>复制功能有所增强&lt;/li>
&lt;/ul>
&lt;p>以上是我个人觉得需要关注的点，若是对此版本感兴趣，可以参看其 &lt;a href="https://github.com/goharbor/harbor/releases/tag/v1.9.0-rc1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v300-beta3-发布">Helm v3.0.0-beta.3 发布&lt;/h2>
&lt;p>Helm 仍然在为 v3 版本努力中，此次版本的发布，其中主要多是用于修正一些问题和改善文档之类的。&lt;/p>
&lt;p>如果你对此版本有兴趣，可以参看其 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-beta.3">ReleaseNote&lt;/a> ,非常推荐你在本地进行试用，可能还有一些问题，请及时反馈。&lt;/p>
&lt;h2 id="istio-130-rc2-发布">Istio 1.3.0-rc2 发布&lt;/h2>
&lt;p>Istio 1.3 也在蠢蠢欲动，最近 Istio 的版本更新算是比较频繁的了，按之前的习惯，一般发 3 个 rc 版就基本会发布正式版了。 如果没有啥大问题，估计本月能发布正式版。&lt;/p>
&lt;p>对于这个版本其实没有太多想说的，还是等正式版出来好了。&lt;/p>
&lt;h2 id="上游进展">上游进展&lt;/h2>
&lt;p>不知道你是否还记得之前 Kubernetes 的一个安全漏洞（可以翻翻本系列周报，前面有描述），其实受影响的主要是 &lt;code>kubectl cp&lt;/code> 命令。&lt;/p>
&lt;p>考虑到这个命令可能带来的安全问题，以及对比该命令所带来的收益（或者说用户使用频次），在下一个版本中 &lt;code>kubectl cp&lt;/code> 也许就被移除掉了。 而讨论中，有些人认为 &lt;code>docker cp&lt;/code> 可以是一个很好的替代选择。&lt;/p>
&lt;p>&lt;code>kubectl log&lt;/code> 被移除掉了。这个命令很早之前就已经标记为废弃了，但是很多人为了方便可能还是会使用 &lt;code>log&lt;/code> 命令。已经标记为废弃长大 4 年左右了，是时候把它给移除掉了。&lt;/p>
&lt;p>其他的，比如 CoreDNS 升级到了 1.6.2 这些也都值得关注一下， 我记得之前的周报中大概说过 CoreDNS 的新版本的内容。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| etcd v3.4.0 带来众多更新</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/09/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-etcd-v3.4.0-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%9B%B4%E6%96%B0/"/><id>https://moelove.info/2019/09/01/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-etcd-v3.4.0-%E5%B8%A6%E6%9D%A5%E4%BC%97%E5%A4%9A%E6%9B%B4%E6%96%B0/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-09-01T23:56:38+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm 3 beta2 发布 Helm 3 从 Alpha……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-3-beta2-发布">Helm 3 beta2 发布&lt;/h2>
&lt;p>Helm 3 从 Alpha 之后，就一直进入了持续改进阶段。终于现在 beta2 发布了，按现在社区的开发进度来看，今年发布正式版的希望还是很大的。&lt;/p>
&lt;p>感兴趣还是建议可以先尝试下，以免之后升级时带来不适。&lt;/p>
&lt;h2 id="coredns-v163-发布">CoreDNS v1.6.3 发布&lt;/h2>
&lt;ul>
&lt;li>&lt;code>federation&lt;/code> 将在 1.7.0 中被完全废弃；&lt;/li>
&lt;li>新增两个插件 &lt;code>clouddns&lt;/code> 和 &lt;code>sign&lt;/code>，其中 &lt;code>clouddns&lt;/code> 顾名思义是为云环境设计的，现在它支持 GCP （Google Cloud Platform）Cloud DNS 提供的 zone 数据，实际上它是通过 Google Cloud 的 API 来获取这些信息的，如果你没有在使用 GCP Cloud DNS 的话，目前这个插件应该是用不到的；&lt;code>sign&lt;/code> 插件则是根据 RFC 6781 对 Zone 使用 NSEC 签名，但需要注意的是签名是有时效的，如果到了过期时间，则 Zone 信息会变成 Bad 状态（RFC 4035），所以如果你想要使用这个插件，请明确知道自己需要做什么以及为何使用它；&lt;/li>
&lt;li>&lt;code>file&lt;/code> 插件修复了一些内存泄漏的问题；&lt;/li>
&lt;/ul>
&lt;p>除了上述提到的内容外，想稍微再提一下在 v1.6.2 中新增的 &lt;code>azure&lt;/code> 插件，它其实和 &lt;code>clouddns&lt;/code> 做的事情类似，只不过是从 Azure 获取记录罢了。另外从 v1.6.1 开始 &lt;code>reload&lt;/code> 插件可以正确的检查在 Corefile 中导入的文件的变化了。&lt;/p>
&lt;p>更多关于此版本的信息，请参考 &lt;a href="https://coredns.io/2019/08/31/coredns-1.6.3-release/">Release Note&lt;/a>&lt;/p>
&lt;h2 id="strimzi-成为-cncf-sandbox-项目">Strimzi 成为 CNCF sandbox 项目&lt;/h2>
&lt;p>&lt;a href="https://strimzi.io/">Strimzi&lt;/a> 是一个致力于将 Apache Kafka 运行在 Kubernetes 上的项目，不过在它这次申请成为 CNCF sandbox 项目之前，它的另一个方向是让 Apache Kafka 运行在 OpenShift 上。为了成为 CNCF 的 sandbox 项目，所以现在你能在网站上看到的内容已经大部分都重写成为了让其在 Kubernetes 上运行了。&lt;/p>
&lt;p>所以如果你在使用 Openshift 那倒是也可以尝试下此项目。附一张架构图&lt;/p>
&lt;p>&lt;img src="https://strimzi.io/docs/latest/images/operators.png" alt="Strimzi - https://moelove.info">&lt;/p>
&lt;h2 id="etcd-v340-正式发布">etcd v3.4.0 正式发布&lt;/h2>
&lt;p>etcd &lt;a href="https://github.com/etcd-io/etcd/releases/tag/v3.4.0">v3.4.0&lt;/a> 已于近日发布，这个版本中包含了大量的更新。&lt;/p>
&lt;ul>
&lt;li>添加 Raft learner：推荐直接查看&lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/learning/design-learner.md">设计文档&lt;/a>&lt;/li>
&lt;li>后端完全并发读：通过这个改进，写入吞吐可增加 70%，P99 写入延迟减少 90% ，&lt;a href="https://github.com/etcd-io/etcd/pull/10523">相关 PR&lt;/a>；&lt;/li>
&lt;li>使用 gRPC balancer API 重写了 client v3 的负载均衡实现：当然在这个过程中，将 gRPC 依赖升级到了 v1.23.0 ，同时也修正了一个 Kubernetes 中遇到的 etcd 的问题，详细内容请参考 &lt;a href="https://github.com/kubernetes/kubernetes/issues/72102">k/k#72102&lt;/a>&lt;/li>
&lt;li>&lt;code>ETCDCTL_API=3 etcdctl&lt;/code> 和 &lt;code>etcd --enable-v2=false&lt;/code> 成为了默认配置；&lt;/li>
&lt;li>添加了大量 Metrics 信息；&lt;/li>
&lt;li>还有一个重大变化是现在要求 GO 1.12+ 了，依赖管理也从 &lt;code>glide&lt;/code> 转变为了 GO Module；&lt;/li>
&lt;/ul>
&lt;p>此次的更新非常多，建议升级前详细查看文档。&lt;/p>
&lt;p>更多关于此版本的信息，请参考 &lt;a href="https://github.com/etcd-io/etcd/blob/master/CHANGELOG-3.4.md">Release Note&lt;/a>&lt;/p>
&lt;h2 id="上游开发进展">上游开发进展&lt;/h2>
&lt;ul>
&lt;li>kubeadm 默认使用的 CoreDNS 版本已经更新成了 v1.6.2 ，如果你一直都有看我发布的K8S 生态周报的话，相关变更需要注意的内容就基本都讨论过了。不过这里稍微多提一下，现在的 CoreDNS 的 Deployment 通过 &lt;code>ready&lt;/code> 插件来做 readiness 检查，之前其实这里存在着问题来着；另外 &lt;code>proxy&lt;/code> 插件已经被废弃掉了，所以如果你要升级集群的话，需要注意下 Corefile 是否需要做调整；&lt;/li>
&lt;li>kubeadm 的内核校验规则改成了支持所有 3.10+ 的内核；&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| cilium 1.6 发布 100% kube-proxy 的替代品</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/08/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-cilium-1.6-%E5%8F%91%E5%B8%83-100-kube-proxy-%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/"/><id>https://moelove.info/2019/08/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-cilium-1.6-%E5%8F%91%E5%B8%83-100-kube-proxy-%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-08-25T21:19:10+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kind(Kubernetes In Docker) v0.5.1 正式发布 Kind(Kubernetes……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kindkubernetes-in-docker-v051-正式发布">Kind(Kubernetes In Docker) v0.5.1 正式发布&lt;/h2>
&lt;p>Kind(Kubernetes In Docker) 已经广泛的应用于 Kubernetes 上游及相关项目的 CI 环境中，作为个人本地的测试环境也很方便，推荐大家尝试。&lt;/p>
&lt;p>本次发布，将默认的 Kubernetes 版本更新为 v1.15.3 ；支持了 UDP 和 SCTP 协议的端口转发；对构建 Node 镜像进行了优化，使它更快；同时也对 arm32 增加了有限的支持。&lt;/p>
&lt;p>对 kind load-image 进行了改进，从原先的只是判断镜像名称和 tag 到现在增加了对哈希值的校验；修正了在使用 Proxy 时，部分服务可能受代理影响导致的问题（对国内用户友好）。&lt;/p>
&lt;p>更多关于此版本的内容，请参考 &lt;a href="https://github.com/kubernetes-sigs/kind/releases">ReleaseNote&lt;/a>，欢迎使用和反馈。&lt;/p>
&lt;h2 id="kubernetes-受-go-的-nethttp-安全漏洞影响">Kubernetes 受 Go 的 net/http 安全漏洞影响&lt;/h2>
&lt;p>Kubernetes 近期紧急发布了 v1.15.3, v1.14.6, v1.13.10 版本，距离上个集体更新发布仅过了两周而已，上次的说明请参考&lt;a href="https://zhuanlan.zhihu.com/p/77664404">两周前的 k8s 生态周报&lt;/a>，不过本次的漏洞的根本原因不在 Kubernetes 的功能逻辑上，还是在于其使用的 Go 语言的 &lt;code>net/http&lt;/code> 库的安全漏洞 CVE-2019-9512 和 CVE-2019-9514 。&lt;/p>
&lt;p>关于此次漏洞的信息，可参考 &lt;a href="https://github.com/golang/go/issues/33606">golang/go#33606&lt;/a>，另外 Go 最近陆续发布了几个版本，建议大家也最好升到 v1.12.9 版本。&lt;/p>
&lt;p>作为标准库来说，其实影响面还是比较大的，K8S 最近也是相继从 1.12.6 陆续升级到了 1.12.9 , 当然也包括 Docker 团队等，也都做了相关的更新。&lt;/p>
&lt;p>最后，还是建议尽快升级。&lt;/p>
&lt;h2 id="kubernetes-v1160-beta1-发布">Kubernetes v1.16.0-beta.1 发布&lt;/h2>
&lt;p>本次的开发进度基本都是按照预期进行的，本周发布了 v1.16.0-beta.1 版本，相信很快就会发布正式版了。&lt;/p>
&lt;p>本次的更新内容暂不展开了，有兴趣的朋友可以直接参看 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#changelog-since-v1160-alpha3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="weaveworks-出品的-flux-成为-cncf-sandbox-项目">weaveworks 出品的 Flux 成为 CNCF sandbox 项目&lt;/h2>
&lt;p>Flux 作为 Kubernetes GitOps operator 成功加入了 CNCF。&lt;/p>
&lt;p>它最初是 weaveworks 内部为了加速开发工作流而产生的，但发展至后期，比较独立了，项目规划也比较成熟了，所以现在就托管至 CNCF 了。&lt;/p>
&lt;p>Flux 可以确保集群的配置与 Git 仓库中的内容相符，同时又可自动化你的部署。其实是一个很不错的工具集，因为实际上它基本能满足大多数人的应用场景。&lt;/p>
&lt;p>&lt;img src="https://fluxcd.io/img/flux-cd-diagram.png" alt="flux cd - moelove.info">&lt;/p>
&lt;p>关于此次&lt;a href="https://www.weave.works/blog/flux-joins-the-cncf-sandbox">成为 CNCF sandbox 项目官宣文章请查看其官方博客&lt;/a>&lt;/p>
&lt;h2 id="cilium-16-发布-100-kube-proxy-的替代品">cilium 1.6 发布 100% kube-proxy 的替代品&lt;/h2>
&lt;p>cilium 1.6 发布，本次最大的新闻是它完成了最后的两个核心需求，成功的在使用 cilium 时可以不再需要 kube-proxy 即它可 100% 替换 kube-proxy 。&lt;/p>
&lt;p>这里先对 cilium 做个基本介绍，它是一个基于 eBPF 实现的可用于透明的提供和保护使用 Kubernetes 和 Docker 等容器管理平台部署的应用程序服务之间的网络和 API 连接。&lt;/p>
&lt;p>说的比较绕口，说直白点就是基于 eBPF 的一个性能超厉害的网络组件。至于它具备的能力下面这张图还是比较明白的，有兴趣研究的朋友们推荐看它的官方文档。&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/ba490f8f5ef1241512f8cb7d30dc6f9d4a56e33e/68747470733a2f2f63646e2e7261776769742e636f6d2f63696c69756d2f63696c69756d2f6d61737465722f446f63756d656e746174696f6e2f696d616765732f63696c69756d2d617263682e706e67" alt="cilium - moelove.info">&lt;/p>
&lt;p>kube-proxy 作为 Kubernetes 集群中的一个重要组件，它的性能问题经常被人拿出来说。其实它的性能对多数公司/场景下也表现挺好了，但追求极致才是前进的动力嘛。现在 cilium 发布 1.6 版本，最大的新闻就是可以 100% 替换 kube-proxy 了，性能测试如下图：&lt;/p>
&lt;p>&lt;img src="https://cilium.io/static/k8s-service-benchmark-81bd650b0c6e51860472f409e3c03d37-84ad3.png" alt="cilium performance - moelove.info">&lt;/p>
&lt;p>这里稍微说几句我关于 cilium 的看法：&lt;/p>
&lt;ul>
&lt;li>厉不厉害？厉害。&lt;/li>
&lt;li>值不值得研究？值得。&lt;/li>
&lt;li>会不会放到自己的集群替代 kube-proxy ？不会，最起码目前不会。&lt;/li>
&lt;/ul>
&lt;p>如果你想要通过 cilium 研究 eBPF 或者 XDP 我倒是建议你可以看看，是个很不错的项目，而且通过这个项目能加深很多网络方面的认识。这么说吧，如果把 cilium 的源码及所涉及原理都研究通透了，那就很厉害了。&lt;/p>
&lt;p>至于要不要替换 kube-proxy 在我看来，最起码目前我不会这样去做。解决问题的办法有很多种，而替换掉一个核心组件，却不一定是一个最值得的选择。&lt;/p>
&lt;p>关于此次的性能测试，请参考其&lt;a href="https://cilium.io/blog/2019/08/20/cilium-16/">官方博客&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-08-12~2019-08-18</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/08/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-08-12~2019-08-18/"/><id>https://moelove.info/2019/08/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-08-12~2019-08-18/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-08-19T01:08:00+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 rkt 项目正式被 CNCF 归档……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rkt-项目正式被-cncf-归档">rkt 项目正式被 CNCF 归档&lt;/h2>
&lt;p>8 月 16 日，CNCF 宣布技术委员会已经投票通过将 &lt;code>rkt&lt;/code> 项目归档。&lt;/p>
&lt;p>这个事情，我在几周前的周报大概介绍过，既然现在已经尘埃落定，不如一起来看看 &lt;code>rkt&lt;/code> 的前世今生，毕竟它在容器技术的发展中也曾做出了很多贡献。&lt;/p>
&lt;p>&lt;code>rkt&lt;/code> 最早是由 CoreOS 公司创建的，而 CoreOS 最早应该也算是 Docker 的用户之一。但是随着 Docker 发展的日趋壮大，CoreOS 就想要脱离 Docker，成立自己的标准。&lt;/p>
&lt;p>之后 CoreOS 发布了 AppC 规范（这个规范我也曾仔细研究过），而 CoreOS 主打的旗号是开放，毕竟当时 Docker 一枝独秀，所以也就吸引了不少的伙伴参与。当然 &lt;code>rkt&lt;/code> 也就借着这股风，得到了不少人的青睐。&lt;/p>
&lt;p>这里且不说 &lt;code>rkt&lt;/code> 功能或是规范如何，我们单独来看看那场容器市场份额的争夺战是如何打的。&lt;/p>
&lt;p>在那时候，同时进行的另外一场战役是容器编排系统的战役。所以 &lt;code>rkt&lt;/code> 也算是做了努力，它选择了与 Kubernetes 的合作（大概算是共同阵营的合作吧），所以在 2016 年 Kubernetes 1.3 版本中，宣布了支持 &lt;code>rkt&lt;/code> 作为容器运行时的一个可选想。&lt;/p>
&lt;p>但 Docker 的发展（指 Docker 项目），却几乎没有受到影响。为什么呢？ Docker 早已凭借自身的稳定性和易用性占领了大批的用户，即使有用户选择 &lt;code>rkt&lt;/code> 大多也只是用于尝试（心疼选择 &lt;code>rkt&lt;/code> 放入生产环境中的那批）。而且不得不说，Docker 在用户心中几乎是容器的代名词，是一个默认选项。&lt;/p>
&lt;p>所以很自然的 &lt;code>rkt&lt;/code> 在此战役中失败，之后 Kubernetes 也抛弃了对 rkt 的支持。 另外，CoreOS 公司的发展可能对造成 &lt;code>rkt&lt;/code> 的现状也有很大的关系。&lt;/p>
&lt;p>最后，最关键的其实还是因为项目存活率，我们来用数据说话：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/rkt-health.png" alt="rkt 项目健康值">&lt;/p>
&lt;p>关于事情的官方报道是：&lt;a href="https://www.cncf.io/blog/2019/08/16/cncf-archives-the-rkt-project/">CNCF Archives the rkt Project&lt;/a>&lt;/p>
&lt;h2 id="cni-plugins-v082-发布">CNI Plugins v0.8.2 发布&lt;/h2>
&lt;p>是一个 bugfix 的版本，但是要注意的是这个版本中包含了一个错误修复 #366 , 当在节点启动时，同时运行多个 Pod ，&lt;code>cni0&lt;/code> 网桥将被多个 &lt;code>goroutine&lt;/code> 创建，这就有可能引起一个错误 &lt;code>failed to set bridge addr: could not add IP address to \&amp;quot;cni0\&amp;quot;: file exists.&lt;/code>&lt;/p>
&lt;p>关于此版本的更多细节请查看 &lt;a href="https://github.com/containernetworking/plugins/releases/tag/v0.8.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-124-发布大量安全更新">Istio 1.2.4 发布，大量安全更新&lt;/h2>
&lt;p>&lt;strong>这个版本中有大量的安全更新，建议尽快升级。&lt;/strong>&lt;/p>
&lt;p>我们来看看漏洞的影响，主要是 CVE-2019-14993， CVE-2019-9512，CVE-2019-9513，CVE-2019-9515，CVE-2019-9518 这些漏洞主要是可能被用来做 DoS 攻击。当然原问题是在 &lt;a href="https://github.com/envoyproxy/envoy/issues/7728">Envoy 上&lt;/a> 的。&lt;/p>
&lt;p>关于此版本的更多内容请参考 &lt;a href="https://istio.io/about/notes/1.2.4/">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Kubernetes 1.15 新特性解读</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/08/13/Kubernetes-1.15-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/><id>https://moelove.info/2019/08/13/Kubernetes-1.15-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</id><updated>2021-11-22T22:59:57+08:00</updated><published>2019-08-13T06:22:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">k8s v1.15 于 2019 年 6 月 19 日正式发布，这个版本中包含了 25 个特性变更：其中 2 个成为 stable ，13 个处于 beta 以及 10 个处于 alpha 阶段。 这个版本所围绕的主题是……</summary><content type="html">&lt;blockquote>
&lt;p>k8s v1.15 于 2019 年 6 月 19 日正式发布，这个版本中包含了 25 个特性变更：其中 2 个成为 stable ，13 个处于 beta 以及 10 个处于 alpha 阶段。&lt;/p>
&lt;p>这个版本所围绕的主题是提高稳定性和可扩展性。所以此版本中 CRD 相关的变更比较多。&lt;/p>
&lt;p>本文将围绕 Kubernetes 1.15 的新特性进行展开，集中在 CRD 和 kubeadm 之上。&lt;/p>
&lt;/blockquote>
&lt;h2 id="customresourcedefinition-crd-的基本介绍">CustomResourceDefinition (CRD) 的基本介绍&lt;/h2>
&lt;h2 id="环境准备">环境准备&lt;/h2>
&lt;p>我们使用 &lt;a href="https://kind.sigs.k8s.io">&lt;code>kind&lt;/code>&lt;/a> 创建我们所需的 Kubernetes 1.15 的环境。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kind create cluster --image kindest/node:v1.15.0 --name 115
Creating cluster &amp;quot;115&amp;quot; ...
✓ Ensuring node image (kindest/node:v1.15.0) 🖼
✓ Preparing nodes 📦
✓ Creating kubeadm config 📜
✓ Starting control-plane 🕹️
✓ Installing CNI 🔌
✓ Installing StorageClass 💾
Cluster creation complete. You can now use the cluster with:
export KUBECONFIG=&amp;quot;$(kind get kubeconfig-path --name=&amp;quot;115&amp;quot;)&amp;quot;
kubectl cluster-info
(MoeLove) ➜ ~ export KUBECONFIG=&amp;quot;$(kind get kubeconfig-path --name=&amp;quot;115&amp;quot;)&amp;quot;
(MoeLove) ➜ ~ kubectl get nodes
NAME STATUS ROLES AGE VERSION
115-control-plane Ready master 41s v1.15.0
&lt;/code>&lt;/pre>&lt;p>接下来部署我们的 CRD，关于 CRD 的开发相关知识不是本文的重点，暂且忽略，有兴趣的朋友可以看看官方文档的介绍。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl get crd -o name
customresourcedefinition.apiextensions.k8s.io/hobbies.moe.moelove.info
(MoeLove) ➜ ~ kubectl get hobby
NAME AGE
music 44s
&lt;/code>&lt;/pre>&lt;p>可以看到已经部署成功了。既然环境已经准备就绪，我们回到本文的重点来看看 Kubernetes 1.15 中我们所需要关注的核心特性。&lt;/p>
&lt;h2 id="beta-customresourcedefinition-webhook-conversion">beta: CustomResourceDefinition Webhook Conversion&lt;/h2>
&lt;p>CRD API 当中有个 &lt;code>versions&lt;/code> 字段，可以用来配置 CR 的版本，并且 Kubernetes 允许我们有多个版本的 CR 存在。通过 kubectl 可以进行查看&lt;/p>
&lt;pre>&lt;code># 篇幅原因，省略了无关输出
(MoeLove) ➜ ~ kubectl get crd hobbies.moe.moelove.info -o yaml
...
version: v1alpha1
versions:
- name: v1alpha1
served: true
storage: true
- name: v1beta1
served: true
storage: false
...
&lt;/code>&lt;/pre>&lt;p>注意你会看到这里有 &lt;code>version&lt;/code> 字段和 &lt;code>versions&lt;/code> 字段，不过 &lt;code>version&lt;/code> 字段已过期，并且是可选的，如果该字段不为空，则它应该与 &lt;code>versions&lt;/code> 中的第一个项匹配。&lt;/p>
&lt;p>Kubernetes 提供了一个 CRD 转换的机制，可允许我们在多个不同的版本之间进行转换。当然，这个转换可以根据你具体的配置进行转换。比如设置为 &lt;code>None&lt;/code> 模式的话，则只是针对于 API 版本的转换，并不会随意变更资源中的其他内容。&lt;/p>
&lt;p>这里还提供了一种使用 Webhook 的方式，允许你进行更多灵活的转换规则。主要将 &lt;code>conversion&lt;/code> 字段配置为 &lt;code>Webhook&lt;/code>。&lt;/p>
&lt;p>具体的实现可以参考 &lt;a href="https://github.com/kubernetes/kubernetes/tree/v1.15.0/test/images/crd-conversion-webhook">官方代码库中用于 Kubernetes e2e 测试的 webhook server&lt;/a> 这里就不再进行展开了。&lt;/p>
&lt;h2 id="beta-customresourcedefinition-openapi-publishing">beta: CustomResourceDefinition OpenAPI Publishing&lt;/h2>
&lt;p>另一个变化在于 Kubernetes 可为 CRD 发布 OpenAPI，具体的提案可以查看 &lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/00xx-publish-crd-openapi.md">publish-crd-openapi&lt;/a> 。&lt;/p>
&lt;p>那它的意义是什么呢？ 通过发布 OpenAPI 可以很方便的支持客户端侧的验证，模式说明之类的。&lt;/p>
&lt;p>比如说，如果你要 &lt;code>kubectl apply&lt;/code> 一个 CRD 的 YAML ，在已经发布 OpenAPI 的情况下，客户端侧可以很方便的进行验证，具备掉未包含或者未通过验证的在 CRD 中的字段。&lt;/p>
&lt;p>还有便是通过此项功能，也可以让&lt;code>kubectl explain&lt;/code> 支持 CRD：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl explain hobbies.moe.moelove.info
KIND: Hobby
VERSION: moe.moelove.info/v1beta1
DESCRIPTION:
&amp;lt;empty&amp;gt;
&lt;/code>&lt;/pre>&lt;p>让我们得到一种类似原生资源的体验。&lt;/p>
&lt;h2 id="beta-customresourcedefinitions-pruning-和-alpha-customresourcedefinition-defaulting">beta: CustomResourceDefinitions Pruning 和 alpha: CustomResourceDefinition Defaulting&lt;/h2>
&lt;p>另外这两个特性，主要都是对于结构化的 CRD 来讲的，可以通过配置设置默认值，或者是自动清理掉未包含在 CRD 结构中的字段。&lt;/p>
&lt;p>这两个特性也就不额外展开了。&lt;/p>
&lt;h2 id="kubeadm-集群生命周期的稳定性和可用性的改进">kubeadm: 集群生命周期的稳定性和可用性的改进&lt;/h2>
&lt;p>kubeadm 是一个很方便的集群部署，管理和升级的工具，也同时上游社区也有庞大的维护团队致力于将 kubeadm 变得更加稳定和易用。&lt;/p>
&lt;p>对使用 kubeadm 部署的集群而言，证书管理算是之前的一个短板。而在 1.15 中，kubeadm 可以无缝的对证书进行需求。这会大大方便所有使用 kubeadm 部署集群的维护者。&lt;/p>
&lt;p>另外，在此版本中 kubeadm 在 HA 集群的部署上也做了很多改进。比如现在你可以通过 &lt;code>kubeadm join --control-plane&lt;/code> 来加入其他控制面的节点，并且从 1.15 开始允许并行加入多个控制面节点。&lt;/p>
&lt;p>kubeadm 为了能提升其稳定性，基于 &lt;a href="https://kind.sigs.k8s.io">kind&lt;/a> 开发了一套测试组件，可极大的在测试过程中模拟真实集群的情况。（Kind 是通过 CNCF Kubernetes 一致性认证的安装工具）&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上内容便是 Kubernetes 1.15 中比较关键的一些信息了。 在 kubernetes 1.16 中， CRD API 将达到 GA 级别。这也是 Kubernetes 的一个重要发展方向。&lt;/p>
&lt;hr>
&lt;p>欢迎订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://gitee.com/tlrr/awesome/raw/master/2020-9-9/1599632564572-mp-qrcode.png" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/kubeadm/" term="kubeadm" label="kubeadm"/></entry><entry><title type="text">K8S 生态周报| 2019-08-05~2019-08-11</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/08/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-08-05~2019-08-11/"/><id>https://moelove.info/2019/08/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-08-05~2019-08-11/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-08-12T07:14:40+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes 两个重要漏洞修复……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-两个重要漏洞修复">Kubernetes 两个重要漏洞修复&lt;/h2>
&lt;p>最近 Kubernetes 发布了 1.13.9, 1.14.5, 和 1.15.2 版本，旨在修复两个重要漏洞对 Kubernetes 带来的影响， &lt;strong>强烈建议将集群及 kubectl 进行升级&lt;/strong>&lt;/p>
&lt;p>&lt;strong>CVE-2019-11247&lt;/strong> 简单来说其影响就是可以访问单个命名空间中的自定义资源的用户可以访问具有集群范围的自定义资源。当然，这里的修正主要是 &lt;strong>针对 CRD&lt;/strong> 。核心的修正代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">possiblyAcrossAllNamespacesVerbs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">sets&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;list&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;watch&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">namespacedCRD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">namespacedReq&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">crd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Scope&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">apiextensions&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamespaceScoped&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">requestInfo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Namespace&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">namespacedCRD&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">namespacedReq&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">delegate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServeHTTP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">namespacedCRD&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">namespacedReq&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">possiblyAcrossAllNamespacesVerbs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Has&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">requestInfo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Verb&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">delegate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServeHTTP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当未通过检查时，delegate 将会触发一个 404 。对此问题感兴趣的朋友可以查看 &lt;a href="https://github.com/kubernetes/kubernetes/issues/80983">#80983&lt;/a> 。&lt;/p>
&lt;p>&lt;strong>CVE-2019-11249&lt;/strong> 则是对于之前暴出来的使用 &lt;code>kubectl cp&lt;/code> 可进行恶意目录浏览的漏洞 CVE-2019-1002101 和 CVE-2019-11246 的不完整修复。有兴趣可以参考 &lt;a href="https://github.com/kubernetes/kubernetes/pull/80436">#80436&lt;/a> 。&lt;/p>
&lt;h2 id="coredns-v161-发布">CoreDNS v1.6.1 发布&lt;/h2>
&lt;p>主要是修复了 &lt;code>host&lt;/code> 插件的错误处理；&lt;code>reload&lt;/code> 插件也可以检测 Corefile 中导入的文件的变化了。&lt;/p>
&lt;p>更多关于此版本的信息请参考 &lt;a href="https://coredns.io/2019/08/01/coredns-1.6.1-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="nginx-ingress-controller-153-发布">NGINX Ingress Controller 1.5.3 发布&lt;/h2>
&lt;p>这个版本其实没啥说的，把 NGINX Plus 版本更新到了 R18p1. 升级的话，直接修改镜像的 tag 到 1.5.3 或者 Helm chart 使用 0.3.3 版本即可。&lt;/p>
&lt;h2 id="kubernetes-上游开发进展">Kubernetes 上游开发进展&lt;/h2>
&lt;p>1.16 将会有 39 项特性增强，看现在的发布进度也还算是按照预期的，期待后续顺利。&lt;/p>
&lt;p>最近合并的 PR 中我认为值得注意的是 &lt;a href="https://github.com/kubernetes/kubernetes/pull/80231">#80231 AdmissionReview 版本至 v1 &lt;/a> 这里没有 schema 的变化，但是所有的系统都将接收 v1 版本的对象和数据，当发送回 v1 响应的时候，响应验证比 beta 时候更加严格。&lt;/p>
&lt;p>注意，现在要使用的 API 版本是 &lt;code>apiVersion: &amp;quot;admission.k8s.io/v1&amp;quot;&lt;/code> 如果升级的话，请注意检查对应代码的变化。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-07-29~2019-08-04</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/08/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-29~2019-08-04/"/><id>https://moelove.info/2019/08/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-29~2019-08-04/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-08-05T00:47:54+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 containerd 1.3.0-beta.0 发布 containerd 2014 年从 Docker……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="containerd-130-beta0-发布">containerd 1.3.0-beta.0 发布&lt;/h2>
&lt;p>containerd 2014 年从 Docker 孵化出来，最初是作为 Docker 引擎的底层管理器；在 2017 年 3 月被 CNCF 接受后，containerd 几乎成为了行业容器运行引擎的标准，它专注于简单，健壮和可移植性，任何人都可以使用它来构建自己的容器引擎/平台。它是从 CNCF 毕业的第 5 个项目，目前发展势头良好。&lt;/p>
&lt;p>本次发布的 1.3.0-beta.0 版本是 containerd 的第 4 个主要版本，主要是为了提升项目的稳定性，以及为了保持项目的活力而持续加入了很多新的特性。&lt;/p>
&lt;p>这次的发布和之前版本类似，保持着 containerd 的一贯作风，API 变化很小；并且也保持向后兼容。插件生态和用户的发展也促使了 containerd 变得更易用，可配置和更灵活。&lt;/p>
&lt;p>在 Windows 上，此次版本带来了一个新运行时（使用 &lt;code>hcsshim&lt;/code>）; 对于客户端而言，本次也带来了很多特性和升级。&lt;/p>
&lt;p>这里我只说两点，其余的等正式版出来看情况再进行介绍。&lt;/p>
&lt;ul>
&lt;li>增加了 &lt;code>devicemapper&lt;/code> 的快照插件。这个功能本身是个好事儿，如果用过旧版本 Docker 或者系统内核较低的朋友们，应该对 Docker 的 &lt;code>devicemapper&lt;/code> 存储驱动不会太陌生的（虽然现在 Docker 的新版本中已经将 &lt;code>devicemapper&lt;/code> 的存储驱动废弃掉了）；至于 containerd 中增加的 &lt;code>devicemapper&lt;/code> 快照插件，我还没有来得及具体测试，所以这里不说太多了。&lt;/li>
&lt;li>客户端支持了跨 repository push 镜像，对此功能感兴趣的朋友可以参考 &lt;a href="https://github.com/containerd/containerd/pull/2697">#2697&lt;/a> 的讨论。&lt;/li>
&lt;/ul>
&lt;p>更多关于此版本的信息请参考 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.3.0-beta.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-v1160-alpha2-发布">Kubernetes v1.16.0-alpha.2 发布&lt;/h2>
&lt;p>本周按照预期发布了 v1.16.0 的 alpha.2 版本，这个版本现在介绍未免有点早，也就先不再多说了，一会儿说到上游开发进展的时候再提一些。&lt;/p>
&lt;p>更多关于此版本的信息请参考 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.16.0-alpha.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v2143-发布">Helm v2.14.3 发布&lt;/h2>
&lt;p>本周也发布了 Helm 的 v2.14.3 版本，这个版本中主要就修复了在 upgrade CRD 的时候的问题，算是个遗留问题吧。有兴趣的朋友可以看看 &lt;a href="https://github.com/helm/helm/issues/5853">#5853&lt;/a> 的讨论。不过其实也比较有意思，通常大家会认为基础工具会很可靠，所以在遇到这种问题的时候，会反复验证是不是自己搞错了，或者是不是自己使用姿势的问题之类的。&lt;/p>
&lt;p>另外，之后会发布版本应该会是 v2.15 系列，至于 Helm v3 嘛，还得再等等。&lt;/p>
&lt;p>更多关于此版本的信息请参考 &lt;a href="https://github.com/helm/helm/releases/tag/v2.14.3">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-上游开发进展">Kubernetes 上游开发进展&lt;/h2>
&lt;p>最近合并的 PR 中我个人认为值得注意的是 &lt;a href="https://github.com/kubernetes/kubernetes/pull/79992">#79992 为保留的 API 组添加保护&lt;/a> 这个 PR 应该归属于 &lt;a href="https://github.com/kubernetes/enhancements/pull/1111">kubernetes/enhancements#1111&lt;/a>。&lt;/p>
&lt;p>它主要是要求所有在 &lt;code>k8s.io&lt;/code> 和 &lt;code>kubernetes.io&lt;/code> 命名空间下的 CRD 都必须有个 annotation 链接到标记它们被 approved 的地方。这可以避免一些尚未经过完整验证流程的 API 的发布，并且也希望通过它来提高 API 的一致性。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】，在公众号后台回复 k8s 可加入技术圈交流。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-07-21~2019-07-28</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/07/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-21~2019-07-28/"/><id>https://moelove.info/2019/07/28/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-21~2019-07-28/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-07-28T22:14:44+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker CE v19.03 正式发布 7 月……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-ce-v1903-正式发布">Docker CE v19.03 正式发布&lt;/h2>
&lt;p>7 月 22 日，正式发布了 Docker CE v19.03 版本，按照 Docker CE 版本的生命周期，此次的 v19.03 可以说是千呼万唤始出来，原本按语义应该是在 3 月，不过之前的发布计划中开始是设定在了 5 月份，而一转眼现在已经到 7 月底了。
先跳过这次发布时间延期的问题，我们来看看此版本中最值得注意的一些变化。&lt;/p>
&lt;p>首先来看看被废弃的部分：&lt;/p>
&lt;ul>
&lt;li>废弃 &lt;code>aufs&lt;/code> 存储驱动，在此版本之前 &lt;code>devicemapper&lt;/code> 和 &lt;code>overlay&lt;/code> 也都已经被废弃;&lt;/li>
&lt;li>当 docker daemon 运行时，如果没有指定存储驱动，则会自动选择一个，v19.03 中增加了自动选择时跳过已被废弃的存储驱动的逻辑；&lt;/li>
&lt;li>废弃 image manifest v2 schema1 以支持 v2 schema2 ，这里的废弃涉及到的内容很多，尤其是涉及到了 image registry 的部分, 所以后续还有很长的路要走。还记得之前推送过 Docker Hub 今年 6 月份停止 v1 API 进行 Pull 操作的事情吗？早年 2015 年 11 月的时候，它就已经禁止了 v1 API 的 Push 操作。从这点上也能看到 Docker 在功能弃用上其实为用户考虑了很多，并且也给了足够长的时间来让用户进行迁移。&lt;/li>
&lt;/ul>
&lt;p>其次，我们看看功能增强的部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>对 NVIDIA GPU 设备的支持&lt;/strong>，在 docker CLI 的 &lt;code>docker run&lt;/code> 命令中添加了 &lt;code>--gpus&lt;/code> 参数，用于为容器添加 GPU 设备。事实上，大家需要注意的是，这里严格的表述应该是它目前是对 &lt;strong>NVIDIA GPU的支持&lt;/strong>而不是很多国内媒体报道的，对 GPU 的支持（毕竟做 GPU 的有很多家），而且现在对 NVIDIA 的支持，也都是硬编码在代码中的，之后还有很长的路要走。至于很多人可能想问，它添加这个支持后，是否还需要安装驱动，安装 CUDA 是否需要安装 nvidia-docker2 之类的， 我在这部分逻辑刚合并后就在机器上实验过了， &lt;strong>代码中硬编码了对 &lt;code>nvidia-container-cli&lt;/code> 的依赖，现在修改成了对 &lt;code>vidia-container-runtime-hook&lt;/code> 的依赖，&lt;/strong> 所以，像驱动啊 &lt;code>nvidia-container-cli&lt;/code> 之类的东西还是需要装的，只不过用户使用上和原先用法不一样了罢了。（这里非常希望大家能自行尝试下）&lt;/li>
&lt;li>API 更新至了 v1.40；&lt;/li>
&lt;li>对 &lt;code>/_ping&lt;/code> 接口添加了对 &lt;code>HEAD&lt;/code> 请求的支持，返回结果中会包含当前 docker daemon 的 API 和版本，系统类型等信息；&lt;/li>
&lt;li>构建系统有了很多的改进，这里不再一一细述，感兴趣的朋友可以看我写的文章 &lt;a href="https://gitbook.cn/gitchat/activity/5cf026eaff33b82ee0eb425b">「Docker 镜像构建原理及源码分析」&lt;/a> 这篇文章中使用的源码版本是 v19.03.0-rc2 内容很新；&lt;/li>
&lt;li>支持 &lt;code>Rootless&lt;/code> 模式，事实上这个功能在去年就已经在逐步推进了，但即使是现在，我也尚不推荐将此功能应用于生产环境。（国内有很多媒体对此大肆宣扬来着，说以后可以不用 &lt;code>root&lt;/code> 权限了如何如何 - - 我只想说你们有没有真的用过 &lt;code>Rootless&lt;/code> 模式，或者有没有在生产实践中验证过） 这个功能确实是有了，但尚不完善，也尚并不能达到替代当前 docker 全部能力的时候，包括它的网络能力，它的存储能力等目前都还有很多路要走；&lt;/li>
&lt;li>对 &lt;code>docker network&lt;/code> 支持了 &lt;code>dangling&lt;/code> 状态的筛选支持。&lt;/li>
&lt;/ul>
&lt;p>以上便是 v19.03 中我个人认为最值得注意的内容。当然，现在我还要额外多说一点（划重点）：&lt;/p>
&lt;p>使用此版本，我们可以在一台机器上同时管理多个 Docker Engine 这是我用了很长时间的功能，特别有用，与大家分享一下具体使用方法：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker context create build-context --description &amp;quot;build context&amp;quot; --docker &amp;quot;host=tcp://172.17.0.3:2375&amp;quot;
build-context
Successfully created context &amp;quot;build-context&amp;quot;
(MoeLove) ➜ ~ docker context ls
NAME DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR
build-context build context tcp://172.17.0.3:2375
default * Current DOCKER_HOST based configuration unix:///var/run/docker.sock https://10.234.9.30:8443 (default) swarm
&lt;/code>&lt;/pre>&lt;p>使用该 &lt;code>context&lt;/code>&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker context use build-context
build-context
Current context is now &amp;quot;build-context&amp;quot;
&lt;/code>&lt;/pre>&lt;p>这样，我们便可以直接在本机管理远程的一台机器上的 Docker Engine 了，当然它也可以支持用 &lt;code>ssh&lt;/code> 连接远程主机的模式。&lt;/p>
&lt;p>好了，关于此版本的介绍就到这里，对此版本中构建系统有想深入的了解的还是同样建议阅读 &lt;a href="https://gitbook.cn/gitchat/activity/5cf026eaff33b82ee0eb425b">「Docker 镜像构建原理及源码分析」&lt;/a> 关于此版本中更多的更新内容请参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="helm-v300-alpha2-发布">Helm v3.0.0-alpha.2 发布&lt;/h2>
&lt;p>这个版本中主要是对 Helm 3 内部的架构进行了优化，所以外部看到的功能特性变化并不是很大。 如果对 Helm 3 还不了解的朋友，推荐阅读 &lt;a href="https://zhuanlan.zhihu.com/p/66058355">初试 Helm 3&lt;/a> 。&lt;/p>
&lt;p>更多关于此版本的信息请参考 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-alpha.2">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-上游开发进展">Kubernetes 上游开发进展&lt;/h2>
&lt;p>按照预期，特性冻结的 deadline 是 7 月 30 日，过段时间，下一个版本就将会正式发布了。&lt;/p>
&lt;p>最近合并的 PR 中最值得注意的我个人认为应该是 &lt;a href="https://github.com/kubernetes/kubernetes/pull/59416">#59416 将 Ephemeral Containers 添加到 Kubernetes 核心 API&lt;/a> 这个 PR 应该归属于 &lt;a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190212-ephemeral-containers.md">Ephemeral Containers 相关 KEP&lt;/a> 的一部分。&lt;/p>
&lt;p>其主要目的在于提供一种机制，方便进行容器的在线调试或者监测。可以理解为启动一个与待调试容器具备相同网络和 Namespace 的容器，以此来进行调试。现在我们一般做这个事情一般是手动完成或者借助一些其他工具，但其实不够&amp;quot;优雅&amp;quot;，随着这个 KEP 的完善，希望能弥补这部分的空缺。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-07-15~2019-07-21</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/07/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-15~2019-07-21/"/><id>https://moelove.info/2019/07/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-15~2019-07-21/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-07-22T00:07:54+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.16.0-alpha.1 发布 Kubernetes 于近日发……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v1160-alpha1-发布">Kubernetes v1.16.0-alpha.1 发布&lt;/h2>
&lt;p>Kubernetes 于近日发布了 v1.16.0-alpha.1 版本，变化是比较大，但这里暂时先不细说了，等到 9 月份正式版本发布前后再慢慢说。当然也稍微聊一些 :) 比如：&lt;/p>
&lt;p>官方 &lt;code>etcd&lt;/code> 镜像中不再提供 &lt;code>etcd&lt;/code> 2 和 3 的兼容工具了，对 &lt;code>etcd&lt;/code> 2 的兼容代码也都全部删掉了（对 &lt;code>etcd&lt;/code> 2 的支持其实从 1.13 就已经停止了）#80037 ；&lt;/p>
&lt;p>1.16 中对以下四种类型资源的 API 有所调整：&lt;/p>
&lt;ul>
&lt;li>&lt;code>NetworkPolicy&lt;/code>&lt;/li>
&lt;li>&lt;code>PodSecurityPolicy&lt;/code>&lt;/li>
&lt;li>&lt;code>DaemonSet&lt;/code>, &lt;code>Deployment&lt;/code>, &lt;code>StatefulSet&lt;/code> 和 &lt;code>ReplicaSet&lt;/code>&lt;/li>
&lt;li>&lt;code>Ingress&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>具体调整细节如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>NetworkPolicy&lt;/code> 将使用从 v1.8 版本开始提供的 &lt;code>networking.k8s.io/v1&lt;/code> API;&lt;/li>
&lt;li>&lt;code>PodSecurityPolicy&lt;/code> 将使用从 v1.10 开始提供的 &lt;code>policy/v1beta1&lt;/code> API;&lt;/li>
&lt;li>&lt;code>DaemonSet&lt;/code>, &lt;code>Deployment&lt;/code>, &lt;code>StatefulSet&lt;/code> 和 &lt;code>ReplicaSet&lt;/code> 将使用从 v1.9 版本开始提供的 &lt;code>apps/v1&lt;/code> API;&lt;/li>
&lt;li>&lt;code>Ingress&lt;/code> 迁移到 &lt;code>networking.k8s.io/v1beta1&lt;/code> API;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：只是资源的 API 进行了调整，并不会删除这些资源&lt;/strong> 现在还有足够的时间将 API 进行调整和更新。&lt;/p>
&lt;p>可以直接通过 &lt;code>kubectl&lt;/code> 来完成 API 升级的转换，比如 &lt;code>kubectl convert -f &amp;lt;file&amp;gt; --output-version &amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;&lt;/code> 。验证的话，可以直接通过修改 &lt;code>api-server&lt;/code> 的 &lt;code>runtime-config&lt;/code> 参数来进行验证。（当然更简单的方式是使用 Kind 来完成）&lt;/p>
&lt;p>另外 &lt;code>MutatingWebhookConfiguration&lt;/code> 和 &lt;code>ValidatingWebhookConfiguration&lt;/code> API 也被提升为 &lt;code>admissionregistration.k8s.io/v1&lt;/code> 并且一些默认值，比如 &lt;code>failurePolicy&lt;/code> 也从 &lt;code>Ignore&lt;/code> 改为了 &lt;code>Fail&lt;/code> &lt;strong>注意：只影响了 v1 API&lt;/strong> 更多细节可参考 #79549&lt;/p>
&lt;p>关于 Kubernetes v1.16.0-alpha.1 版更多内容请参考 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#v1160-alpha1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-ce-v18098-发布">Docker CE v18.09.8 发布&lt;/h2>
&lt;p>这是个常规的 bugfix 版本，本次更新的主要内容是修复 CVE-2019-13509 ，建议大家升级。
另外，如果是将 Docker daemon 的 API 暴露出来的话，建议增加 TLS ，以确保安全。&lt;/p>
&lt;p>更多内容请参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v18.09.8">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="thanos-正式成为-cncf-sandbox-孵化项目">thanos 正式成为 CNCF Sandbox 孵化项目&lt;/h2>
&lt;p>&lt;a href="https://github.com/thanos-io/thanos">thanos&lt;/a> 是一个致力于提供 Prometheus 高可用方案的一套组件，可在现有 Prometheus 基础上无缝添加。&lt;/p>
&lt;p>具体而言，通过 thanos 可以“无限”的保存指标，可以提供全局查询视图，可提供包括 Prometheus 在内组件的高可用。&lt;/p>
&lt;p>随着 Kubernetes 的发展，Prometheus 几乎成为了当前云原生时代下的首选监控系统了，如果你在用 Prometheus 我推荐你看看 thanos。&lt;/p>
&lt;p>贴一张官方的架构图：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/thanos-io/thanos/master/docs/img/arch.jpg" alt="thanos's arch - moelove.info">&lt;/p>
&lt;h2 id="kubernetes-nginx-ingress-0250-正式发布">Kubernetes NGINX Ingress 0.25.0 正式发布&lt;/h2>
&lt;p>&lt;a href="https://moelove.info/2019/07/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-01~2019-07-07/#nginx-ingress-controller-1-5-1-%E5%8F%91%E5%B8%83">前两周 NGINX Ingress 也发布过新版本&lt;/a>，看当前社区的情况，两者都有人在使用。&lt;/p>
&lt;p>本次 Kubernetes NGINX Ingress 新版本中最重要的点之一莫过于 &lt;strong>将 &lt;code>NGINX&lt;/code> 迁移到了 &lt;code>OpenResty&lt;/code>&lt;/strong> ，通过这一改变，也可以利用 &lt;code>OpenResty&lt;/code> 社区的工具和模块等扩展一些功能（我考虑也可能是为了吸引一部分用户）&lt;/p>
&lt;p>关于此版本的更多细节请参考 &lt;a href="https://github.com/kubernetes/ingress-nginx/releases/tag/nginx-0.25.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubectl-get--w-新增了事件列">&lt;code>kubectl get -w&lt;/code> 新增了事件列&lt;/h2>
&lt;p>通过指定 &lt;code>--output-watch-events&lt;/code> 可以为 &lt;code>kubectl get -w&lt;/code> 的输出增加事件列，之后配合其他简单的代码便可完成很多有趣的事情了，比如说 Node 的登记变更等。 这个功能预期会在下个版本发布。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl get ns -w --output-watch-events
EVENT NAME STATUS AGE
ADDED default Active 19m
ADDED kube-node-lease Active 19m
ADDED kube-public Active 19m
ADDED kube-system Active 19m
ADDED moelove Active 56s
MODIFIED moelove Terminating 76s
DELETED moelove Terminating 81s
ADDED moelove Active 0s
───────────────────────────────────────────────────────────────────────────────────────────────
(MoeLove) ➜ ~ kubectl delete ns moelove
namespace &amp;quot;moelove&amp;quot; deleted
(MoeLove) ➜ ~ kubectl create ns moelove
namespace/moelove created
(MoeLove) ➜ ~
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://moelove.info/img/kubectl-watch-out-event.jpg" alt="kubectl-watch-out-event - moelove.info">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-07-08~2019-07-14</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/07/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-08~2019-07-14/"/><id>https://moelove.info/2019/07/15/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-08~2019-07-14/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-07-15T05:44:22+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 本周为什么发布时间……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。
本周为什么发布时间比往常迟呢？因为我在忙结婚呀。&lt;/p>
&lt;/blockquote>
&lt;h2 id="coredns-v152-发布">CoreDNS v1.5.2 发布&lt;/h2>
&lt;p>这是 CoreDNS 在 1.5.x 版本中发布的第二个小版本，关于 1.5.1 版本的说明可参考上上周的文章。&lt;/p>
&lt;p>在此版本中，一个重要的变更便是移除掉了 &lt;code>upstream&lt;/code> 插件相关的所有文档和说明。比如，Kubernetes 1.14 版本中默认的 CoreDNS 的配置文件的内容如下：&lt;/p>
&lt;pre>&lt;code>.:53 {
errors
health
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
upstream
fallthrough in-addr.arpa ip6.arpa
}
prometheus :9153
forward . /etc/resolv.conf
cache 30
loop
reload
loadbalance
}
&lt;/code>&lt;/pre>&lt;p>其中 &lt;code>kubernetes&lt;/code> 插件中有一行 &lt;code>upstream&lt;/code> 的配置，它是定义了用于解析指向外部主机的服务的上游解析器（也称之为外部服务，CNAME）CoreDNS 将针对自身解析该服务。&lt;/p>
&lt;p>在此次变更之后， &lt;code>upstream&lt;/code> 配置行便可直接移除。&lt;/p>
&lt;p>另外 &lt;code>template&lt;/code> 插件支持元数据了。比如说可以给它增加一个配置 &lt;code>.Meta &amp;quot;kubernetes/my-namespace&amp;quot;&lt;/code>。&lt;/p>
&lt;p>关于此版本的更详细说明可阅读 &lt;a href="https://coredns.io/2019/07/03/coredns-1.5.2-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="envoy-v1110-正式发布">Envoy v1.11.0 正式发布&lt;/h2>
&lt;p>这个版本的变化其实还比较多，主要集中在特性增强和各类兼容性支持上。&lt;/p>
&lt;p>在此版本中增加了对 Redis Cluster 命令路由的支持，添加了 &lt;code>prefix routing&lt;/code> 以支持对 Redis 按照 key 前缀进行路由的能力。&lt;/p>
&lt;p>在管理方面增加了主机的优先级，ready 检查的接口等。&lt;/p>
&lt;p>关于此版本更详细说明可阅读 &lt;a href="https://www.envoyproxy.io/docs/envoy/v1.11.0/intro/version_history">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="为-kubernetes-而生的操作系统---talos">为 Kubernetes 而生的操作系统 - Talos&lt;/h2>
&lt;p>正如该项目的介绍中说的 &lt;a href="https://github.com/talos-systems/talos">Talos&lt;/a> 是一款现代操作系统，旨在提供安全，不可变和最小的功能。所有系统管理都是通过 API 完成的，没有 shell 或交互式控制台。&lt;/p>
&lt;p>Talos 提供的一些功能和好处包括:&lt;/p>
&lt;ul>
&lt;li>Security：Talos 通过实践最小特权原则（PoLP）并通过相互 TLS（mTLS）身份验证来保护 API 来减少攻击面。&lt;/li>
&lt;li>Predictability：Talos 通过采用不可变的基础架构意识形态来消除不必要的变量并减少环境中的未知因素。&lt;/li>
&lt;li>Evolvability：Talos 简化了你的架构，提高了轻松适应未来变化的能力。&lt;/li>
&lt;/ul>
&lt;p>这个项目其实挺有意思的，它示例中的做法其实很像我们的 &lt;a href="https://github.com/kubernetes-sigs/kind">Kubernetes In Docker&lt;/a> 项目。我也会持续关注它的发展。&lt;/p>
&lt;p>我会在近期分享一篇关于这类操作系统的文章(flag+1) ，大概内容就是关于 k3os， Talos, 曾经的 CoreOS 之类的操作系统的介绍和分析吧，敬请期待。&lt;/p>
&lt;h2 id="分享一个工具---kubectl-bindrole">分享一个工具 - kubectl-bindrole&lt;/h2>
&lt;p>&lt;a href="https://github.com/Ladicle/kubectl-bindrole">kubectl-bindrole&lt;/a> 是一款 kubectl 插件，可用于帮助查找 Kubernetes 集群中指定 SA/Group/User 的权限等信息。&lt;/p>
&lt;p>可以直接在项目的 &lt;a href="https://github.com/Ladicle/kubectl-bindrole/releases">Relase 页面&lt;/a>进行下载安装。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl bindrole -n kube-system kube-proxy
ServiceAccount: kube-system/kube-proxy
Secrets:
• */kube-proxy-token-2f5ll
Policies:
• Name: */system:node-proxier
Resource Name Exclude Verbs G L W C U P D DC
endpoints [*] [-] [-] ✖ ✔ ✔ ✖ ✖ ✖ ✖ ✖
events [*] [-] [-] ✖ ✖ ✖ ✔ ✔ ✔ ✖ ✖
nodes [*] [-] [-] ✔ ✖ ✖ ✖ ✖ ✖ ✖ ✖
services [*] [-] [-] ✖ ✔ ✔ ✖ ✖ ✖ ✖ ✖
(MoeLove) ➜ ~ kubectl bindrole -n kube-system node-controller
ServiceAccount: kube-system/node-controller
Secrets:
• */node-controller-token-kfgf2
Policies:
• Name: */system:controller:node-controller
Resource Name Exclude Verbs G L W C U P D DC
events [*] [-] [-] ✖ ✖ ✖ ✔ ✔ ✔ ✖ ✖
nodes [*] [-] [-] ✔ ✔ ✖ ✖ ✔ ✔ ✔ ✖
nodes/status [*] [-] [-] ✖ ✖ ✖ ✖ ✔ ✔ ✖ ✖
pods [*] [-] [-] ✖ ✔ ✖ ✖ ✖ ✖ ✔ ✖
pods/status [*] [-] [-] ✖ ✖ ✖ ✖ ✔ ✖ ✖ ✖
&lt;/code>&lt;/pre>&lt;p>在终端下它看起来是这样：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kubectl-bindrole.png" alt="kubectl-bindrole preview - moelove.info">&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-07-01~2019-07-07</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/07/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-01~2019-07-07/"/><id>https://moelove.info/2019/07/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-07-01~2019-07-07/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-07-07T23:20:10+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.16 发布周期开始 随……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v116-发布周期开始">Kubernetes v1.16 发布周期开始&lt;/h2>
&lt;p>随着前段时间 Kubernetes v1.15 的发布，v1.16 的发布周期开始了。本次的发布周期一如往常，本月底增强功能冻结，下月底代码冻结，9 月初完善文档，计划在 9 月中发布 v1.16 版本。&lt;/p>
&lt;p>其实按这个节奏看得话，大家如果需要维护生产中的 Kubernetes 集群的话，还是尽快测试验证并完成升级，以免所用版本 EOL，带来一些其他的问题。&lt;/p>
&lt;h2 id="knative-serving-v07x-发布">Knative Serving v0.7.x 发布&lt;/h2>
&lt;p>本周 Knative Serving 发布了 v0.7.1 版本，Knative 近期的开发还是比较活跃的。&lt;/p>
&lt;p>需要注意的是若使用 v0.7.x 版本中新增的 &lt;code>serving.knative.dev/v1beta1&lt;/code> API 的话，则需要 Kubernetes v1.14 版本以上。具体原因请参考 &lt;a href="https://github.com/knative/serving/issues/4533">#4533&lt;/a>&lt;/p>
&lt;p>Non-root 容器：在这个版本中所有发布的容器均以非 root 用户运行，这使得我们可以使用更严格的 PSP。&lt;/p>
&lt;p>当然此版本中也包含一些破坏性变更，比如 status 字段废弃。&lt;/p>
&lt;p>关于此版本更多的细节请参考 &lt;a href="https://github.com/knative/serving/releases/tag/v0.7.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="debian-10-buster-正式发布">Debian 10 buster 正式发布&lt;/h2>
&lt;p>Debian 10 正式发布了，其实按一般的角度来看，Linux 的一个发行版发布不会出现在 K8S 生态周报中的。&lt;/p>
&lt;p>但这里有个需要注意的点，对于使用此版本部署 Kubernetes 时，需要注意一下。此版本中使用的 &lt;code>systemd&lt;/code> 版本是 241.5 而这个版本中有个对于使用 Kubernetes 而言值得注意的点。&lt;/p>
&lt;p>这个版本的 systemd 可能会破坏 LXD 容器的网络，表现在可能无法生成 MAC 地址上。（我猜测现在关注 LXD 的用户没有那么多了，这里我也就不过多解释了。）当然这个问题同样也可能会出现在使用 Docker/runc/cri-o 等容器运行时的场景中。&lt;/p>
&lt;p>最后，还是庆祝一下 Debian 10 的正式发布，此版本内核也已经升级到了 4.19 。并且这个版本也有很多的改善和升级。具体内容可参考其 &lt;a href="https://www.debian.org/releases/buster/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="nginx-ingress-controller-151-发布">NGINX Ingress Controller 1.5.1 发布&lt;/h2>
&lt;p>NGINX Ingress Controller 是由 NGINX 社区开发的 Ingress Controller 相比于 Kubernetes 的 Nginx Ingress Controller 而言主要区别如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Aspect or Feature&lt;/th>
&lt;th>kubernetes/ingress-nginx&lt;/th>
&lt;th>nginxinc/kubernetes-ingress with NGINX&lt;/th>
&lt;th>nginxinc/kubernetes-ingress with NGINX Plus&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Fundamental&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Authors&lt;/td>
&lt;td>Kubernetes community&lt;/td>
&lt;td>NGINX Inc and community&lt;/td>
&lt;td>NGINX Inc and community&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NGINX version&lt;/td>
&lt;td>&lt;a href="https://github.com/kubernetes/ingress-nginx/tree/master/images/nginx">Custom&lt;/a> NGINX build that includes several third-party modules&lt;/td>
&lt;td>NGINX official mainline &lt;a href="https://github.com/nginxinc/docker-nginx">build&lt;/a>&lt;/td>
&lt;td>NGINX Plus&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Commercial support&lt;/td>
&lt;td>N/A&lt;/td>
&lt;td>N/A&lt;/td>
&lt;td>Included&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Load balancing configuration via the Ingress resource&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Merging Ingress rules with the same host&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported via &lt;a href="../examples/mergeable-ingress-types">Mergeable Ingresses&lt;/a>&lt;/td>
&lt;td>Supported via &lt;a href="../examples/mergeable-ingress-types">Mergeable Ingresses&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HTTP load balancing extensions - Annotations&lt;/td>
&lt;td>See the &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md">supported annotations&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="configmap-and-annotations.md">supported annotations&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="configmap-and-annotations.md">supported annotations&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HTTP load balancing extensions -- ConfigMap&lt;/td>
&lt;td>See the &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/configmap.md">supported ConfigMap keys&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="configmap-and-annotations.md">supported ConfigMap keys&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="configmap-and-annotations.md">supported ConfigMap keys&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TCP/UDP&lt;/td>
&lt;td>Supported via a ConfigMap&lt;/td>
&lt;td>Supported via a ConfigMap with native NGINX configuration&lt;/td>
&lt;td>Supported via a ConfigMap with native NGINX configuration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Websocket&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported via an &lt;a href="../examples/websocket">annotation&lt;/a>&lt;/td>
&lt;td>Supported via an &lt;a href="../examples/websocket">annotation&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TCP SSL Passthrough&lt;/td>
&lt;td>Supported via a ConfigMap&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JWT validation&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Session persistence&lt;/td>
&lt;td>Supported via a third-party module&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Canary testing (by header, cookie, weight)&lt;/td>
&lt;td>Supported via annotations&lt;/td>
&lt;td>Supported via custom resources&lt;/td>
&lt;td>Supported via custom resources&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Configuration templates *1&lt;/td>
&lt;td>See the &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/rootfs/etc/nginx/template/nginx.tmpl">template&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="../internal/configs/version1">templates&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="../internal/configs/version1">templates&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Load balancing configuration via Custom Resources&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HTTP load balancing&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>See &lt;a href="virtualserver-and-virtualserverroute.md">VirtualServer and VirtualServerRoute&lt;/a> resources.&lt;/td>
&lt;td>See &lt;a href="virtualserver-and-virtualserverroute.md">VirtualServer and VirtualServerRoute&lt;/a> resources.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Deployment&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Command-line arguments *2&lt;/td>
&lt;td>See the &lt;a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/cli-arguments.md">arguments&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="cli-arguments.md">arguments&lt;/a>&lt;/td>
&lt;td>See the &lt;a href="cli-arguments.md">arguments&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TLS certificate and key for the default server&lt;/td>
&lt;td>Required as a command-line argument/ auto-generated&lt;/td>
&lt;td>Required as a command-line argument&lt;/td>
&lt;td>Required as a command-line argument&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Helm chart&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Operational&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Reporting the IP address(es) of the Ingress controller into Ingress resources&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Extended Status&lt;/td>
&lt;td>Supported via a third-party module&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Prometheus Integration&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Dynamic reconfiguration of endpoints (no configuration reloading)&lt;/td>
&lt;td>Supported with a third-party Lua module&lt;/td>
&lt;td>Not supported&lt;/td>
&lt;td>Supported&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>内容来源：&lt;a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md">NGINX Ingress Controller 文档&lt;/a>&lt;/em>&lt;/p>
&lt;p>本次发布的 1.5.1 将 NGINX 版本更新到了 1.17.1 ，升级时可直接使用 &lt;code>nginx/nginx-ingress:1.5.1&lt;/code> 或 &lt;code>nginx/nginx-ingress:1.5.1-alpine&lt;/code> 也可直接使用 0.3.1 的 Helm Chart&lt;/p>
&lt;p>更多信息请参考 &lt;a href="https://github.com/nginxinc/kubernetes-ingress/releases/tag/v1.5.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-上游进展">Kubernetes 上游进展&lt;/h2>
&lt;p>来说一点上游开发的进展吧&lt;/p>
&lt;ul>
&lt;li>
&lt;p>新增了 &lt;code>Runtimeclass&lt;/code> 的准入控制，通过这个新的特性，我们可以计算和 Pod 的 sanbox 绑定的资源了, 参见 &lt;a href="https://github.com/kubernetes/kubernetes/pull/78484">78484&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新增了对在每个节点上可部署的每个卷类型的数量的限制, 参见 &lt;a href="https://github.com/kubernetes/kubernetes/pull/77595">77595&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kubeadm 修复了一个 &lt;code>reset&lt;/code> 命令时候使用错误的函数, 参见 &lt;a href="https://github.com/kubernetes/kubernetes/pull/79326">79326&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-06-24~2019-06-30</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/06/30/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-24~2019-06-30/"/><id>https://moelove.info/2019/06/30/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-24~2019-06-30/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-06-30T23:12:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 kind (Kubernetes In Docker) v0.4.0 正式发布……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-kubernetes-in-docker-v040-正式发布">kind (Kubernetes In Docker) v0.4.0 正式发布&lt;/h2>
&lt;p>kind (Kubernetes In Docker) 是我很喜欢并且一直持续参与贡献的项目，本周发布了 v0.4.0 版本。关于 Kind 的介绍和基础使用，可以参考我之前写的文章 &lt;a href="https://zhuanlan.zhihu.com/p/60464867">《使用 Kind 搭建你的本地 Kubernetes 集群》&lt;/a>&lt;/p>
&lt;p>v0.4.0 版本中，默认的 Kubernetes 版本升级到了 v1.15 版本，且 &lt;code>kind.sigs.k8s.io/v1alpha2&lt;/code> 版本的 API 已经过期，请更新使用 &lt;code>kind.sigs.k8s.io/v1alpha3&lt;/code> 。&lt;/p>
&lt;p>目前暂时移除了使用 &lt;code>apt&lt;/code> 构建 Node 镜像的选项，之后版本中可能会加回来，直接使用上游构建好的二进制文件进行安装。&lt;/p>
&lt;p>在此版本中，我们增加了一个 &lt;code>nodes[].extraPortMappings&lt;/code> 的配置，可以直接通过此配置进行端口的转发，以便从宿主机上直接访问到集群上使用 &lt;code>NodePort&lt;/code> 方式部署的服务，这样更容易模拟真实的网络环境，否则只能通过其他的转发或者网络代理的方式来进行通信了。&lt;/p>
&lt;p>同样的，紧跟着上游的开放，这个版本中也增加了对 IPv6 的支持，可以直接通过 &lt;code>networking.ipFamily&lt;/code> 的配置进行使用。&lt;/p>
&lt;p>为了能让 kind 更加易用，且满足多数 CI 或者测试使用的场景，在这个版本中，我们尤其对单节点集群的启动时间做了优化，可以更快速的启动集群。&lt;/p>
&lt;p>顺便公布一个数据，kind 目前的 star 数是 2.2k 上个版本发布时是 1.8k 并且还在持续增长中 :)&lt;/p>
&lt;p>更多的细节和信息请参考 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.4.0">ReleaseNote&lt;/a> 欢迎大家使用！&lt;/p>
&lt;h2 id="docker-ce-18097-发布">Docker CE 18.09.7 发布&lt;/h2>
&lt;p>这是一个例行的 bugfix 版本，此版本中包含两个比较重要的修复：&lt;/p>
&lt;ul>
&lt;li>修复了构建系统在构建只含有注释的 Dockerfile 的时候的 panic&lt;/li>
&lt;li>修复了 CVE-2018-15664 漏洞，关于此漏洞的说明请参考&lt;a href="https://zhuanlan.zhihu.com/p/67674642">我之前的文章&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>关于此版本的更多信息，请参考 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v18.09.7">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="linkerd2-edge-1964-发布">Linkerd2 Edge 19.6.4 发布&lt;/h2>
&lt;p>Linkerd2 有两个主要发布通道，除去 Stable 外便是 Edge 通道。Edge 版本主要集中在新功能发布上，发布其实比较频繁的。&lt;/p>
&lt;p>在这个版本中最主要的特性在于支持了 &lt;a href="https://github.com/deislabs/smi-spec/blob/master/traffic-split.md">SMI 的 流量切割 API&lt;/a>。&lt;/p>
&lt;p>当创建了 TrafficSplit 资源后，Linkerd 便可根据配置对流量进行切割。&lt;/p>
&lt;p>先暂且不说这个功能到底如何，只说 Linkerd 支持 SMI 这个事情，就已经是在往好的方面走了，这很有利于 SMI 的标准化推进。&lt;/p>
&lt;p>关于此版本的更多信息，请参考 &lt;a href="https://github.com/linkerd/linkerd2/releases/tag/edge-19.6.4">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-122-发布">Istio 1.2.2 发布&lt;/h2>
&lt;p>最近 Istio 发布很频繁，包括 1.0.9、1.1.10 和 1.2.1 都是在本周内发布的。&lt;/p>
&lt;p>其实主要内容都是 bugfix 但也有一些特性的增加，比如允许通过设置为 0 以禁止 Istio 默认的重试次数。&lt;/p>
&lt;p>这里不做太多展开了，关于此版本的更多信息，请参考 &lt;a href="https://istio.io/about/notes/1.2.2/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="coredns-151-正式发布">CoreDNS 1.5.1 正式发布&lt;/h2>
&lt;p>CoreDNS 发布了 1.5.1 版本，此版本中包含了不少的 bugfix，当然也有些特性增强。&lt;/p>
&lt;p>此版本增加了一个新的 &lt;code>any&lt;/code> 插件，可以通过此插件禁止任意的查询。&lt;/p>
&lt;p>修复了重启时的问题，当重启或者配置文件不规范的时候， &lt;code>ready&lt;/code> &lt;code>health&lt;/code> 和 &lt;code>prometheus&lt;/code> 插件等都将继续工作。&lt;/p>
&lt;p>需要注意的是，增加了对客户端 TLS 证书的验证，不过此版本中并没有更改默认行为，预期在 1.6 版本中，会将 TLS 的默认行为修改为 &lt;code>required_and_verify&lt;/code> 。&lt;/p>
&lt;p>关于此版本的更多信息，请参考 &lt;a href="https://coredns.io/2019/06/26/coredns-1.5.1-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-06-17~2019-06-23</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/06/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-17~2019-06-23/"/><id>https://moelove.info/2019/06/22/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-17~2019-06-23/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-06-22T23:23:17+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.15.0 正式发布 经过了……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v1150-正式发布">Kubernetes v1.15.0 正式发布&lt;/h2>
&lt;p>经过了三个月左右的开发，Kubernetes v1.15.0 正式发布了。&lt;/p>
&lt;p>这是 2019 年 Kubernetes 发布的第二个版本，这个版本由 25 个增强功能组成，其中 2 个移动到 stable ，13 个 beta 以及 10 个 alpha ，整体上集中于稳定性改进和扩展的增强。&lt;/p>
&lt;p>CRD (Custom Resource Definition) 是 Kubernetes 提供的一种可用于扩展其能力的方式，当前有很多使用 CRD 构建于 Kubernetes 上的平台/系统，可以说之后对 Kubernetes 的扩展，或者说想要基于 Kubernetes 开发，同时又想与上游保持同步的话，CRD 是个最佳的选择。&lt;/p>
&lt;p>Kubeadm 在此版本开始有了自己独立的 LOGO ，同时在这个版本中 kubeadm 的功能也得到了很多的完善和补充。这使得 kubeadm 成为更普遍/更好用的搭建集群的工具，同时对集群生命周期的管理也做的更加到位了。这部分的功能我很喜欢也一直在关注，近期我会针对这部分写篇文章出来。感兴趣的朋友们可以&lt;a href="https://gitbook.cn/gitchat/activity/5d0b4ed9a81a44231ac6c9ba">关注下&lt;/a>&lt;/p>
&lt;p>关于此版本更多的介绍，可参考 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.15.0">Kubernetes v1.15 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-120-正式发布">Istio 1.2.0 正式发布&lt;/h2>
&lt;p>经过三个 rc 版本之后， Istio 1.2.0 版本正式发布。&lt;/p>
&lt;p>在这个版本中，它添加了对 Kubernetes IPv6 的实验性支持。Kind （Kubernetes in Docker） 项目也是本周内刚增加了 IPv6 的支持 :)&lt;/p>
&lt;p>同时在这个版本中，自签名证书的有效期也被设置成了 10 年，这可以大大避免很多人的担忧，有利于促进用户的使用。&lt;/p>
&lt;p>此外它还对很多功能做了升级，同时它也增加了对 CRD 的验证之类的。&lt;/p>
&lt;p>感兴趣的朋友可以阅读 &lt;a href="https://istio.io/about/notes/1.2/">Istio 1.2.0 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="alpine-linux-310-正式发布">Alpine Linux 3.10 正式发布&lt;/h2>
&lt;p>Alpine Linux 凭借其安全及体积小等优势，在容器化时代带来了一大批的支持者，现在社区发展也算比较活跃。&lt;/p>
&lt;p>这次发布了 3.10 版本，各类软件包都已经升级到了最新版，同时漏洞也会相对少一点。&lt;/p>
&lt;p>感兴趣的朋友可以参考 &lt;a href="https://alpinelinux.org/posts/Alpine-3.10.0-released.html">Alpine Linux 3.10 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubecon--cloudnativecon-将在上海召开">KubeCon + CloudNativeCon 将在上海召开&lt;/h2>
&lt;p>2019年，KubeCon + CloudNativeCon 和 Open Source Summit 将在上海世博中心举办为期三天的大会，届时会有很多 CNCF 项目的维护者参与，也会有国内外公司的技术分享，值得关注。&lt;/p>
&lt;p>写这篇 k8s 周报的时候，我已经在上海了。会和大家分享一些我的所见所闻及了解到的信息。 也期待和很多一直合作/网络交流的朋友们面基下。&lt;/p>
&lt;p>大会日程： &lt;a href="https://www.lfasiallc.com/events/kubecon-cloudnativecon-china-2019/">https://www.lfasiallc.com/events/kubecon-cloudnativecon-china-2019/&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-06-10~2019-06-16</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/06/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-10~2019-06-16/"/><id>https://moelove.info/2019/06/16/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-10~2019-06-16/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-06-16T23:17:17+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Helm 新下载域名正式上……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="helm-新下载域名正式上线">Helm 新下载域名正式上线&lt;/h2>
&lt;p>&lt;a href="https://get.helm.sh/">https://get.helm.sh/&lt;/a> 正式上线。用户之后下载 Helm 预编译好的二进制文件时，可通过此域名进行下载。&lt;/p>
&lt;p>原来 Kubernetes 尚未成为 CNCF 托管项目时，Helm 是作为 Kubernetes 项目的一部分的，所以很自然的使用了 Google 的一个云存储仓库。但随着项目托管至 CNCF 以及后续 Helm 的独立发展，现在使用托管于 Google 的云存储不那么合适了，一方面在于 CNCF 正在接管 K8S 的基础设施，另一方面在于在于这个仓库不只受 Helm 的控制。&lt;/p>
&lt;p>考虑到项目的独立性，以及 &lt;strong>大陆用户无法正常访问 GCloud 存储的问题&lt;/strong> 经过维护者们的慎重考虑以及实际测试，终于决定选择 Azure 的 Blob 存储 + CDN 可满足当前所有地区的快速访问（尤其是国内可以直接访问并下载），不再需要花费时间精力解决网络等问题了。&lt;/p>
&lt;p>&lt;strong>这次的更改仅限于 Helm 客户端的下载位置，类似 Tiller 或者 Chart 等并没有被包含在内。&lt;/strong>&lt;/p>
&lt;p>强烈建议更新有在 CI/自动化任务中使用的 Helm 下载地址，使用 &lt;a href="https://get.helm.sh/">https://get.helm.sh/&lt;/a> 来进行替换。&lt;/p>
&lt;p>对此内容感兴趣的朋友可参考 &lt;a href="https://github.com/helm/helm/issues/5663">Move Helm Downloads&lt;/a> 的讨论&lt;/p>
&lt;h2 id="apple-作为白金终端用户成员加入-cncf">Apple 作为白金终端用户成员加入 CNCF&lt;/h2>
&lt;p>Apple 在 K8S 社区中在这之前也算相对低调，并没有像各类云厂商或其他公司那样疯狂安利或者输出之类的。但是这次突然加入 CNCF 而且作为白金会员，是可具备话语权的。&lt;/p>
&lt;p>之后会有什么动作，目前不得而知，但是随着 Apple 作为白金会员加入，对于 CNCF 当然是件利好的事情，期待后续的进展。&lt;/p>
&lt;p>对此内容感兴趣的朋友可参考 &lt;a href="https://www.cncf.io/blog/2019/06/11/apple-joins-cloud-native-computing-foundation-as-platinum-end-user-member/">Apple Join CNCF&lt;/a> 的官方说明。&lt;/p>
&lt;h2 id="containerd-127-正式发布">containerd 1.2.7 正式发布&lt;/h2>
&lt;p>这个版本其实也是个 patch 版本，但其中也包含了一些比较重要的特性。&lt;/p>
&lt;p>这个版本支持了 OCI 镜像描述符的注解支持；包括了对 containerd shim 日志、容器的启/停、cri 插件和 SELinux 的一些修复。&lt;/p>
&lt;p>另外包含了一些 fd 和 goroutine 泄漏的修复。&lt;/p>
&lt;p>以及 runc 也终于更新到了 v1.0.0-rc8 之后使用 containerd 的朋友们需要特别关注内核版本以及 SELinux 相关的配置等信息。&lt;/p>
&lt;p>对此内容感兴趣的朋友可参考 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.2.7">containerd v1.2.7 ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-v1150-rc1-发布">Kubernetes v1.15.0-rc1 发布&lt;/h2>
&lt;p>仍然是例行的正式发布前的 rc 版本，但有几个点尤其需要注意。&lt;/p>
&lt;ul>
&lt;li>CoreDNS 回滚到了 1.3.1 版本。这是由于 1.5.0 配置合并的问题，等之后有空再来介绍这个，当然如果没有对 CoreDNS 单个组件有太多其他需求或者持续追求新版本的话，这个问题也可以跳过；&lt;/li>
&lt;li>&lt;code>ResourceQuotaScopeSelectors&lt;/code> 的特性又由 GA 退回到了 Beta 版本，由想要尝试的小伙伴要注意。&lt;/li>
&lt;/ul>
&lt;p>对此内容感兴趣的朋友可参考 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.15.0-rc.1">Kubernetes v1.15.0-rc1 ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-06-03~2019-06-09</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/06/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-03~2019-06-09/"/><id>https://moelove.info/2019/06/09/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-06-03~2019-06-09/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-06-09T22:15:11+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes CVE-2019-11245 漏洞 这是一个评……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-cve-2019-11245-漏洞">Kubernetes CVE-2019-11245 漏洞&lt;/h2>
&lt;p>这是一个评分为 4.9 的漏洞，算是一个中等漏洞。 &lt;strong>受此漏洞影响的版本为 v1.13.6 和 v1.14.2&lt;/strong> ，所以本周也加紧发布了 v1.13.7 和 v1.14.3 版本，以避免受此漏洞影响。 如果有使用 v1.13.6 和 v1.14.2 版本的小伙伴，请尽快进行 &lt;strong>升级&lt;/strong> 以免受到影响。&lt;/p>
&lt;p>上面说了最直接的解决办法，接下来对此漏洞大致做下介绍：&lt;/p>
&lt;p>这个漏洞影响了 v1.13.6 和 v1.14.2 版本的 &lt;code>kubelet&lt;/code>，具体表现为， 1) 如果 Pod 中的容器，开始时是以某个非 root 用户启动的，但是当它重启后，则会以 root (uid 0) 的身份启动。2) 或者是 Node 节点上已经存在了启动容器所需的镜像。&lt;/p>
&lt;p>第 2 个情况比较常见，不再具体介绍。我们来看下第 1 种情况。举个栗子：&lt;/p>
&lt;p>通常情况下，如果我们使用 Docker 官方的 Redis 镜像进行部署的时候，默认情况下将会以 &lt;code>redis&lt;/code> 用户启动；而如果受此漏洞影响，当容器重启后，则当前的用户可能会变成 root (uid 0) 。使用 root 用户启动服务可能带来的危害，这里也不再多进行展开了。&lt;/p>
&lt;p>也存在例外，比如已经显式的通过 &lt;code>runAsUser&lt;/code> 指定了运行用户，则不会受到此漏洞影响。&lt;/p>
&lt;p>所以除了开头说的升级到 v1.13.7 或者 v1.14.3 版本外，也可以通过显式的指定 &lt;code>runAsUser&lt;/code> 以缓解此漏洞的影响。&lt;/p>
&lt;p>更多信息可访问 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.13.md#v1137">v1.13.7 ReleaseNote&lt;/a> &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#changelog-since-v1142">v1.14.3 ReleaseNote&lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/issues/78308">CVE-2019-11245 issues&lt;/a>&lt;/p>
&lt;h2 id="docker-cve-2018-15664-已经解决">Docker CVE-2018-15664 已经解决&lt;/h2>
&lt;p>在上周的 &lt;a href="https://zhuanlan.zhihu.com/p/67674642">K8S 周报&lt;/a> 中，我提到了 &lt;strong>Docker CVE-2018-15664 安全漏洞&lt;/strong> , 当时国内很多自媒体发布了各种看起来很可怕的标题（这里就不举例了），实际上那个漏洞的影响正如我说的那样并没有特别大。&lt;/p>
&lt;p>现在该漏洞已经修复，并将移植到 Docker 18.09 和 19.03 版本中，本周发布的 Docker 19.03-rc2 就已经包含了此项修复。&lt;/p>
&lt;p>感兴趣的朋友可阅读关于 &lt;a href="https://github.com/moby/moby/pull/39292">CVE-2018-15664 的相关讨论&lt;/a>&lt;/p>
&lt;h2 id="docker-1903-rc2-发布">Docker 19.03-rc2 发布&lt;/h2>
&lt;p>这仍然是一个正式版本发布前的常规测试版本，正如上面提到的，这个版本中包含了对 CVE-2018-15664 的修复。同时在此版本中，还包含了构建系统中，可能导致错误的一些 bug 。&lt;/p>
&lt;p>对此版本有兴趣的朋友可阅读 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.0-rc2">19.03-rc2 ReleaseNote&lt;/a>; 对 Docker 构建系统有兴趣的朋友可以阅读我写的 &lt;a href="https://moelove.info/2019/06/01/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%89%E9%83%A8%E6%9B%B2/">Docker 构建三部曲&lt;/a>&lt;/p>
&lt;h2 id="istio-120-rc0-发布">Istio 1.2.0-rc.0 发布&lt;/h2>
&lt;p>这个版本的变动其实还算比较大，但这里暂时先不介绍了，还在持续迭代中，具体的介绍我等正式版发布后再介绍好了。&lt;/p>
&lt;p>这里只说一个可能很多用户都会在意的改动，Istio 中自签的 CA 根证书默认有效期是 1 年，但是在 1.2 中，有效期已经修改成了默认 10 年。大概这个改动能免除一些用户的担忧。&lt;/p>
&lt;p>对此版本感兴趣的朋友可以在 &lt;a href="https://github.com/istio/istio/releases/tag/1.2.0-rc.0">Istio 1.2.0-rc.0 的 Release 页面&lt;/a> 进行尝鲜体验&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">Docker 镜像构建三部曲</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/06/01/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%89%E9%83%A8%E6%9B%B2/"/><id>https://moelove.info/2019/06/01/Docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%89%E9%83%A8%E6%9B%B2/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-06-01T00:19:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">我最近在 GitChat 写了一些 Docker 构建镜像相关的文章，这个系列写了三篇，通过这三篇将 Docker 构建镜像相关的事情基本就讲明白了，感兴趣的朋友扫描二维码……</summary><content type="html">&lt;blockquote>
&lt;p>我最近在 GitChat 写了一些 Docker 构建镜像相关的文章，这个系列写了三篇，通过这三篇将 Docker 构建镜像相关的事情基本就讲明白了，感兴趣的朋友扫描二维码或者点击链接即可。&lt;/p>
&lt;/blockquote>
&lt;h2 id="高效构建-docker-镜像的最佳实践">高效构建 Docker 镜像的最佳实践&lt;/h2>
&lt;p>Docker 可谓是开启了容器化技术的新时代，现在无论大中小公司基本上都对容器化技术有不同程度的尝试，或是已经进行了大量容器化的改造。伴随着 Kubernetes 和 Cloud Native 等技术和理念的普及，也大大增加了业务容器化需求。&lt;/p>
&lt;p>而这一切的推进，不可避免的技术之一便是构建容器镜像。&lt;/p>
&lt;p>在本场 Chat 中，会讲到如下内容：&lt;/p>
&lt;ul>
&lt;li>Docker 镜像是什么&lt;/li>
&lt;li>Docker 镜像常规管理操作&lt;/li>
&lt;li>如何构建 Docker 镜像&lt;/li>
&lt;li>逐步分解构建 Docker 镜像的最佳实践&lt;/li>
&lt;li>如何提升构建效率&lt;/li>
&lt;/ul>
&lt;p>适合人群： 对高效构建 Docker 镜像有兴趣的技术人员&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-chat-1.jpg" alt="高效构建 Docker 镜像的最佳实践">&lt;/p>
&lt;p>地址：https://gitbook.cn/gitchat/activity/5cd527e864de19331ba79278&lt;/p>
&lt;h2 id="进阶dockerfile-高阶使用指南及镜像优化">进阶：Dockerfile 高阶使用指南及镜像优化&lt;/h2>
&lt;p>在上次的 Chat &lt;a href="https://gitbook.cn/gitchat/activity/5cd527e864de19331ba79278">高效构建 Docker 镜像的最佳实践&lt;/a> 中，我们重点深入内部介绍了 Docker 镜像是什么；以及构建 Docker 镜像的最佳实践等。&lt;/p>
&lt;p>即将发布的 Docker 19.03 版本中 Dockerfile 及构建系统有了很多变化。&lt;/p>
&lt;p>在本场 Chat 中，会讲到如下内容：&lt;/p>
&lt;ul>
&lt;li>Dockerfile 高阶使用及新特性解读&lt;/li>
&lt;li>Docker 19.03 构建系统解读&lt;/li>
&lt;li>Docker 镜像安全实践&lt;/li>
&lt;li>发现并优化镜像大小&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://moelove.info/img/docker-chat-2.jpg" alt="进阶：Dockerfile 高阶使用指南及镜像优化">&lt;/p>
&lt;p>地址：https://gitbook.cn/gitchat/activity/5cdc40db94539c0c5ded160c&lt;/p>
&lt;h2 id="docker-镜像构建原理及源码分析">Docker 镜像构建原理及源码分析&lt;/h2>
&lt;p>通过前两次的 Chat《高效构建 Docker 镜像的最佳实践》和《进阶：Dockerfile 高阶使用指南及镜像优化》我们对 Dockerfile 的实践、镜像优化以及 Docker 的构建系统应该有了很深层次的了解。&lt;/p>
&lt;p>本次 Chat 是继续深入 Docker 镜像的构建，结合源码分析上一代的构建系统与新一代构建系统的差异，帮你更好的掌握新一代的构建系统的特性，以及如何能更好的使用它。&lt;/p>
&lt;p>适宜人群：想深入 Docker 构建系统的开发者&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/docker-chat-3.jpg" alt="Docker 镜像构建原理及源码分析">&lt;/p>
&lt;p>地址：https://gitbook.cn/gitchat/activity/5cf026eaff33b82ee0eb425b&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-05-27~2019-06-02</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-27~2019-06-02/"/><id>https://moelove.info/2019/05/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-27~2019-06-02/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-31T07:42:37+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes v1.15.0-beta.1 发布 随着 KubeCon EU 的……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-v1150-beta1-发布">Kubernetes v1.15.0-beta.1 发布&lt;/h2>
&lt;p>随着 KubeCon EU 的结束，Kubernetes 的开发工作继续回归正常，本周相继发布了 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.12.9">v1.12.9&lt;/a> 和 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.15.0-beta.1">v1.15.0-beta.1&lt;/a>。&lt;/p>
&lt;p>随着 v1.15 的正式版临近，维护期的 Kubernetes 版本也将变成 1.12~1.15，请尽快升级。&lt;/p>
&lt;p>这个版本的变化，等正式版发布时候再进行介绍好了，有兴趣可以先看 &lt;a href="https://github.com/kubernetes/kubernetes/releases/tag/v1.15.0-beta.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-v19030-beta5-发布">Docker v19.03.0-beta5 发布&lt;/h2>
&lt;p>按照正常规律 Docker 19.03 正式版也将在近期进行发布，而最近的所有测试版本中，其实变化比较大的东西主要在 &lt;strong>构建系统&lt;/strong> 上；构建系统的升级可以使构建速度更快，同时也增加了更多的安全特性。&lt;/p>
&lt;p>这次的 beta5 也是常规修复，有兴趣可以先看 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.0-beta5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-cve-2018-15664-安全漏洞">Docker CVE-2018-15664 安全漏洞&lt;/h2>
&lt;p>在 5 月 29 日我看到了 &lt;a href="https://seclists.org/oss-sec/2019/q2/131">CVE 的信息&lt;/a>，这个漏洞会影响 Docker 的全部版本，漏洞攻击的主要途径是 &lt;code>docker cp&lt;/code> 相关的操作。&lt;/p>
&lt;p>但是不必太过紧张，因为这个漏洞的攻击范围其实不算太大；最主要可能被攻击的对象其实是公有云。对于普通用户而言，如果受此攻击，那前提是攻击者已经具备了机器的权限和 Docker 的操作权限（一般用户只要自行控制权限便可避免攻击的发生）。&lt;/p>
&lt;p>漏洞发现者 Aleksa Sarai 开始提了一个 &lt;a href="https://github.com/moby/moby/pull/39252">PR&lt;/a> (他的实现方式是在 &lt;code>docker cp&lt;/code> 操作的同时暂停容器)，不过现在已经被一个新的 &lt;a href="https://github.com/moby/moby/pull/39292">PR&lt;/a> 给取代了，毕竟暂停容器意味着停止服务，这是难以接受的。&lt;/p>
&lt;p>类似 Podman 之类的其实也存在相同的问题，不过现在也已经被修复了。&lt;/p>
&lt;p>感兴趣的朋友可以关注下 PR 的进展。&lt;/p>
&lt;h2 id="推荐阅读jaeger和opentelemetry">推荐阅读：Jaeger和OpenTelemetry&lt;/h2>
&lt;p>最近 OpenTelemetry 被宣布成为 CNCF 的 sandbox 项目，它由 OpenTracing 和 OpenCensus 合并而成。这篇文章是为了回答 OpenTelemetry 的诞生对于 Jaeger 项目的影响。&lt;/p>
&lt;p>作者预期是将 Jaeger 与 OpenTelemetry 结合，放弃一些 Jaeger 自己维护的组件，转而选择 OpenTelemetry 提供的基础组件。&lt;/p>
&lt;p>文章地址： &lt;a href="https://medium.com/jaegertracing/jaeger-and-opentelemetry-1846f701d9f2">https://medium.com/jaegertracing/jaeger-and-opentelemetry-1846f701d9f2&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-05-20~2019-05-26</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-20~2019-05-26/"/><id>https://moelove.info/2019/05/26/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-20~2019-05-26/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-26T23:24:46+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 KubeCon EU 举办 2019 年第一个……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubecon-eu-举办">KubeCon EU 举办&lt;/h2>
&lt;p>2019 年第一个 KubeCon + CloudNativeCon 于 5 月 20 ~ 23 日在巴塞罗那成功举办，这次大会吸引了七千多名参会者远超去年的参会人数。 &lt;strong>这也从另一个侧面反映了 Kubernetes 和云原生在大大的普及&lt;/strong>&lt;/p>
&lt;p>在大会上宣布了不少值得关注的信息, 我在此大致列一下我认为值得关注的信息（虽然有些内容之前已经关注到了）：&lt;/p>
&lt;ul>
&lt;li>OpenTracing, OpenCensus 合并为 OpenTelemetry；&lt;/li>
&lt;li>微软推出 Service Mesh Interface（SMI）规范；&lt;/li>
&lt;li>NGINX Ingress Controller 发布 1.5.0 版本；&lt;/li>
&lt;li>Google 宣布 GKE 将会支持 Windows Server Container；&lt;/li>
&lt;li>Helm 3 的发展历程；（推荐阅读我之前写的 &lt;a href="https://zhuanlan.zhihu.com/p/66058355">初试 Helm 3&lt;/a>）&lt;/li>
&lt;/ul>
&lt;p>当然，大会上公布的信息还有很多，还有一些 CNCF 的计划等，这里暂且不提，感兴趣的朋友可以自行搜索或者参加下个月在上海举办的 KubeCon + CloudNativeCon&lt;/p>
&lt;h2 id="微软推出-service-mesh-interface-smi">微软推出 Service Mesh Interface （SMI）&lt;/h2>
&lt;p>Service Mesh 也是一个趋势，但现在并没有一个统一的规范，各个厂商的实现也都各有不同。微软本次提出的 SMI 主要是为 Kubernetes 服务网格提供通用接口，以便能让 Service Mesh 有更加通用的规范 （就像当初 CNI/CRI 那样子）&lt;/p>
&lt;p>这里我不想引起其他问题，但 K8S 生态中还是存在着各种各样的选择，希望大家理性选择，同时需要注意的是：这个 SMI 中公布的厂商中唯独没有 Google 的存在。&lt;/p>
&lt;p>对 SMI 感兴趣的朋友，推荐阅读&lt;a href="https://cloudblogs.microsoft.com/opensource/2019/05/21/service-mesh-interface-smi-release/">官方的说明&lt;/a> ；不想看英文说明的也可以看下崔总&lt;a href="https://mp.weixin.qq.com/s?timestamp=1558886684&amp;amp;src=3&amp;amp;ver=1&amp;amp;signature=4NGtDd7kZHl9y9XxOpylxI6iGVN0p-RycPibVWX5onpgNatyNU06MSXfpQp3iKBhDrslQJtdahrxcUBK1fakeLBVXc0D1eD7GIkriqC1JxdNGb7zJya7b3mVwxbwV-cjBfbQqxjW9ipRQAwGxc3gJg*5ZfZ*viCQOlK6yR2F9CA=">对 SMI 的介绍&lt;/a>&lt;/p>
&lt;h2 id="openfaas-发布-0131">OpenFaaS 发布 0.13.1&lt;/h2>
&lt;p>OpenFaaS® (Functions as a Service) 是一个通过使用 Docker 和 Kubernetes 构建无服务函数的框架，并且具备一流的指标支持；任何流程都可以打包起来，这样可以避免编写重复的代码。&lt;/p>
&lt;p>它的特性主要包括：&lt;/p>
&lt;ul>
&lt;li>可直接通过 UI 一键安装使用&lt;/li>
&lt;li>可以任何编程语言编写项目，最终打包成容器镜像运行；&lt;/li>
&lt;li>在现有的公有云/私有云均可运行：原生支持 Kubernetes 和 Docker Swarm；&lt;/li>
&lt;li>CLI 使用 YAML 格式便于模板化和定义功能&lt;/li>
&lt;li>可进行自动扩缩容；&lt;/li>
&lt;/ul>
&lt;p>贴一个官方架构图：&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/08bc7c0c4f882ef5eadaed797388b27b1a3ca056/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4446726b46344e586f41414a774e322e6a7067" alt="OpenFaaS - moelove.info">&lt;/p>
&lt;p>本次的 Release 算是一个常规更新，发布了 watchdog 的 Docker 镜像。&lt;/p>
&lt;p>更多内容推荐阅读 &lt;a href="https://github.com/openfaas/faas/releases/tag/0.13.1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="项目推荐-kui">项目推荐： Kui&lt;/h2>
&lt;p>Kui 是 IBM 开源的一款用于云原生应用开发的可视化工具，推荐阅读 &lt;a href="https://zhuanlan.zhihu.com/p/66975768">云原生应用开发新体验：Kui&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">云原生应用开发新体验：Kui</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B0%E4%BD%93%E9%AA%8CKui/"/><id>https://moelove.info/2019/05/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B0%E4%BD%93%E9%AA%8CKui/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-24T10:19:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">云原生（Cloud Native）应用是伴随着 Kubernetes 应用范围的扩大，基于云模型而提出的一种概念。 本文来介绍一个云原生应用开发的工具 Kui, 这……</summary><content type="html">&lt;blockquote>
&lt;p>云原生（Cloud Native）应用是伴随着 Kubernetes 应用范围的扩大，基于云模型而提出的一种概念。&lt;/p>
&lt;/blockquote>
&lt;p>本文来介绍一个云原生应用开发的工具 &lt;a href="https://github.com/IBM/kui">Kui&lt;/a>, 这是一款由 IBM 开源的工具，使用 &lt;a href="https://electronjs.org/">Electron&lt;/a> 提供 GUI 能力。&lt;/p>
&lt;blockquote>
&lt;p>Kui Shell offers a new development experience for building cloud-native applications. By combining the power of familiar CLIs with visualizations in high-impact areas, Kui enables you to manipulate complex JSON and YAML data models, integrate disparate tooling, and provides quick access to aggregate views of operational data.&lt;/p>
&lt;/blockquote>
&lt;p>正如以上介绍中提到的，Kui 提供了一种新的开发体验（原先大多数时候我们是通过 &lt;code>kubectl&lt;/code> 与 Kubernetes 中的资源进行交互），Kui 结合了原有 CLI 的强大功能，并提供一种可视化的方式，方便我们对 Kubernetes 中 YAML 或者 JSON 格式数据的处理。&lt;/p>
&lt;p>介绍就先到这里，我们来看下它的安装及主体功能，看看它能为我们带来什么。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>安装方式其实很简单，项目的&lt;a href="https://github.com/IBM/kui/blob/master/docs/installation.md">安装文档&lt;/a>已经非常详细了。我主要推荐两种在 Linux 下的安装方式（当然，Kui 是支持跨平台的 macOS 和 Windows 也都可以用）：&lt;/p>
&lt;ul>
&lt;li>下载预构建好的二进制包：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>(MoeLove) ➜ wget -O kui.zip https://linux-zip.kui-shell.org/
(MoeLove) ➜ unzip kui.zip
(MoeLove) ➜ ./Kui-linux-x64/Kui shell
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>源码安装：&lt;/li>
&lt;/ul>
&lt;p>这是我最为推荐的方式，以下内容也均是以此方式安装来介绍的。 &lt;strong>注意，此方式需要你机器上已经装好了 NodeJS 相关的环境&lt;/strong>&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ git clone https://github.com/IBM/kui.git
(MoeLove) ➜ cd kui
(MoeLove) ➜ npm install
(MoeLove) ➜ export PATH=$PWD/bin/:$PATH
&lt;/code>&lt;/pre>&lt;p>在执行完上述命令后，便安装了相关的依赖，以及 &lt;code>bin&lt;/code> 目录下的 &lt;code>kubectl-kui&lt;/code> 命令会通过 &lt;code>kubectl&lt;/code> 的插件机制，自动注册好。&lt;/p>
&lt;p>通过以下命令可进行验证：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ kui git:(master) kui version
2.33.0
(MoeLove) ➜ kui git:(master) kubectl kui version
2.33.0
&lt;/code>&lt;/pre>&lt;h2 id="使用">使用&lt;/h2>
&lt;p>你的机器上需要提前配置好 &lt;code>KUBECONFIG&lt;/code> 的环境变量或者是将配置文件放到了正确的位置 i.e. &lt;code>$HOME/.kube/config&lt;/code>&lt;/p>
&lt;p>如果你还没有一个可访问的 Kubernetes 集群，强烈建议你阅读我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/60464867">使用 Kind 搭建你的本地 Kubernetes 集群&lt;/a>， Kind 是一个非常优秀也非常方便的工具。&lt;/p>
&lt;p>如果你对 Kubernetes 还不甚了解的话，也推荐阅读我写的 &lt;a href="https://zhuanlan.zhihu.com/p/53244821">《Kubernetes 从上手到实践》&lt;/a> 进行学习。&lt;/p>
&lt;p>回到正题，我们来看下 Kui 的主体功能。&lt;/p>
&lt;h3 id="可视化展示">可视化展示&lt;/h3>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-1.png" alt="Kui 可视化 - Moelove.info">&lt;/p>
&lt;p>默认情况下，如果我们没有给 &lt;code>kui&lt;/code> 传递 &lt;code>--ui&lt;/code> 参数的话，它和正常使用 &lt;code>kubectl&lt;/code> 的行为一致，仍然在终端下输出内容。&lt;/p>
&lt;p>类似这样：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ kui git:(master) kubectl kui get pods -n kube-system
NAME READY STATUS RESTARTS AGE
coredns-fb8b8dccf-292wk 1/1 Running 0 153m
coredns-fb8b8dccf-lbj2g 1/1 Running 0 153m
etcd-moelove-control-plane 1/1 Running 0 152m
kube-apiserver-moelove-control-plane 1/1 Running 0 152m
kube-controller-manager-moelove-control-plane 1/1 Running 0 152m
kube-proxy-jltdj 1/1 Running 0 153m
kube-proxy-thpq5 1/1 Running 0 153m
kube-scheduler-moelove-control-plane 1/1 Running 0 152m
weave-net-dws2l 2/2 Running 0 153m
weave-net-tt82h 2/2 Running 0 153m
&lt;/code>&lt;/pre>&lt;p>但如果我们给它传递了 &lt;code>--ui&lt;/code> 的参数，则它会打开一个新的窗口，并将内容展示出来。&lt;/p>
&lt;p>点击其中的任意资源，便可打开其详细内容：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-yaml.png" alt="Kui YAML - Moelove.info">&lt;/p>
&lt;p>底部 tab 可进行内容切换，比如可查看它的状态或者它其中的 Container 等。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-conditions.png" alt="Kui Conditions - Moelove.info">&lt;/p>
&lt;p>当然，右下角还有一个删除按钮，可用于删除此资源（没有二次确认的，请慎重）&lt;/p>
&lt;h3 id="截图">截图&lt;/h3>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-screenshot.png" alt="Kui 截图 - Moelove.info">&lt;/p>
&lt;p>在窗口的右下角有一个截图按钮，使用此按钮可以方便的对当前窗口的图像进行拷贝和保存。&lt;/p>
&lt;h3 id="交互式-shell">交互式 Shell&lt;/h3>
&lt;p>使用以下命令可以打开交互式 Shell 窗口：&lt;/p>
&lt;pre>&lt;code>kubectl kui shell
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://moelove.info/img/kui-intro-shell.png" alt="Kui Shell - Moelove.info">&lt;/p>
&lt;p>在此交互式 Shell 窗口中，你可以正常的执行你日常使用的命令：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-git.png" alt="Kui Shell - Moelove.info">&lt;/p>
&lt;p>当然除了像正常在终端中的命令输出外，如果输出内容是 JSON 或者 YAML 的话，则会自动打开 kui 的一个窗口进行展示。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-json.png" alt="Kui JSON - Moelove.info">&lt;/p>
&lt;p>左侧的 + 号可以用于新增标签。&lt;/p>
&lt;h3 id="开发部署">开发部署&lt;/h3>
&lt;p>你可以使用 &lt;strong>内置编辑器&lt;/strong> 或者任意你喜欢的编辑器编辑你的配置文件，比如我们想要部署一个 Redis 在 Kubernetes 集群中。&lt;/p>
&lt;p>你可以写一个配置文件如下：&lt;/p>
&lt;pre>&lt;code>apiVersion: apps/v1
kind: Deployment
metadata:
labels:
run: redis
name: redis
spec:
replicas: 1
selector:
matchLabels:
run: redis
strategy: {}
template:
metadata:
labels:
run: redis
spec:
containers:
- image: redis:alpine
name: redis
resources: {}
&lt;/code>&lt;/pre>&lt;p>保存为 &lt;code>deploy.yaml&lt;/code> 使用 &lt;code>open deploy.yaml&lt;/code> 即可在右侧窗口查看该内容, 并且在左侧进行部署后，也可在右侧进行管理等操作。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-deploy.png" alt="Kui deploy - Moelove.info">&lt;/p>
&lt;h3 id="易扩展">易扩展&lt;/h3>
&lt;p>项目代码比较简单，&lt;a href="https://github.com/IBM/kui/blob/master/docs/dev/custom-clients.md">文档&lt;/a>中也有开发文档，可以很方便的自信进行扩展。（不展开了）&lt;/p>
&lt;h3 id="tutorials">tutorials&lt;/h3>
&lt;p>当输入此命令后，会看到其内置的几个使用教程，更多功能可以通过此命令进行探索。&lt;/p>
&lt;p>例如这种 Preview 的功能之类的。&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/kui-intro-preview.png" alt="Kui preview - Moelove.info">&lt;/p>
&lt;p>Enjoy your Cloud Native!&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Electron/" term="Electron" label="Electron"/></entry><entry><title type="text">K8S 生态周报| 2019-05-13~2019-05-19</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-13~2019-05-19/"/><id>https://moelove.info/2019/05/19/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-13~2019-05-19/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-19T23:13:42+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 kind v0.3.0 正式发布 kind (Kubernetes In……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-v030-正式发布">kind v0.3.0 正式发布&lt;/h2>
&lt;p>kind (Kubernetes In Docker) 是我很喜欢并且一直持续参与贡献的项目，本周发布了 v0.3.0 版本。关于 Kind 的介绍和基础使用，可以参考我之前写的文章 &lt;a href="https://zhuanlan.zhihu.com/p/60464867">《使用 Kind 搭建你的本地 Kubernetes 集群》&lt;/a>&lt;/p>
&lt;p>本次的发布主要侧重于加速集群的启动速度及提高稳定性，优化镜像大小，以及对网络的优化和一些 bugfix 等；其中最主要的内容是将默认的 CRI 从 Docker 换成了 Containerd，以此可以缩小镜像体积，以及加快集群的启动。&lt;/p>
&lt;p>v0.3.0 版本中，可以通过配置文件自行部署不同的 CNI，更有利于用户测试实际的集群情况；现在版本中已经将默认的 Kubernetes 版本升级到了最新的 v1.14.2 。&lt;/p>
&lt;p>当然，也还有一些正在增加的特性，预计会在 v0.4.0 版本中发布，主要集中于 IPv6 和集群重启的支持（相信很快就可以完成了）。&lt;/p>
&lt;p>顺便公布一个数据，Kind 目前的 star 数是 1.8k 还在持续增长中 :)&lt;/p>
&lt;p>更多的细节和信息请参考 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/v0.3.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kubernetes-v1142-正式发布">Kubernetes v1.14.2 正式发布&lt;/h2>
&lt;p>这是一个常规的 bugfix 版本，但有个值得关注的点：&lt;/p>
&lt;ul>
&lt;li>升级到了 golang v1.12.5 版本。&lt;/li>
&lt;/ul>
&lt;p>你可能要问为什么需要关注 golang 版本的升级？这是因为在此版本中 golang 有一些关于运行时的修改，尤其是其中关于二叉树查找部分的&lt;a href="https://github.com/golang/go/commit/438b1a5dae01812a2b91b648c762414d4854ccd7">修改&lt;/a>等部分的修改，可有效的降低 Kubernetes API server 的延迟。&lt;/p>
&lt;p>延迟增大的现象其实是从升级到 golang 1.12 版本之后就出现的：&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/25119199/55189408-25100400-519e-11e9-9b6e-762f3896e61c.png" alt="">&lt;/p>
&lt;p>不过经过这次升级之后，也就延迟也就降下来了，建议升级。&lt;/p>
&lt;p>更多详细信息请阅读 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#changelog-since-v1141">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="istio-117-发布">Istio 1.1.7 发布&lt;/h2>
&lt;p>常规 bugfix 版本，详细内容可阅读 &lt;a href="https://istio.io/about/notes/1.1.7/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="knative-serving-v060-正式发布">Knative Serving v0.6.0 正式发布&lt;/h2>
&lt;p>Knative 是一个基于 Kubernetes 和 Istio 支持部署 serverless 平台。本次的发布增加了 &lt;code>v1beta1&lt;/code> 版本的 API，这其实也是项目趋向稳定的一个信号。关于其具体介绍可参考官方文档，写的比较详细了 &lt;a href="https://knative.dev/docs/serving/">knative/serving&lt;/a>&lt;/p>
&lt;p>本次版本，无论是核心 API 或者是自动扩容等变化都算是比较大，具体内容请参考 &lt;a href="https://github.com/knative/serving/releases/tag/v0.6.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="推荐阅读linkerd-vs-istio-性能评测">推荐阅读：Linkerd vs Istio 性能评测&lt;/h2>
&lt;p>这是一个由 Kinvolk 发布的性能测试，算是比较中立的一个对比。我这里贴出一个延迟的对比图：&lt;/p>
&lt;p>&lt;img src="https://kinvolk.io/media/500rps-latency.png" alt="">&lt;/p>
&lt;p>感兴趣的朋友建议阅读原文 &lt;a href="https://kinvolk.io/blog/2019/05/performance-benchmark-analysis-of-istio-and-linkerd/">Performance Benchmark Analysis of Istio and Linkerd&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">初试 Helm 3</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/16/%E5%88%9D%E8%AF%95-Helm-3/"/><id>https://moelove.info/2019/05/16/%E5%88%9D%E8%AF%95-Helm-3/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-16T21:30:00+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">经过了长时间的开发，Helm 3 终于在今天发布了第一个 alpha 版本。本文将简单介绍 Helm 3 新特性。 移除 Tiller Helm 2 是 C/S 架构，主要分为客户端 helm 和服务……</summary><content type="html">&lt;blockquote>
&lt;p>经过了长时间的开发，&lt;a href="https://v3.helm.sh/">Helm 3&lt;/a> 终于在今天发布了&lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-alpha.1">第一个 alpha 版本&lt;/a>。本文将简单介绍 Helm 3 新特性。&lt;/p>
&lt;/blockquote>
&lt;h2 id="移除-tiller">移除 Tiller&lt;/h2>
&lt;p>Helm 2 是 C/S 架构，主要分为客户端 &lt;code>helm&lt;/code> 和服务端 &lt;code>Tiller&lt;/code>; 与之前版本相同，Helm 3 同样在 &lt;a href="https://github.com/helm/helm/releases">Release&lt;/a> 页面提供了预编译好的二进制文件。差别在于原先的二进制包下载下来你会看到 &lt;code>helm&lt;/code> 和 &lt;code>tiller&lt;/code> 。而 Helm 3 则只有 &lt;code>helm&lt;/code> 的存在了。&lt;/p>
&lt;p>&lt;code>Tiller&lt;/code> 主要用于在 Kubernetes 集群中管理各种应用发布的版本，在 Helm 3 中移除了 &lt;code>Tiller&lt;/code>, 版本相关的数据直接存储在了 Kubernetes 中。&lt;/p>
&lt;p>现在我们直接在一个新创建的集群上来使用 Helm。测试集群的创建可以参考我之前的文章 &lt;a href="https://zhuanlan.zhihu.com/p/60464867">使用 Kind 搭建你的本地 Kubernetes 集群&lt;/a>。&lt;/p>
&lt;p>与之前版本相同，我们需要先执行 &lt;code>helm init&lt;/code> 来进行初始化。但现在的初始化就简单了很多，不再需要给集群中部署 &lt;code>Tiller&lt;/code> 了&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ export HELM_HOME=/tmp/helm3
(MoeLove) ➜ ~ helm3 init
Creating /tmp/helm3/repository
Creating /tmp/helm3/repository/cache
Creating /tmp/helm3/plugins
Creating /tmp/helm3/starters
Creating /tmp/helm3/cache/archive
Creating /tmp/helm3/repository/repositories.yaml
Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com
$HELM_HOME has been configured at /tmp/helm3.
Happy Helming!
&lt;/code>&lt;/pre>&lt;p>原先，由于有 RBAC 的存在，我们在开始使用时，必须先创建一个 ServiceAccount 而现在 Helm 的权限与当前的 &lt;code>KUBECONFIG&lt;/code> 中配置用户的权限相同，非常容易进行控制。&lt;/p>
&lt;p>这样也大大增强了使用 Helm 的安全性。&lt;/p>
&lt;h2 id="release-名称可在不同-ns-间重用">Release 名称可在不同 ns 间重用&lt;/h2>
&lt;p>这是 Helm Release 中提到的功能。 &lt;strong>但此功能目前并不直接可用&lt;/strong> 相关 issue 也已经创建。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ helm3 list
NAME NAMESPACE REVISION UPDATED STATUS CHART
redis1 default 1 2019-05-17 00:21:06.686127031 +0800 CST deployed redis-7.1.0
redis default 1 2019-05-17 00:19:28.234013017 +0800 CST deployed redis-7.1.0
(MoeLove) ➜ ~ helm3 -n moelove install redis1 stable/redis
Error: cannot re-use a name that is still in use
&lt;/code>&lt;/pre>&lt;p>根源在于 &lt;code>namespace&lt;/code> 参数的获取实现上。&lt;/p>
&lt;p>对应代码为：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="nf">getNamespace&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">ns&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">kubeConfig&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">ToRawKubeConfigLoader&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Namespace&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">ns&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;default&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接使用 Kubeconfig 中的 Namespace 了，所以，我们可以做以下操作以使用此特性。&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ kubectl config current-context
kubernetes-admin@moelove
(MoeLove) ➜ ~ kubectl config set-context kubernetes-admin@moelove --namespace moelove
Context &amp;quot;kubernetes-admin@moelove&amp;quot; modified.
(MoeLove) ➜ ~ helm3 -n moelove install redis stable/redis
...# 省略输出
(MoeLove) ➜ ~ helm3 list
NAME NAMESPACE REVISION UPDATED STATUS CHART
redis moelove 1 2019-05-17 00:26:44.572578745 +0800 CST deployed redis-7.1.0
&lt;/code>&lt;/pre>&lt;p>可以看到，&lt;code>redis&lt;/code> 这个 release 名称可以在 &lt;code>moelove&lt;/code> 这个 Namespace 中重复使用了。&lt;/p>
&lt;h2 id="必须指定-release-名称">必须指定 release 名称&lt;/h2>
&lt;p>在 Helm 2 中，如果没有指定 release 的名称，则会自动随机生成一个名称。但是在 Helm 3 中，则必须主动指定名称，或者增加 &lt;code>--generate-name&lt;/code> 的参数。比如：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ ~ helm3 install stable/redis
Error: must either provide a name or specify --generate-name
(MoeLove) ➜ ~ helm3 install stable/redis --generate-name
...# 省略输出
(MoeLove) ➜ ~ helm3 list
NAME NAMESPACE REVISION UPDATED STATUS CHART
redis1 default 1 2019-05-17 00:21:06.686127031 +0800 CST deployed redis-7.1.0
redis-1558024567 default 1 2019-05-17 00:36:09.294632336 +0800 CST deployed redis-7.1.0
redis default 1 2019-05-17 00:19:28.234013017 +0800 CST deployed redis-7.1.0
&lt;/code>&lt;/pre>&lt;h2 id="支持将-chart-推送至-docker-镜像仓库中">支持将 Chart 推送至 Docker 镜像仓库中&lt;/h2>
&lt;p>简而言之就是使用镜像仓库同时存储 Docker 镜像和 Helm 3 Chart 不过这个功能我暂时还没验证。之后有空再验证。&lt;/p>
&lt;h2 id="移除掉了-helm-serve">移除掉了 &lt;code>helm serve&lt;/code>&lt;/h2>
&lt;p>在 Helm 2 中，可以简单的通过 &lt;code>helm serve&lt;/code> 来启动一个本地简单的 HTTP 服务，用于托管本地 local repo 中的 Chart 信息。&lt;/p>
&lt;p>不过这个功能在 Helm 3 中被移除了。可能是使用场景有限。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Helm 3 的改动还是比较大的，但是去除掉 &lt;code>Tiller&lt;/code> 的选择是非常正确的，这让集群权限的管理更加简单清晰。更多关于 Helm 3 的信息请关注 &lt;a href="https://github.com/helm/helm/releases/tag/v3.0.0-alpha.1">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Helm/" term="Helm" label="Helm"/></entry><entry><title type="text">K8S 生态周报| 2019-05-06~2019-05-12</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-06~2019-05-12/"/><id>https://moelove.info/2019/05/12/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-05-06~2019-05-12/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-12T20:47:02+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Alpine Linux Docker 镜像漏洞 CVE-2019-5021 本……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏&lt;a href="https://zhuanlan.zhihu.com/container">「k8s生态」&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="alpine-linux-docker-镜像漏洞-cve-2019-5021">Alpine Linux Docker 镜像漏洞 CVE-2019-5021&lt;/h2>
&lt;p>本周比较吓人的是 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5021">CVE-2019-5021&lt;/a>, 根据漏洞报告，自 Alpine Linux 3.3 版本开始的所有 Docker 镜像中，root 用户包含一个空密码，这可能会导致攻击者获得 root 权限，今儿造成攻击。&lt;/p>
&lt;p>&lt;strong>报告中称：受影响范围是 Alpine Linux Docker 镜像 3.3、3.4、3.5、3.6、3.7、3.8、3.9、edge 等全部版本。&lt;/strong>&lt;/p>
&lt;p>要知道由于 Alpine Linux 镜像体积较小，所以在构建 Docker 镜像时，很多人都会推荐使用 Alpine Linux 作为基础镜像；包括很多 Docker 官方镜像也基本上都提供了基于 Alpine Linux 的镜像，甚至像 Docker 镜像等是只提供了使用 Alpine Linux 作为基础镜像的版本。&lt;/p>
&lt;p>当前漏洞已经修复，更多内容请阅读 &lt;a href="https://zhuanlan.zhihu.com/p/65513733">关于 Alpine Docker 镜像漏洞 CVE-2019-5021&lt;/a> 。&lt;/p>
&lt;h2 id="istio-operator-发布-0112-版本">istio-operator 发布 0.1.12 版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/banzaicloud/istio-operator">banzaicloud/istio-operator&lt;/a> 发布 &lt;a href="https://github.com/banzaicloud/istio-operator/releases/tag/0.1.12">0.1.12&lt;/a> 版本，默认已支持 &lt;a href="https://istio.io">istio&lt;/a> 1.1.5 。（虽然截至目前 istio 发布了 1.1.6 版本，见下条）&lt;/p>
&lt;p>&lt;img src="https://github.com/banzaicloud/istio-operator/blob/release-1.1/docs/img/operator.png" alt="">&lt;/p>
&lt;h2 id="istio-发布-116-版本">istio 发布 1.1.6 版本&lt;/h2>
&lt;p>常规版本，主要在 Helm Chart 的 fix 上。更多信息请参考 &lt;a href="https://github.com/istio/istio.io/blob/a913ce8bdea28f754163b6c2c1d603fd331e50ea/content/boilerplates/notes/1.1.6.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="envoy-支持-kafka-了">Envoy 支持 Kafka 了&lt;/h2>
&lt;p>这是一个长达半年之久的 PR， 在之前 Envoy 从 CNCF 毕业时，其作者就提到过在 2019 年会增加更多协议，其中便包括对 Kafka 的支持。&lt;/p>
&lt;p>对此内容感兴趣的朋友可以参考 &lt;a href="https://github.com/envoyproxy/envoy/pull/4950">PR 内容&lt;/a>.&lt;/p>
&lt;h2 id="cni-plugins-v080-正式发布">CNI plugins v0.8.0 正式发布&lt;/h2>
&lt;p>这是一个 major release 主要支持了 CNI spec v0.4.0，增加了 CHECK 的支持, 并且添加了 6 个新插件。&lt;/p>
&lt;p>CHECK 支持允许容器运行时验证容器的网络是否正常运行，所有的官方插件都支持 CHECK。&lt;/p>
&lt;p>新的插件包括：&lt;/p>
&lt;ul>
&lt;li>bandwidth - 限制进出流量.&lt;/li>
&lt;li>firewall - 添加容器到防火墙规则.&lt;/li>
&lt;li>sbr - 将容器路由转换为基于源的路由.&lt;/li>
&lt;li>static - 分配固定的 IP 地址.&lt;/li>
&lt;li>win-bridge, win-overlay: Windows 插件.&lt;/li>
&lt;/ul>
&lt;p>更多内容，请参考 &lt;a href="https://github.com/containernetworking/plugins/releases/tag/v0.8.0">ReleaseNote&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">关于 Alpine Docker 镜像漏洞 CVE-2019-5021</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/11/%E5%85%B3%E4%BA%8E-Alpine-Docker-%E9%95%9C%E5%83%8F%E6%BC%8F%E6%B4%9E-CVE-2019-5021/"/><id>https://moelove.info/2019/05/11/%E5%85%B3%E4%BA%8E-Alpine-Docker-%E9%95%9C%E5%83%8F%E6%BC%8F%E6%B4%9E-CVE-2019-5021/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-11T21:07:10+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">关于 CVE-2019-5021 带来的一点思考。 本周比较吓人的是 CVE-2019-5021, 根据漏洞报告，自 Alpine Linux 3.3 版本开始的所有 Docker 镜像中，root 用户包含一个空密码，这可能会导致攻……</summary><content type="html">&lt;blockquote>
&lt;p>关于 CVE-2019-5021 带来的一点思考。&lt;/p>
&lt;/blockquote>
&lt;p>本周比较吓人的是 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5021">CVE-2019-5021&lt;/a>, 根据漏洞报告，自 Alpine Linux 3.3 版本开始的所有 Docker 镜像中，root 用户包含一个空密码，这可能会导致攻击者获得 root 权限，进而造成攻击。&lt;/p>
&lt;p>&lt;strong>报告中称：受影响范围是 Alpine Linux Docker 镜像 3.3、3.4、3.5、3.6、3.7、3.8、3.9、edge 等全部版本。&lt;/strong>&lt;/p>
&lt;p>要知道由于 Alpine Linux 镜像体积较小，所以在构建 Docker 镜像时，很多人都会推荐使用 Alpine Linux 作为基础镜像；包括很多 Docker 官方镜像也基本上都提供了基于 Alpine Linux 的镜像，甚至像 Docker 镜像等，是只提供了使用 Alpine Linux 作为基础镜像的版本。&lt;/p>
&lt;p>报告一出，瞬间这个消息就被传播成了 “Alpine Linux Docker 镜像不安全”/“不要再使用 Alpine Linux 了”。当然 Google 的开发者也顺便推了一次自家的 distroless 镜像。&lt;/p>
&lt;p>我们来看一下 CVE-2019-5021 到底是什么以及如何复现吧。&lt;/p>
&lt;h2 id="cve-2019-5021">CVE-2019-5021&lt;/h2>
&lt;pre>&lt;code>(MoeLove) ➜ ~ docker run --rm -it alpine:3.9
/ # grep root /etc/passwd
root:x:0:0:root:/root:/bin/ash
operator:x:11:0:operator:/root:/bin/sh
/ # grep root /etc/shadow
root:::0:::::
/ #
&lt;/code>&lt;/pre>&lt;p>以上是一个 &lt;code>alpine:3.9&lt;/code> 的镜像，我们分别来看它的 &lt;code>/etc/passwd&lt;/code> 和 &lt;code>/etc/shadow&lt;/code> 文件，很明显，此刻 &lt;code>root&lt;/code> 用户是一个空密码；并不符合预期。这样也就导致了被攻击的可能性。我们来看下如何复现攻击以及修复。&lt;/p>
&lt;h2 id="复现">复现&lt;/h2>
&lt;p>先来看下如何复现, 编写如下的 &lt;code>Dockerfile&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> alpine:3.9&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apk add --no-cache shadow&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> adduser -S moelove&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">USER&lt;/span>&lt;span class="s"> moelove&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用 &lt;code>docker build -t local/alpine:cve .&lt;/code> 构建镜像，接下来复现：&lt;/p>
&lt;pre>&lt;code>(MoeLove) ➜ cve docker run --rm -it local/alpine:cve
/ $ id
uid=100(moelove) gid=65533(nogroup) groups=65533(nogroup)
/ $ whoami
moelove
/ $ su -
4a5cc376be74:~#
4a5cc376be74:~# whoami
root
4a5cc376be74:~# grep root /etc/passwd /etc/shadow
/etc/passwd:root:x:0:0:root:/root:/bin/ash
/etc/passwd:operator:x:11:0:operator:/root:/bin/sh
/etc/shadow:root:::0:::::
&lt;/code>&lt;/pre>&lt;p>可以看到成功使用普通用户获取的 &lt;code>root&lt;/code> 权限。&lt;/p>
&lt;h2 id="修复">修复&lt;/h2>
&lt;p>&lt;strong>当前官方镜像已经修复，可直接更新对应镜像&lt;/strong>&lt;/p>
&lt;p>或是&lt;/p>
&lt;p>在 Dockerfile 中增加下面这行：&lt;/p>
&lt;pre>&lt;code>RUN sed -ie 's/^root::/root:!:/' &amp;quot;$rootfs/etc/shadow&amp;quot;
&lt;/code>&lt;/pre>&lt;p>对应于刚才容器内的操作便是：&lt;/p>
&lt;pre>&lt;code>4a5cc376be74:~# sed -ie 's/^root::/root:!:/' /etc/shadow
4a5cc376be74:~# grep root /etc/passwd /etc/shadow
/etc/passwd:root:x:0:0:root:/root:/bin/ash
/etc/passwd:operator:x:11:0:operator:/root:/bin/sh
/etc/shadow:root:!::0:::::
4a5cc376be74:~# / $ su -
Password:
su: Authentication failure
/ $ whoami
moelove
&lt;/code>&lt;/pre>&lt;h2 id="思考">思考&lt;/h2>
&lt;p>这个“漏洞” (姑且称之为漏洞吧)，是在 5 月 9 日被公布，网上的讨论其实有些言过其实。&lt;/p>
&lt;p>本身这个问题如果想要成为攻击点，其中一种方式是需要安装 &lt;code>shadow&lt;/code> 和 &lt;code>linux-pam&lt;/code> 替代 Alpine Linux 默认的 BusyBox 工具链。而在 Docker 镜像中安装 &lt;code>shadow&lt;/code> 的可能性其实很小（最起码我暂时没想到我会主动在镜像中安装 shadow 的情况）。&lt;/p>
&lt;p>在我看来，这个问题是对于默认镜像来说，问题存在，但是几乎没有触发的可能, 必须要具备上面提到的特定条件。(当然也还有另一种可能，这里不赘述了)&lt;/p>
&lt;p>另外，受影响的镜像，大多其实已经 EOL 不再进行维护了。这也同时提醒我们及时升级依赖非常重要。&lt;/p>
&lt;p>此外，关于这是不是一个漏洞的讨论其实很多，关注点在于说这些漏洞触发都是人为操作/扩展来造成的，这个事情我不想聊太多，因为即使对于其他的 Linux 发行版来说，也有很多方式能造成被攻击之类的，那这种情况算是 Linux 漏洞 还是算其他的呢？&lt;/p>
&lt;p>就先聊到这儿吧。请及时更新/修复 Alpine 相关镜像。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/></entry><entry><title type="text">K8S 生态周报| 2019-04-28~2019-05-05</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/05/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-28~2019-05-05/"/><id>https://moelove.info/2019/05/05/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-28~2019-05-05/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-05-05T21:59:07+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker Hub 只读维护 在上周……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-hub-只读维护">Docker Hub 只读维护&lt;/h2>
&lt;p>在&lt;a href="https://zhuanlan.zhihu.com/p/64157368">上周的推送&lt;/a>中，有写到 Docker Hub 用户隐私数据泄漏。受此事件影响，5 月 4 日 Docker Hub 进行升级维护，在此期间 Docker Hub 有一段时间处于只读模式，包括自动构建等服务不可用；在最后有小于 15 分钟的完全宕机时间，服务完全不可用。&lt;/p>
&lt;p>如果只是看事情表面的话，可能这就是一个由于发现“安全问题”而进行的升级/维护；但如果仔细考虑下，作为云原生服务，升级为何会有宕机的情况，为何会有服务完全不可用的时候？&lt;/p>
&lt;p>摘录一段来自本次维护的公告内容：&lt;/p>
&lt;blockquote>
&lt;p>Q: Is this maintenance related to recent Docker Hub data breach?&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>A: While we discovered unauthorized access to a single Hub database storing a subset of non-financial user data last week, which has since been remediated, we are always looking at ways to improve and enhance our security practices to protect our customers and their data. The planned maintenance for Docker Hub on Saturday May 4 is a proactive step we are taking to provide the best possible customer experience and highest level of security&lt;/p>
&lt;/blockquote>
&lt;p>本次的维护与上周用户数据泄漏有很大关系，而服务只读和有宕机情况可能主要是由于数据库的原因，毕竟这样处理可以避免很多麻烦和提供更多的保障。&lt;/p>
&lt;p>再者，本次的通知是在操作前 24 小时左右发布的，而且并没有披露细节，可能是为了避免再次被攻击，或者是在上次发现问题，经过排查之后发现了其他的问题之类的，需要及时修正（不过到目前为止，没有任何细节披露）。&lt;/p>
&lt;p>建议对于重要的镜像或者服务，尽量维护一个私有镜像源，以免在这种宕机情况下，无法进行正常的使用。&lt;/p>
&lt;p>更多内容请阅读 &lt;a href="https://success.docker.com/article/docker-hub-maintenance">Docker Hub Maintenance - May 2019&lt;/a>&lt;/p>
&lt;h2 id="docker-ce-v18096-rc1-发布">Docker CE v18.09.6-rc1 发布&lt;/h2>
&lt;p>一个常规的 bugfix 版本，包含了一个使用 buildkit 时，&lt;code>COPY&lt;/code> 和 &lt;code>ADD&lt;/code> 使用了缓存的 bug 。&lt;/p>
&lt;p>更多细节可以查看 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v18.09.6-rc1">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-enterprise-30-发布">Docker Enterprise 3.0 发布&lt;/h2>
&lt;p>在 DockerCon 上，Docker 公司正式宣布了 Docker Enterprise 3.0 这是唯一一个桌面到云的企业级容器平台，支持组织构建和分发应用，并且安全的运行应用，从混合云到边缘计算都可以。&lt;/p>
&lt;p>在国内用 Docker 企业版的公司貌似很少，但我们也可以通过此版本来了解下企业级容器平台所关注的一些重点：&lt;/p>
&lt;ul>
&lt;li>基于模板来更方便的创建容器化应用的工作流，在企业推动应用容器化的过程中，模板化工作流可以降低门槛，更容易推动应用改造；&lt;/li>
&lt;li>可立即在本地环境复制线上环境的配置，容器技术的兴起，主要是由于它可以屏蔽掉一些环境差异所带来的问题，减少运维/开发负担，但由于使用姿势的不同，现在很可能面临过去的 “在我本地跑的好好的” 这种问题，这些主要是由于配置和环境的差异造成的，应尽量避免，以及规范使用姿势；&lt;/li>
&lt;li>Docker Kubernetes Service (DKS) : Docker Enterprise 3.0 包含了 Kubernetes 1.14 ，并且包含了对 CSI 的全功能支持；&lt;/li>
&lt;li>提供了基于证书的认证；&lt;/li>
&lt;/ul>
&lt;p>更多细节请参考 &lt;a href="https://blog.docker.com/2019/04/announcing-docker-enterprise-3-0/">Announcing Docker Enterprise 3.0: Delivering High-Velocity Application Innovation&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-04-22~2019-04-28</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/04/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-22~2019-04-28/"/><id>https://moelove.info/2019/04/29/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-22~2019-04-28/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-04-29T00:36:25+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Docker Hub 用户隐私数据泄……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-hub-用户隐私数据泄漏">Docker Hub 用户隐私数据泄漏&lt;/h2>
&lt;p>&lt;strong>2019 年 4 月 25 日，Docker Hub 团队发现了对存储非财务用户数据子集的单个 Hub 数据库的未授权访问。&lt;/strong> 在发现异常后官方团队迅速采取行动并保护网站免受攻击。&lt;/p>
&lt;p>经过官方团队的调查，目前大概有 190000 帐号的敏感信息（小于总用户数的 5% ）包括用户名和哈希后的用户密码，当然也包括 GitHub 及 Bitbucket 等的用于自动构建的 Token 。&lt;/p>
&lt;p>当前的主要措施是对可能被泄漏信息的用户发送了邮件通知，对于可能泄漏哈希密码的用户发送了重置密码的邮件，并且 &lt;strong>主动&lt;/strong> 将密码失效，以及自动构建的 Token 也都被失效。( &lt;strong>所以如果你收到了 Docker Hub 团队关于此次事件的直接报告邮件，很大概率是因为你的信息已经被泄漏了&lt;/strong> )&lt;/p>
&lt;p>附上官方声明中关于此次事件的处理声明：&lt;/p>
&lt;blockquote>
&lt;p>During a brief period of unauthorized access to a Docker Hub database, sensitive data from approximately 190,000 accounts may have been exposed (less than 5% of Hub users). Data includes usernames and hashed passwords for a small percentage of these users, as well as GitHub and Bitbucket tokens for Docker autobuilds.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>We are asking users to change their password on Docker Hub and any other accounts that shared this password.&lt;/li>
&lt;li>For users with autobuilds that may have been impacted, we have revoked GitHub tokens and access keys. This means your autobuilds will fail, and we ask that you reconnect to your repositories and check security logs to see if any unexpected actions have taken place.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>You may view security actions on your GitHub or BitBucket accounts to verify if any unexpected access has occurred - see &lt;a href="https://help.github.com/en/articles/reviewing-your-security-log">https://help.github.com/en/articles/reviewing-your-security-log&lt;/a> and &lt;a href="https://bitbucket.org/blog/new-audit-logs-give-you-the-who-what-when-and-where">https://bitbucket.org/blog/new-audit-logs-give-you-the-who-what-when-and-where&lt;/a>&lt;/li>
&lt;li>You may need to unlink and then relink your GitHub and Bitbucket source provider as described in &lt;a href="https://docs.docker.com/docker-hub/builds/link-source/">https://docs.docker.com/docker-hub/builds/link-source/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>We are enhancing our overall security processes and reviewing our policies. Additional monitoring tools are now in place.&lt;/p>
&lt;/blockquote>
&lt;h2 id="runc-10-rc8-正式发布">runc 1.0-rc8 正式发布&lt;/h2>
&lt;p>我在 &lt;a href="https://zhuanlan.zhihu.com/p/50923312">《runc 1.0-rc6 发布之际》&lt;/a> 和 &lt;a href="https://zhuanlan.zhihu.com/p/60981504">《runc 1.0-rc7 发布之际》&lt;/a> 这两篇文章中，分别介绍了 runc 的基础内容以及为何 runc 迟迟未发布 1.0 正式版本的原因；以及 rc6 和 rc7 出现的原因和对用户的影响。&lt;/p>
&lt;p>本次 runc 1.0-rc8 没有专门写文章说明，主要是因为此版本主要是作为一个 hot-fix 版本，主要修复一个旧内核上的回归的情况。这个情况是在 runc 1.0-rc7 时引入的，但是因为这个问题，也阻碍了部分用户升级，以解决 CVE-2019-5736。&lt;/p>
&lt;p>目前距离 1.0 正式发布，最主要的内容就是讨论一些 OCI hooks 以及和现有的 NVIDIA runtime hooks 集成的问题（毕竟现在机器学习使用 Docker 时，用的最多的便是 NVIDIA runtime）。&lt;/p>
&lt;p>期待能早日解决相关问题，并迎来 1.0 的正式发布。&lt;/p>
&lt;p>更多内容推荐阅读 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc8">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-和-arm-宣布新的合作">Docker 和 Arm 宣布新的合作&lt;/h2>
&lt;p>Docker 和 Arm 宣布一项新的合作，将为 Docker 的工具链提供 Arm 平台的支持。主要的想法其实是想让 Docker 变得更简单， &lt;strong>使开发人员可以在自己的桌面电脑上就可以直接构建出 Arm 平台的应用程序&lt;/strong> 然后将其部署至 Cloud, 物联网设备, 或者边缘网络上。并且也可直接构建 Arm 的镜像而无需任何交叉编译等。&lt;/p>
&lt;p>这样的主要好处是，现有的已经掌握 Docker 技术的开发者，可以有能力直接转身成为 Arm 平台的开发者，而无需更多额外的条件。&lt;/p>
&lt;p>这些功能适用于 JavaScript / Node.js，Python，Java，C++，Ruby，.NET Core，Go，Rust 和 PHP 编写的应用程序等，并将在下周放出技术预览版本。&lt;/p>
&lt;p>更多内容推荐阅读 &lt;a href="https://techcrunch.com/2019/04/24/docker-partners-with-arm/">TC 报道&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019-04-15~2019-04-21</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/04/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-15~2019-04-21/"/><id>https://moelove.info/2019/04/21/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019-04-15~2019-04-21/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-04-21T21:46:02+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Prometheus v2.9.0 正式发布 Prometheus 是 CNCF……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="prometheus-v290-正式发布">Prometheus v2.9.0 正式发布&lt;/h2>
&lt;p>&lt;a href="https://github.com/prometheus/prometheus">Prometheus&lt;/a> 是 CNCF 毕业项目，可用于监控系统及服务状态。它整体是使用 Pull 的模式，在周期时间内采集目标的 metrics ，并且提供了 PromQL 的查询语言，以供对监控数据进行查询过滤等操作。并且可以通过配置规则来触发报警等。我首次接触 Prometheus 大概是在 2015 年 0.15.0 版本左右，当时 Prometheus 还处于比较早期的阶段，不过在进入 CNCF 后，Prometheus 基本就成为了 K8S 监控的实施标准了，并且多数软件也都增加了对 Prometheus metrics 的支持。&lt;/p>
&lt;p>&lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.9.0">v2.9.0&lt;/a> 的主要更新：&lt;/p>
&lt;ul>
&lt;li>从 2.8 开始引入了的从 WAL 读取进行 remote write 有时候会丢数据的问题已经得到修复；&lt;/li>
&lt;li>Kubernetes 和 OpenStack 在服务发现时候增加了更多元数据；&lt;/li>
&lt;li>Consul 现在支持多 tag；&lt;/li>
&lt;li>添加了一个 &lt;code>honor_timestamps&lt;/code> 的选项；&lt;/li>
&lt;li>TLS 证书会自动从磁盘加载；&lt;/li>
&lt;li>日志也变的更易读；&lt;/li>
&lt;/ul>
&lt;p>其他更新请阅读 &lt;a href="https://github.com/prometheus/prometheus/releases/tag/v2.9.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="linkerd-23-正式发布">Linkerd 2.3 正式发布&lt;/h2>
&lt;p>Linkerd 是一个 service mesh 旨在提供平台范围的可观察性，可靠性和安全性，而无需用户更改代码。在本月初的&lt;a href="https://moelove.info/2019/04/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.04.01~2019.04.07/#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-linkerd-v2-%E4%BB%8E%E4%BA%A7%E5%93%81%E4%B8%AD%E5%90%B8%E5%8F%96%E7%9A%84%E6%95%99%E8%AE%AD">周报推送&lt;/a>中，推荐了一篇关于 Linkerd v2 从产品中吸取的教育和经验的文章，Linkerd v2 使用 Go 和 Rust 进行了重写，并因此获得了巨大的收益。&lt;/p>
&lt;p>2.3 的主要更新：&lt;/p>
&lt;ul>
&lt;li>提供了一种全新的基于 TLS 的服务验证机制，默认情况下会在服务网格中进行经过身份认证的保密通信；&lt;/li>
&lt;li>控制平面附带证书颁发机构；&lt;/li>
&lt;li>数据平面代理接收 TLS 证书并与 K8S 的 SA 进行绑定，24 小时轮转一次；&lt;/li>
&lt;/ul>
&lt;p>这里仅列出了比较关键的更新，事实上本次的更新特别多。2.3 版本也是 Linkerd 在安全路线中的重要一步。更多内容请阅读 &lt;a href="https://github.com/linkerd/linkerd2/releases/tag/stable-2.3.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-ce-19030-beta2-发布">Docker CE 19.03.0-beta2 发布&lt;/h2>
&lt;p>这是 Docker CE 19.03 版本正式发布前的常规发布，现在的主要变更基本都是为正式发布前做准备，集中于依赖的更新和一些 bugfix ，这个版本暂时不建议使用/更新，目前在 SELinux 开启的机器可能会有点小问题，还在测试及问题定位中。&lt;/p>
&lt;p>更多信息请阅读 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.0-beta2">ReleasesNote&lt;/a>&lt;/p>
&lt;h2 id="推荐阅读配置-kubernetes-network-policy">推荐阅读：配置 Kubernetes Network Policy&lt;/h2>
&lt;p>随着 Kubernetes 生态的发展，很多公司和团队也愈发的注重 Kubernetes 和其中部署的应用的安全性，&lt;a href="https://www.cncf.io/blog/2019/04/19/setting-up-kubernetes-network-policies-a-detailed-guide/">这篇文章 - Setting up Kubernetes Network Policies – A Detailed Guide&lt;/a> 通过示例介绍了如何在 Kubernetes 中配置 Network Policy ，希望能对你有所启发。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019.04.08~2019.04.14</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/04/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.04.08~2019.04.14/"/><id>https://moelove.info/2019/04/14/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.04.08~2019.04.14/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-04-14T22:53:09+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 CRI-O 成为 CNCF 托管项目 CRI-O……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="cri-o-成为-cncf-托管项目">CRI-O 成为 CNCF 托管项目&lt;/h2>
&lt;p>&lt;a href="https://github.com/cri-o/cri-o">CRI-O&lt;/a> 是基于 OCI 的 Kubernetes CRI 实现，旨在提供符合 OCI 运行时和 kubelet 之间的集成。简单来说就是完全符合 OCI 标准的 CRI 实现。（比如之前介绍的 runc 便是 OCI 标准的参考实现）&lt;/p>
&lt;p>在 2016 年的时候 Kubernetes 就推出了容器运行时接口（CRI），这给了 kubelet 一种使用各种不同容器运行时的能力，现在最常用的当然还是 Docker，当然也有人使用 containerd、runc、CRI-O 等各类运行时。&lt;/p>
&lt;p>CRI-O 最初由 Red Hat 和 Google 开发，现在已达到稳定状态，且已有大量的贡献者，本次成为 CNCF 托管项目，也算是给容器运行时提供一个更大的可能。&lt;/p>
&lt;p>附一张官方图：&lt;/p>
&lt;p>&lt;img src="https://www.cncf.io/wp-content/uploads/2019/04/CRIO-768x461.png" alt="CRI-O-https://moelove.info">&lt;/p>
&lt;p>详细信息请阅读 &lt;a href="https://www.cncf.io/blog/2019/04/08/cncf-to-host-cri-o/">CNCF 官方新闻&lt;/a>&lt;/p>
&lt;h2 id="helm-子项目-chart-testing-发布-v230-版本">Helm 子项目 chart-testing 发布 v2.3.0 版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/helm/chart-testing">chart-testing&lt;/a> v2.3.0 版本正式发布，该项目的主要目标是用于 Helm Chart 的测试，使用该项目可更方便的检查 Chart 中是否有错误，以及定位错误位置等。&lt;/p>
&lt;p>本次发布主要在于覆盖更多异常情况，详细内容建议阅读 &lt;a href="https://github.com/helm/chart-testing/releases/tag/v2.3.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="coredns-v150-版本发布">CoreDNS v1.5.0 版本发布&lt;/h2>
&lt;p>CoreDNS 是一个 CNCF 毕业的灵活且快速的 DNS server 项目，包含了众多插件。&lt;/p>
&lt;p>1.5.0 的主要更新：&lt;/p>
&lt;ul>
&lt;li>增加了两个 plugin: &lt;strong>grpc&lt;/strong> 和 &lt;strong>ready&lt;/strong>;&lt;/li>
&lt;li>使用 grpc 插件可转发 gRPC;&lt;/li>
&lt;li>使用 ready 插件，可为每个后端配置一个 ready 探针，类似于 Kubernetes 中的 Readiness 探针的作用；&lt;/li>
&lt;/ul>
&lt;p>其他更新请阅读 &lt;a href="https://coredns.io/2019/04/06/coredns-1.5.0-release/">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="docker-ce-v18095-发布">Docker CE v18.09.5 发布&lt;/h2>
&lt;p>v18.09.5 的主要更新：&lt;/p>
&lt;ul>
&lt;li>修复了一个当 &lt;code>systemd-resolve&lt;/code> 且使用主机网络（network=host）时，&lt;code>resolv.conf&lt;/code> 使用错误的问题（之前都默认使用 &lt;code>/etc/resolv.conf&lt;/code>）；&lt;/li>
&lt;/ul>
&lt;p>其他修复和更新请阅读 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v18.09.5">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="fluentd-从-cncf-毕业">fluentd 从 CNCF 毕业&lt;/h2>
&lt;p>fluentd 是 CNCF 中毕业的第 6 个项目，在 Kubernetes 生态中，fluentd 被广泛用于日志采集，而且项目经过 CNCF 孵化，也发展迅速。&lt;/p>
&lt;p>详细信息请阅读 &lt;a href="https://zhuanlan.zhihu.com/p/62156473">恭喜 fluentd 毕业&lt;/a>&lt;/p>
&lt;h2 id="dockerhub-将完全禁用-v1-api">DockerHub 将完全禁用 v1 API&lt;/h2>
&lt;p>DockerHub 将在今年 6 月份禁止通过 v1 API 进行 Pull 操作，实际上我们现在用到的接口基本都是 v2 API，而早在 2015 年 11 月 DockerHub 就已经禁止了通过 v1 API 进行 Push 操作了。&lt;/p>
&lt;p>如果你还在使用特别老旧的客户端，请注意升级，否则 6 月之后就无法正常通过 DockerHub Pull 镜像使用了。&lt;/p>
&lt;p>详情请阅读 &lt;a href="https://engineering.docker.com/2019/03/registry-v1-api-deprecation/">Registry v1 API Deprecation&lt;/a>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">恭喜 Fluentd 从 CNCF 毕业</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/04/12/%E6%81%AD%E5%96%9C-Fluentd-%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/"/><id>https://moelove.info/2019/04/12/%E6%81%AD%E5%96%9C-Fluentd-%E4%BB%8E-CNCF-%E6%AF%95%E4%B8%9A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-04-12T07:23:14+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">今年新闻不断，多数早期进入 CNCF 的项目都相继宣布毕业。 CNCF（云原生计算基金会）在美国时间 2019 年 4 月 11 日宣布 fluentd 今天正式毕业了。 这是 CNCF……</summary><content type="html">&lt;blockquote>
&lt;p>今年新闻不断，多数早期进入 CNCF 的项目都相继宣布毕业。&lt;/p>
&lt;/blockquote>
&lt;p>CNCF（云原生计算基金会）在美国时间 2019 年 4 月 11 日宣布 &lt;a href="https://www.fluentd.org/">fluentd&lt;/a> 今天正式毕业了。&lt;/p>
&lt;p>这是 CNCF 中毕业的第 6 个项目，之前已经毕业的项目为 &lt;a href="https://github.com/kubernetes">Kubernetes&lt;/a>、&lt;a href="https://github.com/prometheus">Prometheus&lt;/a>、&lt;a href="https://github.com/envoyproxy/envoy">Envoy&lt;/a> 、&lt;a href="https://github.com/coredns/coredns">CoreDNS&lt;/a> 和 &lt;a href="https://github.com/containerd/containerd/">containerd&lt;/a> 。&lt;/p>
&lt;p>fluentd 自 2011 年由 Treasure Data 公司的联合创始人 Sadayuki “Sada” Furuhashi 创建，作为构建统一记录层的开源数据收集器，统一记录层统一收集采集和消费，以便更好的使用和理解数据。在 2016 年 11 月，fluentd 也是第 6 个成为 CNCF 托管项目的。&lt;/p>
&lt;p>fluentd 可以从多种数据源采集事件，并将它写入文件, RDBMS, NoSQL, IaaS, SaaS, Hadoop等等各类的目标地址。截至目前，fluentd 在 GitHub 上有 7629 个 star ，895 个 fork，以及 166 位贡献者，超过 4k+ commit 。&lt;/p>
&lt;p>做日志相关的小伙伴基本都玩过 ELK ，我们都知道在大规模使用 Logstash 时的痛苦（还记得被 Logstash 配置文件支配的恐惧吗？ 2333） 而 fluentd 的事件路由是通过 tag 来做，相比 Logstash 使用管道将所有数据路由到单个流里再通过配置将它发送到对应的目标而言这将大大简化配置的复杂度。(是的，这里是吐槽)&lt;/p>
&lt;p>再一个，便是需要考虑部署和插件生态，首先来说部署：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>fluentd 使用 C + Ruby 编写（Ruby 写起来蛮舒服的，早先写过一段时间），只要有 Ruby 的环境，可以很方便的进行部署。而大多数的 Linux 发行版是默认带着 Ruby 环境的，这也非常方便。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Logstash 使用 JRuby 编写（JRuby 就是使用 Java 实现的 Ruby 解释器），部署时需要有 JDK 和 JRuby 的环境。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里只做陈述，不再展开。&lt;/p>
&lt;p>回到插件生态上：&lt;/p>
&lt;p>两者都有丰富的插件，并且编写插件也很简单。不过插件这种东西，按需使用，日常需要的基本都能找的到。唯一需要注意的就是选择插件时，需要仔细甄别。&lt;/p>
&lt;blockquote>
&lt;p>“Fluentd has earned its place as the industry standard for log collection and shipping, and I am excited to see it as a graduated CNCF project,” said Gabe Monroy, Lead Program Manager for Containers, Microsoft Azure. “At Microsoft, we are proud to use Fluentd to power our cloud native logging subsystems and we look forward to working with the growing the open source community around Fluentd.”&lt;/p>
&lt;/blockquote>
&lt;p>引用一段话，fluentd 是否成为整个日志收集的行业标准，这个我不确定， 但在它托管至 CNCF 后，在云原生领域它确实发展迅速，多数公司都会采用 EFK 的方式进行云原生时代下的日志方案。&lt;/p>
&lt;p>附一张 fluentd 的图，有空会写下 fluentd 的使用姿势 （flag++）&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/a3dc75aaf0277efbbbc698a80b4c620f969969bd/68747470733a2f2f646f63732e666c75656e74642e6f72672f696d616765732f666c75656e74642d6172636869746563747572652e706e67" alt="fluentd - https://moelove.info">&lt;/p>
&lt;p>再次恭喜 fluentd 毕业。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019.04.01~2019.04.07</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/04/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.04.01~2019.04.07/"/><id>https://moelove.info/2019/04/07/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.04.01~2019.04.07/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-04-07T10:03:13+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes client-go v11.0.0 正式发布 这是……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-client-go-v1100-正式发布">Kubernetes client-go v11.0.0 正式发布&lt;/h2>
&lt;p>这是最后一个使用 &lt;code>dep&lt;/code> 作为依赖管理的版本，后续版本将转向使用 &lt;code>go modules&lt;/code>.&lt;/p>
&lt;p>Kubernetes 生态中的相关项目大多都已转向或正在转向使用 &lt;code>go modules&lt;/code> 了，这也是一个技术风向，理性选择。&lt;/p>
&lt;p>&lt;a href="https://github.com/kubernetes/client-go/releases/tag/v11.0.0">Release&lt;/a>&lt;/p>
&lt;h2 id="containerd-126-正式发布">containerd 1.2.6 正式发布&lt;/h2>
&lt;p>这是 containerd 1.2 的第 6 个 patch 版本，主要更新：&lt;/p>
&lt;ul>
&lt;li>在默认的 seccomp profile 白名单增加了 &lt;code>io_pgetevents&lt;/code> 和 &lt;code>statx&lt;/code> 这两个系统调用;&lt;/li>
&lt;li>修复了在 1.2.5 中自定义 cgroup path 无法工作的 bug；&lt;/li>
&lt;li>更新 CNI 插件到 v0.7.5 以修复 &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2019-9946">CVE-2019-9946&lt;/a>;&lt;/li>
&lt;li>更新 runc 版本，修复在无 SELinux 系统下的失败情况；&lt;/li>
&lt;/ul>
&lt;p>当然还有一些其他的改进和修复，比如修复了 pod 的 UTS namespace 等，建议阅读 &lt;a href="https://github.com/containerd/containerd/releases/tag/v1.2.6">ReleaseNote&lt;/a>。&lt;/p>
&lt;h2 id="docker-ce-19030-beta1-版本发布">Docker CE 19.03.0-beta1 版本发布&lt;/h2>
&lt;p>这是 Docker CE 修改发布周期后，第二个发布的版本，上个版本是 Docker CE 18.09 。从发布周期来看，由原先的季度发布改成半年发布，也意味着 Docker 的日渐成熟。&lt;/p>
&lt;p>正式版估计会在 5 月发布，从 beta 版中能看到一些主要更新：&lt;/p>
&lt;ul>
&lt;li>API 更新至 v1.40;&lt;/li>
&lt;li>允许以非 root 用户运行 dockerd （Rootless mode），这将更有利于容器安全（这也是我最期待的一个特性）；&lt;/li>
&lt;li>移除 v1 manifest 支持；&lt;/li>
&lt;li>移除 AuFS 存储驱动支持，会有提示信息（当前是废弃，还未完全移除，在上个版本中 &lt;code>devicemapper&lt;/code> 也已被标记为废弃）;&lt;/li>
&lt;li>实验性的对 compose 和 Kubernetes 提供一些额外支持，比如 &lt;code>x-pull-secret&lt;/code> 和 &lt;code>x-pull-policy&lt;/code>;&lt;/li>
&lt;li>实验性的对 Windows 和 LCOW 提供一些支持：比如提供对 cpu 和 内存的限制；&lt;/li>
&lt;/ul>
&lt;p>除此之外，在 builder 和 API 方面也都有一些修复和改进，建议阅读 &lt;a href="https://github.com/docker/docker-ce/releases/tag/v19.03.0-beta1">ReleaseNote&lt;/a>。&lt;/p>
&lt;h2 id="推荐阅读-linkerd-v2-从产品中吸取的教训">推荐阅读： Linkerd v2 从产品中吸取的教训&lt;/h2>
&lt;p>Linkerd v2 使用 Go 和 Rust 进行了重写，这篇文章是在 Linkerd v2 发布 6 个月之后写的，该团队认为使用 Go 和 Rust 重写是非常值得的，并且也已经在生产中得到了验证。&lt;/p>
&lt;p>文章内容不错，推荐阅读。文章地址 &lt;a href="https://www.infoq.com/articles/linkerd-v2-production-adoption">Linkerd v2: How Lessons from Production Adoption Resulted in a Rewrite of the Service Mesh&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">K8S 生态周报| 2019.03.25~2019.03.31</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/03/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.03.25~2019.03.31/"/><id>https://moelove.info/2019/03/31/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.03.25~2019.03.31/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-03-31T21:52:01+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。 Kubernetes 1.14 正式发布 1.14 的主……</summary><content type="html">&lt;blockquote>
&lt;p>「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。欢迎订阅知乎专栏「k8s生态」。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kubernetes-114-正式发布">Kubernetes 1.14 正式发布&lt;/h2>
&lt;p>1.14 的主要更新：&lt;/p>
&lt;ul>
&lt;li>对 Windows Node 和 container 的支持达到生产级别，支持 Windows Server 2019；&lt;/li>
&lt;li>本地持久化数据卷正式可用，这可以方便使用本地 SSD 之类的存储，但注意这个特性容错性较差；&lt;/li>
&lt;li>Pod 优先级和抢占机制正式可用，(建议慎重使用)；&lt;/li>
&lt;li>Pod Ready++ (Pod Readiness Gates) 达到稳定，可以更好的判断 Pod 及其需要的资源是否均已就绪；&lt;/li>
&lt;/ul>
&lt;p>当然还有很多的改进和很多被废弃的功能特性等，建议阅读 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md">ReleaseNote&lt;/a>。&lt;/p>
&lt;h2 id="minikube-100-正式发布">Minikube 1.0.0 正式发布&lt;/h2>
&lt;p>Minikube 是一个用于本地搭建 Kubernetes 环境的工具，使用方法可参考 &lt;a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac/section/5b9b81735188255c8b6edc28">使用 Minikube 搭建本地 Kubernetes 环境&lt;/a>。&lt;/p>
&lt;p>1.0.0 的主要更新：&lt;/p>
&lt;ul>
&lt;li>默认 Kubernetes 版本更新至 1.14.0;&lt;/li>
&lt;li>新增 &lt;code>--image-repository&lt;/code> 参数，方便国内用户使用镜像解决网络问题；&lt;/li>
&lt;/ul>
&lt;p>其他特性请阅读 &lt;a href="https://github.com/kubernetes/minikube/blob/v1.0.0/CHANGELOG.md">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="runc-10-rc7-发布">runc 1.0-rc7 发布&lt;/h2>
&lt;p>&lt;strong>注意，低版本内核(尤其是 3.x)的系统，请不要升级至此版本&lt;/strong>&lt;/p>
&lt;p>这个版本主要为解决之前的漏洞及修正一些规范等，版本说明请参考 &lt;a href="https://zhuanlan.zhihu.com/p/60981504">runc 1.0-rc7 发布之际&lt;/a>。&lt;/p>
&lt;p>其他特性请阅读 &lt;a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc7">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="brigade-10-正式发布">Brigade 1.0 正式发布&lt;/h2>
&lt;p>Brigade 是一个使用 JavaScript 来为 Kubernetes 构建 pipeline 的工具，现在是 CNCF 的 sandbox 项目。&lt;/p>
&lt;p>详细内容请阅读 &lt;a href="https://github.com/brigadecore/brigade/releases/tag/v1.0.0">ReleaseNote&lt;/a>&lt;/p>
&lt;h2 id="kind-021-发布">Kind 0.2.1 发布&lt;/h2>
&lt;p>Kind 是 Kubernetes In Docker 的缩写，是一款便于在本地和 CI 环境中进行 Kubernetes 环境搭建的工具，具体用法请参考 &lt;a href="https://zhuanlan.zhihu.com/p/60464867">使用 Kind 搭建你的本地 Kubernetes 集群&lt;/a>&lt;/p>
&lt;p>0.2.1 是 kind 的首个 patch 版本，主要为了修复一个偶发的 panic , 建议尽快升级。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">runc 1.0-rc7 发布之际</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/"/><id>https://moelove.info/2019/03/29/runc-1.0-rc7-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-03-29T10:42:25+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在 18 年 11 月底时，我写了一篇文章 《runc 1.0-rc6 发布之际》 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其……</summary><content type="html">&lt;p>在 18 年 11 月底时，我写了一篇文章 &lt;a href="https://moelove.info/2018/11/23/runc-1.0-rc6-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/">《runc 1.0-rc6 发布之际》&lt;/a> 。如果你还不了解 runc 是什么，以及如何使用它，请参考我那篇文章。本文中，不再对其概念和用法等进行说明。&lt;/p>
&lt;p>在 runc 1.0-rc6 发布之时，给版本的别名为 &lt;strong>&amp;quot;For Real This Time&amp;quot;&lt;/strong>，当时我们原定计划是发布 1.0 的，但是作为基础依赖软件，我们认为当时的版本还有几个问题：&lt;/p>
&lt;ul>
&lt;li>不够规范；&lt;/li>
&lt;li>发布周期不明确;&lt;/li>
&lt;/ul>
&lt;p>为了给相关的 runtime 足够的时间进行修正/升级，以及规范版本生命周期等，最终决定了发布 &lt;code>runc 1.0-rc6&lt;/code>。&lt;/p>
&lt;h2 id="为何有-runc-10-rc7-存在">为何有 &lt;code>runc 1.0-rc7&lt;/code> 存在&lt;/h2>
&lt;p>前面已经基本介绍了相关背景，并且也基本明确了 rc6 就是在 1.0 正式发布之前的最后一个版本，那 rc7 为什么会出现呢？&lt;/p>
&lt;h3 id="cve-2019-5736">CVE-2019-5736&lt;/h3>
&lt;p>我们首先要介绍今年 runc 的一个提权漏洞 &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5736">&lt;code>CVE-2019-5736&lt;/code>&lt;/a>&lt;/strong> 。&lt;/p>
&lt;p>2019 年 2 月 11 日在&lt;a href="https://seclists.org/oss-sec/2019/q1/119"> oss-security 邮件组&lt;/a>正式批露该漏洞，攻击者可以利用恶意容器覆盖主机上的 runc 文件，从而达到攻击的目的；（具体的攻击方式此处略过），注意不要轻易使用来源不可信的镜像创建容器便可有效避免被攻击的可能。&lt;/p>
&lt;p>简单补充下可能被攻击的方式：&lt;/p>
&lt;ul>
&lt;li>运行恶意的 Docker 镜像&lt;/li>
&lt;li>在主机上执行 &lt;code>docker exec&lt;/code> 进入容器内&lt;/li>
&lt;/ul>
&lt;p>关于容器安全或者容器的运行机制，其实涉及的点很多，我在去年的一次线上分享 &lt;a href="https://moelove.info/2018/08/05/%E5%9F%BA%E4%BA%8E-GitLab-%E7%9A%84-CI-%E5%AE%9E%E8%B7%B5/#%E8%AF%A6%E8%A7%A3-docker-in-docker">《基于 GitLab 的 CI 实践》&lt;/a> 有提到过 Linux Security Modules（LSM）等相关的内容，对容器安全感兴趣的朋友可以对 LSM 多了解下。&lt;/p>
&lt;p>不过本文主要看的是 runc 如何修复该漏洞的，以及后续产生的影响。&lt;/p>
&lt;h3 id="修复方式">修复方式&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// 对 memfd_create 系统调用做了个封装 省略部分代码
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="cp">#if !defined(SYS_memfd_create) &amp;amp;&amp;amp; defined(__NR_memfd_create)
&lt;/span>&lt;span class="cp"># define SYS_memfd_create __NR_memfd_create
&lt;/span>&lt;span class="cp">#endif
&lt;/span>&lt;span class="cp">#ifdef SYS_memfd_create
&lt;/span>&lt;span class="cp"># define HAVE_MEMFD_CREATE
&lt;/span>&lt;span class="cp"># ifndef MFD_CLOEXEC
&lt;/span>&lt;span class="cp"># define MFD_CLOEXEC 0x0001U
&lt;/span>&lt;span class="cp"># define MFD_ALLOW_SEALING 0x0002U
&lt;/span>&lt;span class="cp"># endif
&lt;/span>&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">memfd_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">syscall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SYS_memfd_create&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 一个简单的只读缓存区
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">read_file&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4096&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">copy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">fd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_RDONLY&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_CLOEXEC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(;;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">copy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">must_realloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">copy&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">copy&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">memcpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">copy&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">copy&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">error&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">copy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 将复制后的 fd 重赋值/执行
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">clone_binary&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">binfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">ssize_t&lt;/span> &lt;span class="n">sent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cp">#ifdef HAVE_MEMFD_CREATE
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="n">memfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">memfd_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RUNC_MEMFD_COMMENT&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MFD_CLOEXEC&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">MFD_ALLOW_SEALING&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#else
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="n">memfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/tmp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_TMPFILE&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_EXCL&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_RDWR&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_CLOEXEC&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mo">0711&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="cp">#endif
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">memfd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENOTRECOVERABLE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">binfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/proc/self/exe&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_RDONLY&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_CLOEXEC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">binfd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">sent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sendfile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">memfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">binfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RUNC_SENDFILE_MAX&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">binfd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sent&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cp">#ifdef HAVE_MEMFD_CREATE
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fcntl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">memfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">F_ADD_SEALS&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RUNC_MEMFD_SEALS&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">err&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cp">#else
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">newfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">fdpath&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">asprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">fdpath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;/proc/self/fd/%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memfd&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">newfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpath&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">O_RDONLY&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">O_CLOEXEC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fdpath&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">newfd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">goto&lt;/span> &lt;span class="n">error&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">memfd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">memfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="cp">#endif
&lt;/span>&lt;span class="cp">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">memfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nl">error&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">memfd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">ensure_cloned_binary&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">execfd&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">argv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">envp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">cloned&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">is_self_cloned&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cloned&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">cloned&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENOTRECOVERABLE&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">cloned&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fetchve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">envp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EINVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">execfd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clone_binary&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">execfd&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EIO&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">fexecve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">execfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">envp&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ENOEXEC&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>省略掉了部分代码，完整代码可直接参考 &lt;a href="https://github.com/opencontainers/runc">runc 代码仓库&lt;/a> 。&lt;/p>
&lt;p>整个的修复逻辑我在上面的代码中加了备注，总结来讲其实就是：&lt;/p>
&lt;ul>
&lt;li>创建了一个只存在于内存中的 memfd ；&lt;/li>
&lt;li>将原本的 runc 拷贝至这个 memfd ；&lt;/li>
&lt;li>在进入 namespace 前，通过这个 memfd 重新执行 runc ; (这是为了确保之后即使被攻击/替换也操作的还是内存中的这个只读的 runc)&lt;/li>
&lt;/ul>
&lt;p>经过以上的操作，就基本修复了 CVE-2019-5736 。&lt;/p>
&lt;h3 id="影响">影响&lt;/h3>
&lt;h4 id="内核相关">内核相关&lt;/h4>
&lt;p>在上面讲完修复方式后，我们来看下会产生哪些影响。&lt;/p>
&lt;ul>
&lt;li>涉及到了系统调用 &lt;strong>&lt;code>memfd_create(2)&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>fcntl(2)&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>增加了系统调用，那自然就要看内核是否支持了。实际上，这些函数是在 2015 年 2 月（距这次修复整整 4 年，也挺有趣）被加入到 Linux 3.17 内核中的。&lt;/p>
&lt;p>换句话说就是 &lt;strong>凡是在此内核版本之前的系统，均无法正常使用该功能&lt;/strong>，对我们的影响就是，&lt;strong>如果你在此版本内核之前的机器上使用了包含上述修复代码的 runc 或构建在其之上的 containerd、 Docker 等都无法正常工作&lt;/strong> 。&lt;/p>
&lt;p>以 Docker 举例：安装 docker-ce-18.09.2 或 docker-ce-18.06.3 可避免受 CVE-2019-5736 影响，但如果内核版本较低，在运行容器时可能会有如下情况出现: （不同版本/内核可能出现其他情况）&lt;/p>
&lt;pre>&lt;code>[tao@moelove ~]# docker run --rm my-registry/os/debian echo Hello
docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container
process caused &amp;quot;process_linux.go:293: copying bootstrap data to pipe caused \&amp;quot;write init-p: broken pipe\&amp;quot;&amp;quot;: unknown.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>&lt;strong>解决办法&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>升级内核；这是最直接的办法，而且使用一个新版本的内核也能省去很多不必要的麻烦:)&lt;/li>
&lt;li>rancher 提供了一个 &lt;a href="https://github.com/rancher/runc-cve">runc-cve&lt;/a> 的 patch，可兼容部分 3.x 内核的系统（我没有测试过）&lt;/li>
&lt;li>如果你不升级 runc/containerd/Docker 等版本的话，那建议你 1. 将 runc 可执行程序放到只读文件系统上，可避免被覆盖；2. 启动容器时，启用 &lt;code>SELinux&lt;/code>; 3. 在容器内使用低权限用户或者采用映射的方式，但保证用户对主机上的 runc 程序无写权限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意&lt;/strong>:&lt;/p>
&lt;p>&lt;code>memfd_create&lt;/code> 等相关系统调用，也被加入到了 Debian 3.16 和 Ubuntu 14.04 updates 中，当然也被反向移植到了 CentOS 7.3 内核 &lt;code>3.10.0-514&lt;/code> 版本之后。 (Red Hat 给 CentOS 7.x 的 3.10 内核上反向移植了很多特性)&lt;/p>
&lt;h4 id="内存相关">内存相关&lt;/h4>
&lt;p>从上面的说明中，也很容易可以看到, 内存的使用上会有所增加，不过之后已做了修复。这里不再进行展开。&lt;/p>
&lt;h4 id="其他">其他&lt;/h4>
&lt;p>偶尔可能触发一些内核 bug 之类的（总之建议升级 :)&lt;/p>
&lt;h2 id="等待-rc8-发布">等待 rc8 发布&lt;/h2>
&lt;p>上面已经介绍了 1.0-rc7 出现的主要原因 CVE-2019-5736；当然这个版本中也有一些新特性和一些 bugfix 不过不是本文的主要内容，不再赘述。&lt;/p>
&lt;p>值得一提的是这次的版本命名：&lt;code>runc 1.0-rc7 -- &amp;quot;The Eleventh Hour&amp;quot;&lt;/code> 后面这个别名其实来自于一部英剧，感兴趣也可以去看看。&lt;/p>
&lt;p>至于下个版本是不是会是 1.0 正式版呢？目前来看应该不是，有极大可能会发布 &lt;code>runc 1.0-rc8&lt;/code> 做一些 bugfix，让我们拭目以待。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/runc/" term="runc" label="runc"/></entry><entry><title type="text">使用 Kind 搭建你的本地 Kubernetes 集群</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/03/25/%E4%BD%BF%E7%94%A8-Kind-%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0-Kubernetes-%E9%9B%86%E7%BE%A4/"/><id>https://moelove.info/2019/03/25/%E4%BD%BF%E7%94%A8-Kind-%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0-Kubernetes-%E9%9B%86%E7%BE%A4/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-03-25T21:30:24+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Kind 是我很喜欢也一直在参与的项目，我计划将 Kind 相关的文章写成一个系列。（flag++） 这是第一篇。 Kind 介绍 Kind 是 Kubernetes In Docker 的缩写，顾名思义是……</summary><content type="html">&lt;blockquote>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kind">Kind&lt;/a> 是我很喜欢也一直在参与的项目，我计划将 Kind 相关的文章写成一个系列。（flag++） 这是第一篇。&lt;/p>
&lt;/blockquote>
&lt;h2 id="kind-介绍">Kind 介绍&lt;/h2>
&lt;p>Kind 是 Kubernetes In Docker 的缩写，顾名思义是使用 Docker 容器作为 Node 并将 Kubernetes 部署至其中的一个工具。&lt;a href="https://kubernetes.io/docs/setup/pick-right-solution/#community-supported-tools">官方文档&lt;/a>中也把 Kind 作为一种本地集群搭建的工具进行推荐。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="二进制安装">二进制安装&lt;/h3>
&lt;p>Kind 使用 Golang 进行开发，在&lt;a href="https://github.com/kubernetes-sigs/kind/releases">仓库的 Release&lt;/a> 页面，已经上传了构建好的二进制，支持多种操作系统，可直接按需下载进行使用。&lt;/p>
&lt;p>e.g.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="c1"># 下载最新的 0.2.0 版本&lt;/span>
wget -O /usr/local/bin/kind https://github.com/kubernetes-sigs/kind/releases/download/0.2.0/kind-linux-amd64 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> chmod +x /usr/local/bin/kind
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过源码安装">通过源码安装&lt;/h3>
&lt;p>如果你本地已经配置好了 &lt;a href="https://golang.org/doc/install">Golang 的开发环境&lt;/a>，那你可以直接通过源码进行安装。&lt;/p>
&lt;p>e.g.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">go get -u sigs.k8s.io/kind
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行完上述命令后，会将 &lt;code>kind&lt;/code> 的可执行文件放到 &lt;code>$(go env GOPATH)/bin&lt;/code> 文件夹内，你可能需要将此目录加入到 &lt;code>$PATH&lt;/code> 中。&lt;/p>
&lt;p>或者也可以先 clone 源代码再通过 &lt;code>go build&lt;/code> 进行构建。&lt;/p>
&lt;h3 id="依赖">依赖&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Kind 的主要功能目前需要有 Docker 环境的支持，可参考 &lt;a href="https://docs.docker.com/install/">Docker 官方文档&lt;/a>进行安装。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果需要操作集群，则需要安装 &lt;code>kubectl&lt;/code> 命令行。安装方法可参考&lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl">官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="搭建单节点集群">搭建单节点集群&lt;/h2>
&lt;p>以下的演示均使用最新的代码(即通过源码安装)。&lt;/p>
&lt;h3 id="基础用法">基础用法&lt;/h3>
&lt;p>搭建单节点集群是 Kind 最基础的功能。&lt;/p>
&lt;p>e.g.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ kind create cluster --name moelove
Creating cluster &lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.13.4&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦
✓ Creating kubeadm config 📜
✓ Starting control-plane 🕹️
Cluster creation complete. You can now use the cluster with:
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>kind get kubeconfig-path --name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
kubectl cluster-info
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上命令中， &lt;code>--name&lt;/code> 是可选参数，如不指定，默认创建出来的集群名字为 &lt;code>kind&lt;/code>。&lt;/p>
&lt;p>我们根据命令执行完的输出进行操作：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ &lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>kind get kubeconfig-path --name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
master $ kubectl cluster-info
Kubernetes master is running at https://localhost:34458
KubeDNS is running at https://localhost:34458/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
To further debug and diagnose cluster problems, use &lt;span class="s1">&amp;#39;kubectl cluster-info dump&amp;#39;&lt;/span>.
master $ kubectl get nodes
NAME STATUS ROLES AGE VERSION
moelove-control-plane Ready master 2m v1.13.4
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上命令中，&lt;code>kind get kubeconfig-path --name=&amp;quot;moelove&amp;quot;&lt;/code> 会返回该指定集群配置文件所在的路径。&lt;/p>
&lt;p>可以看到单节点的 Kubernetes 已经搭建成功。&lt;/p>
&lt;h3 id="注意">注意&lt;/h3>
&lt;ul>
&lt;li>默认情况下，Kind 会先下载 &lt;code>kindest/node:v1.13.4&lt;/code> 镜像，该镜像目前托管于 Docker Hub 上，下载时间取决于网络状况。&lt;/li>
&lt;li>Kind 实际使用 &lt;code>kubeadm&lt;/code> 进行集群的创建，对 &lt;code>kubeadm&lt;/code> 有所了解的人都知道它默认使用的镜像在国内下载不到，所以需要自己解决网络问题。或者参考下面的方式:&lt;/li>
&lt;/ul>
&lt;p>Kind 在创建集群的时候，支持通过 &lt;code>--config&lt;/code> 的参数传递配置文件给 Kind，在国内，我们可以通过使用国内镜像源的方式来加速集群的创建。（这个方法也适用于直接通过 kubeadm 搭建 Kubernetes 集群）&lt;/p>
&lt;p>我们先通过以下命令删除刚才搭建的集群：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ kind delete cluster --name moelove
Deleting cluster &lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span> ...
&lt;span class="nv">$KUBECONFIG&lt;/span> is still &lt;span class="nb">set&lt;/span> to use /root/.kube/kind-config-moelove even though that file has been deleted, remember to &lt;span class="nb">unset&lt;/span> it
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，将下面的配置内容保存至一个 YAML 文件中，比如名为 &lt;code>kind-config.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kind.sigs.k8s.io/v1alpha3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kubeadmConfigPatches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> apiVersion: kubeadm.k8s.io/v1beta1
&lt;/span>&lt;span class="sd"> kind: ClusterConfiguration
&lt;/span>&lt;span class="sd"> metadata:
&lt;/span>&lt;span class="sd"> name: config
&lt;/span>&lt;span class="sd"> networking:
&lt;/span>&lt;span class="sd"> serviceSubnet: 10.0.0.0/16
&lt;/span>&lt;span class="sd"> imageRepository: registry.aliyuncs.com/google_containers
&lt;/span>&lt;span class="sd"> nodeRegistration:
&lt;/span>&lt;span class="sd"> kubeletExtraArgs:
&lt;/span>&lt;span class="sd"> pod-infra-container-image: registry.aliyuncs.com/google_containers/pause:3.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> apiVersion: kubeadm.k8s.io/v1beta1
&lt;/span>&lt;span class="sd"> kind: InitConfiguration
&lt;/span>&lt;span class="sd"> metadata:
&lt;/span>&lt;span class="sd"> name: config
&lt;/span>&lt;span class="sd"> networking:
&lt;/span>&lt;span class="sd"> serviceSubnet: 10.0.0.0/16
&lt;/span>&lt;span class="sd"> imageRepository: registry.aliyuncs.com/google_containers&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">nodes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们使用该配置文件搭建集群。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ kind create cluster --name moelove --config kind.yaml
Creating cluster &lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.13.4&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦
✓ Creating kubeadm config 📜
✓ Starting control-plane 🕹️
Cluster creation complete. You can now use the cluster with:
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>kind get kubeconfig-path --name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;moelove&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
kubectl cluster-info
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面通过 &lt;code>--config&lt;/code> 将我们的配置文件传递给 Kind 用于搭建集群，&lt;strong>推荐国内用户使用这种方式&lt;/strong>。&lt;/p>
&lt;h2 id="搭建高可用集群">搭建高可用集群&lt;/h2>
&lt;p>Kind 也支持搭建高可用的 K8S 集群，不过只能通过配置文件来实现。可以直接将下面的内容保存至文件中，再将配置文件传递给 Kind 即可。&lt;/p>
&lt;p>e.g.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Cluster&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kind.sigs.k8s.io/v1alpha3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kubeadmConfigPatches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> apiVersion: kubeadm.k8s.io/v1beta1
&lt;/span>&lt;span class="sd"> kind: ClusterConfiguration
&lt;/span>&lt;span class="sd"> metadata:
&lt;/span>&lt;span class="sd"> name: config
&lt;/span>&lt;span class="sd"> networking:
&lt;/span>&lt;span class="sd"> serviceSubnet: 10.0.0.0/16
&lt;/span>&lt;span class="sd"> imageRepository: registry.aliyuncs.com/google_containers
&lt;/span>&lt;span class="sd"> nodeRegistration:
&lt;/span>&lt;span class="sd"> kubeletExtraArgs:
&lt;/span>&lt;span class="sd"> pod-infra-container-image: registry.aliyuncs.com/google_containers/pause:3.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="sd"> apiVersion: kubeadm.k8s.io/v1beta1
&lt;/span>&lt;span class="sd"> kind: InitConfiguration
&lt;/span>&lt;span class="sd"> metadata:
&lt;/span>&lt;span class="sd"> name: config
&lt;/span>&lt;span class="sd"> networking:
&lt;/span>&lt;span class="sd"> serviceSubnet: 10.0.0.0/16
&lt;/span>&lt;span class="sd"> imageRepository: registry.aliyuncs.com/google_containers&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">nodes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">control-plane&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">role&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们使用以下的命令来搭建高可用的 Kubernetes 集群：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ kind create cluster --name moelove-ha --config kind-ha-config.yaml
Creating cluster &lt;span class="s2">&amp;#34;moelove-ha&amp;#34;&lt;/span> ...
✓ Ensuring node image &lt;span class="o">(&lt;/span>kindest/node:v1.13.4&lt;span class="o">)&lt;/span> 🖼
✓ Preparing nodes 📦📦📦📦📦📦📦
✓ Starting the external load balancer ⚖️
✓ Creating kubeadm config 📜
✓ Starting control-plane 🕹️
✓ Joining more control-plane nodes 🎮
✓ Joining worker nodes 🚜
Cluster creation complete. You can now use the cluster with:
&lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>kind get kubeconfig-path --name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;moelove-ha&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
kubectl cluster-info
master $ &lt;span class="nb">export&lt;/span> &lt;span class="nv">KUBECONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>kind get kubeconfig-path --name&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;moelove-ha&amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
master $ kubectl cluster-info
Kubernetes master is running at https://localhost:44019
KubeDNS is running at https://localhost:44019/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
To further debug and diagnose cluster problems, use &lt;span class="s1">&amp;#39;kubectl cluster-info dump&amp;#39;&lt;/span>.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以做下简单的验证：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">master $ kubectl get nodes
NAME STATUS ROLES AGE VERSION
moelove-ha-control-plane Ready master 3m42s v1.13.4
moelove-ha-control-plane2 Ready master 3m24s v1.13.4
moelove-ha-control-plane3 Ready master 2m13s v1.13.4
moelove-ha-worker Ready &amp;lt;none&amp;gt; 96s v1.13.4
moelove-ha-worker2 Ready &amp;lt;none&amp;gt; 98s v1.13.4
moelove-ha-worker3 Ready &amp;lt;none&amp;gt; 95s v1.13.4
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到已经成功创建了多 master 的 Kubernetes 集群。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这是使用 Kind 搭建本地 Kubernetes 集群的第一篇，同时本篇的内容也是&lt;a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac">《Kubernetes 从上手到实践》&lt;/a>第 4 节内容的补充，搭配食用效果更佳 :)&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Kind/" term="Kind" label="Kind"/></entry><entry><title type="text">K8S 生态周报| 2019.03.18~2019.03.24</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/03/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.03.18~2019.03.24/"/><id>https://moelove.info/2019/03/25/K8S-%E7%94%9F%E6%80%81%E5%91%A8%E6%8A%A5-2019.03.18~2019.03.24/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-03-25T20:49:06+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">我将从本篇开始维护「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。 Docker 6 岁啦 Docker 从 2013 年首次亮相，至今已……</summary><content type="html">&lt;blockquote>
&lt;p>我将从本篇开始维护「K8S 生态周报」内容主要包含我所接触到的 K8S 生态相关的每周值得推荐的一些信息。&lt;/p>
&lt;/blockquote>
&lt;h2 id="docker-6-岁啦">Docker 6 岁啦&lt;/h2>
&lt;p>Docker 从 2013 年首次亮相，至今已 6 年之久，而 Docker 也已一度成为容器技术的代名词，很庆幸能投身 Docker 相关的领域。&lt;a href="https://blog.docker.com/2019/02/22757/">官方博客&lt;/a>&lt;/p>
&lt;h2 id="kind-kubernetes-in-docker-发布-020-版本">Kind (Kubernetes In Docker) 发布 0.2.0 版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/kubernetes-sigs/kind/">Kind&lt;/a> 是一个利用容器技术快速部署本地 Kubernetes 的工具，主要是用于对 Kubernetes 1.11+ 版本的测试。现在发布的 &lt;a href="https://github.com/kubernetes-sigs/kind/releases/tag/0.2.0">0.2.0&lt;/a> 版本支持最新 Kubernetes v1.13.4 及 Docker 18.06.3 且通过了 CNCF 的一致性认证。&lt;/p>
&lt;h2 id="rancher-发布-k8s-最佳安全实践文章">Rancher 发布 K8S 最佳安全实践文章&lt;/h2>
&lt;p>Rancher 在 CNCF 最近发布的 &lt;a href="https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/">9 个 Kubernetes 最佳安全实践&lt;/a>的基础上发布了一篇&lt;a href="https://rancher.com/blog/2019/2019-01-17-101-more-kubernetes-security-best-practices/?utm_sq=g0sd44tdr3">更安全的最佳实践&lt;/a>，这两篇文章都值得一看。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Weekly/" term="Weekly" label="Weekly"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">恭喜 containerd 毕业</title><link rel="alternate" type="text/html" href="https://moelove.info/2019/03/01/%E6%81%AD%E5%96%9C-containerd-%E6%AF%95%E4%B8%9A/"/><id>https://moelove.info/2019/03/01/%E6%81%AD%E5%96%9C-containerd-%E6%AF%95%E4%B8%9A/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2019-03-01T10:18:20+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">今年的第一篇文章更新，带来一个重大的消息。 CNCF（云原生计算基金会）在美国时间 2019 年 2 月 28 日宣布 containerd 今天正式毕业了。 这是 CNCF 中毕业的……</summary><content type="html">&lt;blockquote>
&lt;p>今年的第一篇文章更新，带来一个重大的消息。&lt;/p>
&lt;/blockquote>
&lt;p>CNCF（云原生计算基金会）在美国时间 2019 年 2 月 28 日宣布 &lt;a href="https://github.com/containerd/containerd/">containerd&lt;/a> 今天正式毕业了。&lt;/p>
&lt;p>这是 CNCF 中毕业的第 5 个项目，之前已经毕业的项目为 &lt;a href="https://github.com/kubernetes">Kubernetes&lt;/a>、&lt;a href="https://github.com/prometheus">Prometheus&lt;/a>、&lt;a href="https://github.com/envoyproxy/envoy">Envoy&lt;/a> 和 &lt;a href="https://github.com/coredns/coredns">CoreDNS&lt;/a> 。&lt;/p>
&lt;p>containerd 2014 年从 Docker 孵化出来，最初是作为 Docker 引擎的底层管理器；在 2017 年 3 月被 CNCF 接受后，containerd 几乎成为了行业容器运行引擎的标准，它专注于简单，健壮和可移植性，任何人都可以使用它来构建自己的容器引擎/平台。&lt;/p>
&lt;blockquote>
&lt;p>“When Docker contributed containerd to the community, our goal was to share a robust and extensible runtime that millions of users and tens of thousands of organizations have already standardized on as part of Docker Engine,” said Michael Crosby, containerd maintainer and Docker engineer.&lt;/p>
&lt;/blockquote>
&lt;p>截至目前，containerd 的 GitHub 项目有 3533 个 Star ；221 个 Watch 和 726 个 Fork，贡献者超过了 166 位。相信在之后也会发展的更好。&lt;/p>
&lt;p>下面附上 containerd 的架构图，以后会更新关于 containerd 相关原理的文章。&lt;/p>
&lt;p>&lt;img src="https://containerd.io/img/architecture.png" alt="containerd architecture - https://moelove.info">&lt;/p>
&lt;p>再次恭喜 containerd 毕业。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">2018 小回顾</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/12/29/2018-%E5%B0%8F%E5%9B%9E%E9%A1%BE/"/><id>https://moelove.info/2018/12/29/2018-%E5%B0%8F%E5%9B%9E%E9%A1%BE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-12-29T20:43:00+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">年底了，惯例做个小回顾，对这一年做个总结，也对下一年大致做个规划。 不过今儿与往年不同的是昨晚突然发高烧，今儿都没能去上班，感谢我……</summary><content type="html">&lt;p>年底了，惯例做个小回顾，对这一年做个总结，也对下一年大致做个规划。&lt;/p>
&lt;p>不过今儿与往年不同的是昨晚突然发高烧，今儿都没能去上班，感谢我的小可爱在照顾我。这篇文章也是躺在床上用手机编辑的。&lt;/p>
&lt;p>还是按照惯例从工作，生活两方面来说。先聊聊工作。&lt;/p>
&lt;h2 id="工作">工作&lt;/h2>
&lt;p>现在在网易有道负责 DevOPS 实践落地及 k8s 容器化平台和自动化平台的规划建设等。&lt;/p>
&lt;p>总体来说，现在的工作很开心，更能发挥我的所长，也遇到了不错的团队。&lt;/p>
&lt;p>说到现在负责的工作，如果大致有些了解的就会知道这个过程比较漫长，推进起来也会有各种阻力。毕竟要改变很多人的思想和习惯，我也在尽量让这一过程变的更加平滑。&lt;/p>
&lt;p>同时也在 push 一些理念到行业内，到社区中，不断的进行交流碰撞总结。&lt;/p>
&lt;h3 id="社区贡献">社区贡献&lt;/h3>
&lt;p>今年下半年的贡献和分享相比去年更多一些。主要的分享有:&lt;/p>
&lt;ul>
&lt;li>GITC - 《云原生时代下的 CI/CD 实践》&lt;/li>
&lt;li>PyCon China - 《基于 Docker 的 CI/CD 实践》&lt;/li>
&lt;li>DockerOne 社区 - 《基于 GitLab 的 CI 实践》&lt;/li>
&lt;li>Tech Talk Time - 《Docker 实战和基础架构》&lt;/li>
&lt;/ul>
&lt;p>分享的主题基本都围绕在容器化和 CI/CD 方面，但每次分享内容却都不一样。
感谢我的小可爱，也感谢所有支持的朋友们。&lt;/p>
&lt;p>社区中主要活跃在 Docker 和 Kubernetes 生态方向。维护一些官方镜像，做测试，解决问题，提交代码之类的，明年希望做的更多。&lt;/p>
&lt;ul>
&lt;li>开了一个知乎专栏 &lt;a href="https://zhuanlan.zhihu.com/container">『k8s生态』&lt;/a> 明年会花更多时间进行建设。&lt;/li>
&lt;li>写了一本掘金小册&lt;a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac">《Kubernetes 从上手到实践》&lt;/a>。 其实这个名字并不能很好的概括小册里面的内容，其中也有源码分析之类的。要再次感谢小可爱，感谢编辑 Linmi ，感谢马达老板和何世友老板写的推荐语。也感谢所有人的支持，希望这本小册能对大家有所帮助。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/k8s-book-info.jpg" alt="">&lt;/p>
&lt;p>写小册的过程其实也蛮辛苦的，一般要么晚上写，写到凌晨 2~3 点，要么早上 5~6 点钟左右起床，写到去上班。尤其要感谢小可爱，给了我很多支持。&lt;/p>
&lt;h2 id="生活">生活&lt;/h2>
&lt;p>总的来说是丰富多彩的一年。年初(其实是17年底，去HK是为了跨年)和小可爱一起去了香港，看了场杨千嬅的演唱会，回来后她写了几篇游记：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247483867&amp;amp;idx=1&amp;amp;sn=c4b84bade488948a76f423bda2a6cac8&amp;amp;chksm=f9fadd4fce8d5459ac87610a04f981d2b8135916946a30826c713a57db1e62c5e532f283b93c&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229z381NQEOwyIQSiqP5jqa&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">HK游记（一）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247483883&amp;amp;idx=1&amp;amp;sn=9c528890defc11196d5fd36cc5182ac4&amp;amp;chksm=f9fadd7fce8d5469cc76f1b388f5711e978c7a302a8efd96de8a796bd69298c775aa93a7ce0b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229R8ZXEwjmUqltORxjHn5F&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">HK游记（二）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247483894&amp;amp;idx=1&amp;amp;sn=20fa1e71ee22f7c847425f3347efd1ac&amp;amp;chksm=f9fadd62ce8d54746ab686b37e2ef1a2f1c9138ebcf4ed05fa35aa4b665baadc3b373f6c7fc3&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229t5d4Ei9aVCPH0hbxABpl&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">HK游记（三）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>接下来去了成都，重庆，杭州：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247483977&amp;amp;idx=1&amp;amp;sn=9df9aaf0e7ce2d8216f808738297f194&amp;amp;chksm=f9fadeddce8d57cb16c0301f200269cd908af0bc297e6fb98e400d9336405337c2e4392a1131&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229x7UrfShAwPRecCX4noft&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">胖的这几个月与成都、重庆、杭州（一）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247484013&amp;amp;idx=1&amp;amp;sn=116a65d4848ff3211b40a8f184d55622&amp;amp;chksm=f9fadef9ce8d57efc31900570855c024054c8c431ba4f5d4e3492bad62c022f64184b350a596&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229K9lDnsp1n1Gz4rvguxk0&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">胖的这几个月与成都、重庆、杭州（二）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=MzUxOTMxMDg0Mw==&amp;amp;mid=2247484100&amp;amp;idx=1&amp;amp;sn=0bd00d6e132f9c50db4141871f2821cd&amp;amp;chksm=f9fade50ce8d57465e5c0400557d90ecb668eaac4a192cd054ef4d6751c55bbecb3decac3932&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1229sM8QeWMcEyq4vn0HFYvK&amp;amp;pass_ticket=sHR2YqA1CHLTyHoIQilemxv7Gu2axSZTRF7czMh1mHUJxlnxo1fn32Olk397Okml#rd">胖的这几个月与成都、重庆、杭州（三）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>之后我俩还去了苏州和南京，跟三九面基了下。&lt;/p>
&lt;p>再然后小可爱的爸妈来北京，我们一起逛了故宫，王府井之类的地儿。&lt;/p>
&lt;p>在这一年里小可爱的厨艺越来越棒，美滋滋，嘿嘿。（当然我也越来越胖）&lt;/p>
&lt;p>最后，希望明年能越来越好，实现继续在云原生领域的深耕；能跟小可爱越来越幸福。&lt;/p>
&lt;p>PS：今年比较冷，各位注意防寒保暖，免的像我一样生病了，身体很重要。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">《Kubernetes从上手到实践》正式上线</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/12/27/Kubernetes%E4%BB%8E%E4%B8%8A%E6%89%8B%E5%88%B0%E5%AE%9E%E8%B7%B5%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF/"/><id>https://moelove.info/2018/12/27/Kubernetes%E4%BB%8E%E4%B8%8A%E6%89%8B%E5%88%B0%E5%AE%9E%E8%B7%B5%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-12-27T11:16:21+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">时间飞逝，转眼已经到了圣诞节，今年又要结束了。感谢还在关注的小伙伴，今年确实更新很少，能不取关的都是真爱... 今年发生了很多事情……</summary><content type="html">&lt;p>时间飞逝，转眼已经到了圣诞节，今年又要结束了。感谢还在关注的小伙伴，今年确实更新很少，能不取关的都是真爱...&lt;/p>
&lt;p>今年发生了很多事情，留着过几天年终总结的时候再说。有很大一部分的休息时间都用来完成了&lt;a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac">我的第一本掘金小册 《Kubernetes 从上手到实践》&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/k8s-book.jpg" alt="">&lt;/p>
&lt;p>小册已经正式上线，特意送上各位小伙伴一份礼物，小册 8 折优惠。直接扫码 &lt;strong>或者&lt;a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac?referrer=570eef23ebcb7d0055844663">点击此链接&lt;/a>即可&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/k8s-book-info.jpg" alt="">&lt;/p>
&lt;p>以下是关于小册的一些介绍：&lt;/p>
&lt;p>随着容器化及微服务等概念的普及，各个公司都在围绕着如何打造生产环境可用的，高效的容器调度平台，应用快速部署，扩容等平台进行探索。Kubernetes 是 Google 在 2014 年基于其多年在 Borg 系统实践总结出的经验而开源出的一套标准化，可扩展的系统。&lt;/p>
&lt;p>而发展至现在（2018年）Kubernetes 已经基本成为了容器编排领域事实上的标准，并且大量的公司都已在生产中使用，无论是国外的 Google， Amazon, GitHub 等，还是国内的阿里，腾讯，京东，滴滴及其他中小公司都在进行着大量的探索及实践。&lt;/p>
&lt;p>之前在容器化尚未大量推进的时候，开发工程师只需要关注自己业务代码的实现，而运维工程师在反复的为部署，扩容所需的环境而费时费力。&lt;/p>
&lt;p>为了解决环境一致性的问题，也为了能够提高资源的利用率，容器化开始逐步推进，开发工程师的交付由原先的交付代码变成了交付镜像，运维工程师可以将精力集中于保障服务的可高用上。&lt;/p>
&lt;p>但为了能够快速的发版验证功能，不再受单体化架构的拖累，微服务的概念也在实践中逐步推进，从原先的单体集中式的服务，拆分为多个松耦合的微服务。到了这时，微服务 + 容器化已经大势所趋，生产中要大量使用，则容器编排变的愈发重要。Kubernetes 在容器编排领域目前已成为事实上的标准，大量公司均已在生产中推进，此时，无论是开发工程师还是运维工程师，皆需要了解并掌握 Kubernetes 的基础技能，才不至于丢失自己的竞争力。&lt;/p>
&lt;p>Kubernetes 所涉及的知识点很多, 并且版本迭代也很快，本小册将集中于 Kubernetes 的基础技能，以最常见 Case 入手，帮助大家更快的掌握相关知识并将其用于生产实践中。同时在此过程中，也会深入至 Kubernetes 必要的原理中，同时也会提供相关涉及到的 Docker 及 Linux 内核知识的补充，以便让大家不仅知其然，而且知其所以然。&lt;/p>
&lt;h2 id="你会学到什么">你会学到什么？&lt;/h2>
&lt;ul>
&lt;li>Kubernetes 基础架构&lt;/li>
&lt;li>Kubernetes 的基础技能, 覆盖常见 Case&lt;/li>
&lt;li>从零搭建 Kubernetes 集群&lt;/li>
&lt;li>与 Kubernetes 相关的 Docker 和 Linux 内核知识补充&lt;/li>
&lt;li>深入 Kubernetes 组件的原理和源码解析&lt;/li>
&lt;li>了解 Kubernetes 进阶相关知识体系&lt;/li>
&lt;/ul>
&lt;h2 id="适宜人群">适宜人群&lt;/h2>
&lt;ul>
&lt;li>了解 Docker，希望能进入 K8S 领域的各领域工程师；&lt;/li>
&lt;li>正在或即将在生产环境使用 K8S 的后端工程师；&lt;/li>
&lt;li>需要维护或在公司落地 K8S 的运维工程师；&lt;/li>
&lt;li>想要走在技术前沿的前端/后端/运维工程师；&lt;/li>
&lt;li>准备查缺补漏的容器相关开发工程师；&lt;/li>
&lt;/ul></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">runc 1.0-rc6 发布之际</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/11/23/runc-1.0-rc6-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/"/><id>https://moelove.info/2018/11/23/runc-1.0-rc6-%E5%8F%91%E5%B8%83%E4%B9%8B%E9%99%85/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-11-23T04:28:20+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">如果你在用 Docker 或者 Kubernetes 想必你对 容器运行时 这个概念应该不会太陌生。 在 Docker 中，当你使用 docker info 即可查看当前所使用的 runtime。 ➜ ~ docker info ... Server……</summary><content type="html">&lt;p>如果你在用 &lt;a href="http://docker.com">Docker&lt;/a> 或者 &lt;a href="https://kubernetes.io">Kubernetes&lt;/a> 想必你对 &lt;strong>容器运行时&lt;/strong> 这个概念应该不会太陌生。&lt;/p>
&lt;p>在 &lt;code>Docker&lt;/code> 中，当你使用 &lt;code>docker info&lt;/code> 即可查看当前所使用的 runtime。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ docker info
...
Server Version: 18.06.1-ce
Storage Driver: overlay2
Backing Filesystem: extfs
Supports d_type: &lt;span class="nb">true&lt;/span>
Native Overlay Diff: &lt;span class="nb">true&lt;/span>
Logging Driver: json-file
Cgroup Driver: cgroupfs
...
Swarm: inactive
Runtimes: nvidia runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 468a545b9edcd5932818eb9de8e72413e616e86e
runc version: 69663f0bd4b60df09991c08812a60108003fa340
init version: fec3683
Security Options:
seccomp
Profile: default
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时，你还可以自己在 &lt;code>/etc/docker/daemon.json&lt;/code> 中增加支持的 runtime ， 以及在 &lt;code>docker run&lt;/code> 的时候，通过 &lt;code>--runtime&lt;/code> 参数配置所使用的 runtime 。&lt;/p>
&lt;h2 id="什么是-runc">什么是 &lt;code>runc&lt;/code>&lt;/h2>
&lt;p>简单来说，它是 &lt;code>OCI&lt;/code> 标准的一种实现。 &lt;code>OCI&lt;/code> 标准包含 &lt;strong>运行时标准&lt;/strong> 和 &lt;strong>镜像标准&lt;/strong> 两个部分，而 &lt;code>OCI&lt;/code> 这个组织则是由 Docker, CoreOS 和其他的一些公司共同发起创建的，致力于将容器运行时和格式标准化。&lt;/p>
&lt;p>即：凡是遵守此标准的实现，无论是 &lt;code>Docker&lt;/code> 还是 &lt;code>rkt&lt;/code> 或者其他的运行时实现，均可以通过标准的镜像启动容器。&lt;/p>
&lt;p>&lt;code>runc&lt;/code> 则是在 &lt;code>OCI&lt;/code> 成立后，&lt;code>Docker&lt;/code> 将其容器运行时 &lt;code>libcontainer&lt;/code> 贡献出来后，并加以改造而成的。而 &lt;code>libcontainer&lt;/code> 也是在 &lt;code>Docker&lt;/code> 0.9 版本开始加入，我也是从这个版本开始使用它。&lt;/p>
&lt;p>当然 &lt;code>libcontainer&lt;/code> 出现的本意不仅是替换当时的 &lt;code>LXC&lt;/code> 依赖，同时也希望能以此作为规范（让其他的项目使用）最终，目标达成。&lt;/p>
&lt;h2 id="runc-如何使用">&lt;code>runc&lt;/code> 如何使用&lt;/h2>
&lt;p>&lt;code>runc&lt;/code> 的使用本不是本篇的重点，稍微带过。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ docker &lt;span class="nb">export&lt;/span> -o debian.tar &lt;span class="sb">`&lt;/span>docker create debian&lt;span class="sb">`&lt;/span>
➜ ~ ls
debian.tar
➜ ~ tar -C rootfs -xf debian.tar
➜ ~ ls
debian.tar rootfs
➜ ~ tree -L &lt;span class="m">1&lt;/span> -a rootfs
rootfs
├── bin
├── boot
├── dev
├── .dockerenv
├── etc
├── home
├── lib
├── lib64
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
&lt;span class="m">19&lt;/span> directories, &lt;span class="m">1&lt;/span> file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过以上操作，得到了运行一个容器所必须的 &lt;code>rootfs&lt;/code>，当然，上面看到我是通过 &lt;code>docker&lt;/code> 来获得这个文件的，但其实这只是为了方便罢了，&lt;code>docker&lt;/code> 并不是必须的。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ runc spec
➜ ~ ls
config.json debian.tar rootfs
&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上面的操作，会得到一个基本的 &lt;code>config.json&lt;/code> 的配置文件，这里面包含着运行一个容器所需要的一些配置。其中会包含着一些例如：&lt;/p>
&lt;pre>&lt;code>&amp;quot;ociVersion&amp;quot;: &amp;quot;1.0.1-dev&amp;quot;
&lt;/code>&lt;/pre>&lt;p>这种用于标识规范版本号的信息。&lt;/p>
&lt;p>接下来稍微对 &lt;code>config.json&lt;/code> 文件进行查看，便可以看到未通过 &lt;code>user&lt;/code> Namespace 进行隔离，所以我们需要以 &lt;code>root&lt;/code> 权限运行我们的容器。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">➜ ~ sudo runc run debian
&lt;span class="c1"># ls &lt;/span>
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
&lt;span class="c1"># hostname &lt;/span>
runc
&lt;span class="c1"># cat /etc/os-release&lt;/span>
&lt;span class="nv">PRETTY_NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Debian GNU/Linux 9 (stretch)&amp;#34;&lt;/span>
&lt;span class="nv">NAME&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Debian GNU/Linux&amp;#34;&lt;/span>
&lt;span class="nv">VERSION_ID&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;9&amp;#34;&lt;/span>
&lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;9 (stretch)&amp;#34;&lt;/span>
&lt;span class="nv">ID&lt;/span>&lt;span class="o">=&lt;/span>debian
&lt;span class="nv">HOME_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;https://www.debian.org/&amp;#34;&lt;/span>
&lt;span class="nv">SUPPORT_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;https://www.debian.org/support&amp;#34;&lt;/span>
&lt;span class="nv">BUG_REPORT_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;https://bugs.debian.org/&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到容器已经运行成功。当然，我们也可以不通过 &lt;code>root&lt;/code> 权限运行容器，只要简单的通过 &lt;code>user&lt;/code> Namespace 进行隔离，并添加 &lt;code>user&lt;/code> 和 &lt;code>group&lt;/code> 的映射之类的便可以了。此处不做赘述。&lt;/p>
&lt;h2 id="为何有-runc-10-rc6-存在">为何有 &lt;code>runc 1.0-rc6&lt;/code> 存在&lt;/h2>
&lt;p>我们知道，&lt;code>OCI&lt;/code> 在 2015 年成立，在 2017 年 7 月的时候正式宣布 &lt;code>OCI&lt;/code> v1.0.0 release 。其实在 2017 年的 11 月还 release 了 v1.0.1 版本。&lt;/p>
&lt;p>前面已经提过 &lt;code>runc&lt;/code> 是 &lt;code>OCI&lt;/code> 的官方实现，那为何时过一年还未正式 release 1.0 呢？这里面原因其实说来也复杂，这也是这篇文章想聊的部分。&lt;/p>
&lt;p>首先：&lt;code>runc&lt;/code> 1.0 我们想正式 relase 么？ 答案是 想。其实早在 2017 年 8 月份的时候 &lt;code>runc 1.0-rc4&lt;/code> 就已经支持 &lt;code>OCI&lt;/code> v1.0.0 了。但当时并没有进行正式版发布，转而三个月后， &lt;code>OCI&lt;/code> 稍做了更新。&lt;/p>
&lt;p>到 2018 年 2 月份的时候，发布了 &lt;code>runc 1.0-rc5 -- &amp;quot;The Final Stretch&amp;quot;&lt;/code> 这个版本取名其实已经很明确了 &lt;code>The Final Stretch&lt;/code> 已经将这个版本作为正式版本前的最后一个版本进行发布了。&lt;/p>
&lt;p>但是，提笔前又发了新版本 &lt;code>runc 1.0-rc6 -- &amp;quot;For Real This Time&amp;quot;&lt;/code> ，这个版本在预期中其实是想发布 1.0 的。我们讨论后总结的结论主要有以下几个：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不够规范。一方面是 &lt;code>runc&lt;/code> 在持续的迭代改进，另一方面是目前很多其他的运行时实现的一些 hooks 依赖于当前的一些实现，而这些实现，并不完全符合规范。这就造成了一旦修正了这些 “错误” 势必造成其他运行时的不稳定和错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发布周期不明确。目前容器相关生态中较为核心的项目，估计就 &lt;code>runc&lt;/code> 的发布周期比较 “佛系” 了，我们甚至没有一个明确的发布周期。这次的总结中，我以 Kubernetes 的发布做了例子：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Kubernetes Release&lt;/th>
&lt;th style="text-align:center">Date&lt;/th>
&lt;th style="text-align:center">Cadence&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Christening of 1.0&lt;/td>
&lt;td style="text-align:center">10th July 2015&lt;/td>
&lt;td style="text-align:center">~one year from inception&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.0 to 1.1&lt;/td>
&lt;td style="text-align:center">9th November 2015&lt;/td>
&lt;td style="text-align:center">122 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.1 to 1.2&lt;/td>
&lt;td style="text-align:center">16th March 2016&lt;/td>
&lt;td style="text-align:center">128 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.2 to 1.3&lt;/td>
&lt;td style="text-align:center">1st July 2016&lt;/td>
&lt;td style="text-align:center">107 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.3 to 1.4&lt;/td>
&lt;td style="text-align:center">26th September 2016&lt;/td>
&lt;td style="text-align:center">87 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.4 to 1.5&lt;/td>
&lt;td style="text-align:center">12th December 2016&lt;/td>
&lt;td style="text-align:center">77 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.5 to 1.6&lt;/td>
&lt;td style="text-align:center">28th March 2017&lt;/td>
&lt;td style="text-align:center">106 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.6 to 1.7&lt;/td>
&lt;td style="text-align:center">30th June 2017&lt;/td>
&lt;td style="text-align:center">94 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.7 to 1.8&lt;/td>
&lt;td style="text-align:center">28th September 2017&lt;/td>
&lt;td style="text-align:center">90 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.8 to 1.9&lt;/td>
&lt;td style="text-align:center">15th December 2017&lt;/td>
&lt;td style="text-align:center">78 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.9 to 1.10&lt;/td>
&lt;td style="text-align:center">28th March 2018&lt;/td>
&lt;td style="text-align:center">103 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.10 to 1.11&lt;/td>
&lt;td style="text-align:center">3rd July 2018&lt;/td>
&lt;td style="text-align:center">97 days&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">From 1.11 to 1.12&lt;/td>
&lt;td style="text-align:center">ETA 25th September 2018&lt;/td>
&lt;td style="text-align:center">84 days&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以这个发布记录来看的话，每三个月作为以此发布相对合适，也比较通用。&lt;/p>
&lt;p>至于这次，&lt;code>runc 1.0-rc6&lt;/code> 的发布，将作为特性冻结发布，直到下次发布前，重点都将放在 “符合规范” 上面，同时也给其他的运行时实现充足的时间，用于做好兼容之类的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上就是本次关于 &lt;code>runc 1.0-rc6&lt;/code> 发布时的一些碎碎念，对这种情况颇有感慨，“符合规范” 并没有那么好做，尤其是做基础支撑的时候。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/><category scheme="https://moelove.info/tags/Container/" term="Container" label="Container"/><category scheme="https://moelove.info/tags/runc/" term="runc" label="runc"/></entry><entry><title type="text">Docker 深入篇之 Build 原理</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/09/04/Docker-%E6%B7%B1%E5%85%A5%E7%AF%87%E4%B9%8B-Build-%E5%8E%9F%E7%90%86/"/><id>https://moelove.info/2018/09/04/Docker-%E6%B7%B1%E5%85%A5%E7%AF%87%E4%B9%8B-Build-%E5%8E%9F%E7%90%86/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-09-04T22:21:46+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">使用 Docker 时，最常用的命令无非是 docker container 和 docker image 相关的子命令，当然最初没有管理类命令（或者说分组）的时候，最常使用的命令也无非是 docker run docker commit docker……</summary><content type="html">&lt;p>使用 Docker 时，最常用的命令无非是 &lt;code>docker container&lt;/code> 和 &lt;code>docker image&lt;/code> 相关的子命令，当然最初没有管理类命令（或者说分组）的时候，最常使用的命令也无非是 &lt;code>docker run&lt;/code> &lt;code>docker commit&lt;/code> &lt;code>docker build&lt;/code> 和 &lt;code>docker images&lt;/code> 这些。&lt;/p>
&lt;p>今天来聊一下和 Docker 中核心概念 &lt;code>image&lt;/code> 相关的重要命令， &lt;code>docker build&lt;/code> 或者说 &lt;code>docker image build&lt;/code> 为了简便起见，下文的命令全部使用 &lt;code>docker build&lt;/code> 。&lt;/p>
&lt;h1 id="docker-image">Docker Image&lt;/h1>
&lt;p>先简单介绍下 Docker Image， 通常情况下我们将其称之为镜像，镜像是由多个层组成的文件，这些层用于在容器内执行代码（命令）等。每个镜像基本上都是根据应用程序完整的可执行版本进行构建的，并且需要注意的是，它会依赖于主机的系统内核。当用户在运行镜像时，这将会创建一个或者多个容器实例。&lt;/p>
&lt;h1 id="dockerd">Dockerd&lt;/h1>
&lt;p>Dockerd 是 Docker 的服务端，默认情况下提供 Unix Domain Socket 连接，当然也可以监听某个端口，用于对外提供服务。 所以有时候，我们也可以使用服务器上的 Docker daemon 来提供服务，以加快构建速度及解决一些网络问题之类的。&lt;/p>
&lt;p>好的，基础概念了解了， 那我们开始进入正题。&lt;/p>
&lt;h1 id="使用-dockerfile">使用 Dockerfile&lt;/h1>
&lt;p>我们知道构建镜像的方法有多种，本文中我们只介绍使用 Dockerfile 通过 &lt;code>docker build&lt;/code> 的方式构建镜像。&lt;/p>
&lt;p>为了简便，我们以一个简单的 Dockerfile 开始。构建一个容器内使用的 kubectl 工具 (当然选择它的原因在于 kubectl 足够大，并&lt;strong>不考虑可用性&lt;/strong>，这个稍后解释)&lt;/p>
&lt;pre>&lt;code>FROM scratch
LABEL maintainer='Jintao Zhang &amp;lt;moelove.info&amp;gt;'
ADD kubectl /kubectl
ENTRYPOINT [ &amp;quot;/kubectl&amp;quot; ]
&lt;/code>&lt;/pre>&lt;p>Dockerfile 足够简单，只是将 kubectl 的二进制文件拷贝进去，并将 Entrypoint 设置为 kubectl 。&lt;/p>
&lt;h1 id="dockerd-in-docker">Dockerd in Docker&lt;/h1>
&lt;p>我个人一般为了避免环境的污染，大多数的事情都在容器内完成。包括 dockerd 我也启在容器内。其中的原理不再介绍，可以参考我之前的文章或分享。使用起来很简单：&lt;/p>
&lt;pre>&lt;code>docker run --privileged -d -P docker:stable-dind
&lt;/code>&lt;/pre>&lt;p>注意这里使用了 &lt;code>-P&lt;/code> 所以本地会随机映射一个端口，当然你也可以直接指定映射到容器内的 2375 端口。&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ build git:(master) docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
b56f6483614d docker:stable-dind &amp;quot;dockerd-entrypoint.…&amp;quot; 9 hours ago Up 9 hours 0.0.0.0:32769-&amp;gt;2375/tcp trusting_babbage
&lt;/code>&lt;/pre>&lt;h1 id="构建">构建&lt;/h1>
&lt;p>我们直接使用启动在容器内的 dockerd 进行构建，通过上面的 &lt;code>docker ps&lt;/code> 命令可以看到是映射到了本地的 32769 端口。所以我们使用以下命令进行构建：&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ kubectl git:(master) docker -H 0.0.0.0:32769 images
REPOSITORY TAG IMAGE ID CREATED SIZE
(Tao) ➜ kubectl git:(master) docker -H 0.0.0.0:32769 build -t local/kubectl .
Sending build context to Docker daemon 55.09MB
Step 1/4 : FROM scratch
---&amp;gt;
Step 2/4 : LABEL maintainer='Jintao Zhang &amp;lt;moelove.info&amp;gt;'
---&amp;gt; Running in ebcf44071bf0
Removing intermediate container ebcf44071bf0
---&amp;gt; eb4ea1725ff2
Step 3/4 : ADD kubectl /kubectl
---&amp;gt; 1aad06c4dbb4
Step 4/4 : ENTRYPOINT [ &amp;quot;/kubectl&amp;quot; ]
---&amp;gt; Running in 2fc78fe974e3
Removing intermediate container 2fc78fe974e3
---&amp;gt; 457802d4bf3e
Successfully built 457802d4bf3e
Successfully tagged local/kubectl:latest
(Tao) ➜ kubectl git:(master) docker -H 0.0.0.0:32769 images
REPOSITORY TAG IMAGE ID CREATED SIZE
local/kubectl latest 457802d4bf3e 3 seconds ago 55.1MB
&lt;/code>&lt;/pre>&lt;p>看日志及结果，可以看到我们已经成功的构建了我们所需的镜像。说了这么多，其实我们今天的内容才刚刚开始。&lt;/p>
&lt;h1 id="深入原理">深入原理&lt;/h1>
&lt;h2 id="dockerd-服务">Dockerd 服务&lt;/h2>
&lt;p>在本文一开始，我已经提过 Dockerd 是 Docker 的后端服务，通过上面的&lt;/p>
&lt;pre>&lt;code>docker -H 0.0.0.0:32769 images
&lt;/code>&lt;/pre>&lt;p>这条命令可以看到我们通过 &lt;code>-H&lt;/code> 指定了本地 32679 端口的 dockerd 服务，这其实是个 HTTP 服务，我们来验证下。&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ kubectl git:(master) curl -i 0.0.0.0:32769/_ping
HTTP/1.1 200 OK
Api-Version: 1.37
Docker-Experimental: false
Ostype: linux
Server: Docker/18.03.1-ce (linux)
Date: Tue, 04 Sep 2018 17:20:51 GMT
Content-Length: 2
Content-Type: text/plain; charset=utf-8
OK%
&lt;/code>&lt;/pre>&lt;p>可以看到几条关键的信息 Api-Version: 1.37 这个表明了当前使用的 API 版本，本文的内容也是以 1.37 为例进行介绍，这是当前的稳定版本。我们也可以通过 &lt;code>docker version&lt;/code> 进行查看。&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ kubectl git:(master) docker -H 0.0.0.0:32769 version
Client:
Version: 18.06.0-ce
API version: 1.37 (downgraded from 1.38)
Go version: go1.10.3
Git commit: 0ffa825
Built: Wed Jul 18 19:11:45 2018
OS/Arch: linux/amd64
Experimental: false
Server:
Engine:
Version: 18.03.1-ce
API version: 1.37 (minimum version 1.12)
Go version: go1.9.5
Git commit: 9ee9f40
Built: Thu Apr 26 07:23:03 2018
OS/Arch: linux/amd64
Experimental: false
&lt;/code>&lt;/pre>&lt;p>可以看到我本地在用的 docker cli 版本较高，当连接到低版本的 dockerd 时，API 版本降级至与 dockerd 版本保持一致。&lt;/p>
&lt;p>当然，你可能会问，如果是 dockerd 版本高会如何呢？其实我日常中的开发环境就是这样，大多数 API 都没什么影响, 不过这并不是今天的重点。&lt;/p>
&lt;pre>&lt;code>root@bdcdac73ee20:/# docker version
Client:
Version: 17.06.0-ce
API version: 1.30
Go version: go1.8.3
Git commit: 02c1d87
Built: Fri Jun 23 21:15:15 2017
OS/Arch: linux/amd64
Server:
Version: dev
API version: 1.39 (minimum version 1.12)
Go version: go1.10.3
Git commit: e8cc5a0b3
Built: Tue Sep 4 10:00:36 2018
OS/Arch: linux/amd64
Experimental: false
&lt;/code>&lt;/pre>&lt;h2 id="build-context">build context&lt;/h2>
&lt;p>回到我们上面的构建过程中。我们可以看到日志内容的第一行：&lt;/p>
&lt;pre>&lt;code>...
Sending build context to Docker daemon 55.09MB
&lt;/code>&lt;/pre>&lt;p>从这条日志，我们可以得到两个信息：&lt;/p>
&lt;ul>
&lt;li>构建的过程是将 build context 发送给 dockerd , 实际的构建压力在 dockerd 上&lt;/li>
&lt;li>发送了 55.09 MB&lt;/li>
&lt;/ul>
&lt;p>第一条结论，我们在上一小节已经讨论过了，我们来重点看下第二条结论。&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ kubectl git:(master) ls -al
总用量 53808
drwxrwxr-x. 2 tao tao 4096 9月 5 01:00 .
drwxrwxr-x. 3 tao tao 4096 9月 5 00:57 ..
-rw-rw-r--. 1 tao tao 109 9月 5 01:00 Dockerfile
-rwxrwxr-x. 1 tao tao 55084063 9月 5 00:53 kubectl
(Tao) ➜ kubectl git:(master) du -sh .
53M .
(Tao) ➜ kubectl git:(master) du -sh kubectl Dockerfile
53M kubectl
4.0K Dockerfile
&lt;/code>&lt;/pre>&lt;p>按照我们 Dockerfile 的内容，我们需要将 kubectl 的二进制包放入镜像内，所以 build context 虽然比二进制文件多出来 2M 左右的大小你也不会很意外。&lt;/p>
&lt;p>但我这里做了另一个例子，不多赘述，代码可以在我的 &lt;a href="">GitHub&lt;/a> 中找到。这里贴出来结果：&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ text git:(master) ls -al
总用量 16
drwxrwxr-x. 2 tao tao 4096 9月 5 01:45 .
drwxrwxr-x. 4 tao tao 4096 9月 5 01:44 ..
-rw-rw-r--. 1 tao tao 77 9月 5 01:45 Dockerfile
-rw-rw-r--. 1 tao tao 61 9月 5 01:45 file
(Tao) ➜ text git:(master) du -b Dockerfile file
77 Dockerfile
61 file
(Tao) ➜ text git:(master) docker -H 0.0.0.0:32769 build --no-cache=true -t local/file .
Sending build context to Docker daemon 3.072kB
...
&lt;/code>&lt;/pre>&lt;p>相信你看到这个结果已经明白我想表达的意思，我们继续探索下这个过程。&lt;/p>
&lt;h2 id="build-请求">/build 请求&lt;/h2>
&lt;p>前面我们已经说过，这就是个普通的 HTTP 请求，所以我们当然可以直接抓包来看看到底发生了什么？&lt;/p>
&lt;p>很简单，通过 dockerd 的地址，使用 &lt;code>POST&lt;/code> 方法，访问 &lt;code>/build&lt;/code> 接口, 当然实际情况是会增加前缀，即我在上面提到的版本号，在目前的环境中使用的是 &lt;code>/v1.37/build&lt;/code> 这个接口。&lt;/p>
&lt;p>而这个请求携带了一些很有用的参数，和头信息。这里我来简单说下：&lt;/p>
&lt;h3 id="header">Header&lt;/h3>
&lt;p>build 请求的头部，主要有以下两个&lt;/p>
&lt;ul>
&lt;li>&lt;code>Content-Type&lt;/code> 默认值为 &lt;code>application/x-tar&lt;/code>，表明自己是一个归档。&lt;/li>
&lt;li>&lt;code>X-Registry-Config&lt;/code> 这个头部信息中包含着 registry 的地址及认证信息，并且以 base64 进行编码。对 docker 熟悉的朋友或者看过我之前文章的朋友应该知道， Docker cli 在 login 成功后，会将认证信息保存至本地，密码做 base64 保存。而 build 的时候则会将此信息再次 base64 进行编码。通过这里也可以看出来，在使用远端 Dockerd 的时候， 应该尽量配置 TLS 以防止中间人攻击，造成密码泄漏等情况。&lt;/li>
&lt;/ul>
&lt;h3 id="parameters">Parameters&lt;/h3>
&lt;p>请求参数中，列几个比较有意义的：&lt;/p>
&lt;ul>
&lt;li>&lt;code>t&lt;/code> 这其实就是我们 &lt;code>docker build -t&lt;/code> 时候指定的参数，并且，我们可以同时指定多个 &lt;code>-t&lt;/code> 同时构建多个不同名称的镜像。&lt;/li>
&lt;li>&lt;code>memory&lt;/code> &lt;code>cpusetcpus&lt;/code> 这些主要用于资源限制&lt;/li>
&lt;li>&lt;code>buildargs&lt;/code> 如果想要了解这个参数，可以回忆下 Dockerfile 中的 &lt;code>ARG&lt;/code> 指令的用法&lt;/li>
&lt;/ul>
&lt;p>当然，我们想要探索的过程其实重点就在于请求头部了， 整个请求的输入流，必须是一个 &lt;code>tar&lt;/code> 压缩包，并且支持 &lt;code>identity&lt;/code> (不压缩), &lt;code>gzip&lt;/code>, &lt;code>bzip2&lt;/code>, &lt;code>xz&lt;/code> 等压缩算法。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>我们来看下基本的实现：&lt;/p>
&lt;pre>&lt;code>func (cli *Client) ImageBuild(ctx context.Context, buildContext io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error) {
query, err := cli.imageBuildOptionsToQuery(options)
if err != nil {
return types.ImageBuildResponse{}, err
}
headers := http.Header(make(map[string][]string))
buf, err := json.Marshal(options.AuthConfigs)
if err != nil {
return types.ImageBuildResponse{}, err
}
headers.Add(&amp;quot;X-Registry-Config&amp;quot;, base64.URLEncoding.EncodeToString(buf))
headers.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-tar&amp;quot;)
serverResp, err := cli.postRaw(ctx, &amp;quot;/build&amp;quot;, query, buildContext, headers)
if err != nil {
return types.ImageBuildResponse{}, err
}
osType := getDockerOS(serverResp.header.Get(&amp;quot;Server&amp;quot;))
return types.ImageBuildResponse{
Body: serverResp.body,
OSType: osType,
}, nil
}
&lt;/code>&lt;/pre>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>这篇主要内容集中在 docker build 的过程及其原理上，为什么首先要写这篇，主要是因为镜像和我们息息相关， 并且也是我们使用的第一步。而很多情况下，推进业务容器化也都要面临着性能优化及其他规范之类的。&lt;/p>
&lt;p>其实关于 build 的细节还有很多，如果有空，我就再更新下一篇。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Docker/" term="Docker" label="Docker"/></entry><entry><title type="text">GitLab CI 使用 InsecureRegistry</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/08/06/GitLab-CI-%E4%BD%BF%E7%94%A8-InsecureRegistry/"/><id>https://moelove.info/2018/08/06/GitLab-CI-%E4%BD%BF%E7%94%A8-InsecureRegistry/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-08-06T08:12:03+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">继上次分享后，有读者留言问 dind 使用 insecure-registry 相关的问题。 请教个问题，基于gitlab CI做java项目持续集成，用到了docker in doc……</summary><content type="html">&lt;p>继上次分享后，有读者留言问 dind 使用 insecure-registry 相关的问题。&lt;/p>
&lt;blockquote>
&lt;p>请教个问题，基于gitlab CI做java项目持续集成，用到了docker in docker， docker build使用的Dockerfile中使用了一个insecure registry，在dind的容器中如何配置insecure registry&lt;/p>
&lt;/blockquote>
&lt;p>我的回复是：&lt;/p>
&lt;p>首先, 不推荐使用 insecure registry 毕竟有其固有限制， 如果一定要用的话， 其实在 services 层配置一个 command 就可以，这也是最简单的， 例如：&lt;/p>
&lt;pre>&lt;code>services:
- name: docker:dind
command: [&amp;quot;--insecure-registry=myregistry:5000&amp;quot;]
&lt;/code>&lt;/pre>&lt;p>由于留言字数的限制，就单独写个小文来回复下。&lt;/p>
&lt;p>这个做法实际效果如下：&lt;/p>
&lt;pre>&lt;code>(Tao) ➜ kubernetes git:(master) ✗ sudo docker run -d --privileged --name dind docker:dind --insecure-registry=&amp;quot;myregistry:5000&amp;quot;
8fb68865638ebc65255bb568fbe1fd6b4ed4fca771075d8e55ebbbbdf0aef6d2
(Tao) ➜ kubernetes git:(master) ✗ sudo docker top dind
UID PID PPID C STIME TTY TIME CMD
root 18270 18252 1 11:27 ? 00:00:00 dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --insecure-registry=myregistry:5000
root 18328 18270 0 11:27 ? 00:00:00 docker-containerd --config /var/run/docker/containerd/containerd.toml
&lt;/code>&lt;/pre>&lt;p>当然这样做是可以解决问题，但还是建议不要使用 &lt;code>insecure-registry&lt;/code> 毕竟这不是个安全的做法而且也有其限制。限制的部分不是这次的重点，也就不多做解释了。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/DevOps/" term="DevOps" label="DevOps"/><category scheme="https://moelove.info/tags/CI/" term="CI" label="CI"/><category scheme="https://moelove.info/tags/GitLab/" term="GitLab" label="GitLab"/></entry><entry><title type="text">基于 GitLab 的 CI 实践</title><link rel="alternate" type="text/html" href="https://moelove.info/2018/08/05/%E5%9F%BA%E4%BA%8E-GitLab-%E7%9A%84-CI-%E5%AE%9E%E8%B7%B5/"/><id>https://moelove.info/2018/08/05/%E5%9F%BA%E4%BA%8E-GitLab-%E7%9A%84-CI-%E5%AE%9E%E8%B7%B5/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2018-08-05T14:54:59+08:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">上个月受 DockOne 社区邀请，做了一次 CI 实践方面的线上分享，在此记录下。 本文讲述 GitLab CI 的架构及其能力特性，分析它在 DevOps 实践中的作用。 通过分析 Docker……</summary><content type="html">&lt;blockquote>
&lt;p>上个月受 DockOne 社区邀请，做了一次 CI 实践方面的线上分享，在此记录下。
本文讲述 GitLab CI 的架构及其能力特性，分析它在 DevOps 实践中的作用。 通过分析 Docker In Docker 的技术细节，详细讲述 CI 实践以及在生产环境中的所做的优化，包括但不限于镜像仓库等，以达到数倍的性能提升。
本次分享内容以 GitLab Community Edition 11.0.4 edb037c 为例。&lt;/p>
&lt;/blockquote>
&lt;h2 id="为何选择-gitlab-ci">为何选择 GitLab CI&lt;/h2>
&lt;h3 id="认识-gitlab-ci">认识 GitLab CI&lt;/h3>
&lt;h4 id="什么是-gitlab-ci">什么是 GitLab CI&lt;/h4>
&lt;p>GitLab CI 是 GitLab 为了提升其在软件开发工程中作用，完善 DevOPS 理念所加入的 CI/CD 基础功能。可以便捷的融入软件开发环节中。通过 GitLab CI 可以定义完善的 CI/CD Pipeline。&lt;/p>
&lt;h4 id="优势">优势&lt;/h4>
&lt;ul>
&lt;li>GitLab CI 是默认包含在 GitLab 中的，我们的代码使用 GitLab 进行托管，这样可以很容易的进行集成&lt;/li>
&lt;li>GitLab CI 的前端界面比较美观，容易被人接受&lt;/li>
&lt;li>包含实时构建日志，容易追踪&lt;/li>
&lt;li>采用 C/S 的架构，可方面的进行横向扩展，性能上不会有影响&lt;/li>
&lt;li>使用 YAML 进行配置，任何人都可以很方便的使用。&lt;/li>
&lt;/ul>
&lt;h3 id="重点概念">重点概念&lt;/h3>
&lt;h4 id="pipeline">Pipeline&lt;/h4>
&lt;p>Pipeline 相当于一个构建任务，里面可以包含多个流程，如依赖安装、编译、测试、部署等。
任何提交或者 Merge Request 的合并都可以触发 Pipeline&lt;/p>
&lt;h4 id="stages">Stages&lt;/h4>
&lt;p>Stage 表示构建的阶段，即上面提到的流程.&lt;/p>
&lt;ul>
&lt;li>所有 Stages 按顺序执行，即当一个 Stage 完成后，下一个 Stage 才会开始&lt;/li>
&lt;li>任一 Stage 失败，后面的 Stages 将永不会执行，Pipeline 失败&lt;/li>
&lt;li>只有当所有 Stages 完成后，Pipeline 才会成功&lt;/li>
&lt;/ul>
&lt;h4 id="jobs">Jobs&lt;/h4>
&lt;p>Job 是 Stage 中的任务.&lt;/p>
&lt;ul>
&lt;li>相同 Stage 中的 Jobs 会并行执行&lt;/li>
&lt;li>任一 Job 失败，那么 Stage 失败，Pipeline 失败&lt;/li>
&lt;li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 成功&lt;/li>
&lt;/ul>
&lt;p>好的，基本的概念已经和大家介绍了， 大家可以发现，上面说的概念，没有提到任务的实际执行者. 那任务在哪里执行呢？&lt;/p>
&lt;h3 id="gitlab-runner">GitLab runner&lt;/h3>
&lt;p>Runner 是任务的实际执行者， 可以在 MacOS/Linux/Windows 等系统上运行。使用 golang 进行开发。 同时也可部署在 k8s 上&lt;/p>
&lt;h4 id="注册">注册&lt;/h4>
&lt;pre>&lt;code>docker run --rm -t -i -v /path/to/config:/etc/gitlab-runner --name gitlab-runner gitlab/gitlab-runner register \
--executor &amp;quot;docker&amp;quot; \
--docker-image alpine:3 \
--url &amp;quot;https://gitlab.com/&amp;quot; \
--registration-token &amp;quot;PROJECT_REGISTRATION_TOKEN&amp;quot; \
--description &amp;quot;docker-runner&amp;quot; \
--tag-list &amp;quot;dev&amp;quot; \
--run-untagged \
--locked=&amp;quot;true&amp;quot;
&lt;/code>&lt;/pre>&lt;p>上面的示例为将 runner 注册为一个容器， 当然 大家也可以直接在物理机上执行。 在物理机上的注册方式与注册为容器大致相同&lt;/p>
&lt;pre>&lt;code>sudo gitlab-runner register \
--non-interactive \
--url &amp;quot;https://gitlab.com/&amp;quot; \
--registration-token &amp;quot;PROJECT_REGISTRATION_TOKEN&amp;quot; \
--executor &amp;quot;docker&amp;quot; \
--docker-image alpine:3 \
--description &amp;quot;docker-runner&amp;quot; \
--tag-list &amp;quot;docker,aws&amp;quot; \
--run-untagged \
--locked=&amp;quot;false&amp;quot; \
# （这段代码来自官方文档）
&lt;/code>&lt;/pre>&lt;p>接下来，我们来看下 runner 的类型， 以便在使用时进行区分。&lt;/p>
&lt;h4 id="类型">类型&lt;/h4>
&lt;ul>
&lt;li>Shared - Runner runs jobs from all unassigned projects&lt;/li>
&lt;li>Group - Runner runs jobs from all unassigned projects in its group&lt;/li>
&lt;li>Specific - Runner runs jobs from assigned projects&lt;/li>
&lt;li>Locked - Runner cannot be assigned to other projects&lt;/li>
&lt;li>Paused - Runner will not receive any new jobs&lt;/li>
&lt;/ul>
&lt;h4 id="配置">配置&lt;/h4>
&lt;p>首先最外层的是全局配置， 默认会有&lt;/p>
&lt;pre>&lt;code>concurrent = 1
check_interval = 0
&lt;/code>&lt;/pre>&lt;p>这两个。 比较需要关注的是下面几个&lt;/p>
&lt;h5 id="全局配置">全局配置&lt;/h5>
&lt;ul>
&lt;li>concurrent: 并发数, 0 为无限制&lt;/li>
&lt;li>sentry_dsn：与 Sentry 联动，可以将异常等收集至 Sentry 中。&lt;/li>
&lt;li>listen_address: 暴露出 metrics 供 Prometheus 监控&lt;/li>
&lt;/ul>
&lt;h4 id="executor">Executor&lt;/h4>
&lt;ul>
&lt;li>Shell&lt;/li>
&lt;li>Docker (本次的分享内容)&lt;/li>
&lt;li>Docker Machine and Docker Machine SSH (autoscaling)&lt;/li>
&lt;li>Parallels&lt;/li>
&lt;li>VirtualBox&lt;/li>
&lt;li>SSH&lt;/li>
&lt;li>Kubernetes (推荐)&lt;/li>
&lt;/ul>
&lt;h2 id="详解-docker-in-docker">详解 Docker In Docker&lt;/h2>
&lt;h3 id="概述">概述&lt;/h3>
&lt;p>Docker In Docker 简称 dind，在 GitLab CI 的使用中，可能会常被用于 service 的部分。 dind 表示在 Docker 中实际运行了一个 Docker 容器, 或 Docker daemon。&lt;/p>
&lt;p>其实如果只是在 Docker 中执行 docker 命令， 那装个二进制文件即可。 但是如果想要运行 Docker daemon (比如需要执行 docker info)或者访问任意的设备都是不允许的。&lt;/p>
&lt;p>Docker 在 run 命令中提供了两个很重要的选项 &lt;code>--privileged&lt;/code> 和 &lt;code>--device&lt;/code> ， 另外的选项比如 &lt;code>--cap-add&lt;/code> 和 &lt;code>--cap-drop&lt;/code> 跟权限也很相关，不过不是今天的重点，按下不表。&lt;/p>
&lt;p>&lt;code>--device&lt;/code> 选项可以供我们在不使用 &lt;code>--privileged&lt;/code> 选项时，访问到指定设备, 比如 &lt;code>docker run --device=/dev/sda:/dev/xvdc --rm -it ubuntu fdisk /dev/xvdc&lt;/code> 但是这也只是有限的权限， 我们知道 docker 的技术实现其实是基于 cgroup 的资源隔离，而 &lt;code>--device&lt;/code> 却不足于让我们在容器内有足够的权限来完成 docker daemon 的启动。&lt;/p>
&lt;p>在 2013年 左右， --privileged 选项被加入 docker， 这让我们在容器内启动容器变成了可能。 虽然 --privileged 的初始想法是为了能让容器开发更加便利，不过有些人在使用的时候，其实可能有些误解。&lt;/p>
&lt;p>有时候，我们可能只是想要能够在容器内正常的build 镜像，或者是与 Docker daemon 进行交互，例如 docker images 等命令。 那么，我们其实不需要 dind， 我们需要的是 Docker Out Of Docker，即 dood，在使用的时候，其实是将 docker.sock 挂载入容器内&lt;/p>
&lt;p>例如， 使用如下命令： &lt;code>sudo docker run --rm -ti -v /var/run/docker.sock:/var/run/docker.sock taobeier/docker /bin/sh&lt;/code> 在容器内可进行正常的docker images 等操作， 同时需要注意，在容器内的动作，将影响到宿主机上的 docker daemon。&lt;/p>
&lt;h3 id="如何实现">如何实现&lt;/h3>
&lt;ul>
&lt;li>创建组和用户，并将用户加入该组。 使用 groupadd 和 useradd 命令&lt;/li>
&lt;li>更新 subuid 和 subgid 文件， 将新用户和组配置到 /etc/subgid 和 /etc/subuid 文件中。 subuid 和 subgid 规定了允许用户使用的从属id&lt;/li>
&lt;li>接下来需要挂载 /sys/kernel/security 为 securityfs 类型可以使用 mountpoint 命令进行测试 &lt;code>mountpoint /sys/kernel/security&lt;/code> 如果不是一个挂载点， 那么使用 &lt;code>mount -t securityfs none /sys/kernel/security&lt;/code> 进行挂载。如果没有挂载成功的话， 可以检查是否是 SELinux 或者 AppArmor 阻止了这个行为。这里详细的安全问题，可以参考 Linux Security Modules (LSM)&lt;/li>
&lt;li>接下来允许 dockerd 命令启动 daemon 即可， &lt;code>dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375&lt;/code> 即可将docker daemon 监听至 2375 端口&lt;/li>
&lt;/ul>
&lt;h3 id="简单做法">简单做法&lt;/h3>
&lt;p>可以直接使用 Docker 官方镜像仓库中的 docker:dind 镜像, 但是在运行时， 需要指定 &lt;code>--privileged&lt;/code> 选项&lt;/p>
&lt;h2 id="ci-实践">CI 实践&lt;/h2>
&lt;h3 id="runner-实践">runner 实践&lt;/h3>
&lt;p>看 runner 部分的配置&lt;/p>
&lt;pre>&lt;code>[[runners]]
name = &amp;quot;docker&amp;quot;
url = &amp;quot;https://gitlab.example.com/&amp;quot;
token = &amp;quot;TOKEN&amp;quot;
limit = 0
executor = &amp;quot;docker&amp;quot;
builds_dir = &amp;quot;&amp;quot;
shell = &amp;quot;&amp;quot;
environment = [&amp;quot;ENV=value&amp;quot;, &amp;quot;LC_ALL=en_US.UTF-8&amp;quot;]
clone_url = &amp;quot;http://172.17.0.4&amp;quot;
&lt;/code>&lt;/pre>&lt;p>由于网络原因， clone_url 可以配置为可访问的地址，这样代码 clone 的时候，将会使用配置的这个地址。实际请求为 &lt;code>http://gitlab-ci-token:TOKEN@172.17.0.4/namespace/project.git&lt;/code>&lt;/p>
&lt;ul>
&lt;li>再看一下 runners.docker 的配置，这部分将影响 docker 的实际运行&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>[runners.docker]
host = &amp;quot;&amp;quot;
hostname = &amp;quot;&amp;quot;
tls_cert_path = &amp;quot;/home/tao/certs&amp;quot;
image = &amp;quot;docker&amp;quot;
dns = [&amp;quot;8.8.8.8&amp;quot;]
privileged = false
userns_mode = &amp;quot;host&amp;quot;
devices = [&amp;quot;/dev/net/tun&amp;quot;]
disable_cache = false
wait_for_services_timeout = 30
cache_dir = &amp;quot;&amp;quot;
volumes = [&amp;quot;/data&amp;quot;, &amp;quot;/home/project/cache&amp;quot;]
extra_hosts = [&amp;quot;other-host:127.0.0.1&amp;quot;]
services = [&amp;quot;mongo&amp;quot;, &amp;quot;redis:3&amp;quot;]
allowed_images = [&amp;quot;go:*&amp;quot;, &amp;quot;python:*&amp;quot;, &amp;quot;java:*&amp;quot;]
&lt;/code>&lt;/pre>&lt;p>dns, privileged, extra_hosts, services 比较关键， 尤其是在生产中网络情况多种多样， 需要格外关注。 至于 devices 配置 ，在今儿分享的一开始已经讲过了， allowed_images 的话， 是做了个限制。&lt;/p>
&lt;p>上面几个配置项， 用过 docker 的同学，应该很容易理解。 我们来看下 services 这个配置项&lt;/p>
&lt;pre>&lt;code>image: registry.docker-cn.com/taobeier/docker
variables:
DOCKER_DRIVER: overlay2 # overlay2 is best bug need kernel &amp;gt;= 4.2
services:
- name: registry.docker-cn.com/taobeier/docker:stable-dind
alias: docker
stages:
- build
- deploy
build_and_test:
stage: build
tags:
- build
script:
# change repo
#- sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories
# 使用默认官方源 apk 耗时 7min 30s. 修改后 耗时 18s
- ping -c 1 docker
- ping -c 1 registry.docker-cn.com__taobeier__docker
- ipaddr
- apk add --no-cache py-pip
# 使用默认耗时 1 min 15s. 修改后耗时 43s
- pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple docker-compose
- docker-compose up -d
- docker-compose run --rm web pytest -s -v tests/test_session.py
deploy:
image: &amp;quot;registry.docker-cn.com/library/centos&amp;quot;
stage: deploy
tags:
- deploy
script:
# install ssh client
- 'ssh-agent || (yum install -y openssh-clients)'
# run ssh-agent
- eval $(ssh-agent -s)
- echo &amp;quot;$SSH_PRIVATE_KEY&amp;quot; | tr -d '\r' | ssh-add - &amp;gt; /dev/null
# create ssh dir
- mkdir -p ~/.ssh
- chmod 700 ~/.ssh
# use ssh-keyscan to get key
- ssh-keyscan -p $SSH_PORT $DEPLOY_HOST &amp;gt;&amp;gt; ~/.ssh/known_hosts
- chmod 644 ~/.ssh/known_hosts
# - ssh -p $SSH_PORT $DEPLOY_USER@$DEPLOY_HOST ls
- rm -rf .git
- scp -r -P $SSH_PORT . $DEPLOY_USER@$DEPLOY_HOST:~/we/
&lt;/code>&lt;/pre>&lt;p>services 的本质其实是使用了 docker 的 --link ，我们来看下它如何工作&lt;/p>
&lt;h3 id="docker-executor-如何工作">Docker Executor 如何工作&lt;/h3>
&lt;ul>
&lt;li>创建 service 容器 (已经配置在 service 中的镜像)&lt;/li>
&lt;li>创建 cache 容器 (存储已经配置在 config.toml 的卷和构建镜像的 Dockerfile)&lt;/li>
&lt;li>创建 build 容器 并且 link 所有的 service 容器.&lt;/li>
&lt;li>启动 build 容器 并且发送 job 脚本到该容器中.&lt;/li>
&lt;li>执行 job 的脚本.&lt;/li>
&lt;li>检出代码: /builds/group-name/project-name/.&lt;/li>
&lt;li>执行 .gitlab-ci.yml 中定义的步骤.&lt;/li>
&lt;li>检查脚本执行后的状态码，如果非 0 则构建失败.&lt;/li>
&lt;li>移除 build 和 service 容器.&lt;/li>
&lt;/ul>
&lt;h3 id="私有镜像源">私有镜像源&lt;/h3>
&lt;p>用户认证需要 GitLab Runner 1.8 或更高版本，在 0.6 ~ 1.8 版本之间的 Runner 需要自行去 Runner 的机器上手动执行。&lt;/p>
&lt;p>默认情况下，如果访问的镜像仓库需要认真的话， GitLab Runner 会使用 DOCKER_AUTH_CONFIG 变量的作为认证的凭证。&lt;/p>
&lt;p>注意：DOCKER_AUTH_CONFIG 是完成的 docker auth 凭证，也就是说，它应该和我们 ~/.docker/config.json 中的内容一致，例如：&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;auths&amp;quot;: {
&amp;quot;registry.example.com&amp;quot;: {
&amp;quot;auth&amp;quot;: &amp;quot;5oiR5piv5byg5pmL5rab&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>简单的做法就是，我们在本地/服务器上执行 &lt;code>docker login 私有镜像源&lt;/code> 登录成功后，将 ~/.docker/config.json 的文件内容直接复制，作为我们的变量的值, 或者是 &lt;code>echo -n '用户名:密码' | base64&lt;/code> 以这样的方式来获得 auth 的内容，组装成对应的格式，写入 GitLab 的 value 配置中。&lt;/p>
&lt;h2 id="生产环境中的-ci-性能优化">生产环境中的 CI 性能优化&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>使用国内源对容器镜像进行加速 例如：使用 Docker 中国官方镜像加速服务 &lt;a href="https://registry.docker-cn.com">https://registry.docker-cn.com&lt;/a> 当然各家公司其实也有提供镜像加速的服务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用私有镜像仓库。例如 Docker Registry, 或者 Harbor, 我们是在使用 Harbor 作为私有镜像仓库的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因为网络的原因， 如果默认使用官方镜像， 1. 官方镜像拉不下来；2. 在官方镜像中安装包耗时长；3. 如果换源，需要每个 Dockerfile 都要做相同的事情。 这我们当然是不能同意的。 所以，我们构建了自己的私有镜像。 从 BusyBox 开始, 构建 Alpine Linux 使用私有源， 以此为基础 构建我们所需要的其他镜像。 用户不再需要自行换源。&lt;/p>
&lt;p>这个操作完成后， 原先我们需要在 CI 执行的过程中安装 py-pip（为了安装 docker-compose 和我们的服务依赖）耗时从 3min30s 减少到了 18s。&lt;/p>
&lt;p>这里，需要说下为何我们是从头开始构建镜像，而不是基于官方镜像。 主要是为了减少镜像体积 以及为了更快的适用于我们的需求。&lt;/p>
&lt;p>同样的，我们构建了基础的 Docker 镜像，Python/Maven 等镜像，都是默认使用了我们的私有源，并且，用户在使用时， 并不需要关注换源的事情， 减少用户的心智负担。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>规范 Dockerfile， 减少不必要的依赖安装, 减少镜像体积。其实结合上面的部分，我们做的事情是直接构建了我们的基础镜像 docker/alpine/maven之类的基础镜像，默认直接都换了源。这样既方便使用，还可以减少镜像层数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拆分 job， 通过 tag 的方式可指定runner， 由不同的 runner 来并行执行无强依赖的一些动作。 便于分摊压力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 Cache, CI 的构建中，大多数的镜像，其实变化不大，所以使用cache 可以成倍的提升 CI 的速度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可能遇到的坑&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>前面提到了 service 中可以使用各种各样的服务， 无论是 dind 还是 mysql redis 等。 但是 如果我们全部做到了优化，都使用我们的私有源， 那便会发现问题。&lt;/p>
&lt;p>因为 gitlab ci 默认对于 &lt;code>docker:dind&lt;/code> 的 service 其实会选择连名为 docker 的 host ，以及 2375 端口。 当使用私有镜像源的时候， 比如&lt;/p>
&lt;pre>&lt;code>services:
- name: registry.docker-cn.com/taobeier/docker:stable-dind
&lt;/code>&lt;/pre>&lt;p>那这个 service 的 host 是什么呢？&lt;/p>
&lt;p>这个 service 的 host 其实是会变成 &lt;code>registry.docker-cn.com__taobeier__docker&lt;/code> ，然后 gitlab runner 便会找不到， job 就会执行失败&lt;/p>
&lt;p>有两种解决办法。 一种是加一个变量&lt;/p>
&lt;pre>&lt;code>variables:
DOCKER_HOST: &amp;quot;tcp://registry.docker-cn.com__taobeier__docker:2375&amp;quot;
&lt;/code>&lt;/pre>&lt;p>但是 这种方式 很麻烦， 没有人能完全记住 遇到 / 会转换为 _ 难免会有问题。 那么就有了第二种办法：&lt;/p>
&lt;pre>&lt;code>services:
- name: registry.docker-cn.com/taobeier/docker:stable-dind
- alias: docker
&lt;/code>&lt;/pre>&lt;p>加一个 alias 。 这个方法目前很少人在用， 毕竟网络上查到的都是第一种 ，但是这个方式却是最简单的。&lt;/p>
&lt;h2 id="qa">Q&amp;amp;A&lt;/h2>
&lt;p>Q：您提到把各种依赖都以 Service 的提供，请问是以哪种方式呢？ 比如Python的依赖，怎么做成Service呢？&lt;/p>
&lt;p>A：Service 化的依赖，主要是指类似 DB / MySQL/ Reids 之类的。 或者是 dind 其实它提供的是 2375 端口的TCP服务。 Python 的依赖，我推荐的做法是， 构建一个换了源的 Python 镜像。 安装依赖的时候，耗时会少很多。 或者说， 可以在定义 Pipeline 的时候， 将虚拟环境的 venv 文件夹作为 cache ，之后的安装也会检查这个，避免不必要的安装。&lt;/p>
&lt;p>Q：请问，你们为什么不用Jenkins Pipeline，而使用GitLab CI？&lt;/p>
&lt;p>A：主要原因是我提到的那几个方面。 集成较好， 界面美观优雅， 使用简单（所有有仓库写权限的人 都可以使用， 只要创建 .gitlab-ci.yml 并且配置了 Runner 即可使用） 。换个角度，我们来看下使用Jenkins 的问题， Jenkins 对于项目的配置其实和 GitLab 的代码是分离的， 两部分的， 用户（或者说我们的开发者）在使用的时候， 需要有两个平台， 并且，大多数时候， Jenkins 的权限是不放开的。 对用户来讲， 那相当于是个黑盒。 那可能的问题是什么呢？ 遇到构建失败了， 但是只有运维知道发生了什么，但是研发无能为力，因为没有权限。 使用GItLab的好处，这个时候就更加突出了， 配置就在代码仓库里面，并且使用 YAML 的配置，很简单。 有啥问题，直接查，直接改。&lt;/p>
&lt;p>Q：关于 Runner 的清理的问题，在长时间使用后，Runner 机器上回产生很多的 Cache 容器，如何清理呢。能够在任务中自动清除吗？&lt;/p>
&lt;p>A：这个就相对简单了，首先， 如果你的 Cache 容器确认没用了， 每个 Cache 容器其实都有名字的， 直接按 Cache 的名字过略， 批量删掉。 如果你不确定它是否有用，那你直接删掉也是不影响的， 因为 Docker Excutor 的执行机制是创建完 Service 容器后， 创建 Cache 容器。 要是删掉了，它只是会再创建一次。 如果你想在任务中清除， 目前还没做相关的实践，待我实践后，看看有没有很优雅的方式。&lt;/p>
&lt;p>Q：请问下Maven的settings.xml怎么处理？本地Maven仓库呢？&lt;/p>
&lt;p>A：我们构建了私有的 Maven 镜像， 私有镜像中是默认使用了我们的私有源。 对于项目中用户无需关注 settings.xml 中是否配置repo。&lt;/p>
&lt;p>Q：在GitLab的CD方案中，在部署的时候，需要在变量中配置跳板机的私钥，如果这个项目是对公司整部门开发，那么如何保护这个私钥呢？&lt;/p>
&lt;p>A：可以使用 secret variable 将私钥写入其中， （但是项目的管理员，具备查看该 variable 的权限）开发一个 web server （其实只要暴露 IP 端口之类的就可以） 在 CI 执行的过程中去请求， server 对来源做判断 （比如 执行CI 的时候，会有一些特定的变量，以此来判断，是否真的是 CI 在请求）然后返回私钥。&lt;/p>
&lt;p>Q：GitLab CI适合什么类型的项目呢？国内目前还比较小众吧？&lt;/p>
&lt;p>A：国内目前还较为小众（相比 Jenkins 来说）其实只要需要 CI 的项目，它都适合。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/DevOps/" term="DevOps" label="DevOps"/><category scheme="https://moelove.info/tags/CI/" term="CI" label="CI"/><category scheme="https://moelove.info/tags/GitLab/" term="GitLab" label="GitLab"/></entry><entry><title type="text">Install-Python3.6-on-CentOS7</title><link rel="alternate" type="text/html" href="https://moelove.info/2017/06/30/Install-Python3.6-on-CentOS7/"/><id>https://moelove.info/2017/06/30/Install-Python3.6-on-CentOS7/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2017-06-30T00:13:16+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">拖了很久没有更新，抱歉啦~ 今天受邀写篇如何在 CentOS 7 上配置 Python 3 环境的文章。往常我都选择直接把我早年写的一篇文章源码编译MongoDB……</summary><content type="html">&lt;blockquote>
&lt;p>拖了很久没有更新，抱歉啦~ 今天受邀写篇如何在 CentOS 7 上配置 Python 3 环境的文章。往常我都选择直接把我早年写的一篇文章&lt;a href="http://moelove.info/2015/09/13/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91MongoDB/">源码编译MongoDB&lt;/a>丢过去，让他们看其中的源码编译 Python 那一节，不过那节写的其实不太详细，而且最近被很多人催，所以还是单独写一篇好了。&lt;/p>
&lt;/blockquote>
&lt;p>当前最新的 CentOS 7.3 默认安装的是 Python 2 ，并且默认的官方 &lt;code>yum&lt;/code> 源中不提供 Python 3 的安装包。有些用户想要升级使用 Python 3 但实际可能有各种各样的问题，导致出错，反观一下激进的 Fedora 社区，在23的时候，就将默认的版本修改成了 Python3 （如果我没记错的话）。&lt;/p>
&lt;p>先说下我所使用的系统环境， 一个新创建的 Docker 容器。 使用 &lt;code>cat /etc/redhat-release&lt;/code> 可以看到运行的是 CentOS 7.3 版本。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/systemInfo.png" alt="systeminfo">&lt;/p>
&lt;p>在纯净的 CentOS 系统上安装 Python 环境主要有两种办法。 一种是通过源码编译安装，另外一种就是安装已经打好的 RPM 包。依照个人习惯，我们先来看一下如何通过源码编译的方式安装 Python 3.6 并且配置虚拟环境。&lt;/p>
&lt;h1 id="使用源码进行编译安装">使用源码进行编译安装&lt;/h1>
&lt;h2 id="基础环境">基础环境&lt;/h2>
&lt;ul>
&lt;li>先安装安装几个必须的包，以方便后续的操作&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>➜ yum install wget gcc make
➜ # wget 用于下载源码包
➜ # gcc 和 make 用于编译
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/install_gcc_wget.png" alt="install_gcc_wget">&lt;/p>
&lt;ul>
&lt;li>上 &lt;a href="https://www.python.org/">Python的官网&lt;/a> 下载源码包&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>➜ wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>解包，解压缩&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>➜ xz -d Python-3.6.1.tar.xz
➜ tar -xvf Python-3.6.1.tar
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/decompress_archives.png" alt="decompress_archives">&lt;/p>
&lt;ul>
&lt;li>编译&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>➜ cd Python-3.6.1
➜ ./configure --prefix=/usr/local/python3.6 --enable-optimizations
➜
&lt;/code>&lt;/pre>&lt;p>先解释下上面的参数，&lt;code>--prefix&lt;/code> 是预期安装目录，&lt;code>--enable-optimizations&lt;/code> 是优化选项（LTO，PGO 等）加上这个 flag 编译后，性能有 10% 左右的优化（如果没记错的话），但是这会明显的增加编译时间。不过关于 LTO 和 PGO 其实不在今天文章的讨论范围内，建议感兴趣的可以看看 &lt;a href="https://gcc.gnu.org/onlinedocs/gccint/LTO-Overview.html">GCC 中 LTO 的具体实现&lt;/a>。我应该不太可能去写相关的文章 哈哈哈 毕竟写起来就会停不下来。&lt;/p>
&lt;p>接下来&lt;/p>
&lt;pre>&lt;code>➜ make
➜ make install
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/make_error.png" alt="make_error">&lt;/p>
&lt;p>如图，会看到出错了，提示 &lt;code>zlib not available&lt;/code> 所以，我们需要装一下依赖&lt;/p>
&lt;pre>&lt;code>➜ yum install zlib-devel
&lt;/code>&lt;/pre>&lt;p>那为什么需要这个依赖包呢， 其实是因为 Python 有个很重要的内建模块 &lt;code>zipimport&lt;/code> 用于从 Zip 压缩包中导入模块。 而如果没有 zlib 的包，那么就无法进行解压缩了，也自然该模块就不能使用了。&lt;/p>
&lt;p>当我们的依赖安装好之后，重新执行上面的编译安装的步骤，发现执行成功。&lt;/p>
&lt;pre>&lt;code>➜ /usr/local/python3.6/bin/python3 --version
Python 3.6.1
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/install_success.png" alt="install_success">&lt;/p>
&lt;p>此刻，我们的 Python 3 也就安装成功了。&lt;/p>
&lt;ul>
&lt;li>检查&lt;/li>
&lt;/ul>
&lt;p>编译安装完还远远不够，我们来做些检查。&lt;/p>
&lt;p>当我们运行 Python 终端，输入 &lt;code>import bz2&lt;/code> 的时候，会发现没有这个模块。如果你对这个模块不熟悉，那也没关系。我们输入 &lt;code>import sqlite3&lt;/code>熟悉 Python 的同学应该对 sqlite3 不会太陌生，但如果你还是不熟悉的话，那你按方向键试试看。有没有发现，输出变成了&lt;code>^[[D^[[A&lt;/code> 类似这样的内容？&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/arrow_keys_problem.png" alt="arrow_keys_problem">&lt;/p>
&lt;p>熟悉 Python 源码的同学，肯定知道我要说什么了。但是假如你不熟悉，没关系，我来告诉你。正常来讲，在终端下我们预期当输入上方向键，会显示上一条命令，输入左方向键，可以将光标移动到左侧。但现实和我们的预期不同，什么原因？&lt;/p>
&lt;p>这里涉及到了一点点关于输入设备的历史原因，简单来说就是需要有个模块来对用户的输入进行转义。回到本文的重点，就是我们编译安装的时候缺少了 &lt;code>readline&lt;/code> 这个模块。既然已经发现了问题，那解决的办法其实很简单&lt;/p>
&lt;pre>&lt;code>➜ yum install readline-devel
&lt;/code>&lt;/pre>&lt;p>安装完成后，重复上面的步骤，编译&amp;amp;&amp;amp;安装即可。&lt;/p>
&lt;ul>
&lt;li>再检查&lt;/li>
&lt;/ul>
&lt;p>前面只是解决了方向键输入的问题，但是我提到的那两个模块还是 import 不进来，那我们仔细的看看我们的编译过程的输出。其中有这样的一段（依据系统环境的不同，输出可能也是不一致的）&lt;/p>
&lt;pre>&lt;code>Python build finished successfully!
The necessary bits to build these optional modules were not found:
_curses bz2 _dbm
_gdbm _lzma _sqlite3
_tkinter readline
To find the necessary bits, look in setup.py in detect_modules() for the module's name.
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/some_optional_modules_were_not_found.png" alt="some_optional_modules_were_not_found">&lt;/p>
&lt;p>按照上面的提示，很明显，我们缺少了一些（可选的）模块，这些模块假如你觉得自己不会用到，那也可以不理会它。这些模块，我用到的会多一些，甚至是那个一般人都不会碰的 TK 模块 哈哈哈。解决方式就只是装一下对应的模块即可。&lt;/p>
&lt;pre>&lt;code>➜ # 解决 import bz2 报错
➜ yum install bzip2-devel
➜ # 解决 import curses 报错
➜ yum install ncurses-devel
➜ # 解决 import sqlite3 报错
➜ yum install sqlite-devel
➜ # 解决 _dbm _gdbm 缺失提醒
➜ yum install gdbm-devel
➜ # 解决 _lzma 缺失提醒
➜ yum install xz-devel
➜ # 解决 _tkinter 缺失提醒
➜ yum install tk-devel
➜ # 解决 readline 缺失提醒及方向键行为非预期的问题
➜ yum install readline-devel
&lt;/code>&lt;/pre>&lt;p>当这些模块都装完，重新编译会发现提醒已经消失，安装即可。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/all_modules_were_found.png" alt="all_modules_were_found">&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/import_successful.png" alt="import_successful">&lt;/p>
&lt;h1 id="使用-rpm-包进行安装">使用 rpm 包进行安装&lt;/h1>
&lt;p>先来介绍一下 &lt;a href="https://ius.io/">IUS&lt;/a> 这个社区，名字的全写是【Inline with Upstream Stable】取首字母，它主要是一个提供新版本RPM包的社区。具体使用可以查看&lt;a href="https://ius.io/GettingStarted/#install-via-automation">官方文档&lt;/a> 简单说来就只要按下面的命令操作即可。&lt;/p>
&lt;pre>&lt;code>➜ yum -y install https://centos7.iuscommunity.org/ius-release.rpm
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/yum_install_ius.png" alt="yum_install_ius">&lt;/p>
&lt;p>添加 IUS 之后，先创建缓存元数据，再进行安装即可&lt;/p>
&lt;pre>&lt;code>➜ yum makecache
➜ yum install python36u
➜ yum -y install python36u-pip
➜ yum -y install python36u-devel
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/yum_install_python36u.png" alt="yum_install_python36u">&lt;/p>
&lt;p>完成后直接终端输入 &lt;code>python3&lt;/code> 即可。&lt;/p>
&lt;h1 id="环境配置">环境配置&lt;/h1>
&lt;p>上面只是写了 Python 的安装，如果是使用 RPM 的方式安装的话，那直接是可用的。但如果是源码编译的，总不至于每次都输入一大串路径吧。所以解决方法很简单，加个链接即可。&lt;/p>
&lt;pre>&lt;code>➜ ln -s /usr/local/python3.6/bin/python3 /usr/bin/python3
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/ln.png" alt="ln">&lt;/p>
&lt;p>另外，当系统中存在多个 Python 版本的时候，尽量去避免环境污染。我个人比较推荐使用 &lt;code>virtualenv&lt;/code> 创建独立的虚拟环境，我日常中也是这样用的。不过，当我们安装完 Python 3.6 后，可以直接执行下面的命令进行虚拟环境的创建。&lt;/p>
&lt;pre>&lt;code>➜ python3 -m venv py3
➜ source py3/bin/activate
(py3) ➜ python -V
Python 3.6.1
&lt;/code>&lt;/pre>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>CentOS 7 上安装Python 3.6 主要有两种方式，源码编译和安装 RPM 包。&lt;/p>
&lt;p>对于想快速使用源码配置环境但并不想关心具体原因的读者，可以直接使用我GitHub上提供的这个脚本进行安装 &lt;a href="https://raw.githubusercontent.com/tao12345666333/dotfiles/master/env/install_Python36_on_CentOS7.sh">https://raw.githubusercontent.com/tao12345666333/dotfiles/master/env/install_Python36_on_CentOS7.sh&lt;/a>&lt;/p>
&lt;p>另外Python 3.6 可直接使用 &lt;code>python3 -m venv venv_name&lt;/code> 创建虚拟环境。&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="TheMoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Python/" term="Python" label="Python"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">理解 Redis 的 RESP 协议</title><link rel="alternate" type="text/html" href="https://moelove.info/2017/03/05/%E7%90%86%E8%A7%A3-Redis-%E7%9A%84-RESP-%E5%8D%8F%E8%AE%AE/"/><id>https://moelove.info/2017/03/05/%E7%90%86%E8%A7%A3-Redis-%E7%9A%84-RESP-%E5%8D%8F%E8%AE%AE/</id><updated>2021-11-24T16:36:49+08:00</updated><published>2017-03-05T21:45:07+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">简介 Redis 的客户端和服务端之间采取了一种独立名为 RESP(REdis Serialization Protocol) 的协议，作者主要考虑了以下几个点： 容易实现 解析快 人类可读 注意：RESP 虽然是为……</summary><content type="html">&lt;h1 id="简介">简介&lt;/h1>
&lt;p>Redis 的客户端和服务端之间采取了一种独立名为 RESP(REdis Serialization Protocol) 的协议，作者主要考虑了以下几个点：&lt;/p>
&lt;ul>
&lt;li>容易实现&lt;/li>
&lt;li>解析快&lt;/li>
&lt;li>人类可读&lt;/li>
&lt;/ul>
&lt;p>注意：RESP 虽然是为 Redis 设计的，但是同样也可以用于其他 C/S 的软件。&lt;/p>
&lt;h1 id="数据类型及示例">数据类型及示例&lt;/h1>
&lt;p>RESP 主要可以序列化以下几种类型：整数，单行回复(简单字符串)，数组，错误信息，多行字符串。Redis 客户端向服务端发送的是一组由执行的命令组成的字符串数组，服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以 &amp;quot;\r\n&amp;quot; (CRLF) 结尾的。另外 RESP 是二进制安全的，不需要处理从一个进程到另一个进程的传输，因为它使用了前缀长度进行传输。&lt;/p>
&lt;p>在 RESP 中, 一些数据的类型通过它的第一个字节进行判断：&lt;/p>
&lt;ul>
&lt;li>单行回复：回复的第一个字节是 &amp;quot;+&amp;quot;&lt;/li>
&lt;li>错误信息：回复的第一个字节是 &amp;quot;-&amp;quot;&lt;/li>
&lt;li>整形数字：回复的第一个字节是 &amp;quot;:&amp;quot;&lt;/li>
&lt;li>多行字符串：回复的第一个字节是 &amp;quot;$&amp;quot;&lt;/li>
&lt;li>数组：回复的第一个字节是 &amp;quot;*&amp;quot;&lt;/li>
&lt;/ul>
&lt;h2 id="单行回复">单行回复&lt;/h2>
&lt;p>以 &amp;quot;+&amp;quot; 开头，以 &amp;quot;\r\n&amp;quot; 结尾的字符串形式。e.g.&lt;/p>
&lt;pre>&lt;code>+OK\r\n
&lt;/code>&lt;/pre>&lt;p>响应的客户端库，应该返回除 &amp;quot;+&amp;quot; 和 CRLF 以外的内容，例如上面的内容，则返回 &amp;quot;OK&amp;quot;. e.g.&lt;/p>
&lt;pre>&lt;code>127.0.0.1:6379&amp;gt; set name JintaoZhang
+OK\r\n # 服务端实际返回
---
OK # redis-cli 客户端显示
&lt;/code>&lt;/pre>&lt;h2 id="错误信息">错误信息&lt;/h2>
&lt;p>错误信息和单行回复很像，不过是把 &amp;quot;+&amp;quot; 替换成了 &amp;quot;-&amp;quot;。而这两者之间真正的区别是，错误信息会被客户端视为异常，并且组成错误类型的是错误消息本身。e.g.&lt;/p>
&lt;pre>&lt;code>-Error message\r\n
&lt;/code>&lt;/pre>&lt;p>错误信息只在有错误发生的时候才会发送，比如数据类型错误，语法错误，或者命令不存在之类的。而当接收到错误信息的时候，客户端库应该抛出一个异常。e.g.&lt;/p>
&lt;pre>&lt;code>127.0.0.1:6379&amp;gt; JintaoZhang
-ERR unknown command 'JintaoZhang'\r\n # 服务端实际返回, 下同
---
(error) ERR unknown command 'JintaoZhang' # redis-cli 客户端显示, 下同
127.0.0.1:6379&amp;gt; set name JintaoZhang moelove
-ERR syntax error\r\n
---
(error) ERR syntax error
&lt;/code>&lt;/pre>&lt;h2 id="整数">整数&lt;/h2>
&lt;p>这种类型只是只是使用以 &amp;quot;:&amp;quot; 作为前缀，以CRLF作为结尾的字符串来表示整数。e.g. &amp;quot;:666\r\n&amp;quot; 或者 &amp;quot;:999\r\n&amp;quot; 这种的都是整数回复。很多命令都会返回整数回复，例如 &lt;code>INCR&lt;/code> &lt;code>LLEN&lt;/code> &lt;code>LPUSH&lt;/code> 之类的命令。但是多数情况下，返回的整数回复并没有过多实际含义，例如 &lt;code>LPUSH&lt;/code> 就只是为了表示插入了几个值，但也有例如 &lt;code>EXISTS&lt;/code> 命令是当结果为 true 的时候返回 1，false 返回 0 . e.g.&lt;/p>
&lt;pre>&lt;code>127.0.0.1:6379&amp;gt; LPUSH info JintaoZhang MoeLove
:2\r\n # 服务端实际返回, 下同
---
(integer) 2 # redis-cli 客户端显示, 下同
127.0.0.1:6379&amp;gt; LLEN info
:2\r\n
---
(integer) 2
127.0.0.1:6379&amp;gt; EXISTS info
:1\r\n
---
(integer) 1
127.0.0.1:6379&amp;gt; DEL info
:1\r\n
---
(integer) 1
127.0.0.1:6379&amp;gt; EXISTS info
:0\r\n
---
(integer) 0
&lt;/code>&lt;/pre>&lt;h2 id="多行字符串">多行字符串&lt;/h2>
&lt;p>多行字符串被服务端用来返回长度最大为 512MB 的单个二进制安全的字符串。以 &amp;quot;$&amp;quot; 开头, 后跟实际要发送的字节数，随后是 CRLF，然后是实际的字符串数据，最后以 CRLF 结束。所以，例如我们要发送一个 &amp;quot;moelove.info&amp;quot; 的字符串，那它实际就被编码为 &amp;quot;$12\r\nmoelove.info\r\n&amp;quot;。而如果一个要发送一个空字符串，则会编码为 &amp;quot;$0\r\n\r\n&amp;quot; 。某些情况下，当要表示不存在的值时候，则以 &amp;quot;$-1\r\n&amp;quot; 返回，这被叫做空多行字符串，当客户端库接收到这个响应的时候，同样应该返回一个空值（例如 &lt;code>nil&lt;/code>）而不是一个空字符串。e.g.&lt;/p>
&lt;pre>&lt;code>127.0.0.1:6379&amp;gt; set site moelove.info
+OK\r\n # 服务端实际返回, 下同
---
OK # redis-cli 客户端显示, 下同
127.0.0.1:6379&amp;gt; get site
$12\r\nmoelove.info\r\n
---
&amp;quot;moelove.info&amp;quot;
127.0.0.1:6379&amp;gt; del site
:1\r\n
---
(integer) 1
127.0.0.1:6379&amp;gt; get site
$-1\r\n
---
(nil)
127.0.0.1:6379&amp;gt; set site ''
+OK\r\n
---
OK
127.0.0.1:6379&amp;gt; get site
$0\r\n\r\n
---
&amp;quot;&amp;quot;
&lt;/code>&lt;/pre>&lt;h2 id="数组">数组&lt;/h2>
&lt;p>数组类型可用于客户端向服务端发送命令，同样的当某些命令将元素结合返回给客户端的时候，也是使用数组类型作为回复类型的。它以 &amp;quot;*&amp;quot; 开头，后面跟着返回元素的个数，随后是 CRLF, 再然后就是数组中各元素自己的类型了。最典型的是 &lt;code>LRRANGE&lt;/code> 命令，返回一个列表中的元素。e.g.&lt;/p>
&lt;pre>&lt;code>127.0.0.1:6379&amp;gt; LPUSH info JintaoZhang moelove.info
:2\r\n # 服务端实际返回, 下同
---
(integer) 2 # redis-cli 客户端显示, 下同
127.0.0.1:6379&amp;gt; LRANGE info 0 -1
*2\r\n$12\r\nmoelove.info\r\n$8\r\nJintaoZhang\r\n
---
1) &amp;quot;moelove.info&amp;quot;
2) &amp;quot;JintaoZhang&amp;quot;
127.0.0.1:6379&amp;gt; LPOP info
$12\r\nmoelove.info\r\n
---
&amp;quot;moelove.info&amp;quot;
127.0.0.1:6379&amp;gt; LPOP info
$8\r\nJintaoZhang\r\n
---
&amp;quot;JintaoZhang&amp;quot;
127.0.0.1:6379&amp;gt; LRANGE info 0 -1
*0\r\n
---
(empty list or set)
&lt;/code>&lt;/pre>&lt;h1 id="总结">总结&lt;/h1>
&lt;p>RESP 协议还是相对易于理解的，另外理解了协议也方便对 Redis 一些问题的定位及客户端的实现。&lt;/p>
&lt;p>参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.io/topics/protocol">Redis Protocol specification&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Redis/" term="Redis" label="Redis"/></entry><entry><title type="text">2016 小回顾</title><link rel="alternate" type="text/html" href="https://moelove.info/2017/01/01/2016-%E5%B0%8F%E5%9B%9E%E9%A1%BE/"/><id>https://moelove.info/2017/01/01/2016-%E5%B0%8F%E5%9B%9E%E9%A1%BE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2017-01-01T01:00:51+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">时间很快， 已经走到了 2016 的末尾， 惯例的做个小回顾。（注：这篇起笔的时间是圣诞节TAT） 年初定的目标除了没有能合理安排追番时间， 其他……</summary><content type="html">&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/1043453-ce357ac3c236b6de.png" alt="github-2016.png">&lt;/p>
&lt;p>时间很快， 已经走到了 2016 的末尾， 惯例的做个小回顾。（注：这篇起笔的时间是圣诞节TAT）&lt;/p>
&lt;p>年初定的目标除了没有能合理安排追番时间， 其他的都基本完成了！（话说今年追番的时间简直少的可怜QAQ）&lt;/p>
&lt;p>2016 年发生了太多的事情，要回顾的事情很多，索性就不写那么多了, 只按时间序稍微列几件有趣的事情。&lt;/p>
&lt;ul>
&lt;li>单表亿级数据量的 MongoDB 做在线实时的数据拆分&lt;/li>
&lt;li>在之前做的一些应用性能分析的方案上做了一些额外的设计和开发（明年修改下开源出来）&lt;/li>
&lt;li>PyCon China 2016&lt;/li>
&lt;li>一些预期的计划顺利推进、落地，产出了一些系统&lt;/li>
&lt;li>看了很多源码，折腾了很多东西，如果以后有空就写点东西出来（我又在给自己挖坑了）&lt;/li>
&lt;li>认识了很多有趣的小伙伴~&lt;/li>
&lt;/ul>
&lt;p>全年的状态基本和上面的截图是一致的， 全年都在 coding （截图仅限 GitHub上的记录）倒也比较开心， 另外就是现在看到自己项目的 star/fork 数，文章的阅读/收藏/转发数之类的，也已经不像以前看到 star 数刚上百时候会有那种喜悦了，大概这也是另一种成熟？ 哈哈哈&lt;/p>
&lt;p>另外写一下今年对我比较重要的几个数字：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>1354&lt;/strong>&lt;/li>
&lt;li>&lt;strong>376&lt;/strong>&lt;/li>
&lt;li>&lt;strong>105&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>对这些数字的解释, 放在以后吧 :-)&lt;/p>
&lt;p>&lt;strong>2017 年，希望想做的事情都能基本完成，挖的坑慢慢填。 感谢一路上陪我走过的各位！&lt;/strong>&lt;/p>
&lt;hr>
&lt;p>可以通过下面二维码订阅我的文章公众号【MoeLove】&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/tao12345666333/collection/master/images/my_qrcode.jpg" alt="MoeLove">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">关于 webpack 你可能忽略的细节（附源码分析）</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/12/26/%E5%85%B3%E4%BA%8E-webpack-%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82%E9%99%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/><id>https://moelove.info/2016/12/26/%E5%85%B3%E4%BA%8E-webpack-%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82%E9%99%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-12-26T00:43:02+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">注：本篇不是入门教程，入门请直接查看官方文档。本篇的主要目标是通过实际问题来介绍 webpack 中容易被人忽略的细节, 以及源码分析(以最新发布……</summary><content type="html">&lt;blockquote>
&lt;p>注：本篇不是入门教程，入门请直接查看&lt;a href="http://webpack.github.io/docs/">官方文档&lt;/a>。本篇的主要目标是通过实际问题来介绍 webpack 中容易被人忽略的细节, 以及源码分析(&lt;strong>以最新发布的 release 版本1.14.0的源码为例&lt;/strong>), 并且提供几种解决方案。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://moelove.qiniudn.com/webpack.png" alt="webpack from the official website">&lt;/p>
&lt;p>随着前端技术的火热发展，工程化，模块化和组件化的思想已逐步成为主流，与之相应的，就需要有一整套工具流可以支撑起它。&lt;/p>
&lt;p>现在比较热门的前端资源模块化管理和打包工具应该非 &lt;a href="https://github.com/webpack/webpack">Webpack&lt;/a> 莫属了。&lt;/p>
&lt;h1 id="webpack-是什么">Webpack 是什么&lt;/h1>
&lt;blockquote>
&lt;p>它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。
--引自 Webpack 中文指南&lt;/p>
&lt;/blockquote>
&lt;h1 id="使用举例">使用举例&lt;/h1>
&lt;p>我们来看一下官方文档中的最小用例，新建并写入以下内容到这两个文件：&lt;/p>
&lt;p>&lt;strong>cats.js&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kd">var&lt;/span> &lt;span class="nx">cats&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;dave&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;henry&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;martha&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exports&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">cats&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>app.js (Entry Point)&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="nx">cats&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./cats.js&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">cats&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个时候，就可以使用 &lt;code>webpack&lt;/code> 进行打包了：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">webpack ./app.js app.bundle.js
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们来看一下发生了什么， 目录下生成了一个打包后的文件 &lt;code>app.bundle.js&lt;/code> ，这就是最基础的打包过程。&lt;/p>
&lt;h1 id="提出问题">提出问题&lt;/h1>
&lt;p>&lt;strong>如何判断打包是否成功？&lt;/strong>&lt;/p>
&lt;h2 id="通用方案">通用方案&lt;/h2>
&lt;p>下面是我们常用的两种判断任务是否执行成功的方案&lt;/p>
&lt;h4 id="通过-return-code">通过 return code&lt;/h4>
&lt;p>通过命令执行后的 &lt;code>return code&lt;/code> 来判断（在 &lt;code>shell&lt;/code> 中使用 &lt;code>$?&lt;/code> 获得）。 并且通常情况下 &lt;code>0&lt;/code> 是执行成功， 非 0 是未成功。 我们以上面的例子来测试一下：&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/webpack-c.png" alt="webpack-demo.png">&lt;/p>
&lt;p>可以看到 &lt;code>$?&lt;/code> 的值为 &lt;code>0&lt;/code> , 且打包后的文件运行正常。&lt;/p>
&lt;p>那么我们来修改一下 &lt;code>app.js&lt;/code> 文件的内容， 将 &lt;code>require&lt;/code> 引入的模块路径故意写错，来测试一下：&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/webpack-error.png" alt="webpack-error.png">&lt;/p>
&lt;p>&lt;strong>注意：箭头处 &lt;code>$?&lt;/code> 的值仍然为 &lt;code>0&lt;/code>, 且生成的打包后的文件运行出错。&lt;/strong>&lt;/p>
&lt;p>这就说明，根据 &lt;code>return code&lt;/code> 的值判断任务是否执行成功， 不可行！&lt;/p>
&lt;h4 id="通过标准错误输出">通过标准错误输出&lt;/h4>
&lt;p>我们也会通过&lt;strong>标准错误输出&lt;/strong>（&lt;code>stderr&lt;/code>）来判断一个任务执行过程中是否有错误输出。还是使用上面的例子做示范：&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/webpack-stderr.png" alt="webpack-stderr.png">&lt;/p>
&lt;p>根据这个例子，可以看到 webpack 并没有标准错误输出！所以这个方法也不可行。&lt;/p>
&lt;h1 id="探究原因及源码分析">探究原因及源码分析&lt;/h1>
&lt;p>这里以最新发布的 release 版本 1.14.0 的源码作为分析。 在 &lt;a href="https://github.com/webpack/webpack/blob/v1.14.0/lib/Compilation.js#L194-L204">lib/Compilation.js&lt;/a> 中我们可以看到这样一段代码：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kd">var&lt;/span> &lt;span class="nx">errorAndCallback&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">errorAndCallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">dependencies&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">dependencies&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">origin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">module&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">dependenciesErrors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="mi">_&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">bail&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">callback&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在源码中可以看到这个函数其实被调用的还比较多， 例如：在模块为可选的时候， 会判断只是抛出警告还是处理错误， 而上面这段代码自然也不必多数， 关键点在于 &lt;code>bail&lt;/code> 的值， 而我们继续找， 可以看到在 &lt;code>bin/config-optimist.js&lt;/code> 中有对 &lt;code>bail&lt;/code> 参数的解析， 这是一个布尔值。而因为没有太多描述， 所以这个参数就经常容易被忽略。&lt;/p>
&lt;h1 id="解决方案">解决方案&lt;/h1>
&lt;h3 id="1-加-bail-参数">1. 加 &lt;strong>bail&lt;/strong> 参数&lt;/h3>
&lt;p>基于上面简要的分析， 我们来尝试下 &lt;code>bail&lt;/code> 参数的作用。 仍然使用上面的例子：&lt;/p>
&lt;p>我们使用 &lt;code>webpack --bail true app.js app.bundle.js&lt;/code> 进行测试&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/webpack-bail.png" alt="webpack-bail.png">&lt;/p>
&lt;p>可以看到， 使用 &lt;code>bail&lt;/code> 参数并传递 &lt;code>true&lt;/code> 进去， 在遇到错误的时候，打包过程将会退出， &lt;code>return code&lt;/code> 为 &lt;code>1&lt;/code> 且把错误信息打印到 &lt;code>stderr&lt;/code> .&lt;/p>
&lt;h3 id="2-使用-webpack-fail-plugin">2. 使用 webpack-fail-plugin&lt;/h3>
&lt;p>&lt;a href="https://www.npmjs.com/package/webpack-fail-plugin">webpack-fail-plugin&lt;/a> 是专为解决这个问题而生的，它会在错误发生的时候 &lt;code>return 1&lt;/code>. 使用方法也很简单：&lt;/p>
&lt;p>安装：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">npm install webpack-fail-plugin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kd">var&lt;/span> &lt;span class="nx">failPlugin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;webpack-fail-plugin&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
 
&lt;span class="nx">module&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exports&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
    &lt;span class="c1">//config 
&lt;/span>&lt;span class="c1">&lt;/span>    &lt;span class="nx">plugins&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
        &lt;span class="nx">failPlugin&lt;/span>
    &lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3使用-done-plugin">3.使用 done plugin&lt;/h3>
&lt;p>具体用法如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">plugins&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">plugin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;done&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stats&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">stats&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">compilation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errors&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">stats&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">compilation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stats&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">compilation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">errors&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nx">process&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">});&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="c1">// ...
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-使用-webpack-2">4. 使用 webpack 2&lt;/h3>
&lt;p>不过 webpack 2 现在还在 beta 阶段，可以期待下。 （webpack 2 也仍然是使用 bail 参数）&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Webpack/" term="Webpack" label="Webpack"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/><category scheme="https://moelove.info/tags/%E5%89%8D%E7%AB%AF/" term="前端" label="前端"/></entry><entry><title type="text">Composer 使用技巧简述</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/12/16/Composer-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AE%80%E8%BF%B0/"/><id>https://moelove.info/2016/12/16/Composer-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AE%80%E8%BF%B0/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-12-16T00:49:11+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近使用了世界最好的语言 PHP 用来管理依赖关系的工具 Composer. 稍微做点记录, 以做备忘. 如有错误还望指出. 安装 php -r &amp;#34;copy(&amp;#39;https://getcomposer.org/installer&amp;#39;, &amp;#39;composer-setup.php&amp;#39;);&amp;#34; php -r &amp;#34;if (hash_file(&amp;#39;SHA384&amp;#39;, &amp;#39;composer-setup.php&amp;#39;) === &amp;#39;aa96f26c2b67226a324c27919f1eb05f21c248b987e6195cad9690d5c1ff713d53020a02ac8c217dbf90a7eacc9d141d&amp;#39;) { echo &amp;#39;Installer verified&amp;#39;; }……</summary><content type="html">&lt;blockquote>
&lt;p>最近使用了世界最好的语言 PHP 用来管理依赖关系的工具 &lt;code>Composer&lt;/code>. 稍微做点记录, 以做备忘. 如有错误还望指出.&lt;/p>
&lt;/blockquote>
&lt;h1 id="安装">安装&lt;/h1>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">php -r &lt;span class="s2">&amp;#34;copy(&amp;#39;https://getcomposer.org/installer&amp;#39;, &amp;#39;composer-setup.php&amp;#39;);&amp;#34;&lt;/span>
php -r &lt;span class="s2">&amp;#34;if (hash_file(&amp;#39;SHA384&amp;#39;, &amp;#39;composer-setup.php&amp;#39;) === &amp;#39;aa96f26c2b67226a324c27919f1eb05f21c248b987e6195cad9690d5c1ff713d53020a02ac8c217dbf90a7eacc9d141d&amp;#39;) { echo &amp;#39;Installer verified&amp;#39;; } else { echo &amp;#39;Installer corrupt&amp;#39;; unlink(&amp;#39;composer-setup.php&amp;#39;); } echo PHP_EOL;&amp;#34;&lt;/span>
php composer-setup.php
php -r &lt;span class="s2">&amp;#34;unlink(&amp;#39;composer-setup.php&amp;#39;);&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码来自&lt;a href="https://getcomposer.org/download/">官网&lt;/a>.&lt;/p>
&lt;h2 id="局部安装">局部安装&lt;/h2>
&lt;p>上述代码执行完成后, 只是下载到了 &lt;code>composer.phar&lt;/code> 文件, 可以通过 &lt;code>php composer.phar&lt;/code> 在任意位置执行.&lt;/p>
&lt;h2 id="全局安装">全局安装&lt;/h2>
&lt;p>全局安装只是把 &lt;code>composer.phar&lt;/code> 安装到 PATH 下即可. 可以像下面这样:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">sudo mv composer.phar /usr/local/bin/composer
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="国内镜像加速">国内镜像加速&lt;/h1>
&lt;p>使用&lt;a href="http://pkg.phpcomposer.com/">Composer中文网&lt;/a>提供的中国全量镜像进行加速.&lt;/p>
&lt;h2 id="单项目加速">单项目加速&lt;/h2>
&lt;p>进入项目目录(即 &lt;code>composer.json&lt;/code> 文件所在目录) 执行:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">composer config repo.packagist composer https://packagist.phpcomposer.com
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条命令将在 &lt;code>composer.json&lt;/code> 文件的末尾添加镜像加速配置:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">
&lt;span class="s2">&amp;#34;repositories&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;packagist&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;composer&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;https://packagist.phpcomposer.com&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="全局加速">全局加速&lt;/h2>
&lt;p>可以直接执行:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">composer config --global repo.packagist composer https://packagist.phpcomposer.com
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配置">配置&lt;/h1>
&lt;p>参考 &lt;a href="https://getcomposer.org/doc/06-config.md">官方配置文档&lt;/a>.&lt;/p>
&lt;p>因为 &lt;code>composer&lt;/code> 默认情况下, 会在使用的用户的家目录下生成 &lt;code>.composer&lt;/code> 文件夹, 存放配置相关, 所以我们可以对这些部分进行配置.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">composer config --global data-dir /www/.composer
composer config --global cache-dir /www/.composer
&lt;span class="c1"># cache-files-maxsize 也可以稍微大一点, 还有缓存时间&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="auth-相关">Auth 相关&lt;/h1>
&lt;p>Gitlab token 可以查看 &lt;a href="https://docs.gitlab.com/ee/api/README.html#oauth-2-tokens">https://docs.gitlab.com/ee/api/README.html#oauth-2-tokens&lt;/a>&lt;/p>
&lt;h1 id="注意事项">注意事项&lt;/h1>
&lt;p>当 &lt;code>type&lt;/code> 配置为 &lt;code>gitlab&lt;/code>, &lt;code>github&lt;/code> 等时, 会优先通过 &lt;code>.composer/auth.json&lt;/code> 文件中的配置来选择认证信息进行验证. 如果没有解决 Auth 认证相关问题, 可以使用普通的 &lt;code>vcs&lt;/code> 例如 &lt;code>git&lt;/code> 来使用.&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/PHP/" term="PHP" label="PHP"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/></entry><entry><title type="text">Git workflow 详谈</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/12/05/Git-workflow-%E8%AF%A6%E8%B0%88/"/><id>https://moelove.info/2016/12/05/Git-workflow-%E8%AF%A6%E8%B0%88/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-12-05T22:40:41+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">作为一名工程师， Git 在日常开发中是不可或缺的工具。 这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。……</summary><content type="html">&lt;p>作为一名工程师， &lt;code>Git&lt;/code> 在日常开发中是不可或缺的工具。
这里详细介绍几种比较常用的基于 Git 的工作流模型, 以便于团队协作的规范化和效率提升。&lt;/p>
&lt;h1 id="中心化工作流">中心化工作流&lt;/h1>
&lt;p>使用过SVN的应该都知道， SVN使用的是集中式管理流程， 如果你刚从SVN 切换到 Git ， 你可以尝试使用中心化工作流的方式。这样，你几乎不需要变更之前的工作方式， 就可以完成平滑的过渡了。 而且在使用过程中还可以看到 Git 优于 SVN 的地方：
第一，每个成员都可以在本地拥有一份完整的项目代码仓库，而不只是一个工作区的副本，任何人都可以在本地执行 &lt;code>add&lt;/code> 和 &lt;code>commit&lt;/code> ，而不需要考虑远端仓库是否有变更，直到需要的时候再去提交即可。
第二，Git 的工作区、暂存区、引用更新等设计，可以给开发者更多自由来切换当前工作，且不会造成代码丢失。&lt;/p>
&lt;h2 id="工作细节">工作细节&lt;/h2>
&lt;p>中心化工作流的方式是：在远端（远端可以是服务器端，也可以是本地的任意目录）新建一个仓库，默认是 master 分支，作为唯一的中心仓库。 所有人都 &lt;code>clone&lt;/code> 这个仓库作为本地仓库，并在本地仓库进行开发。本地的提交是和远端仓库无关的，等需要的时候再 &lt;code>push&lt;/code> 进主仓库的 master 分支即可。&lt;/p>
&lt;p>在这种方式下， 远端是唯一确定的中心仓库， 所有人都要以这个仓库为准。 所以，在提交之前要先 &lt;code>fetch&lt;/code> 最新提交，在这些提交之上作出自己的更改(一般我们使用 &lt;code>rebase&lt;/code>来完成)。&lt;/p>
&lt;p>如果本地的修改和远端仓库中的变更发生了冲突，那么 Git 会暂停 &lt;code>rebase&lt;/code> ，并让你来解决这些冲突。我们可以很简单的使用 &lt;code>git status&lt;/code> 和 &lt;code>git add&lt;/code> 等命令完成冲突的合并。 另外, 如果我们解决不了冲突, 我们也可以使用 &lt;code>git rebase --abort&lt;/code> 很容易的退出 &lt;code>rebase&lt;/code> 的过程。&lt;/p>
&lt;p>这样每天的工作方式就变成了，从中心仓库拉取最新代码， 然后开始一天的工作， 开发完成后，拉取中心仓库的更新， 合并代码后， 再提交至中心仓库， 结束一天的工作。 这样的好处就是不需要变更原先（使用SVN）的工作方式。当然弊端也很明显，你并不知道中心仓库的代码是否是稳定的，或者说并不能确定当你的代码和中心仓库代码合并后，是否是稳定的，带来的问题就是开发进度和回滚不那么方便控制。&lt;/p>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>我们有两位程序员, A 和 B, 两人同时在对一个项目做开发, 并且使用 Git 的中心化工作流方式。&lt;/p>
&lt;p>&lt;strong>1.创建远端中心仓库&lt;/strong>&lt;/p>
&lt;p>这里我们有两种方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>借助于已经搭建好的平台 GitHub/GitLab 之类的，点击 &lt;code>create repo&lt;/code> 即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在远端(这里只是为了区别本地仓库，事实上，使用任何一个其他人可以连通的机器都可以,包括自己本地其他目录) 创建一个 &lt;strong>裸仓库&lt;/strong> ，创建裸仓库和我们平时创建本地仓库的区别，可以参考我另一篇文章 &lt;a href="http://www.jianshu.com/p/9a4e8750aea6">Git 本地仓库和裸仓库&lt;/a> 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里以第二种方式为例：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># --bare 参数必须有&lt;/span>
git init --bare /the/repo/path.git
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.所有人都 clone 中心仓库到本地作为本地仓库&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone /the/repo/path.git
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意仓库地址必须是正确的， 且有权限访问才能 &lt;code>clone&lt;/code> 成功。&lt;/p>
&lt;p>&lt;strong>3.程序员 A 在他的本地仓库进行功能开发并进行发布&lt;/strong>&lt;/p>
&lt;p>一般情况下，我们通过 &lt;code>git status&lt;/code> 看看当前状态，并通过 &lt;code>git add &lt;/code> 和 &lt;code>git commit&lt;/code> 等命令完成本地仓库的提交。 当然这个提交影响的也只是本地仓库而已，并没有对中心仓库产生任何影响，所以我们既不需要关心别人有什么提交，也不用担心我们当前的提交是否对别人造成了影响。当 A 认为自己所开发的功能已经完成， 那他将执行 &lt;code>git push origin master&lt;/code> 这样的操作，将自己本地仓库所有不存在于中心仓库的提交都 &lt;code>push&lt;/code> 到远端的中心仓库上。&lt;/p>
&lt;p>&lt;strong>4.程序员 B 在他本地仓库进行功能开发&lt;/strong>&lt;/p>
&lt;p>B 在 &lt;code>clone&lt;/code> 中心仓库后所做的操作和 A 一样，在本地仓库进行项目开发，并在本地仓库进行提交，他不需要知道中心仓库发生了什么样的变化。&lt;/p>
&lt;p>&lt;strong>5.程序员 B 将自己开发的功能并进行发布&lt;/strong>&lt;/p>
&lt;p>B 在确认自己开发的功能已经完成后，想要将自己的代码通过 &lt;code>git push origin master&lt;/code> 这样的操作发布至中心仓库，但是却被中心仓库提示他的修改已经和中心仓库有了分叉， 需要他先执行 &lt;code>git pull&lt;/code> 之类的操作， 将中心仓库上 A 的提交与 B 本地的提交进行合并才允许他并入中心仓库。所以，他执行了 &lt;code>git pull --rebase origin master&lt;/code> 来将中心仓库的修改并入他的本地仓库。使用 &lt;code>--rebase&lt;/code> 参数的意义在于 &lt;code>fetch&lt;/code> 执行完成后，将把 B 的所有提交移至 &lt;code>master&lt;/code> 顶端。&lt;/p>
&lt;p>当然这里不使用 &lt;code>--rebase&lt;/code> 参数也会成功，只不过是会生成一个合并提交，有些情况下使用 &lt;code>--ff&lt;/code> 参数也可以避免产生合并提交。在这里使用 &lt;code>--rebase&lt;/code> 只是一个建议操作。&lt;/p>
&lt;p>如果 A 和 B 修改的文件没有关联，一般情况下会直接完成合并，如果发生冲突，Git 将会暂停 &lt;code>rebase&lt;/code> 的过程，并列出当前冲突的文件，你可以简单的使用 &lt;code>git status&lt;/code> 和 &lt;code>git add&lt;/code> 等命令进行合并，合并后使用 &lt;code>git rebase --continue&lt;/code> 继续 rebase 的过程。或者使用 &lt;code>git rebase --abort&lt;/code> 退出 rebase 过程。&lt;/p>
&lt;p>在 B 合并完成后，可以执行 &lt;code>git push origin master&lt;/code> 将自己开发的功能发布至中心仓库。&lt;/p>
&lt;p>至此，基础的中心化工作流方式就介绍完了，但是这里也很容易看出来其中的问题，除了前面说到过的以外，还有就是效率低下，如果很多人都在持续进行提交，那很影响新功能的提交（多人持续性进行提交）。 一个比较容易提升效率的方式就是切换到&lt;strong>特性分支工作流&lt;/strong>的方式。&lt;/p>
&lt;h1 id="特性分支工作流">特性分支工作流&lt;/h1>
&lt;p>基于特性的分支工作流，可以为每个特性做隔离，避免对中心仓库主干代码造成影响。&lt;/p>
&lt;h2 id="工作细节-1">工作细节&lt;/h2>
&lt;p>顾名思义， 就是根据每个特性都会开一个新的分支，每个分支都应该包含着描述性的名称，无论是一个人开发，还是多人协同，该特性的全部开发工作都在这个分支上进行。待该特性开发完成后， 并入主分支，然后删除分支，代码上线。&lt;/p>
&lt;p>这种情况下， 最大的优势在于， 所有的特性开发都可以并行处理。 不必要像中心化工作流方式， 每个人的变动都可能引起其他的人的代码合并， 并且所有功能都杂糅在一起， 从测试和回滚都会变得很繁琐。 另外的一个好处就是特性分支可以推送到中心仓库，这样也便于单独测试。&lt;/p>
&lt;p>这里需要注意的是，特性分支往主分支合并的时机，应该是该特性开发完成，并测试通过，避免对主干代码造成污染。&lt;/p>
&lt;p>在进行分支隔离后，我们发现，我们当前只处理了开发模式，但并没有涵盖一个很完备的产品生命周期， 开发、发布、维护等过程，所以，我们有了 Gitflow 工作流。&lt;/p>
&lt;h1 id="gitflow-工作流">Gitflow 工作流&lt;/h1>
&lt;p>基于Gitflow 的工作流方式， 这种工作流方式， 主要是管理着新功能开发，发布及维护等模式，根据不同类型的工作对分支进行定义， 分为 &lt;strong>特性分支&lt;/strong> ，&lt;strong>修复分支&lt;/strong>，&lt;strong>release 分支&lt;/strong>，&lt;strong>开发分支&lt;/strong> 和 &lt;strong>主分支&lt;/strong> 。&lt;/p>
&lt;p>主分支：中心仓库建立后的默认 master 分支（当然使用其他分支也可以，但要保证该分支是受保护的）。主分支随时保持代码是稳定的，并且有明确的版本标签，后续代码回滚等操作都将从主分支进行。&lt;/p>
&lt;p>开发分支：中心仓库建立后，从 master 分支切出来，此时与 master 分支保持一致。后续演进中，开发分支随时保持代码最新，但却不一定是线上实际运行的代码。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout -b develop
&lt;/code>&lt;/pre>&lt;/div>&lt;p>特性分支：应该从开发分支切出，开发完成后， 再合并进入开发分支， 如果达到了发布标准， 则从开发分支切出 release 分支， 切出来的这个分支，只做该版本内的代码修复， 不再加入新功能， 这时此分支处于锁定的状态。&lt;/p>
&lt;p>修复分支， 用于对线上主分支代码的及时修复， 待修复完成后， 合并进入主分支， 再并入开发分支。 修复分支只能从主分支切出。&lt;/p>
&lt;p>发版分支， 一般命名为 &lt;code>release-xxx&lt;/code> 这个分支只能从开发分支切出， 最后并入主分支，打上版本号的标签，它也应该并入开发分支，如果中间有其他修复的话。&lt;/p>
&lt;h1 id="fork-工作流">fork 工作流&lt;/h1>
&lt;p>fork 分支流和上面介绍的所有工作流都不太一样。它的上游有一个唯一仓库， 所有人都是 fork 这个仓库， 在自己的远端和自己的本地各维护一个仓库，待开发完成后推入自己的远端仓库，并结合 GitHub/GitLab等提交 Pull Request，进入了 review 阶段，待通过后，将会被合并入上游唯一的仓库。这种方式比较适合 GitHub 中的大型开源项目， 对于小团队的内部项目， 这种方式可能未必合适。
而且 fork 工作流， 会占用更多的资源（毕竟每个人都维护一份远端仓库）。 而且每个人都看不到其他人的动态，只有当提交 Pull Request 的时候， 才知道每个人发生了什么。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>我个人比较推荐的是 Gitflow 的开发工作流， 这种方式下，一切都是可控的， 每个分支都有各自独立的功能，目的性很明确， 同时，在做代码回滚之类的操作也是可以直接剔除。 另外， 在这种工作流方式下， 团队中的每个人都能很轻易的知道其他人在做什么， 做出了什么样的改变， 对于团队协作， 或许更加合适。&lt;/p>
&lt;p>当然所有的工作流并不一定能完全套用， 可以吸取一些规范， 合并入自己的日常工作， 将代码仓库的合作流程标准化和规范化， 这也是一切自动化的基础。&lt;/p>
&lt;p>&amp;lt;全文完&amp;gt;&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Git/" term="Git" label="Git"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/></entry><entry><title type="text">Git 本地仓库和裸仓库</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/"/><id>https://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-12-04T01:37:39+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">通常我们会用 git init 命令来将我们所在的目录转换为一个 Git 本地仓库或者初始化一个新的空仓库。 用法 将当前目录转换为一个本地仓库 git init 这个命令……</summary><content type="html">&lt;p>通常我们会用 &lt;code>git init&lt;/code> 命令来将我们所在的目录转换为一个 Git 本地仓库或者初始化一个新的空仓库。&lt;/p>
&lt;h2 id="用法">用法&lt;/h2>
&lt;ul>
&lt;li>将当前目录转换为一个本地仓库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git init
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令执行后会在本地生成一个 &lt;code>.git&lt;/code> 的文件夹，用来追踪仓库的所有变更。效果如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/gitinit.png" alt="git init">&lt;/p>
&lt;ul>
&lt;li>指定某个目录成为本地仓库&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git init &amp;lt;repo&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令执行后， 将创建一个名为repo且只包含 &lt;code>.git&lt;/code> 子文件夹的空目录。效果如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/git-init-repo.png" alt="git init repo">&lt;/p>
&lt;ul>
&lt;li>指定某个目录成为中心仓库（裸仓库）&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git init --bare &amp;lt;repo&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令执行后，将在本地创建一个名为 repo 的文件夹， 里面包含着 Git 的基本目录， 我们一般会将这个文件夹命名为后面加 &lt;code>.git&lt;/code> 的形式，如 &lt;code>repo.git&lt;/code> （这也是为什么我们从 GitHub clone 仓库的时候，地址都是 xxx.git 这样的形式的原因）。效果如下：&lt;/p>
&lt;p>&lt;img src="https://moelove.info/img/git-init-bare-repo.png" alt="git init --bare repo.git">&lt;/p>
&lt;p>详细说一下使用 &lt;code>--bare&lt;/code> 参数的含义，使用 &lt;code>--bare&lt;/code> 参数初始化的仓库，我们一般称之为裸仓库， 因为这样创建的仓库并不包含 &lt;code>工作区&lt;/code> ， 也就是说，我们并不能在这个目录下执行我们一般使用的 Git 命令。&lt;/p>
&lt;h2 id="对比">对比&lt;/h2>
&lt;p>我们来对比一下直接使用 &lt;code>git init&lt;/code> 创建的仓库和加了 &lt;code>--bare&lt;/code> 参数的两个仓库。 我们直接看两个仓库的的 &lt;code>config&lt;/code> 文件中的内容：&lt;/p>
&lt;ul>
&lt;li>直接 &lt;code>git init&lt;/code> 创建的仓库:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">[&lt;/span>core&lt;span class="o">]&lt;/span>
&lt;span class="nv">repositoryformatversion&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="nv">filemode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">bare&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>
&lt;span class="nv">logallrefupdates&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">ignorecase&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">precomposeunicode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>加了 &lt;code>--bare&lt;/code> 创建的裸仓库:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="o">[&lt;/span>core&lt;span class="o">]&lt;/span>
&lt;span class="nv">repositoryformatversion&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="nv">filemode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">bare&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">ignorecase&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;span class="nv">precomposeunicode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到最直观的差异在于 &lt;code>bare&lt;/code> 配置项是否为 &lt;code>true&lt;/code> ， 此外不加 &lt;code>--bare&lt;/code> 创建的本地仓库配置中有一项 &lt;code>logallrefupdates = true&lt;/code> , 作用根据名字就可以看出来， 记录所有的 &lt;code>ref&lt;/code> (引用) 更新， 关于 ref 的部分之后有时间可以再写，这个配置可以理解为是 Git 的一道防线。&lt;/p>
&lt;h2 id="功能差异">功能差异&lt;/h2>
&lt;p>我们可以使用最简单的例子演示一下。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">
&lt;span class="c1"># 直接创建本地仓库&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ git init repo
&lt;span class="c1"># 创建裸仓库&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ git init --bare repo.git
&lt;span class="c1"># 分别 clone 两个仓库&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ git clone repo c1
Cloning into &lt;span class="s1">&amp;#39;c1&amp;#39;&lt;/span>...
warning: You appear to have cloned an empty repository.
&lt;span class="k">done&lt;/span>.
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ git clone repo.git c2
Cloning into &lt;span class="s1">&amp;#39;c2&amp;#39;&lt;/span>...
warning: You appear to have cloned an empty repository.
&lt;span class="k">done&lt;/span>.
&lt;span class="c1"># 进入 c1 仓库&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ &lt;span class="nb">cd&lt;/span> c1
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c1 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> touch &lt;span class="nb">test&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c1 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ g add -A
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c1 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ g commit -m &lt;span class="s2">&amp;#34;test commit&amp;#34;&lt;/span>
&lt;span class="o">[&lt;/span>master &lt;span class="o">(&lt;/span>root-commit&lt;span class="o">)&lt;/span> b1e32ad&lt;span class="o">]&lt;/span> &lt;span class="nb">test&lt;/span> commit
&lt;span class="m">1&lt;/span> file changed, &lt;span class="m">0&lt;/span> insertions&lt;span class="o">(&lt;/span>+&lt;span class="o">)&lt;/span>, &lt;span class="m">0&lt;/span> deletions&lt;span class="o">(&lt;/span>-&lt;span class="o">)&lt;/span>
create mode &lt;span class="m">100644&lt;/span> &lt;span class="nb">test&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c1 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> git push origin master
Counting objects: 3, &lt;span class="k">done&lt;/span>.
Writing objects: 100% &lt;span class="o">(&lt;/span>3/3&lt;span class="o">)&lt;/span>, &lt;span class="m">200&lt;/span> bytes &lt;span class="p">|&lt;/span> &lt;span class="m">0&lt;/span> bytes/s, &lt;span class="k">done&lt;/span>.
Total &lt;span class="m">3&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>, reused &lt;span class="m">0&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>
remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require &lt;span class="s1">&amp;#39;git reset --hard&amp;#39;&lt;/span> to match
remote: error: the work tree to HEAD.
remote: error:
remote: error: You can &lt;span class="nb">set&lt;/span> &lt;span class="s1">&amp;#39;receive.denyCurrentBranch&amp;#39;&lt;/span> configuration variable to
remote: error: &lt;span class="s1">&amp;#39;ignore&amp;#39;&lt;/span> or &lt;span class="s1">&amp;#39;warn&amp;#39;&lt;/span> in the remote repository to allow pushing into
remote: error: its current branch&lt;span class="p">;&lt;/span> however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in some
remote: error: other way.
remote: error:
remote: error: To squelch this message and still keep the default behaviour, &lt;span class="nb">set&lt;/span>
remote: error: &lt;span class="s1">&amp;#39;receive.denyCurrentBranch&amp;#39;&lt;/span> configuration variable to &lt;span class="s1">&amp;#39;refuse&amp;#39;&lt;/span>.
To /Users/tao/repo
! &lt;span class="o">[&lt;/span>remote rejected&lt;span class="o">]&lt;/span> master -&amp;gt; master &lt;span class="o">(&lt;/span>branch is currently checked out&lt;span class="o">)&lt;/span>
error: failed to push some refs to &lt;span class="s1">&amp;#39;/Users/tao/repo&amp;#39;&lt;/span>
&lt;span class="c1"># 进入 c2 仓库重复执行&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c1 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> &lt;span class="nb">cd&lt;/span> ../c2
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c2 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> touch &lt;span class="nb">test&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c2 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ git add -A
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c2 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> ✗ git commit -m &lt;span class="s2">&amp;#34;test commit&amp;#34;&lt;/span>
&lt;span class="o">[&lt;/span>master &lt;span class="o">(&lt;/span>root-commit&lt;span class="o">)&lt;/span> 7aacc58&lt;span class="o">]&lt;/span> &lt;span class="nb">test&lt;/span> commit
&lt;span class="m">1&lt;/span> file changed, &lt;span class="m">0&lt;/span> insertions&lt;span class="o">(&lt;/span>+&lt;span class="o">)&lt;/span>, &lt;span class="m">0&lt;/span> deletions&lt;span class="o">(&lt;/span>-&lt;span class="o">)&lt;/span>
create mode &lt;span class="m">100644&lt;/span> &lt;span class="nb">test&lt;/span>
&lt;span class="o">(&lt;/span>Tao&lt;span class="o">)&lt;/span> ➜ c2 git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> git push origin master
Counting objects: 3, &lt;span class="k">done&lt;/span>.
Writing objects: 100% &lt;span class="o">(&lt;/span>3/3&lt;span class="o">)&lt;/span>, &lt;span class="m">201&lt;/span> bytes &lt;span class="p">|&lt;/span> &lt;span class="m">0&lt;/span> bytes/s, &lt;span class="k">done&lt;/span>.
Total &lt;span class="m">3&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>, reused &lt;span class="m">0&lt;/span> &lt;span class="o">(&lt;/span>delta 0&lt;span class="o">)&lt;/span>
To /Users/tao/repo.git
* &lt;span class="o">[&lt;/span>new branch&lt;span class="o">]&lt;/span> master -&amp;gt; master
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从裸仓库 clone 下来的本地仓库可以进行正常的 &lt;code>push&lt;/code> 操作， 但是从一般仓库 clone 下来的本地仓库却不行。 这也正是裸仓库存在的意义。 裸仓库一般情况下是作为远端的中心仓库而存在的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>使用 &lt;code>git init --bare &amp;lt;repo&amp;gt;&lt;/code> 可以创建一个裸仓库，并且这个仓库是可以被正常 &lt;code>clone&lt;/code> 和 &lt;code>push&lt;/code> 更新的， 裸仓库不包含工作区，所以并不会存在在裸仓库上直接提交变更的情况。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Git/" term="Git" label="Git"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/></entry><entry><title type="text">源码编译Vim 8</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/09/24/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91Vim-8/"/><id>https://moelove.info/2016/09/24/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91Vim-8/</id><updated>2021-11-24T16:36:07+08:00</updated><published>2016-09-24T19:46:47+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Vim 8.0 在2016.09.12发布了, 在各 Linux 发行版还没更新包的时候就源码编译来使用吧! 以 Debian 编译 Vim 为例. 下载Vim 源码 可以在Vim 官网……</summary><content type="html">&lt;blockquote>
&lt;p>Vim 8.0 在2016.09.12发布了, 在各 Linux 发行版还没更新包的时候就源码编译来使用吧! 以 Debian 编译 Vim 为例.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://moelove.qiniudn.com/Vim-8-simple-version.png" alt="简单编译截图">&lt;/p>
&lt;h1 id="下载vim-源码">下载Vim 源码&lt;/h1>
&lt;p>可以在&lt;a href="http://www.vim.org/">Vim 官网&lt;/a>下载&lt;a href="ftp://ftp.vim.org/pub/vim/unix/vim-8.0.tar.bz2">打包好的源代码&lt;/a>.
或者使用 Git:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/vim/vim.git
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="编译">编译&lt;/h1>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> vim/src
./configure --with-compiledby&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;Jintao Zhang&amp;#34;&lt;/span> --with-features&lt;span class="o">=&lt;/span>huge --enable-pythoninterp&lt;span class="o">=&lt;/span>yes --with-python-config-dir&lt;span class="o">=&lt;/span>/usr/lib/python2.7/config-x86_64-linux-gnu --enable-cscope --enable-perlinterp&lt;span class="o">=&lt;/span>yes --enable-rubyinterp&lt;span class="o">=&lt;/span>yes --with-luajit --enable-luainterp&lt;span class="o">=&lt;/span>yes --with-lua-prefix&lt;span class="o">=&lt;/span>/usr/include/lua5.1 --enable-multibyte --with-x --enable-fail-if-missing
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的参数使用 &lt;code>./configure --help&lt;/code> 都可以看到对应用途. 上面使用的参数是增加了对 Python, Ruby, Perl, 以及X window的支持.&lt;/p>
&lt;p>建议加上 &lt;code>--enable-fail-if-missing&lt;/code> 参数, 以方便定位到哪里依赖缺失.&lt;/p>
&lt;h1 id="依赖">依赖&lt;/h1>
&lt;p>这里检查可能通不过, 首先是 &lt;code>lua&lt;/code> 和 &lt;code>luajit&lt;/code>. 需要执行&lt;/p>
&lt;p>&lt;code>sudo apt-get install lua5.1 liblua5.1-0 luajit libluajit-5.1-dev&lt;/code>&lt;/p>
&lt;p>其次注意 &lt;code>Python&lt;/code> 的 config 位置.&lt;/p>
&lt;p>最后就是 &lt;code>Perl&lt;/code> 需要 &lt;code>sudo apt-get install libperl-dev&lt;/code>.&lt;/p>
&lt;h1 id="最终">最终&lt;/h1>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">make &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo make install
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最终结果">最终结果&lt;/h2>
&lt;p>&lt;img src="http://moelove.qiniudn.com/Vim-8-full-version.png" alt="完整编译截图">&lt;/p>
&lt;p>PS: 其实我一开始是想介绍 Vim 8 的, 然后碰巧在 GitHub 上有人问如何编译之类的, 就先写了这篇.&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Vim/" term="Vim" label="Vim"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/></entry><entry><title type="text">利器系列-更高效的Vim</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/09/16/%E5%88%A9%E5%99%A8%E7%B3%BB%E5%88%97-%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84Vim/"/><id>https://moelove.info/2016/09/16/%E5%88%A9%E5%99%A8%E7%B3%BB%E5%88%97-%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84Vim/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-09-16T16:55:44+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这是利器系列第0篇, 当然要以每天我使用率最高的Vim来开始啦! 截图 安装 (你需要一个有Python支持的Vim版本. 请使用 vim --version | grep……</summary><content type="html">&lt;blockquote>
&lt;p>这是利器系列第0篇, 当然要以每天我使用率最高的Vim来开始啦!&lt;/p>
&lt;/blockquote>
&lt;h2 id="截图">截图&lt;/h2>
&lt;p>&lt;img src="http://moelove.qiniudn.com/vim.png" alt="screenshot.png">&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>(你需要一个有Python支持的Vim版本. 请使用 &lt;code>vim --version | grep +python&lt;/code> 来检查)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>依赖&lt;/strong>(Debian/Ubuntu 平台)&lt;/p>
&lt;p>&lt;code>sudo apt-get install python vim exuberant-ctags git&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo pip install dbgp vim-debug pep8 flake8 pyflakes isort&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>依赖&lt;/strong>(RedHat/CentOS 平台)&lt;/p>
&lt;p>CentOS 6.7的yum源自带的Python版本较旧，推荐自行安装Python2.7.&lt;/p>
&lt;p>&lt;code>sudo yum install python vim ctags git&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo pip install dbgp vim-debug pep8 flake8 pyflakes isort&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>依赖&lt;/strong>(Mac OS 平台)&lt;/p>
&lt;p>&lt;code>brew install python vim git&lt;/code>&lt;/p>
&lt;p>&lt;code>wget http://tenet.dl.sourceforge.net/project/ctags/ctags/5.8/ctags-5.8.tar.gz &amp;amp;&amp;amp; tar -zxvf ctags-5.8.tar.gz &amp;amp;&amp;amp; cd ctags-5.8 &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install&lt;/code>&lt;/p>
&lt;p>&lt;code>sudo pip install dbgp vim-debug pep8 flake8 pyflakes isort&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>下载vimrc 文件到用户主目录&lt;/strong>&lt;/p>
&lt;p>&lt;code>wget https://raw.githubusercontent.com/tao12345666333/vim/master/vimrc -O $HOME/.vimrc&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>打开 Vim&lt;/strong>&lt;/p>
&lt;p>打开Vim, 它将会自动安装插件. 请耐心等待它完成. 或者你可以使用下面的命令来自行安装.&lt;/p>
&lt;p>&lt;code>vim -E -u $HOME/.vimrc +qall&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>享受你的Vim并个性化它吧!&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="支持特性">支持特性&lt;/h2>
&lt;h3 id="插件管理vundle">插件管理（Vundle）&lt;/h3>
&lt;p>在这份配置中，使用了&lt;a href="https://github.com/VundleVim/Vundle.vim">&lt;strong>Vundle&lt;/strong>&lt;/a>作为插件管理器. Vundle会自动接管 &lt;code>.vim&lt;/code> 文件夹，所有配置好的插件将默认下载至&lt;code>~/.vim/bundle/&lt;/code>， 在使用之前请确保&lt;code>.vim&lt;/code>文件夹干净. Vundle的插件安装需要触发 &lt;code>git clone&lt;/code> 操作，搜索需要 &lt;code>curl&lt;/code> 支持.&lt;/p>
&lt;h4 id="配置截取了部分">配置(截取了部分)&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; let Vundle manage Vundle&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;gmarik/vundle&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; ============================================================================&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Active plugins&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; You can disable or add new ones here:&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; Plugins from github repos:&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; Python and PHP Debugger&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;fisadev/vim-debug.vim&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Better file browser&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;scrooloose/nerdtree&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Code commenter&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;scrooloose/nerdcommenter&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Class/module browser&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;majutsushi/tagbar&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Code and files fuzzy finder&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;kien/ctrlp.vim&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Extension to ctrlp, for fuzzy command finder&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;fisadev/vim-ctrlp-cmdpalette&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Zen coding&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;mattn/emmet-vim&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Git integration&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;motemen/git-vim&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Tab list panel&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">Bundle&lt;/span> &lt;span class="s1">&amp;#39;kien/tabman.vim&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>:PluginList&lt;/td>
&lt;td style="text-align:center">列出所有Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:PluginInstall(!)&lt;/td>
&lt;td style="text-align:center">安装/更新Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:PluginSearch(!) foo&lt;/td>
&lt;td style="text-align:center">搜索foo相关的Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:PluginClean(!)&lt;/td>
&lt;td style="text-align:center">清理未使用的Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:PluginUpdate&lt;/td>
&lt;td style="text-align:center">更新插件&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="工程文件浏览nerdtree">工程文件浏览（NERDTree）&lt;/h3>
&lt;p>在这份配置中, 使用了&lt;a href="https://github.com/scrooloose/nerdtree">&lt;strong>NERDTree&lt;/strong>&lt;/a>查看文件列表. 你可以在NERDTree中浏览和打开你文件系统中的目录或文件. 还可以进行文件隐藏和过滤, 设置添加书签等. 在NERDTree窗口输入&lt;code>?&lt;/code>可获得操作指南. 这份配置中默认过滤掉了&lt;code>.pyc&lt;/code>, &lt;code>.git&lt;/code>, &lt;code>.hg&lt;/code>, &lt;code>.svn&lt;/code>等文件或文件夹的显示.&lt;/p>
&lt;h4 id="配置">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; auto open or close NERDTree&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">autocmd&lt;/span> &lt;span class="nx">vimenter&lt;/span> * &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">argc&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nx">NERDTree&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="k">endif&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">autocmd&lt;/span> &lt;span class="nx">bufenter&lt;/span> * &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">winnr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;$&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="m">1&lt;/span> &amp;amp;&amp;amp; &lt;span class="nx">exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;b:NERDTreeType&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &amp;amp;&amp;amp; &lt;span class="nx">b&lt;/span>:&lt;span class="nx">NERDTreeType&lt;/span> &lt;span class="p">==&lt;/span> &lt;span class="s2">&amp;#34;primary&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nx">q&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="k">endif&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; NERDTree -----------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; toggle nerdtree display&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">map&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">F3&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> :&lt;span class="nx">NERDTreeToggle&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; open nerdtree with the current file selected&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">,&lt;/span>&lt;span class="nx">t&lt;/span> :&lt;span class="nx">NERDTreeFind&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; don;t show these file types&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">NERDTreeIgnore&lt;/span> &lt;span class="p">=&lt;/span> [&lt;span class="s1">&amp;#39;\.pyc$&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;\.pyo$&amp;#39;&lt;/span>]&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-1">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>F3&lt;/td>
&lt;td style="text-align:center">打开/关闭NERDTree&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>,t&lt;/td>
&lt;td style="text-align:center">打开NERDTree并选中当前文件&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="语法检查">语法检查&lt;/h3>
&lt;p>在这份配置中， 使用&lt;a href="https://github.com/scrooloose/syntastic">&lt;strong>Syntastic&lt;/strong>&lt;/a>插件进行语法静态检查. 包括但不限于&lt;code>C/C++/Go/Python/Haskell/Ruby/JavaScript&lt;/code>等. 在本配置中对JavaScript的静态检查使用&lt;code>eslint&lt;/code>,可以支持ES6及JSX等, 细节可以参考&lt;a href="http://moelove.info/2015/11/28/JSLint-JSHint-ESLint%E5%AF%B9%E6%AF%94%E5%92%8CVim%E9%85%8D%E7%BD%AE/">JSLint, JSHint和ESLint的对比及Vim配置&lt;/a>, 想要切换检查工具只要修改对应位置即可.&lt;/p>
&lt;h4 id="配置-1">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Syntastic ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; show list of errors and warnings on the current file&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">leader&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">e&lt;/span> :&lt;span class="nx">Errors&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; turn to next or previous errors, after open errors list&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">leader&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">n&lt;/span> :&lt;span class="nx">lnext&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">leader&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">p&lt;/span> :&lt;span class="nx">lprevious&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; check also when just opened the file&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_check_on_open&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; syntastic checker for javascript.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; eslint is the only tool support JSX.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; If you don&amp;#39;t need write JSX, you can use jshint.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; And eslint is slow, but not a hindrance&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; let g:syntastic_javascript_checkers = [&amp;#39;jshint&amp;#39;]&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_javascript_checkers&lt;/span> &lt;span class="p">=&lt;/span> [&lt;span class="s1">&amp;#39;eslint&amp;#39;&lt;/span>]&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; don&amp;#39;t put icons on the sign column (it hides the vcs status icons of signify)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_enable_signs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; custom icons (enable them if you use a patched font, and enable the previous &lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; setting)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_error_symbol&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;✗&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_warning_symbol&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;⚠&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_style_error_symbol&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;✗&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">syntastic_style_warning_symbol&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;⚠&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="特性">特性&lt;/h4>
&lt;p>保存时自动进行语法静态检查，方便的错误提示及灵活的可扩展性.&lt;/p>
&lt;h4 id="支持操作-2">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>\e&lt;/code>&lt;/td>
&lt;td style="text-align:center">打开错误列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\n&lt;/code>&lt;/td>
&lt;td style="text-align:center">移动到下一个错误位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\p&lt;/code>&lt;/td>
&lt;td style="text-align:center">移动到上一个错误位置&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="git支持">Git支持&lt;/h3>
&lt;p>在这份配置中, 使用&lt;a href="https://github.com/tpope/vim-fugitive">&lt;strong>vim-fugitive&lt;/strong>&lt;/a>和&lt;a href="https://github.com/mhinz/vim-signify">&lt;strong>vim-signify&lt;/strong>&lt;/a>做Git方面的支持. 可以进行常用的git操作及优雅的状态提示等(目前支持&lt;code>git&lt;/code>和&lt;code>hg&lt;/code>).&lt;/p>
&lt;h4 id="配置-2">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Signify ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; this first setting decides in which order try to guess your current vcs&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; UPDATE it to reflect your preferences, it will speed up opening files&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">signify_vcs_list&lt;/span> &lt;span class="p">=&lt;/span> [ &lt;span class="s1">&amp;#39;git&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;hg&amp;#39;&lt;/span> ]&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; mappings to jump to changed blocks&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">leader&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">sn&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">plug&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="nx">signify&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">next&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">hunk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">leader&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="nx">sp&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">plug&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="nx">signify&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">prev&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">hunk&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; nicer colors&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">DiffAdd&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">none&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">119&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">DiffDelete&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">none&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">167&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">DiffChange&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">none&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">227&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">SignifySignAdd&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">237&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">119&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">SignifySignDelete&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">237&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">167&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">highlight&lt;/span> &lt;span class="nx">SignifySignChange&lt;/span> &lt;span class="nx">cterm&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">bold&lt;/span> &lt;span class="nx">ctermbg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">237&lt;/span> &lt;span class="nx">ctermfg&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">227&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-3">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>:Git [args]&lt;/td>
&lt;td style="text-align:center">类似执行&lt;code>git&lt;/code>命令一样&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gstatus&lt;/td>
&lt;td style="text-align:center">类似&lt;code>git status&lt;/code>.在列表中使用&lt;code>-&lt;/code>添加/移除文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gcommit [args]&lt;/td>
&lt;td style="text-align:center">类似 &lt;code>git commit&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gmerge [args]&lt;/td>
&lt;td style="text-align:center">类似 &lt;code>git merge&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gpull [args]&lt;/td>
&lt;td style="text-align:center">类似 &lt;code>git pull&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gpush [args]&lt;/td>
&lt;td style="text-align:center">类似 &lt;code>git push&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>:Gvdiff [revision]&lt;/td>
&lt;td style="text-align:center">类似 &lt;code>git push&lt;/code> 但是会切分窗口&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>更多详细的操作可以使用 &lt;code>:help fugitive&lt;/code>&lt;/p>
&lt;h3 id="tag支持">Tag支持&lt;/h3>
&lt;p>在这份配置中，使用了&lt;a href="http://github.com/godlygeek/tagbar">&lt;strong>Tagbar&lt;/strong>&lt;/a>做Tag支持，可以显示当前文件中定义的类/变量等.&lt;/p>
&lt;h4 id="配置-3">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Tagbar -----------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; toggle tagbar display&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">map&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">F4&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> :&lt;span class="nx">TagbarToggle&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">CR&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; autofocus on tagbar open&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">tagbar_autofocus&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-4">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>F4&lt;/td>
&lt;td style="text-align:center">打开Tag列表&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="超全自动补全">超全自动补全&lt;/h3>
&lt;p>在这份配置中, 使用了&lt;a href="https://github.com/Shougo/neocomplcache.vim">&lt;strong>Neocomplcache&lt;/strong>&lt;/a>作为主要的自动补全插件.&lt;/p>
&lt;h4 id="配置-4">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; NeoComplCache ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; most of them not documented because I&amp;#39;m not sure how they work&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; (docs aren&amp;#39;t good, had to do a lot of trial and error to make &lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; it play nice)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; Disable AutoComplPop.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">acp_enableAtStartup&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Use neocomplcache.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_at_startup&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_ignore_case&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Use smartcase.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_smart_case&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_auto_select&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_fuzzy_completion&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_camel_case_completion&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_enable_underbar_completion&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_fuzzy_completion_start_length&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_auto_completion_start_length&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_manual_completion_start_length&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Set minimum syntax keyword length.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_min_keyword_length&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_min_syntax_length&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_lock_buffer_name_pattern&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;\*ku\*&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; complete with workds from any opened file&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_same_filetype_lists&lt;/span> &lt;span class="p">=&lt;/span> {}&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_same_filetype_lists&lt;/span>.&lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;_&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; &amp;lt;TAB&amp;gt;: completion.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">TAB&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">pumvisible&lt;/span>&lt;span class="p">()&lt;/span> ? &lt;span class="s2">&amp;#34;\&amp;lt;C-n&amp;gt;&amp;#34;&lt;/span> : &lt;span class="s2">&amp;#34;\&amp;lt;TAB&amp;gt;&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Define keyword.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;g:neocomplcache_keyword_patterns&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_keyword_patterns&lt;/span> &lt;span class="p">=&lt;/span> {}&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">endif&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">neocomplcache_keyword_patterns&lt;/span>[&lt;span class="s1">&amp;#39;default&amp;#39;&lt;/span>] &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;\h\w*&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Plugin key-mappings.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">g&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">undo_completion&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">l&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">complete_common_string&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; &amp;lt;C-h&amp;gt;, &amp;lt;BS&amp;gt;: close popup and delete backword char.&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">h&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">smart_close_popup&lt;/span>&lt;span class="p">()&lt;/span>.&lt;span class="s2">&amp;#34;\&amp;lt;C-h&amp;gt;&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">BS&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">smart_close_popup&lt;/span>&lt;span class="p">()&lt;/span>.&lt;span class="s2">&amp;#34;\&amp;lt;C-h&amp;gt;&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">close_popup&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">inoremap&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">expr&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">neocomplcache&lt;/span>#&lt;span class="nx">cancel_popup&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-5">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&amp;lt;Tab&amp;gt;&lt;/td>
&lt;td style="text-align:center">使用Tab键进行待提示项目选择&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;C-g&amp;gt;&lt;/td>
&lt;td style="text-align:center">取消补全&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;C-l&amp;gt;&lt;/td>
&lt;td style="text-align:center">完成待补全项中共同的字符串&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;C-h&amp;gt;&lt;/td>
&lt;td style="text-align:center">关闭待选项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;C-y&amp;gt;&lt;/td>
&lt;td style="text-align:center">关闭待选项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;C-e&amp;gt;&lt;/td>
&lt;td style="text-align:center">退出待选项&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;BS&amp;gt;&lt;/td>
&lt;td style="text-align:center">关闭待选项&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="类tmux的窗口选择">类Tmux的窗口选择&lt;/h3>
&lt;p>在这份配置中，使用了&lt;a href="https://github.com/t9md/vim-choosewin">&lt;strong>vim-choosewin&lt;/strong>&lt;/a>进行窗口管理器. 支持类Tmux的操作.&lt;/p>
&lt;h4 id="配置-5">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Window Chooser ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; mapping&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="nx">nmap&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nx">Plug&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="nx">choosewin&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; show big letters&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">choosewin_overlay_enable&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-6">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td style="text-align:center">开启窗口选择&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- [&lt;/td>
&lt;td style="text-align:center">选择上一个tab的窗口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>- ]&lt;/td>
&lt;td style="text-align:center">选择下一个tab的窗口&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>更多操作可以使用 &lt;code>:help choosewin&lt;/code>&lt;/p>
&lt;h3 id="灵活的tab管理">灵活的Tab管理&lt;/h3>
&lt;p>在这份配置中使用了&lt;a href="https://github.com/kien/tabman.vim">TabMan&lt;/a>进行Tab管理,可以进行灵活切换与管理&lt;/p>
&lt;h4 id="配置-6">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; TabMan ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; mappings to toggle display, and to focus on it&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">tabman_toggle&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;tl&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">tabman_focus&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;tf&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-7">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>tl&lt;/td>
&lt;td style="text-align:center">开启/关闭tab管理&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tf&lt;/td>
&lt;td style="text-align:center">将光标移动到tab管理窗口&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="优雅的状态栏">优雅的状态栏&lt;/h3>
&lt;p>在这份配置中，使用了&lt;a href="https://github.com/vim-airline/vim-airline">&lt;strong>Airline&lt;/strong>&lt;/a>提供更多状态栏支持.&lt;/p>
&lt;h4 id="配置-7">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Airline ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_powerline_fonts&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_theme&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;bubblegum&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34;let g:airline#extensions#tabline#enabled = 1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34;let g:airline#extensions#tabline#left_sep = &amp;#39; &amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34;let g:airline#extensions#tabline#left_alt_sep = &amp;#39;|&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline&lt;/span>#&lt;span class="nx">extensions&lt;/span>#&lt;span class="nx">whitespace&lt;/span>#&lt;span class="nx">enabled&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; to use fancy symbols for airline, uncomment the following lines and use a&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; patched font (more info on the README.rst)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;g:airline_symbols&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span> &lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_symbols&lt;/span> &lt;span class="p">=&lt;/span> {}&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">endif&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_left_sep&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_left_alt_sep&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_right_sep&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_right_alt_sep&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_symbols&lt;/span>.&lt;span class="nx">branch&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_symbols&lt;/span>.&lt;span class="nx">readonly&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">airline_symbols&lt;/span>.&lt;span class="nx">linenr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持特性-1">支持特性&lt;/h4>
&lt;p>可以显示分支，语法静态检查结果等.&lt;/p>
&lt;h3 id="自动插入头部">自动插入头部&lt;/h3>
&lt;p>在这份配置中写了个小函数根据新建的不同类型的文件，自动插入头部，支持&lt;code>python&lt;/code>, &lt;code>ruby&lt;/code>, &lt;code>bash&lt;/code>等.&lt;/p>
&lt;h3 id="markdown实时预览">Markdown实时预览&lt;/h3>
&lt;p>在这份配置中, 使用了&lt;a href="https://github.com/suan/vim-instant-markdown">&lt;strong>vim-instant-markdown&lt;/strong>&lt;/a>和&lt;a href="https://github.com/plasticboy/vim-markdown">vim-markdown&lt;/a>做Markdown格式的支持，可以支持实时预览等特性.&lt;/p>
&lt;p>此功能需要有node环境支持，可以执行 &lt;code>npm -g install instant-markdown-d&lt;/code> 进行安装.&lt;/p>
&lt;h4 id="配置-8">配置&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-vim" data-lang="vim">&lt;span class="c">&amp;#34; Vim-markdown ------------------------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; Disabled automatically folding&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">vim_markdown_folding_disabled&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; LeTeX math&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">vim_markdown_math&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; Highlight YAML frontmatter&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">vim_markdown_frontmatter&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; Vim-instant-markdown -----------------&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">
&lt;/span>&lt;span class="c">&amp;#34; If it takes your system too much, you can specify&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; let g:instant_markdown_slow = 1&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; if you don&amp;#39;t want to manually control it&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; you can open this setting&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; and when you open this, you can manually trigger preview&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c">&amp;#34; via the command :InstantMarkdownPreview&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nx">g&lt;/span>:&lt;span class="nx">instant_markdown_autostart&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="支持操作-8">支持操作&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>快捷键&lt;/th>
&lt;th style="text-align:center">解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>:InstantMarkdownPreview&lt;/td>
&lt;td style="text-align:center">手动触发markdown文件的预览&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="多游标选择编辑等">多游标选择、编辑等&lt;/h3>
&lt;p>在这份配置中, 可以在高亮某单词时, 通过使用 &lt;code>Ctrl-n&lt;/code> 或者 &lt;code>Ctrl-p&lt;/code> 进行多游标选择, 然后进行编辑或修改等操作.&lt;/p>
&lt;h3 id="快速文件查找">快速文件查找&lt;/h3>
&lt;p>在这份配置中, 可以通过使用&lt;code>,R&lt;/code>进行全文查找或者&lt;code>,r&lt;/code>进行快速查找, 或者在当前字符串上使用&lt;code>,wR&lt;/code>以及&lt;code>,wr&lt;/code>来进行全文查找或者快速查找.&lt;/p>
&lt;h3 id="快速注释">快速注释&lt;/h3>
&lt;p>使用&lt;a href="https://github.com/scrooloose/nerdcommenter">&lt;strong>NERDCommenter&lt;/strong>&lt;/a>插件完成快速注释, 可以通过&lt;code>\ci&lt;/code>进行快速注释.&lt;/p>
&lt;h4 id="python-支持">Python 支持&lt;/h4>
&lt;p>完备的Python支持, 可以自动识别当前是系统环境或虚拟环境, 使用&lt;code>:Isort&lt;/code>可智能对导入包进行排序, 使用&lt;code>:PymodeLintAuto&lt;/code>可自动格式化.&lt;/p>
&lt;p>&lt;strong>除了上述列出的功能以外, 还有很多方便的特性，可以大大提升效率，在使用中慢慢体会吧！有问题可以在&lt;a href="https://github.com/tao12345666333/vim">tao12345666333/vim&lt;/a> on github 提issue&lt;/strong>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Vim/" term="Vim" label="Vim"/><category scheme="https://moelove.info/tags/Tool/" term="Tool" label="Tool"/></entry><entry><title type="text">Python性能优化之工具篇</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/05/14/Python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/"/><id>https://moelove.info/2016/05/14/Python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-05-14T00:14:54+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">之前对公司的一个后端项目做了些性能优化, 学到一些值得记录的东西, 这篇主要是介绍在做性能分析时所用到的工具, 至于如何优化基本就是智……</summary><content type="html">&lt;blockquote>
&lt;p>之前对公司的一个后端项目做了些性能优化, 学到一些值得记录的东西, 这篇主要是介绍在做性能分析时所用到的工具, 至于如何优化基本就是智者见智吧, 如果有时间可能会写的.&lt;/p>
&lt;/blockquote>
&lt;h1 id="python-web应用程序的常见性能指标">Python web应用程序的常见性能指标&lt;/h1>
&lt;pre>&lt;code>此处忽略外部DNS解析等方面的性能
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>响应时间&lt;/li>
&lt;li>错误率&lt;/li>
&lt;li>吞吐率&lt;/li>
&lt;li>执行时间&lt;/li>
&lt;li>内存占用&lt;/li>
&lt;/ul>
&lt;h1 id="python-性能分析工具">Python 性能分析工具&lt;/h1>
&lt;p>##TODO&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Python/" term="Python" label="Python"/><category scheme="https://moelove.info/tags/Performance/" term="Performance" label="Performance"/></entry><entry><title type="text">想从二次元群体手里赚钱？你真的懂二次元吗!</title><link rel="alternate" type="text/html" href="https://moelove.info/2016/04/16/%E6%83%B3%E4%BB%8E%E4%BA%8C%E6%AC%A1%E5%85%83%E7%BE%A4%E4%BD%93%E6%89%8B%E9%87%8C%E8%B5%9A%E9%92%B1%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E4%BA%8C%E6%AC%A1%E5%85%83%E5%90%97/"/><id>https://moelove.info/2016/04/16/%E6%83%B3%E4%BB%8E%E4%BA%8C%E6%AC%A1%E5%85%83%E7%BE%A4%E4%BD%93%E6%89%8B%E9%87%8C%E8%B5%9A%E9%92%B1%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E4%BA%8C%E6%AC%A1%E5%85%83%E5%90%97/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2016-04-16T10:36:04+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">“节操”，“鬼畜”，“萌”, &amp;quot;二次元&amp;quot;这些词是不是逐渐的融入了你的日常？ 这些词其实都是二次元产物。越来越多的……</summary><content type="html">&lt;blockquote>
&lt;p>“节操”，“鬼畜”，“萌”, &amp;quot;二次元&amp;quot;这些词是不是逐渐的融入了你的日常？ 这些词其实都是二次元产物。越来越多的人将关注点放到了“二次元群体”上，但是这里的价值和它真正的含义你懂了吗？&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是原本的二次元">什么是原本的二次元&lt;/h2>
&lt;p>很多人认为二次元就是指“二维平面”，“平面世界”，也有人认为是ACGN，但这个观点其实是带有误区的。&lt;/p>
&lt;p>为什么这样说呢？我们一起来追溯一下“二次元”这个词是什么时候出现的，有部和我年龄相仿的动画片《机动战舰》(暴露年龄系列,我下一篇就写这个)，其中的反派们超级崇拜一部叫《激钢人3》的动画片，甚至这部动画片已经成为反派军中的圣典（除了很热血很好看外，其实是因为他们逃亡的时候就只带了这一部动画片吧，充分说明做资源党是有好处的！），当然剧中的主角也是很喜欢这部动画片的。动画（机动战舰）中的反派非常喜欢激钢人3中的女主菜菜子，但是毕竟现实和动画是不可逾越的（明明都是在动画里面！），处于伤感中的反派们相互安慰：“&lt;strong>菜菜子再好，但她毕竟只是二次元的女子啊！&lt;/strong>”，这句话引起了很多ACG爱好者的共鸣，所以逐步的借用了其中的“二次元”来描述自己所喜爱的由ACG创造出来的世界了。&lt;/p>
&lt;h2 id="什么是现在的二次元">什么是现在的二次元&lt;/h2>
&lt;p>很多人说现在的二次元是“泛二次元”，可这个”泛“到底是泛到了什么程度呢？这就好像从15年开始，”IP“在圈子里吵得火热，但到底什么是IP？很多人只是知道一个名词或者一个模糊的概念罢了。
有多少真正爆款的IP产生呢？&lt;/p>
&lt;p>现在一般指的二次元确实是”泛二次元“，不仅包含着ACGN，还包含着其相关的衍生产物（这不是废话吗？）。也就是这种模棱两可的概念让绝大多数人身处次元壁外，不得其门而入。&lt;/p>
&lt;p>为了避免概念混淆，本篇不具体解释“核心二次元文化”和“泛二次元文化”（放到下篇来写），谈谈现在的二次元群体即“泛二次元”群体。&lt;/p>
&lt;h3 id="宅">&amp;quot;宅&amp;quot;&lt;/h3>
&lt;p>大多数情况下，ACG爱好者被冠上了“宅”的标签，外界一般这样看我们“不爱出门”，“就知道看动漫”，“沉迷于虚拟世界”等等。实际上“宅”也分了很多种，“御宅族”应该是相对较早的称呼了，现在大多使用“宅男/宅女”来形容这部分人和长期待在家里不出去的人。并且基于当前环境和舆论等，“宅”一度被加上了变异的色彩。&lt;/p>
&lt;p>但是当二次元群体以“宅”自称或称呼别人的时候，一般是指对于某种兴趣爱好的痴迷，有时候也指大触（某方面很厉害的人）。这种倾注了情感的痴迷，不仅支撑着我们可以长时间宅在家，还可以不断的利用现有资源，发展自己的圈子和技能，结识同好，分享兴趣，一起做很多好玩的事情。一般会被称为“动漫宅”，“偶像宅”，“技术宅”等，也会称为“游戏狗”，“单身汪”之类的。（但是我们都有着做现充的觉悟的！）&lt;/p>
&lt;h3 id="腐">“腐”&lt;/h3>
&lt;p>这个群体中女性相比男性更多一些（目前表现出来的是这样），这个群体多表现为对“BL”（boy’s love），“GL”（girl’s love）等的喜爱。“腐”和“宅”并不能完全隔离开，会有重合，不过“宅”群体一般更多的关注点在于虚拟世界中，而很可能一个并不宅的妹子有天你突然发现她其实是腐的，并且长期YY你和其他男同事（orz）。&lt;/p>
&lt;h3 id="coserlo娘舞见">“Coser”，“lo娘”，“舞见”&lt;/h3>
&lt;p>作为一枚野生后期，对这部分群体和我接下来要谈的“唱见”等了解也相对多了一些。Coser（玩Cosplay 的人），lo娘（喜欢Lolita穿衣风格的人），舞见（一般指宅舞的舞者）都逐渐变多，这也和大众对这个群体的接受度逐渐变高了有关。这个群体相对的要辛苦一些，喜欢某些东西，喜欢到了不满足于看，而想自己亲自去尝试。&lt;/p>
&lt;p>Coser需要经过服装，道具，化妆等工序打磨，而一般在网上直接买的衣服可能不合适还需要自行修改。这三类人都很容易被外界的人投以另类的目光，但是也比较容易通过活动或者交流找到同好。毕竟这些都是既看脸又走心的形式，既传达自己对原作的感情又能将自己美好的一面示人。&lt;/p>
&lt;h3 id="唱见">&amp;quot;唱见&amp;quot;&lt;/h3>
&lt;p>“唱见”（投稿翻唱歌曲的业余歌手）也越来越多，而且很多也唱的非常棒！以动漫的OP，ED投稿较多，目前有很多的应用或网站都提供了方便的音频发布，电台之类的功能，比较容易获得粉丝。&lt;/p>
&lt;h3 id="网配">&amp;quot;网配&amp;quot;&lt;/h3>
&lt;p>“网配”（网络配音）大多是基于网配文或某些小说进行PIA戏，也有一部分人会选择制作广播剧之类的。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>其他就是一部分我不常接触或者人数相对较少的群体了。&lt;/p>
&lt;h2 id="为什么是二次元群体">为什么是二次元群体&lt;/h2>
&lt;p>在大致了解了当前二次元群体之后，我们来谈谈为什么从二次元群体入手&lt;/p>
&lt;ol>
&lt;li>群体基数大，覆盖面广。在上面我已经大致说过了，看看自己的周围，随便上微博、贴吧之类的看看，大抵就知道了;&lt;/li>
&lt;li>增长迅速。看看当前A、B站，腾讯动漫等的用户增长量也可窥一斑;&lt;/li>
&lt;li>付费能力强。只要戳中了二次元群体的G点，付费能力非常强，以Coser和lo娘为例，一般都会花上万块在服装上;&lt;/li>
&lt;li>自我传播能力较强。二次元群体大多活跃在手Q，微博，贴吧等平台上，且有自己的圈子，自我传播能力相对更强;&lt;/li>
&lt;li>用户相对忠实。由于二次元文化作为一个独特的亚文化发展起来，当前占据主体的还是90后，00后，碎片化时间相对较多，且更容易在应用/网站中形成关系链;&lt;/li>
&lt;li>二次元作品相对可扩展的面更广，更容易找到增长点。&lt;/li>
&lt;/ol>
&lt;h2 id="可能发展的方向">可能发展的方向&lt;/h2>
&lt;h3 id="资源平台">资源平台&lt;/h3>
&lt;p>二次元群体本就对资源有非常高的渴望和期待，当然也很挑剔，有着很完整的选择要求，用资源吸引到用户，才是解决了用户的需求。&lt;/p>
&lt;h3 id="周边产业">周边产业&lt;/h3>
&lt;p>二次元群体对于正版周边产物是有着强烈需求的，但是目前无论是市场还是价格上都不是很好。&lt;/p>
&lt;h3 id="同人">同人&lt;/h3>
&lt;p>同人资源对二次元文化的发展是有着相当大影响的，若能吸引到用户，将可能迎来爆发式的增长。&lt;/p>
&lt;p>以上都是我一本正经的胡说八道，小心误入歧途 2333&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/ACG/" term="ACG" label="ACG"/></entry><entry><title type="text">2015小回顾</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/12/31/2015%E5%B0%8F%E5%9B%9E%E9%A1%BE/"/><id>https://moelove.info/2015/12/31/2015%E5%B0%8F%E5%9B%9E%E9%A1%BE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-12-31T00:00:00+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">时间过得很快2015年最后一天。 还是继续给自己做个总结吧。 去年也有做总结，不过没有发布到Blog罢了。 2015年初在公司定了两个……</summary><content type="html">&lt;p>时间过得很快2015年最后一天。 还是继续给自己做个总结吧。 去年也有做总结，不过没有发布到Blog罢了。&lt;/p>
&lt;p>2015年初在公司定了两个主要目标:&lt;/p>
&lt;ul>
&lt;li>对工具的打磨&lt;/li>
&lt;li>计算机图形学&lt;/li>
&lt;/ul>
&lt;p>第一个目标算是基本完成，现在在用的工具都很顺手，效率能提升很多，而且用起来也很爽！现在也还会再尝试一些其他的工具，或者提升现在使用的工具的便利性。有时间的话可以写篇文章介绍一下。第二个目标目前没有什么进展，可以考虑是不是要留到今年了XD，当然还有一些其他自己定的目标基本完成，大致写写自己的收获好了。&lt;/p>
&lt;h2 id="收获">收获&lt;/h2>
&lt;p>(大致按照时间来写吧)&lt;/p>
&lt;ul>
&lt;li>读了一部分 &lt;code>Nginx&lt;/code> 的源码，算是对Nginx有了比以前更深入的认识，但是现在回过头来再重新审视的话，发现对它的理解还远远不够，还需要继续深入。&lt;/li>
&lt;li>学习了 &lt;code>Haskell&lt;/code>, Haskell我觉得是一门非常棒的语言，非常值得学习，通过对这门语言的学习，改变了我的一些思维方式。除了用它写过一些小程序以外，还没能在工程中大量使用，今后继续加油，尽量引入到工程中～&lt;/li>
&lt;li>学习了 &lt;code>Node.js&lt;/code>, 同样的还缺乏工程中的实践&lt;/li>
&lt;li>学习了 &lt;code>Backbone.js&lt;/code>,&lt;code>AngularJS&lt;/code> 和 &lt;code>ReactJS&lt;/code>. Backbone记忆中应该是5月份左右学习的，ReactJS要晚很多。写Backbone的时候想起来了之前用过的&lt;code>Riot&lt;/code>, 轻量，随意，但是要写完整的应用相比AngularJS之类的要写很多代码。&lt;/li>
&lt;li>开源了&lt;a href="https://pypi.python.org/pypi/qyweixin">qyweixin&lt;/a>和一个&lt;a href="https://pypi.python.org/pypi/httpmultipart">HTTPmultipart&lt;/a>的库，下载量各自也都已经几千了，上次在评论中也看到确实有人在使用～ 还是蛮开心的啦！&lt;/li>
&lt;li>学会了使用 &lt;code>Docker&lt;/code>，也准备学习一些内部机制之类的东西。&lt;/li>
&lt;li>还在翻译中的&lt;a href="https://tornado-zh.readthedocs.org/">Tornado 4.3文档&lt;/a>也会尽快抽时间翻译完成的.&lt;/li>
&lt;li>此外还有学习了&lt;code>Lua&lt;/code>和正在深入学习的&lt;code>Shell&lt;/code>，还有一系列的框架和库, 正在用来写一些自己的小东西。&lt;/li>
&lt;li>1383 Contributions.&lt;/li>
&lt;li>运营了公众号 &lt;code>TheMoeLove&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>还有一些目前还无法放入&lt;em>收获&lt;/em>这一项中的东西，在2016年尽量都再多积累一些。&lt;/p>
&lt;p>另外，下面这部分也非常的重要！&lt;/p>
&lt;ul>
&lt;li>认识了很多好玩的小伙伴，从他们那里也学到了很多东西&lt;/li>
&lt;li>工作中同事们都很好，感谢给予的帮助～&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>学会拒绝。一些事情是可以容忍的，但是要遵守原则，也要考虑时间成本和效率问题。&lt;/li>
&lt;li>学习和思考。这一年之间其实学到的东西也蛮多的，只不过有些东西没能在工程实践中应用，效果不是很明显。多思考，做个靠谱的人，尽量不在相同的地方摔倒两次。&lt;/li>
&lt;li>多读书&lt;/li>
&lt;li>尝试新东西&lt;/li>
&lt;li>多深入一些。浅尝辄止不是应该有的状态。&lt;/li>
&lt;li>合理安排追番时间 2333&lt;/li>
&lt;/ul></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">JSLint,JSHint,ESLint对比和Vim配置</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/11/28/JSLintJSHintESLint%E5%AF%B9%E6%AF%94%E5%92%8CVim%E9%85%8D%E7%BD%AE/"/><id>https://moelove.info/2015/11/28/JSLintJSHintESLint%E5%AF%B9%E6%AF%94%E5%92%8CVim%E9%85%8D%E7%BD%AE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-11-28T23:43:49+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近在用React写项目，但是我的Vim配置之前并没有配置对JSX和ES6的支持，然后看着那堆报错各种不爽了，于是还是要继续折腾……</summary><content type="html">&lt;p>最近在用&lt;code>React&lt;/code>写项目，但是&lt;a href="https://github.com/tao12345666333/vim">我的Vim配置&lt;/a>之前并没有配置对&lt;code>JSX&lt;/code>和&lt;code>ES6&lt;/code>的支持，然后看着那堆报错各种不爽了，于是还是要继续折腾，顺便也增加了点知识，记录一下。&lt;/p>
&lt;h1 id="主流的js-lint工具及介绍">主流的JS Lint工具及介绍&lt;/h1>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript&lt;/a>已经发展蛮长时间了，对应的Lint工具也是层出不穷，下面介绍一下比较主流的几个Lint工具(其实是我用过的几个XD)&lt;/p>
&lt;h2 id="jslint">JSLint&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/JSLint">JSLint&lt;/a>是由&lt;a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford&lt;/a>开发的，可能是最早的JavaScript Lint工具了吧，它的名字来源于著名的&lt;code>C&lt;/code>语言工具&lt;code>Lint&lt;/code>。老道把他认为的非&lt;code>Good Parts&lt;/code>的部分都报了warning，而且在它的&lt;a href="http://www.jslint.com/help.html">文档&lt;/a>中也提到了你应该欣然接受所有的&lt;code>JSLint&lt;/code>的建议。最近看了下，老道还在持续更新着&lt;a href="https://github.com/douglascrockford/JSLint">这个项目&lt;/a>，而且&lt;a href="http://www.jslint.com/">官网&lt;/a>上也有着一个在线的体验工具，可以尝试一下。对了，如果想要使用这个工具，建议看看老道在&lt;a href="https://www.youtube.com/watch?v=taaEzHI9xyY">YouTube&lt;/a>上关于JavaScript编程风格的视频，讲的还是很幽默的。&lt;/p>
&lt;h2 id="jshint">JSHint&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/JSHint">JSHint&lt;/a>是由&lt;a href="http://anton.kovalyov.net/">Anton Kovalyov&lt;/a>&lt;strong>基于&lt;/strong>&lt;code>JSLint&lt;/code>的代码实现的开源项目，由于JSLint时期大多数人都在受JSLint压迫，JSHint相比较之下，更友好，也更容易配置，所以很快就发展了起来，也得到了众多IDE和编辑器的&lt;a href="http://jshint.com/install/">支持&lt;/a>。但是，由于它是基于JSLint开发的，自然原有的一些问题它也继承下来了，比如不易扩展，不容易直接根据报错定位到具体的规则配置等，虽然之前好像是有过相关的讨论，但是现在仍然没有什么好的解决办法。好在它发展的不错，很多时候遇到的问题都可以在网上找到相关的解决方案，而且文档也是非常不错的。&lt;/p>
&lt;h2 id="eslint">ESLint&lt;/h2>
&lt;p>&lt;a href="http://eslint.org/">ESLint&lt;/a>是由&lt;a href="https://www.nczonline.net/">Nicholas C. Zakas&lt;/a>在2013年开始开发的，它的初衷就是为了能让开发者能自定义自己的&lt;code>linting rules&lt;/code>，而且它提供了一套相当完善的插件机制，可以自由的扩展，动态加载配置规则，同时可以方便的根据报错定位到具体的规则配置。而且我比较喜欢它的一点是&lt;a href="http://eslint.org/docs/user-guide/configuring">文档&lt;/a>非常详细，可能这也是灵活所必须的吧。在这里还要提一点，&lt;code>ESLint&lt;/code>最初并不是为了造一个重复的轮子，而是作者在实际使用中的需求&lt;a href="https://github.com/eslint/eslint#why-dont-you-like-jshint">没有能得到JSHint团队的回应&lt;/a>，所以他就结合当时的&lt;code>JSHint&lt;/code>和另一个代码风格的检查工具&lt;code>JSCS&lt;/code>写出来了现在具备&lt;strong>代码风格检查&lt;/strong>，&lt;strong>自定义插件扩展&lt;/strong>功能的&lt;code>ESLint&lt;/code>了。&lt;/p>
&lt;h1 id="jslintjshint和eslint的对比">JSLint，JSHint和ESLint的对比&lt;/h1>
&lt;p>这三个工具各有特色，我只是做一下对比，选择的话，看个人需求就好了。&lt;/p>
&lt;h2 id="jslint-1">JSLint&lt;/h2>
&lt;h3 id="优点">优点&lt;/h3>
&lt;ul>
&lt;li>配置是老道已经定好的，开箱即用。&lt;/li>
&lt;/ul>
&lt;h3 id="不足">不足&lt;/h3>
&lt;ul>
&lt;li>有限的配置选项，很多规则不能禁用&lt;/li>
&lt;li>规范严格，凡是不符合老道所认为的好的风格的，都会有警告(这一项就看你是否完全认同老道了)&lt;/li>
&lt;li>扩展性差&lt;/li>
&lt;li>无法根据错误定位到对应的规则&lt;/li>
&lt;/ul>
&lt;h2 id="jshint-1">JSHint&lt;/h2>
&lt;h3 id="优点-1">优点&lt;/h3>
&lt;ul>
&lt;li>有了很多参数可以配置&lt;/li>
&lt;li>支持配置文件，方便使用&lt;/li>
&lt;li>支持了一些常用类库&lt;/li>
&lt;li>支持了基本的&lt;code>ES6&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="不足-1">不足&lt;/h3>
&lt;ul>
&lt;li>不支持自定义规则&lt;/li>
&lt;li>无法根据错误定位到对应的规则&lt;/li>
&lt;/ul>
&lt;h2 id="eslint-1">ESLint&lt;/h2>
&lt;h3 id="优点-2">优点&lt;/h3>
&lt;ul>
&lt;li>默认规则里面包含了&lt;code>JSLint&lt;/code>和&lt;code>JSHint&lt;/code>的规则，易于迁移(这肯定是故意的XD)&lt;/li>
&lt;li>可配置为&lt;code>警告&lt;/code>和&lt;code>错误&lt;/code>两个等级，或者直接禁用掉&lt;/li>
&lt;li>支持插件扩展&lt;/li>
&lt;li>可以自定义规则&lt;/li>
&lt;li>可以根据错误定位到对应的规则&lt;/li>
&lt;li>支持&lt;code>ES6&lt;/code>&lt;/li>
&lt;li>唯一一个支持&lt;code>JSX&lt;/code>的工具&lt;/li>
&lt;/ul>
&lt;h3 id="不足-2">不足&lt;/h3>
&lt;ul>
&lt;li>需要进行一些自定义配置(因为太灵活了嘛，不过文档是很详细的)&lt;/li>
&lt;li>&lt;strong>慢&lt;/strong> (它比其他两个都要慢)&lt;/li>
&lt;/ul>
&lt;h1 id="vim支持">Vim支持&lt;/h1>
&lt;p>我们都使用&lt;a href="https://github.com/scrooloose/syntastic">&lt;code>Syntastic&lt;/code>&lt;/a>来配置&lt;/p>
&lt;h2 id="jslint的vim配置">JSLint的Vim配置&lt;/h2>
&lt;p>有一个&lt;a href="https://github.com/hallettj/jslint.vim">jslint.vim&lt;/a>当然版本太老了。。我们不用这种方式做。&lt;/p>
&lt;ul>
&lt;li>安装&lt;code>jslint&lt;/code>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo npm install jslint -g
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在&lt;code>vimrc&lt;/code>中添加如下配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>let g:syntastic_javascript_checkers = ['jslint']
&lt;/code>&lt;/pre>&lt;h2 id="jshint的vim配置">JSHint的Vim配置&lt;/h2>
&lt;ul>
&lt;li>安装&lt;code>jshint&lt;/code>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo npm install jshint -g
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在&lt;code>vimrc&lt;/code>中添加如下配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>let g:syntastic_javascript_checkers = ['jshint']
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>也可以使用独立插件&lt;a href="https://github.com/wookiehangover/jshint.vim">jshint.vim&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="eslint的vim配置">ESLint的Vim配置&lt;/h2>
&lt;pre>&lt;code>sudo npm install eslint -g
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在&lt;code>vimrc&lt;/code>中添加如下配置&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>let g:syntastic_javascript_checkers = ['eslint']
&lt;/code>&lt;/pre>&lt;p>&lt;strong>这里有个很重要的问题，记得要在添加一份配置文件，在官网或者在我vim配置的仓库可以找到&lt;/strong>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Vim/" term="Vim" label="Vim"/><category scheme="https://moelove.info/tags/React/" term="React" label="React"/></entry><entry><title type="text">用正确的姿势开源Python项目</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/10/26/%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%BC%80%E6%BA%90Python%E9%A1%B9%E7%9B%AE/"/><id>https://moelove.info/2015/10/26/%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%BC%80%E6%BA%90Python%E9%A1%B9%E7%9B%AE/</id><updated>2021-11-24T16:36:22+08:00</updated><published>2015-10-26T22:17:36+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">做个备忘，也希望可以帮到别人。 目录结构（初始化） 一般我们都会选择在项目的顶层包含较基础的文件，比如setup.py，requir……</summary><content type="html">&lt;blockquote>
&lt;p>做个备忘，也希望可以帮到别人。&lt;/p>
&lt;/blockquote>
&lt;h2 id="目录结构初始化">目录结构（初始化）&lt;/h2>
&lt;p>一般我们都会选择在项目的顶层包含较基础的文件，比如&lt;code>setup.py&lt;/code>，&lt;code>requirements&lt;/code>，&lt;code>README&lt;/code>等文件。
一般情况下，一个预发布的Python项目中应该包含以下几类文件：&lt;/p>
&lt;ul>
&lt;li>projects (项目的主体文件)&lt;/li>
&lt;li>setup.py&lt;/li>
&lt;li>requirements&lt;/li>
&lt;li>Readme (项目说明)&lt;/li>
&lt;li>docs (项目文档)&lt;/li>
&lt;li>test&lt;/li>
&lt;/ul>
&lt;p>其中，&lt;code>projects&lt;/code>文件夹要以项目命名，存放实际的Python Package.
这里放一个&lt;a href="https://github.com/tao12345666333/httpmultipart">我的项目的目录&lt;/a>作为例子。&lt;/p>
&lt;pre>&lt;code>➜ httpmultipart git:(master) tree -L 2
.
├── build
│   ├── bdist.linux-x86_64
│   └── lib.linux-x86_64-2.7
├── dist
│   ├── httpmultipart-0.1.0-py2.py3-none-any.whl
│   └── httpmultipart-0.1.0.tar.gz
├── docs
│   ├── _build
│   ├── conf.py
│   ├── index.rst
│   ├── Makefile
│   ├── userguide
│   └── userguide.rst
├── env
│   ├── bin
│   ├── include
│   ├── lib
│   └── local
├── httpmultipart
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── main.py
│   └── main.pyc
├── httpmultipart.egg-info
│   ├── dependency_links.txt
│   ├── not-zip-safe
│   ├── PKG-INFO
│   ├── SOURCES.txt
│   └── top_level.txt
├── LICENSE
├── MANIFEST.in
├── README.rst
├── setup.cfg
├── setup.py
└── test_httpmultipart.py
14 directories, 21 files
&lt;/code>&lt;/pre>&lt;p>这个目录中包含了我的&lt;code>virtual enviroment&lt;/code> 和打包构建时候生成的文件夹。
这些东西在下面会提到。&lt;/p>
&lt;h2 id="文档">文档&lt;/h2>
&lt;p>文档的话，并没有严格要求必须使用什么样的工具进行构建，也没有很严格的格式要求。不过我推荐使用&lt;a href="http://sphinx-doc.org/">&lt;code>SPHINX&lt;/code>&lt;/a>,它是用Python写的工具，使用了一种叫做&lt;code>reStructuredText&lt;/code>的语法编辑，可以对多个文本文件重编，可以输出成HTML或者PDF等格式。&lt;/p>
&lt;p>这里稍微介绍下使用：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>安装&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Bash" data-lang="Bash">$ pip install sphinx
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Bash" data-lang="Bash">$ &lt;span class="nb">cd&lt;/span> docs
$ sphinx-quickstart
...#&lt;span class="o">(&lt;/span>这里有一系列的提问，进行初始化&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>编译&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Bash" data-lang="Bash">$ make html &lt;span class="c1">#(如果按照默认配置生成的Makefile的话，这样就可以编译出html了)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>Sphinx的使用还有很多值得说的地方，推荐两个资料：&lt;/p>
&lt;ul>
&lt;li>英文的&lt;a href="http://sphinx-doc.org/contents.html">Sphinx 的官方文档&lt;/a>&lt;/li>
&lt;li>中文的&lt;a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-Python%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E6%97%A5%E6%9C%ACBePROUD%E8%82%A1%E4%BB%BD%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/dp/B00KGQ4NRO/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1448116359&amp;amp;sr=1-1&amp;amp;keywords=python+%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98">Python 开发实战&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>官方文档写的非常详细，那本书偏向于实战，是很不错的书。
还有很关键的一点是Sphinx有&lt;code>autodoc&lt;/code>和&lt;code>automodule&lt;/code>的扩展，
可以从代码中提取出文档，与代码直接进行关联。提供一个&lt;a href="https://tornado-zh.readthedocs.org/zh/latest/ioloop.html#running-an-ioloop">例子&lt;/a>可以方便的在文档和源码中进行跳转。&lt;/p>
&lt;h2 id="read-the-docs-持续文档集成">Read the Docs 持续文档集成&lt;/h2>
&lt;p>说完写文档就不得不提到&lt;a href="https://readthedocs.org/">&lt;code>Read the Dosc&lt;/code>&lt;/a>了,这是一个第三方的文档托管平台,使用&lt;code>Django&lt;/code>开发，它可以很轻松的和Github上的项目进行集成，在每次代码提交的时候会自动进行文档构建，我们可以看看&lt;a href="https://tornado-zh.readthedocs.org/">生成文档的效果&lt;/a>。现在有很多开源项目的文档都是托管在这里的，具体的配置可以参考&lt;a href="https://read-the-docs.readthedocs.org/en/latest/getting_started.html">官方文档&lt;/a>。&lt;/p>
&lt;h2 id="travisci-持续集成">TravisCI 持续集成&lt;/h2>
&lt;p>&lt;a href="https://travis-ci.org/">&lt;code>Travisci&lt;/code>&lt;/a>可以与Github非常好的结合，可以手动导入&lt;code>repo&lt;/code>，并设置&lt;code>Webhooks &amp;amp; services&lt;/code>,在每次提交的时候都会测试运行来发现是否存在异常。在使用之前，我们需要先做一些初始化的操作：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建&lt;code>.travis.yml&lt;/code>文件&lt;/p>
&lt;p>我们需要告诉它一些基本的信息：&lt;/p>
&lt;ul>
&lt;li>我们项目使用的语言&lt;/li>
&lt;li>项目使用的语言版本&lt;/li>
&lt;li>环境的依赖&lt;/li>
&lt;li>是否需要&lt;code>sudo&lt;/code>权限运行&lt;/li>
&lt;li>使用什么命令来安装&lt;/li>
&lt;li>使用什么命令运行测试&lt;/li>
&lt;/ul>
&lt;p>下面提供一个例子：&lt;/p>
&lt;pre>&lt;code> ```YML
language: python
python:
- 2.7
env:
- DEPS=true
- DEPS=false
sudo: false
install:
- travis_retry python setup.py install
- travis_retry pip install coveralls
- coverage run test_httpmultipart.py
- coverage report
script:
- python test_httpmultipart.py
after_success:
coveralls
```
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>PS： 在&lt;code>install&lt;/code>这一项配置中要注意，如果项目存在依赖，一定要进行安装，还有&lt;code>Travisci&lt;/code>提供了多项配置，包括出错重试等，具体配置可以参考&lt;a href="http://docs.travis-ci.com/">官方文档&lt;/a>，要特别注意&lt;code>travis_retry&lt;/code>等命令的使用，非常容易出现坑。&lt;/p>
&lt;h2 id="测试">测试&lt;/h2>
&lt;p>Python有内置的&lt;code>unittest&lt;/code>测试库，支持断言;当然还有其他的一些测试框架，看个人喜好和项目需求。在项目中应该包含测试文件或者测试目录，测试文件一般以&lt;code>test_projects_name.py&lt;/code>命名。我选择使用&lt;code>coverage&lt;/code>作为测试覆盖率的检查，下面是一个运行示例：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Bash" data-lang="Bash">➜ httpmultipart git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> coverage run test_httpmultipart.py
....
----------------------------------------------------------------------
Ran &lt;span class="m">4&lt;/span> tests in 36.125s
OK
➜ httpmultipart git:&lt;span class="o">(&lt;/span>master&lt;span class="o">)&lt;/span> coverage report
Name Stmts Miss Branch BrPart Cover
-------------------------------------------------------------
httpmultipart/__init__.py &lt;span class="m">10&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> 100%
httpmultipart/main.py &lt;span class="m">37&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">0&lt;/span> 100%
-------------------------------------------------------------
TOTAL &lt;span class="m">47&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">0&lt;/span> 100%
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="coveralls-测试覆盖率检查">Coveralls 测试覆盖率检查&lt;/h2>
&lt;p>&lt;a href="https://coveralls.io">Coveralls&lt;/a>可以很友好的支持Github和Bitbucket仓库的导入，同时也可以很好的和&lt;code>Travisci&lt;/code>集成，在上面我们的&lt;code>.travis.yml&lt;/code>文件中，在最后一项&lt;code>after_success&lt;/code>中，我们就配置了对&lt;code>Coveralls&lt;/code>的支持。&lt;/p>
&lt;h2 id="发布包到pypi">发布包到PyPI&lt;/h2>
&lt;p>&lt;a href="https://pypi.python.org/pypi">PyPI - the Python Package Index&lt;/a>
是Python的包仓库，它允许我们将自己写的包上传上去，这样就可以使用&lt;code>pip&lt;/code>和&lt;code>easy_install&lt;/code>进行安装了。这里说一个很重要的事情：
&lt;strong>请在发布自己项目之前做好测试，确认自己上传的是一个可用，无害的包&lt;/strong>
当你已经完成上面的步骤之后，那么你只需要以下几步就可以完成了。以我的项目为例子:&lt;/p>
&lt;ul>
&lt;li>配置&lt;code>setup.py&lt;/code>:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Python" data-lang="Python">&lt;span class="ch">#!/usr/bin/env python&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">re&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">sys&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">codecs&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="nb">open&lt;/span>
&lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">setuptools&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">setup&lt;/span>
&lt;span class="k">except&lt;/span> &lt;span class="ne">ImportError&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">distutils.core&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">setup&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">sys&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;publish&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;python setup.py sdist upload&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">sys&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">exit&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">packages&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="s1">&amp;#39;httpmultipart&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="n">requires&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="nb">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;httpmultipart/__init__.py&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;r&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">version&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">re&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">r&lt;/span>&lt;span class="s1">&amp;#39;^__version__\s*=\s*[&lt;/span>&lt;span class="se">\&amp;#39;&lt;/span>&lt;span class="s1">&amp;#34;]([^&lt;/span>&lt;span class="se">\&amp;#39;&lt;/span>&lt;span class="s1">&amp;#34;]*)[&lt;/span>&lt;span class="se">\&amp;#39;&lt;/span>&lt;span class="s1">&amp;#34;]&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">fd&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">re&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">MULTILINE&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">group&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">version&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">RuntimeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Cannot find version information&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="nb">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;README.rst&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;r&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;utf-8&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">readme&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;httpmultipart&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">version&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">version&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">description&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;A httpmultipart post handler&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">long_description&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">readme&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="se">\n\n&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">author&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;Jintao Zhang&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">author_email&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;zhangjintao9020@gmail.com&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">url&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;https://github.com/tao12345666333/httpmultipart&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">packages&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">packages&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">package_data&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;LICENSE&amp;#39;&lt;/span>&lt;span class="p">]},&lt;/span>
&lt;span class="n">package_dir&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;httpmultipart&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;httpmultipart&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="n">include_package_data&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">True&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">install_requires&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">requires&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">license&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;MIT&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">zip_safe&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">platforms&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;any&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">classifiers&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="s1">&amp;#39;Development Status :: 5 - Production/Stable&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Intended Audience :: Developers&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Natural Language :: English&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;License :: OSI Approved :: MIT License&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Programming Language :: Python&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Programming Language :: Python :: 2.7&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Topic :: Software Development :: Libraries&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;Topic :: Software Development :: Libraries :: Python Modules&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">),&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然大部分时候也不需要这么麻烦，简化的配置可以参考官方的文档。注意最下面那部分&lt;code>classifiers&lt;/code>是按照&lt;a href="https://pypi.python.org/pypi?:action=list_classifiers">PyPI官方的列表填写&lt;/a>的。还有，如果有些文件想要额外打包进去，那么需要在根目录添加&lt;code>MANIFEST.in&lt;/code>文件。&lt;/p>
&lt;ul>
&lt;li>打包代码&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Bash" data-lang="Bash">$ python setup.py sdist &lt;span class="c1"># 生成pip支持的安装包&lt;/span>
$ python setup.py bdist_wheel &lt;span class="c1"># 生成支持easy_install的安装包&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>发布到PyPI上&lt;/p>
&lt;p>首先在&lt;a href="https://pypi.python.org/pypi">PyPI&lt;/a>上&lt;a href="https://pypi.python.org/pypi?%3Aaction=register_form">注册&lt;/a>一个帐号，然后进行下面两步：&lt;/p>
&lt;ul>
&lt;li>注册package
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ python setup.py register
$ &lt;span class="c1"># 在这一步会有一些提示，按照提示选择，输入自己帐号密码相关的信息即可&lt;/span>
$ &lt;span class="c1"># 在提示你要不要保存帐号信息的时候，&lt;/span>
$ &lt;span class="c1"># 你选择了‘y’，&lt;/span>
$ &lt;span class="c1"># 则会在你的用户目录下生成一个 .pypirc 的文件，&lt;/span>
$ &lt;span class="c1"># 其中明文保存着你的帐号和密码。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这里稍微再提一点，如果在提示是否保存账户信息的时候，选择了‘n’，想反悔了也没关系，我们可以手动创建一个&lt;code>~/.pypirc&lt;/code>文件。格式如下：
```
[distutils]
index-servers=pypi&lt;/p>
&lt;pre>&lt;code> [pypi]
repository = https://pypi.python.org/pypi
username = your username
password = your password
```
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>上传package
&lt;code>bash $ python setup.py sdist bdist_wheel upload&lt;/code>
在上传完成提示&lt;code>200&lt;/code>响应的时候，你就上传成功了，去PyPI上看看有没有上传成功的包，并且试着用&lt;code>pip&lt;/code>进行安装吧！&lt;/li>
&lt;/ul>
&lt;p>这里我省略了一步，就是发布前的测试，你可以使用&lt;a href="https://testpypi.python.org/pypi">PyPI的测试服务器&lt;/a>进行测试发布，发布到这里的包并不会对你正式发布有任何影响。&lt;/p>
&lt;h2 id="项目托管在github上">项目托管在Github上&lt;/h2>
&lt;p>开源到Github上后，就是继续维护和开发，这点就不多说了。&lt;/p>
&lt;h2 id="开发相关">开发相关&lt;/h2>
&lt;p>建议使用&lt;code>virtualenv&lt;/code>之类的工具构建纯净的环境，重复的动作交给&lt;code>Make&lt;/code>之类的工具。&lt;/p>
&lt;p>这篇算是一个小小的总结加备忘吧，经验尚缺，还望指正。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/pip/" term="pip" label="pip"/><category scheme="https://moelove.info/tags/Git/" term="Git" label="Git"/></entry><entry><title type="text">对监控系统的思考</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/10/16/%E5%AF%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83/"/><id>https://moelove.info/2015/10/16/%E5%AF%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%9D%E8%80%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-10-16T00:59:01+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">近期在做运维监控方面的事情，也研究了一下其他人是如何做的。把自己的想法做个总结记录一下吧。 监控期望的目标 及时发现 需要的是即时监控……</summary><content type="html">&lt;blockquote>
&lt;p>近期在做运维监控方面的事情，也研究了一下其他人是如何做的。把自己的想法做个总结记录一下吧。&lt;/p>
&lt;/blockquote>
&lt;h3 id="监控期望的目标">监控期望的目标&lt;/h3>
&lt;ul>
&lt;li>及时发现&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>需要的是即时监控并报警&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>及时定位&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>定位问题要分开讲&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>运维层面&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>是机器硬件问题还是上面运行的基础服务的问题，或者是新上线代码的问题，需要回滚。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>代码层面&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在发生问题的时候，优先解决问题。定位代码问题提交hotfix 可以在解决问题之后做。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;ul>
&lt;li>及时处理&lt;/li>
&lt;li>提前预测（尽量减少问题的发生）&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>提前预测可以做的事情有很多，数据挖掘/分析之类的。当然有个更简单的方法，就是先小范围上线，进行监控。如果发现出问题了，就停止上线，进行回滚。（我们现在就是这样做的，虽然原因并不是这个 2333&lt;/p>
&lt;/blockquote>
&lt;h3 id="监控遇到的主要问题">监控遇到的主要问题&lt;/h3>
&lt;ul>
&lt;li>监控指标多&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>服务器CPU,内存，网络等的指标，基础服务Redis, MongoDB等的运行指标，对外服务的API是否正常工作，还有数据是否正确等。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>监控报警多&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>监控指标多的时候，自然报警也会相应增加，但是报警的分组与轻重缓急也是一个很麻烦的问题。还有就是部署着不同服务的机器，触发报警时候的指标也不好确定。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>报警多而且有关联，如何查找原因&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>可能同时会有多个指标触发了报警，但是要定位问题的时候，如何可以快速的定位问题。&lt;/p>
&lt;/blockquote>
&lt;h3 id="多维度数据监控">多维度数据监控&lt;/h3>
&lt;blockquote>
&lt;p>这个话题太大(要感谢Baidu的颜大大的指点）&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>数据监控符合&lt;a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99">二八原则&lt;/a>,重要数据需要多角度进行观察，需要有meta管理，需要动态简单配置。选择 好的，合理的数据模型可以有效的进行处理。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>数据采集部分，在单机器做聚合;命名上使用正则格式化;完善的配置功能，支持数据流自定义维度。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>对开源系统的使用，需要按照自己的实际情况进行适配。保证高可用性&lt;/li>
&lt;/ul>
&lt;p>&lt;em>先写这些吧，之后有时间再写，还有QCon上对运维监控上的一些分享也非常值得思考&lt;/em>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/DevOps/" term="DevOps" label="DevOps"/></entry><entry><title type="text">Open-Falcon监控系统部署</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/10/13/Open-Falcon%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/><id>https://moelove.info/2015/10/13/Open-Falcon%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-10-13T21:01:00+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">本文并不分析Open-Falcon的架构或者选用它的原因，官方的文档在这里，虽然还不够完善。不过这也是我写这篇的原因，官方文档并……</summary><content type="html">&lt;blockquote>
&lt;p>本文并不分析Open-Falcon的架构或者选用它的原因，官方的文档在&lt;a href="http://book.open-falcon.com/zh/intro/README.html">这里&lt;/a>，虽然还不够完善。不过这也是我写这篇的原因，官方文档并没能把整个部署过程连在一起，而且个别地方有点问题。我在这篇文章中就不介绍各个组件的作用和功能了，只是单纯的介绍如何从零部署。&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装">安装&lt;/h2>
&lt;h3 id="下载">下载&lt;/h3>
&lt;blockquote>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>wget &lt;a href="https://github.com/XiaoMi/open-falcon/releases/download/0.0.5/open-falcon-0.0.5.tar.gz">https://github.com/XiaoMi/open-falcon/releases/download/0.0.5/open-falcon-0.0.5.tar.gz&lt;/a> -O open-falcon.tar.gz&lt;/p>
&lt;pre>&lt;code>
### 解压
&amp;gt; ```
mkdir tmp
tar -zxvf open-falcon.tar.gz -C ./tmp
&lt;/code>&lt;/pre>&lt;h3 id="基础环境">基础环境&lt;/h3>
&lt;blockquote>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>sudo apt-get install redis-server
sudo apt-get install mysql-server
pip install virtualenv&lt;/p>
&lt;h1 id="数据库初始化的代码来源于官方文档">数据库初始化的代码来源于官方文档&lt;/h1>
&lt;p>git clone &lt;a href="https://github.com/open-falcon/scripts.git">https://github.com/open-falcon/scripts.git&lt;/a>
cd scripts
mysql -h localhost -u root -p &amp;lt; db_schema/graph-db-schema.sql
mysql -h localhost -u root -p &amp;lt; db_schema/dashboard-db-schema.sql&lt;/p>
&lt;p>mysql -h localhost -u root -p &amp;lt; db_schema/portal-db-schema.sql
mysql -h localhost -u root -p &amp;lt; db_schema/links-db-schema.sql
mysql -h localhost -u root -p &amp;lt; db_schema/uic-db-schema.sql&lt;/p>
&lt;pre>&lt;code>
## 配置
**数据库连接的配置格式是:** `username:password@tcp(path:port)/xxxx`
### agent
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; 开始监听1988端口,查看log.
&amp;gt; 默认端口是1988, 可以打开 [http://127.0.0.1:1988](http://127.0.0.1:1988) 查看一个比较简单的web dashboard. 没什么特殊需要的话, 可以使用默认配置.
### hbs
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; 心跳服务默认http端口是6030, rpc 端口 6031
### transfer
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; 默认http端口是6060, rpc端口8433
### judge
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; http端口6081, rpc端口 6080
&amp;gt; 配置项中注意alarm的 redis链接 和hbs的server地址,如果修改过请记得对应.
### graph
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; rpc端口 6070, http端口 6071
&amp;gt; 数据库文件存储在`/home/work/data/6070` 启动报错的话, 换sudo 或者 root 用户启动.
&amp;gt; 注意修改数据库连接.
上面的服务配置完成数据就开始采集了.
### dashboard
&amp;gt; ```
virtualenv env
source env/bin/activate
./env/bin/pip install -r pip_requirements.txt
# 使用
./env/bin/python wsgi.py
# 或者用
deactivate &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>可以更改为自定义端口.这里可以查看Endpoints 的相关数据并绘图.&lt;/p>
&lt;/blockquote>
&lt;h3 id="query">query&lt;/h3>
&lt;blockquote>
&lt;p>&lt;code>mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail&lt;/code>
只要修改cfg.json 文件即可, 注意还有 &lt;code>graph_backends.txt&lt;/code> 文件&lt;/p>
&lt;/blockquote>
&lt;h3 id="fe">fe&lt;/h3>
&lt;blockquote>
&lt;p>&lt;code>mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail&lt;/code>
注意配置项目中的数据库连接, 以及下面的&lt;code>shortcut&lt;/code> 中需要配置外网可以访问的地址,如果不是在服务器部署的话,这里默认也没有关系.&lt;/p>
&lt;/blockquote>
&lt;h3 id="portal">portal&lt;/h3>
&lt;blockquote>
&lt;p>这里要注意一个坑. 如果使用&lt;code>./control start&lt;/code> 启动服务, 并且更改了默认端口的, 请配置 &lt;strong>gunicorn.conf&lt;/strong> 中的&lt;strong>bind&lt;/strong>项. 如果是使用&lt;code>python wsgi.py&lt;/code>启动的话, 修改&lt;strong>wsgi.py&lt;/strong>中的端口即可.
同时在配置 &lt;code>frame/config.py&lt;/code> 的时候, 要注意所谓&lt;strong>UIC_ADDRESS&lt;/strong> 选项的配置, 其实就是填写上面&lt;strong>fe&lt;/strong> 模块的地址.&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>UIC_ADDRESS = {
'internal': 'http://127.0.0.1:port', #你的内网地址
'external': 'http://your_fe_name', #外网访问的地址, 如果是本地部署,这里可以和内网地址一样
}&lt;/p>
&lt;pre>&lt;code>
### alarm
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; 需要配置的就是自定义的端口监控地址, 和下面的api, 其他部分保持默认即可.
&amp;gt; 在[它的文档](http://book.open-falcon.com/zh/install_from_src/alarm.html)中写着下面这样的说明
&amp;gt; ```
{...
&amp;quot;api&amp;quot;: {
&amp;quot;portal&amp;quot;: &amp;quot;http://falcon.example.com&amp;quot;, # 内网可访问的portal的地址
&amp;quot;uic&amp;quot;: &amp;quot;http://uic.example.com&amp;quot;, # 内网可访问的uic(或fe)的地址
&amp;quot;links&amp;quot;: &amp;quot;http://link.example.com&amp;quot; # 外网可访问的links的地址
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>但是如果按照这样配的话,所有东西就只能在内网访问了.这明显是不符合我们的期望的. 所以这里要全部配置成外网可以访问的地址,&lt;strong>防止踩坑&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="sender">sender&lt;/h3>
&lt;blockquote>
&lt;p>这个组件用于调用自己提供的短信和邮件接口, 编辑 cfg.json 添加&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>{...
'api': {
'sms': 'http://your_send_sms_api',
'mail': 'http://your_send_mail_api'
}
}&lt;/p>
&lt;pre>&lt;code>&amp;gt; 在调用的时候, 会把消息先写入redis队列中, 之后再调用接口,进行消息发送.
&amp;gt; worker 参数是对队列的配置.
### links
&amp;gt; `mv cfg.example.json cfg.json &amp;amp;&amp;amp; ./control start &amp;amp;&amp;amp; ./control tail`
&amp;gt; 告警合并组件, python应用, 记得修改默认端口即可.
## 其他
### task
&amp;gt; 监控自检程序
### gateway
&amp;gt; 没有跨机房问题可以忽略.(hhah
### redis-monitor.py
&amp;gt; scripts 文件夹中一个很简单的脚本, 把redis info 中的数据读出,写入数据库, 供监控使用.
最后附图一张，前几天我启动这个服务时候的终端。
![screen_shot](http://moelove.qiniudn.com/1911x1160_scrot.png)
&lt;/code>&lt;/pre></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/DevOps/" term="DevOps" label="DevOps"/><category scheme="https://moelove.info/tags/Open-Falcon/" term="Open-Falcon" label="Open-Falcon"/><category scheme="https://moelove.info/tags/Go/" term="Go" label="Go"/></entry><entry><title type="text">源码编译MongoDB</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/09/13/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91MongoDB/"/><id>https://moelove.info/2015/09/13/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91MongoDB/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-09-13T21:28:43+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">上周放假正好有时间，编译安装了MongoDB，虽然MongoDB用了挺长时间的，但还是第一次用源码编译。在此做个备忘。因为已经完……</summary><content type="html">&lt;blockquote>
&lt;p>上周放假正好有时间，编译安装了MongoDB，虽然MongoDB用了挺长时间的，但还是第一次用源码编译。在此做个备忘。因为已经完整编译安装过了，所以写起来的时候，就按照先知视角来写了～ 2333&lt;/p>
&lt;/blockquote>
&lt;h2 id="下载mongodb源码">下载MongoDB源码&lt;/h2>
&lt;p>MongoDB的&lt;a href="https://www.mongodb.org/">官网&lt;/a>上是有已经编译好的二进制包的，这里选择clone &lt;a href="https://github.com/mongodb/mongo">MongoDB在github上的仓库&lt;/a>&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/mongodb/mongo &amp;amp;&amp;amp; cd mongo
&lt;/code>&lt;/pre>&lt;p>在&lt;code>docs/building.md&lt;/code>中是编译所需的依赖。&lt;/p>
&lt;ul>
&lt;li>A modern C++ compiler. One of the following is required.
&lt;ul>
&lt;li>GCC 4.8.2 or newer&lt;/li>
&lt;li>Clang 3.4 (or Apple XCode 5.1.1 Clang) or newer&lt;/li>
&lt;li>Visual Studio 2013 Update 2 or newer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python 2.7&lt;/li>
&lt;li>SCons 2.3&lt;/li>
&lt;/ul>
&lt;p>我这台服务器是CentOS 6.5, 上面的gcc版本比较低，这里就先更新gcc咯.&lt;/p>
&lt;pre>&lt;code>gcc --version
gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-16)
Copyright © 2010 Free Software Foundation, Inc.
本程序是自由软件；请参看源代码的版权声明。
本软件没有任何担保；
包括没有适销性和某一专用目的下的适用性担保。
&lt;/code>&lt;/pre>&lt;h2 id="编译升级gcc">编译升级gcc&lt;/h2>
&lt;p>在gcc的&lt;a href="https://gcc.gnu.org/">官网&lt;/a>找到&lt;a href="https://gcc.gnu.org/install/download.html">下载页面&lt;/a>。使用&lt;a href="https://gcc.gnu.org/svn.html">svn&lt;/a>或者通过&lt;a href="https://gcc.gnu.org/mirrors.html">ftp镜像站&lt;/a>下载源码.
我使用了&lt;a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/">一个ftp镜像站&lt;/a>下载的&lt;a href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-5.2.0/gcc-5.2.0.tar.bz2">源码压缩包&lt;/a>。 然后进行解压和安装依赖。&lt;/p>
&lt;pre>&lt;code>tar -xjf gcc-5.2.0.tar.bz2 &amp;amp;&amp;amp; cd gcc-5.2.0
./contrib/download_prerequisites(等待依赖完成)
&lt;/code>&lt;/pre>&lt;p>之后编译&lt;/p>
&lt;pre>&lt;code>cd .. &amp;amp;&amp;amp; mkdir gcc-build-5.2.0 &amp;amp;&amp;amp; cd gcc-build-5.2.0
# 编译
../gcc-5.2.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib
&lt;/code>&lt;/pre>&lt;p>输出：&lt;/p>
&lt;pre>&lt;code>checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... x86_64-unknown-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether ln works... yes
checking whether ln -s works... yes
checking for a sed that does not truncate output... /bin/sed
checking for gawk... gawk
checking for libatomic support... yes
checking for libcilkrts support... yes
checking for libitm support... yes
checking for libsanitizer support... yes
checking for libvtv support... yes
checking for gcc... gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... no
checking for suffix of executables...
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking for g++... g++
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking whether g++ accepts -static-libstdc++ -static-libgcc... no
checking for gnatbind... no
checking for gnatmake... no
checking whether compiler driver understands Ada... no
checking how to compare bootstrapped objects... cmp --ignore-initial=16 $$f1 $$f2
checking for objdir... .libs
configure: WARNING: using in-tree ISL, disabling version check
&lt;/code>&lt;/pre>&lt;p>一般情况下， 就这样gcc就可以编译完成了。 但是因为我这台机器是单核1G没有swap区， 所以我遇到了下面的问题：&lt;/p>
&lt;pre>&lt;code># 排版有点错乱惹...
build/vec.o
build/min-insn-modes.o
build/gensupport.o
build/print-rtl.o
build/read-md.o
build/errors.o ../build-x86_64-unknown-linux-gnu/libiberty/libiberty.a
build/genattrtab ../../gcc-5.2.0/gcc/common.md ../../gcc-5.2.0/gcc/config/i
386/i386.md insn-conditions.md \
-Atmp-attrtab.c -Dtmp-dfatab.c -Ltmp-latencytab.c
make[3]: *** [s-attrtab] 已杀死
make[3]: Leaving directory `/home/tao/gcc-build-5.0.2/gcc'
make[2]: *** [all-stage1-gcc] 错误 2
make[2]: Leaving directory `/home/tao/gcc-build-5.0.2'
make[1]: *** [stage1-bubble] 错误 2
make[1]: Leaving directory `/home/tao/gcc-build-5.0.2'
make: *** [all] 错误 2
&lt;/code>&lt;/pre>&lt;p>大致查了下，是因为没有swap区的原因，根据&lt;a href="http://stackoverflow.com/questions/18389612/make-exits-with-error-2-when-trying-to-install-gcc-4-8-1#">这篇&lt;/a> 得到的解决办法是：&lt;/p>
&lt;pre>&lt;code>SWAP=/tmp/swap
dd if=/dev/zero of=$SWAP bs=1M count=500
mkswap $SWAP
sudo swapon $SWAP
&lt;/code>&lt;/pre>&lt;p>之后就是gcc 的编译时间了， 这个时间可以去写写代码补个番啥的。这台机器只是平时拿来玩的，配置炒鸡低。编译gcc从17：20开始，一直到20：09停止。(期间我去补番啦 2333)&lt;/p>
&lt;pre>&lt;code># 只会执行下面的命令
make
make install
# 切换gcc到新版本
update-alternatives --install /usr/bin/gcc gcc /usr/local/bin/gcc-5.0.2 66
# 我重新ssh登录后才看到更新生效的
gcc --version
gcc (GCC) 5.2.0
Copyright © 2015 Free Software Foundation, Inc.
本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；
包括没有适销性和某一专用目的下的适用性担保。
&lt;/code>&lt;/pre>&lt;h2 id="升级python">升级Python&lt;/h2>
&lt;p>CentOS上默认的Python对于之后要安装的scons来说，还是版本太低。再次上&lt;a href="https://www.python.org">Python 官网&lt;/a> (官网真是个好地方2333)下载Python2.7的&lt;a href="https://www.python.org/ftp/python/2.7.10/Python-2.7.10.tar.xz">源码&lt;/a>
编译过很多次了， 就只写主要的东西了&lt;/p>
&lt;pre>&lt;code>xz -d python-2.7.10.tar.xz
tar -xvf python-2.7.10.tar &amp;amp;&amp;amp; cd python-2.7.10
# 对于这次编译MongoDB来说，一定需要安装的是bzip2依赖
yum install -y bzip2-devel
# 编译
./configure --prefix=/usr/local/python2.7
make
make install
# 更新
update-alternatives --install /usr/bin/python python /usr/local/bin/python 69
&lt;/code>&lt;/pre>&lt;h2 id="安装scons">安装scons&lt;/h2>
&lt;p>在&lt;a href="http://www.scons.org/">官网&lt;/a>上找到&lt;a href="http://iweb.dl.sourceforge.net/project/scons/scons/2.3.6/scons-2.3.6.tar.gz">源码包&lt;/a>直接安装&lt;/p>
&lt;pre>&lt;code># 依赖解决
yum install pcre-devel python-devel
# 解压安装
tar -zxvf scons-2.3.6.tar.gz &amp;amp;&amp;amp; cd scons-2.3.6
python setup.py install
&lt;/code>&lt;/pre>&lt;h2 id="编译安装mongodb">编译安装MongoDB&lt;/h2>
&lt;p>最后的安装过程就不是这篇里面的重点了， 遇到的一个坑是：&lt;/p>
&lt;pre>&lt;code>Initializer* _theGlobalInitializer = &amp;amp;getGlobalInitializer();
&lt;/code>&lt;/pre>&lt;p>有这样的报错信息。 查了一下，根据&lt;a href="https://jira.mongodb.org/browse/SERVER-19353">这篇&lt;/a>只要在构建的时候，加上&lt;code>--disable-warnings-as-errors&lt;/code>就可以解决了&lt;/p>
&lt;pre>&lt;code>scons all --disable-warnings-as-errors
# 其他的设置可以查看scons的相关文档
&lt;/code>&lt;/pre>&lt;p>本篇的重点是编译的过程，后续MongoDB配置部分抽空再写。全文完。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/MongoDB/" term="MongoDB" label="MongoDB"/></entry><entry><title type="text">重置Ghost博客的密码</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/07/21/%E9%87%8D%E7%BD%AEGhost%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AF%86%E7%A0%81/"/><id>https://moelove.info/2015/07/21/%E9%87%8D%E7%BD%AEGhost%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AF%86%E7%A0%81/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-07-21T23:11:04+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在搭建Ghost博客的时候，尚未配置mail服务器时，重置密码的方法做个记录 打开数据库查看用户信息 如果全部默认设置，使用生产环境……</summary><content type="html">&lt;blockquote>
&lt;p>在搭建Ghost博客的时候，尚未配置mail服务器时，重置密码的方法做个记录&lt;/p>
&lt;/blockquote>
&lt;h3 id="打开数据库查看用户信息">打开数据库查看用户信息&lt;/h3>
&lt;p>如果全部默认设置，使用生产环境的话，应该是
&lt;code>sqlite3 content/data/ghost.db&lt;/code>&lt;/p>
&lt;p>如果是开发环境应该是
&lt;code>sqlite3 content/date/ghost-dev.db&lt;/code>&lt;/p>
&lt;p>查看用户信息
&lt;code>sqlite&amp;gt;SELECT * FROM users;&lt;/code>&lt;/p>
&lt;h3 id="更新用户密码">更新用户密码&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Ghost对用户密码用的是BCrypt加密，可以使用&lt;a href="http://bcrypthashgenerator.apphb.com/">BCrypt Hash Generator&lt;/a>之类的工具生成一个想要修改的密码，例如&amp;quot;mypasswd&amp;quot;生成的密码是
&lt;code>$2a$10$QecJeBdw2lONRTnHJ0RoVO6DczdJWf4h4QgaUcgKsYFZlzTe1yeEK&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设之前查看到的用户信息，邮箱是&lt;strong>&lt;a href="mailto:admin@domain.com">admin@domain.com&lt;/a>&lt;/strong> 那么，使用这样更新密码&lt;/p>
&lt;pre>&lt;code> UPDATE users SET password=&amp;quot;$2a$10$QecJeBdw2lONRTnHJ0RoVO6DczdJWf4h4QgaUcgKsYFZlzTe1yeEK&amp;quot; WHERE email=&amp;quot;admin@domain.com&amp;quot;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>退出sqlite3
&lt;code>.exit&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Blog/" term="Blog" label="Blog"/><category scheme="https://moelove.info/tags/sqlite/" term="sqlite" label="sqlite"/></entry><entry><title type="text">3.17</title><link rel="alternate" type="text/html" href="https://moelove.info/2015/03/17/3.17/"/><id>https://moelove.info/2015/03/17/3.17/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2015-03-17T00:34:34+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">8小时内求生存 8小时外求发展</summary><content type="html">&lt;h2 id="8小时内求生存">8小时内求生存&lt;/h2>
&lt;h2 id="8小时外求发展">8小时外求发展&lt;/h2></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">近况</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/10/16/%E8%BF%91%E5%86%B5/"/><id>https://moelove.info/2014/10/16/%E8%BF%91%E5%86%B5/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-10-16T23:34:39+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">博客好长时间没有更新了，今天抽空大致来说一下近况吧 工作 用这个标题的话，其实感觉想写的确实好多，但是还是挑一些比较重要的来说吧。现……</summary><content type="html">&lt;blockquote>
&lt;p>博客好长时间没有更新了，今天抽空大致来说一下近况吧&lt;/p>
&lt;/blockquote>
&lt;h3 id="工作">工作&lt;/h3>
&lt;p>用这个标题的话，其实感觉想写的确实好多，但是还是挑一些比较重要的来说吧。现在的公司说实话还确实没有让我失望，工位上配的是一个 22寸的 AOC 显示器和一个24寸的 Dell 显示器， 主机内存 12G （我每天跑个Linux是有点浪费）办公区每天有物业定时打扫神马的，下午的时候有茶歇（茶水间还有一堆零食）。同事们相处感觉都很不错,每天中午一起出去吃饭，各种聊天调侃神马的，只是一开始不太了解项目中的配置神马的，让老大费心了...&lt;/p>
&lt;p>这段时间还有很多有趣的事情 比如： 去金海湾度假村团建之类的。 再说一下最近的感受吧。&lt;/p>
&lt;p>因为国庆前需要上线，所以放假前就每天都是在忙着开发神马的。不过那两周也是近期感觉最爽的时候 &lt;s>写代码高潮不断&lt;/s> 而且也确实感觉工作是蛮有挑战性的，确实是我想要的工作 :-) 。 不过我还记得那周一，一打开邮箱看到中有7份未读的需求邮件， 确实是略惊吓。
在开发的项目，因为改变了设计思路，所以这些天主要都是在写前端。只不过一开始的时候感觉略虐心啊， 写Python时间长了已经是不习惯其他语言那种书写规范了 &lt;s>一堆括号写的好烦躁&lt;/s> 但是从这两天的感觉来看，得感谢老大的这种设计思路，这段时间学到的确实很多。 从框架到一些库，一些插件， 还有程序上一些比较巧妙的用法 &lt;s>正在努力消化中&lt;/s>&lt;/p>
&lt;h3 id="生活">生活&lt;/h3>
&lt;p>&lt;s>有点后悔加上标题了&lt;/s> 其实主要要说的应该都放在这里吧。
从搬家后基本上每天生活都很规律，目前差不多适应了。&lt;s>(找工作和面试神马的我写到碎碎念里面了，具体的等半年或者一年后当回忆录来写 233)&lt;/s>值得吐槽的就是电信的客服，用的是电信的网，前几天换了路由器忘记了密码，打客服重置密码，但是一直连接不成功（691错误，明显就是帐号密码的问题嘛）结果本来想到了周末放假的时候再好好处理，结果到了周末打电话却一直没有客服啊&lt;s>用联通号打电信的客服我也是醉了&lt;/s> 最后到了周一才让客服又重置才成功。&lt;/p>
&lt;p>其实那也是导致我这么久没有更新博客的原因orz 。&lt;/p>
&lt;ul>
&lt;li>一个原因是因为电脑重装了系统，环境啥的一直没有配置&lt;/li>
&lt;li>另一个就是因为网络坑爹，实在有心无力&lt;/li>
&lt;/ul>
&lt;p>再者就是帝都的天气让人确实有点无奈，有天早上刚下楼，我还以为我要迈步进入寂静岭了 TAT ，感觉能幸存下来确实是很不容易啊。&lt;/p>
&lt;p>最后说一下最近在网络弄好之后，挖了一个坑。打算独立开发一个网站的说， 重复造轮子的原因和大多数人是一样的 ，现有的东西没有我想要的 &lt;s>&lt;B>正好把最近学到的东西都拿来练练手&lt;/B>&lt;/s>&lt;/p>
&lt;h2 id="b-try-my-best--b">&lt;B> Try My Best ! &lt;/B>&lt;/h2></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Life/" term="Life" label="Life"/></entry><entry><title type="text">正则匹配中文及字符编码问题</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/07/22/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/><id>https://moelove.info/2014/07/22/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%96%87%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-07-22T21:16:34+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">匹配中文的正则表达式 窝写了一小段代码（虽然写的不太好，但是基本可以表达意思） -- import re nickname = raw_input('Please input your nickname &amp;gt; ') if not re.search(u'^[\u4e00-\u9fa5a-zA-Z0-9]+$', unicode(nickname,'utf8')): print 'Your nickname format is error, please try again !' else:……</summary><content type="html">&lt;h2 id="匹配中文的正则表达式">匹配中文的正则表达式&lt;/h2>
&lt;p>窝写了一小段&lt;a href="http://moelove.qiniudn.com/regex-match-Chinese.py">代码&lt;/a>（虽然写的不太好，但是基本可以表达意思）&lt;/p>
&lt;!--&lt;script src="https://gist.github.com/tao12345666333/13edb463b04da758dade.js">&lt;/script>-->
&lt;pre>&lt;code>import re
nickname = raw_input('Please input your nickname &amp;gt; ')
if not re.search(u'^[\u4e00-\u9fa5a-zA-Z0-9]+$', unicode(nickname,'utf8')):
print 'Your nickname format is error, please try again !'
else:
print 'Hello %s'% nickname
&lt;/code>&lt;/pre>&lt;p>如你所见，上面第5行的代码，就是匹配中文和字母，数字的正则表达式了。里面的&lt;code>\u4e00-\u9fa5&lt;/code> 就是中文汉字的&lt;code>unicode&lt;/code>编码所在位置。&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/2014-07-23%2023:21.png" alt="运行截图">&lt;/p>
&lt;hr>
&lt;h2 id="python字符串的编码问题">Python字符串的编码问题&lt;/h2>
&lt;p>还是以上面那段代码来说。注意看第5行的代码&lt;/p>
&lt;pre>&lt;code>if not re.search(u'^[\u4e00-\u9fa5a-zA-Z0-9]+$', unicode(nickname,'utf8')):
&lt;/code>&lt;/pre>&lt;p>其实这样的代码并不严谨。因为在Python 中默认是用&lt;code>unicode&lt;/code>编码来处理字符串的，因此做编码转换的时候，一般要以&lt;code>unicode&lt;/code>作为中间编码，也就是说：
其他编码格式的字符串---&amp;gt;解码(decode)---&amp;gt;&lt;code>unicode&lt;/code>---&amp;gt;编码(encode)---&amp;gt;所需要的编码格式。&lt;/p>
&lt;p>因此，处理字符串编码的问题的时候，先要明白需要转换的字符串的编码格式是什么。&lt;/p>
&lt;h3 id="代码中字符串的默认编码格式与代码文件本身的编码格式是一样的">代码中字符串的默认编码格式与代码文件本身的编码格式是一样的&lt;/h3>
&lt;p>比如： s = '涛' 在utf8的文件中，那么s就是utf8编码的，但是如果文件是gb2312编码，那么s就是gb2312编码的。此时，如果想要处理s这个字符串就要先decode成unicode编码了。&lt;/p>
&lt;p>不过如果是酱紫 s = u'涛'，那么s就是unicode编码了，这个时候s的编码方式不会被文件的编码所影响。&lt;/p>
&lt;h3 id="如果一个字符串已经是unicode编码了再解码就会出错">如果一个字符串已经是unicode编码了，再解码就会出错&lt;/h3>
&lt;p>因此严谨的方式就是先对字符串进行编码格式的判别，最简单的办法就是使用Python 默认提供的&lt;code>isinstance()&lt;/code> 方法.&lt;/p>
&lt;p>代码可以这样写
&lt;code>isinstance(s, unicode)&lt;/code> 如果不是unicode编码就会报错。&lt;/p>
&lt;p>窝今天在处理用户昵称的地方，忘记字符串会直接使用文件的编码了，所以对它进行了重新编码orz果断就报错了。。。以后还是要好好注意细节的说。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Regex/" term="Regex" label="Regex"/></entry><entry><title type="text">Bash 显示 Git 分支</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/07/17/Bash-%E6%98%BE%E7%A4%BA-Git-%E5%88%86%E6%94%AF/"/><id>https://moelove.info/2014/07/17/Bash-%E6%98%BE%E7%A4%BA-Git-%E5%88%86%E6%94%AF/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-07-17T21:54:33+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">虽然一直都在用git，但是并没有注意到还有这个方便的用法 于是乎赶快学习一下 ：-） 上网查了一下资料，都说Ubuntu下如何如何方便……</summary><content type="html">&lt;h3 id="虽然一直都在用git但是并没有注意到还有这个方便的用法">虽然一直都在用git，但是并没有注意到还有这个方便的用法&lt;/h3>
&lt;p>于是乎赶快学习一下 ：-）&lt;/p>
&lt;p>上网查了一下资料，都说Ubuntu下如何如何方便，其他的发行版需要先下载一个文件，然后添加source，再如何如何。。&lt;/p>
&lt;p>其实查再多都不如实践。以下是窝经过查资料加上对个人bash的配色后写出的配置文件，加入到 &lt;code>~/.bashrc&lt;/code> 中即可（对各个发行版通用的）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="k">function&lt;/span> git_branch &lt;span class="o">{&lt;/span>
&lt;span class="nv">ref&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>git symbolic-ref HEAD 2&amp;gt; /dev/null&lt;span class="k">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">ref&lt;/span>&lt;span class="p">#refs/heads/&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;) &amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nv">PS1&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;[\[\e[1;35m\]\u\[\e[1;32m\]\w\[\e[0m\]] \[\e[0m\]\[\e[1;36m\]\$(git_branch)\[\e[0;33m\]\$&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">
&lt;span class="k">function&lt;/span> git-branch-name &lt;span class="o">{&lt;/span>
git symbolic-ref HEAD 2&amp;gt;/dev/null &lt;span class="p">|&lt;/span> cut -d&lt;span class="s2">&amp;#34;/&amp;#34;&lt;/span> -f &lt;span class="m">3&lt;/span>
&lt;span class="c1">#git rev-parse --abbrev-ref HEAD&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">function&lt;/span> git-branch-prompt &lt;span class="o">{&lt;/span>
&lt;span class="nb">local&lt;/span> &lt;span class="nv">branch&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="sb">`&lt;/span>git-branch-name&lt;span class="sb">`&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="nv">$branch&lt;/span> &lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="nb">printf&lt;/span> &lt;span class="s2">&amp;#34; [%s]&amp;#34;&lt;/span> &lt;span class="nv">$branch&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="k">fi&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nv">PS1&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;\u@\h \[\033[0;36m\]\W\[\033[0m\]\[\033[0;32m\]\$(git-branch-prompt)\[\033[0m\] \$ &amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;!--&lt;script src="https://gist.github.com/tao12345666333/4a81478aa5db7c30e94e.js">&lt;/script>-->
&lt;p>按照惯例，上一张图
&lt;img src="http://moelove.qiniudn.com/bashrc2014-07%2022:57:55.png" alt="屏幕截图">&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Git/" term="Git" label="Git"/></entry><entry><title type="text">Grub2 rescue 修复</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/07/02/Grub2-rescue-%E4%BF%AE%E5%A4%8D/"/><id>https://moelove.info/2014/07/02/Grub2-rescue-%E4%BF%AE%E5%A4%8D/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-07-02T21:53:03+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">昨天下午的时候想要把分区处理一下，突然发现硬盘里面有一个未使用的102M的分区,很果断的把这些乱七八糟的分区都给干掉了。结果呢，……</summary><content type="html">&lt;p>昨天下午的时候想要把分区处理一下，突然发现硬盘里面有一个未使用的102M的分区,很果断的把这些乱七八糟的分区都给干掉了。结果呢，再次开机的时候就坑了（虽然酱紫的事情干过很多次了，这次做个记录吧）开机时提示如下：&lt;/p>
&lt;pre>&lt;code>GRUB loading..
error: unknown filesystem.
Entering rescue mode....
grub rescue&amp;gt;
&lt;/code>&lt;/pre>&lt;h3 id="grub-rescue-支持的命令">grub rescue 支持的命令&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>ls&lt;/strong> 查看硬盘的分区情况，如果你已知自己的grub的安装位置（比如我的在&lt;code>(hd0,msdos9)/boot/grub2&lt;/code>），那么就直接进行下一步。
如果不知道，那就ls每个分区，比如: &lt;code>ls (hd0,msdos2)/&lt;/code>,如果正确就会显示里面到内容，直到找到grub&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>这里一个很关键的地方就是在硬盘位置后应该加入&lt;code>/&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>set&lt;/strong> 直接输入的话， 可以看到root 和 prefix 的设置。这里需要把这两个选项改成我们已经找到的位置。&lt;/li>
&lt;/ul>
&lt;p>窝的设置如下&lt;/p>
&lt;pre>&lt;code>grub rescue&amp;gt; set
grub rescue&amp;gt; prefix=(hd0,msdos9)/boot/grub2
grub rescue&amp;gt; root=hd0,msdos9
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;strong>insmod&lt;/strong> 载入模块。这里区别是窝这次记录的关键。
grub2和grub的一个很重要的区别就是模块的位置。grub2的模块位置在&lt;code>/boot/grub2/i386-pc/normal.mod&lt;/code>
执行命令：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>grub rescue&amp;gt;insmod (hd0,msdos9)/boot/grub2/i386-pc/normal.mod
&lt;/code>&lt;/pre>&lt;p>执行成功之后，提示符会变成&lt;code>normal&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>normal&lt;/strong> 进入正常模式，直接输入命令即可&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>grub rescue&amp;gt;normal
&lt;/code>&lt;/pre>&lt;p>这个时候，就可以看到熟悉的引导界面了。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>grub2-install&lt;/strong>
进入系统后执行命令&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ sudo update-grub
$ sudo grub2-install /dev/sda
&lt;/code>&lt;/pre>&lt;p>如果不执行这样的命令的话，重启之后还会回到之前的界面orz&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/grub2/" term="grub2" label="grub2"/></entry><entry><title type="text">Linux中Sublime中文输入</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/06/19/Linux%E4%B8%ADSublime%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5/"/><id>https://moelove.info/2014/06/19/Linux%E4%B8%ADSublime%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-06-19T23:17:31+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这篇只是为了备忘所以把以前写的东西搬这边了 -.- 代码源于网络，感谢分享 这里的关键就是以下的代码和编译 /* sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.……</summary><content type="html">&lt;blockquote>
&lt;p>这篇只是为了备忘所以把以前写的东西搬这边了 -.-&lt;/p>
&lt;/blockquote>
&lt;h5 id="代码源于网络感谢分享">代码源于网络，感谢分享&lt;/h5>
&lt;!-- more -->
&lt;p>这里的关键就是以下的代码和编译&lt;/p>
&lt;!-- more -->
&lt;pre>&lt;code>/*
sublime-imfix.c
Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.
By Cjacker Huang &amp;lt;jianzhong.huang at i-soft.com.cn&amp;gt;
gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC
LD_PRELOAD=./libsublime-imfix.so sublime_text
*/
#include &amp;lt;gtk/gtk.h&amp;gt;
#include &amp;lt;gdk/gdkx.h&amp;gt;
typedef GdkSegment GdkRegionBox;
struct _GdkRegion
{
long size;
long numRects;
GdkRegionBox *rects;
GdkRegionBox extents;
};
GtkIMContext *local_context;
void
gdk_region_get_clipbox (const GdkRegion *region,
GdkRectangle *rectangle)
{
g_return_if_fail (region != NULL);
g_return_if_fail (rectangle != NULL);
rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
GdkRectangle rect;
rect.x = rectangle-&amp;gt;x;
rect.y = rectangle-&amp;gt;y;
rect.width = 0;
rect.height = rectangle-&amp;gt;height;
//The caret width is 2;
//Maybe sometimes we will make a mistake, but for most of the time, it should be the caret.
if(rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
gtk_im_context_set_cursor_location(local_context, rectangle);
}
}
//this is needed, for example, if you input something in file dialog and return back the edit area
//context will lost, so here we set it again.
static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)
{
XEvent *xev = (XEvent *)xevent;
if(xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {
GdkWindow * win = g_object_get_data(G_OBJECT(im_context),&amp;quot;window&amp;quot;);
if(GDK_IS_WINDOW(win))
gtk_im_context_set_client_window(im_context, win);
}
return GDK_FILTER_CONTINUE;
}
void gtk_im_context_set_client_window (GtkIMContext *context,
GdkWindow *window)
{
GtkIMContextClass *klass;
g_return_if_fail (GTK_IS_IM_CONTEXT (context));
klass = GTK_IM_CONTEXT_GET_CLASS (context);
if (klass-&amp;gt;set_client_window)
klass-&amp;gt;set_client_window (context, window);
if(!GDK_IS_WINDOW (window))
return;
g_object_set_data(G_OBJECT(context),&amp;quot;window&amp;quot;,window);
int width = gdk_window_get_width(window);
int height = gdk_window_get_height(window);
if(width != 0 &amp;amp;&amp;amp; height !=0) {
gtk_im_context_focus_in(context);
local_context = context;
}
gdk_window_add_filter (window, event_filter, context);
}
&lt;/code>&lt;/pre>&lt;p>这段代码是要写入 sublime_imfix.c中的，&lt;/p>
&lt;pre>&lt;code>cd /opt/sublime_text
sudo touch sublime_imfix.c
sudo vi sublime_imfix.c
#以下要安装的是必须的，否则编译会报错的
sudo apt-get install build-essential libgtk2.0-dev
sudo gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC
&lt;/code>&lt;/pre></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Sublime-Text/" term="Sublime Text" label="Sublime Text"/></entry><entry><title type="text">upyun-for-pelican</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/05/16/upyun-for-pelican/"/><id>https://moelove.info/2014/05/16/upyun-for-pelican/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-05-16T21:51:41+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这几天写了一个插件，方便把pelican生成静态博客部署到又拍云上。 整体思路就是： 先格式化路径，以/为根目录 def formatPath(path): path = path.replace(os.sep, '/') return path 定义……</summary><content type="html">&lt;p>这几天写了一个插件，方便把pelican生成静态博客部署到又拍云上。
整体思路就是：&lt;/p>
&lt;ul>
&lt;li>先格式化路径，以/为根目录&lt;/li>
&lt;/ul>
&lt;pre>&lt;code> def formatPath(path):
path = path.replace(os.sep, '/')
return path
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>定义两个列表来存储文件和目录&lt;/li>
&lt;/ul>
&lt;p>之后就是验证用户，以及bucketname 之类的了。&lt;/p>
&lt;h3 id="简介">简介&lt;/h3>
&lt;p>&lt;a href="https://github.com/getpelican/pelican">pelican&lt;/a> 是一款基于python的静态博客生成工具，本程序可以方便的把生成的静态博客部署到&lt;a href="https://www.upyun.com/index.html">又拍云&lt;/a>上。演示地址：&lt;a href="http://pelican-for-upyun.b0.upaiyun.com/">upyun-for-pelican &lt;/a>&lt;/p>
&lt;h3 id="生成网站">生成网站&lt;/h3>
&lt;pre>&lt;code> make html
make serve (进行本地预览)
&lt;/code>&lt;/pre>&lt;h3 id="说明">说明&lt;/h3>
&lt;ul>
&lt;li>程序使用了又拍云的&lt;a href="https://github.com/upyun/python-sdk">官方SDK&lt;/a> 需要先安装 upyun&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>pip install upyun
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>可以自定义要上传的文件目录。在最下方的&lt;code>local_dir&lt;/code> 中指定即可。Pelican默认的上传目录是 output 目录&lt;/li>
&lt;/ul>
&lt;h3 id="使用">使用&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>可以在 &lt;strong>pelicanconf.py&lt;/strong> 文件中直接设置 &lt;code>BUCKETNAME, USERNAME, PASSWORD&lt;/code> 参数（这些参数的使用大写命名格式也是为了符合&lt;em>pelicanconf.py&lt;/em>中的习惯），也可以直接在 &lt;code>upyun-for-pelican.py&lt;/code>文件的最下方直接设置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行&lt;/p>
&lt;pre>&lt;code>python upyun-for-pelican.py
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>程序在 &lt;code>Python 2.7&lt;/code> 环境下测试通过。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="其他说明">其他说明&lt;/h4>
&lt;ul>
&lt;li>程序执行开始会有上传确认提示，输入&lt;code>Y / y&lt;/code> 都可以继续上传。&lt;/li>
&lt;li>可以使用项目中的&lt;code>pelicanconf.py&lt;/code>作为个人站点的配置文件。&lt;/li>
&lt;/ul>
&lt;h4 id="未完待续">未完待续...&lt;/h4></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Pelican/" term="Pelican" label="Pelican"/><category scheme="https://moelove.info/tags/upyun/" term="upyun" label="upyun"/></entry><entry><title type="text">使用Pelican搭建Blog</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/05/07/%E4%BD%BF%E7%94%A8Pelican%E6%90%AD%E5%BB%BABlog/"/><id>https://moelove.info/2014/05/07/%E4%BD%BF%E7%94%A8Pelican%E6%90%AD%E5%BB%BABlog/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-05-07T21:48:59+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">安装配置Pelican 使用环境： 系统 : Linux X86_64 Pelican : 3.3.0 首先说一下安装： 网上有不少建议说使用虚拟环境 virtualenv，以免污染本地的……</summary><content type="html">&lt;h2 id="安装配置pelican">安装配置Pelican&lt;/h2>
&lt;hr>
&lt;h5 id="使用环境">使用环境：&lt;/h5>
&lt;pre>&lt;code> 系统 : Linux X86_64
Pelican : 3.3.0
&lt;/code>&lt;/pre>&lt;p>首先说一下安装： 网上有不少建议说使用虚拟环境 &lt;a href="https://virtualenv.pypa.io/en/latest/virtualenv.html">virtualenv&lt;/a>，以免污染本地的环境。不过，如果不是去更改&lt;code>Python&lt;/code>的全局设置的话，也不至于影响本地环境的。我是直接安装的。根据 Pelican 官方的文档，我是使用 &lt;code>pip&lt;/code> 安装的，不过&lt;code>pip&lt;/code>又是依赖于&lt;code>distribute&lt;/code> 安装的。所以，我使用的命令如下：&lt;/p>
&lt;pre>&lt;code> curl -O http://python-distribute.org/distribute_setup.py
sudo python distribute_setup.py
curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py
sudo python get-pip.py
sudo pip install pelican
&lt;/code>&lt;/pre>&lt;p>还有，如果要用 &lt;a href="http://zh.wikipedia.org/zh-cn/Markdown">&lt;code>Markdown&lt;/code>&lt;/a>来写文章，也需要执行如下命令：&lt;/p>
&lt;pre>&lt;code> pip install markdown
&lt;/code>&lt;/pre>&lt;p>新建一个目录，用来存放你的博客文件（我直接建立了&amp;quot;blog&amp;quot;文件夹）&lt;/p>
&lt;pre>&lt;code> mkdir blog
cd blog
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="新建博客">新建博客：&lt;/h2>
&lt;p>使用如下命令：&lt;/p>
&lt;pre>&lt;code> pelican-quickstart
&lt;/code>&lt;/pre>&lt;p>按照提示一步步即可完成新建， 这些配置之后可以在&lt;code>pelicanconf.py&lt;/code>这个文件中修改&lt;/p>
&lt;pre>&lt;code> Where do you want to create your new web site?[.] (你想在哪里创建你的网站，默认为当前目录)
What will be the title of this web site?(网站的标题是什么)
Who will be the author of this web site?(网站的作者是谁)
What will be the default language of this web site? [en] (网站的默认语言是),这里我们写'zh'中文
Do you want to specify a URL prefix? e.g., http://example.com(Y/n) (是否指定域名),Y
What is your URL prefix?(see above example; no trailing slash)(输入域名，不能包含反斜杠'/'),http://moelove.info
Do you want to enable article pagination?(是否启用文章分页)
Do you want to generate a Makefile to easily manage your website?(是否生成一个Makefile来管理网站(这里我建议生成，因为会比较方便的))
Do you want an auto-reload &amp;amp; simpleHTTP script to assist with theme and site development?(是否想有一个自动加载的小型http脚本用来修改主题和站点开发)
Do you want to upload your website using FTP?
Do you want to upload your website using SSH?
Do you want to upload your website using Dropbox?
Do you want to upload your website using S3?
&lt;/code>&lt;/pre>&lt;hr>
&lt;h2 id="新建博文">新建博文：&lt;/h2>
&lt;p>这个时候就可以写博客了。具体的写作方式可以参考 &lt;a href="http://docs.getpelican.com/en/latest/internals.html">Pelican的官方文档&lt;/a>
我以&lt;a href="http://daringfireball.net/projects/markdown/syntax">Markdown&lt;/a> 为例说明一下。&lt;/p>
&lt;p>在content 目录，新建一个 &lt;code>hello.md&lt;/code>文件&lt;/p>
&lt;pre>&lt;code> vim content/htllo.md
Date: 2014-04-18 #日期
Title: HelloWorld #标题
Tags: hello #标签
Category: test #分类
Hello World !
&lt;/code>&lt;/pre>&lt;p>之后，执行&lt;code>make html&lt;/code> 或者 &lt;code>pelican content&lt;/code>即可将 md文件转换成html文件。执行 &lt;code>make serve&lt;/code> 即可打开本地浏览器，&lt;a href="http://127.0.0.1:8000/">预览&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>现在一个使用默认主题的博客就建立好了。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="后续">后续&lt;/h2>
&lt;h4 id="接下来说一下修改主题和使用插件的方法">接下来说一下修改主题和使用插件的方法&lt;/h4>
&lt;p>Pelican 默认提供了很多主题可以 github 上下载，当然也可以自己制作。&lt;/p>
&lt;pre>&lt;code> git clone git://github.com/getpelican/pelican-themes.git
&lt;/code>&lt;/pre>&lt;p>在里面找到你喜欢的主题，使用&lt;/p>
&lt;pre>&lt;code> sudo pelican-theme -i /path/to/your/themes
&lt;/code>&lt;/pre>&lt;p>命令进行主题的安装。&lt;/p>
&lt;p>随后可以使用&lt;code>pelican-themes -l -v&lt;/code> 查看已经安装好的主题。&lt;/p>
&lt;pre>&lt;code> /usr/lib/python2.7/site-packages/pelican/themes/simple
/usr/lib/python2.7/site-packages/pelican/themes/notmyidea
/usr/lib/python2.7/site-packages/pelican/themes/bootstrap2
&lt;/code>&lt;/pre>&lt;p>想要开始使用主题的话， 只需要在&lt;code> pelicanconf.py&lt;/code>文件中添加 &lt;code>THEME&lt;/code>项为主题名,例如：&lt;/p>
&lt;pre>&lt;code> THEME = &amp;quot;bootstrap2&amp;quot;
&lt;/code>&lt;/pre>&lt;p>重新 &lt;em>make html&lt;/em> 即可, 这时候声成的页面就是所要使用的主题了。&lt;/p>
&lt;h4 id="为博客使用插件">为博客使用插件&lt;/h4>
&lt;p>Pelican 也提供了不少的插件来方便使用， 可以从github 上面下载到博客所在目录：&lt;/p>
&lt;pre>&lt;code> git clone git://github.com/getpelican/pelican-plugins.git
&lt;/code>&lt;/pre>&lt;p>现在博客目录就新添了一个 pelican-plugins 目录，接下来在 pelicanconf.py 里面添加配置即可(里面是我最开始使用的三个插件):&lt;/p>
&lt;pre>&lt;code> PLUGIN_PATH = u&amp;quot;pelican-plugins&amp;quot;
PLUGINS = [&amp;quot;sitemap&amp;quot;, &amp;quot;summary&amp;quot;, &amp;quot;neighbors&amp;quot;]
&lt;/code>&lt;/pre>&lt;p>再添加 sitemap 的配置&lt;/p>
&lt;pre>&lt;code> SITEMAP = {
'format': 'xml',
'priorities': {
'articles': 0.5,
'indexes': 0.5,
'pages': 0.5
},
'changefreqs': {
'articles': 'weekly',
'indexes': 'daily',
'pages': 'monthly'
}
}
&lt;/code>&lt;/pre>&lt;p>然后执行 &lt;code>*make html*&lt;/code> 即可&lt;/p>
&lt;h4 id="添加多说评论">添加多说评论&lt;/h4>
&lt;p>一开始搭建静态博客的时候，使用的&lt;a href="http://disqus.com/">disqus&lt;/a> 并且Pelican 的主题中默认提供了支持，只要在 pelicanconf.py 的里面加入 disqus 的short_name 即可开始使用了。不过，身在天朝，还是尽量本地化一些吧，使用&lt;a href="http://duoshuo.com/">多说&lt;/a>评论插件。
在&lt;a href="http://duoshuo.com/">多说&lt;/a>注册一个帐号，&lt;a href="http://duoshuo.com/create-site/">添加一个站点&lt;/a>，获取自己的 &lt;em>short_name&lt;/em> ，点击工具一栏--&amp;gt;获取代码&lt;/p>
&lt;pre>&lt;code>&amp;lt;!-- 多说评论框 start --&amp;gt;
&amp;lt;div class=&amp;quot;ds-thread&amp;quot; data-thread-key=&amp;quot;请将此处替换成文章在你的站点中的ID&amp;quot; data-title=&amp;quot;请替换成文章的标题&amp;quot; data-url=&amp;quot;请替换成文章的网址&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- 多说评论框 end --&amp;gt;
&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
var duoshuoQuery = {short_name:&amp;quot;替换成你自己的&amp;quot;};
(function() {
var ds = document.createElement('script');
ds.type = 'text/javascript';ds.async = true;
ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
ds.charset = 'UTF-8';
(document.getElementsByTagName('head')[0]
|| document.getElementsByTagName('body')[0]).appendChild(ds);
})();
&amp;lt;/script&amp;gt;
&amp;lt;!-- 多说公共JS代码 end --&amp;gt;
&lt;/code>&lt;/pre>&lt;p>把这段代码放在你想要显示评论的地方就可以了。建议直接修改放在article.html模板里面。&lt;/p>
&lt;h4 id="添加其他功能">添加其他功能&lt;/h4>
&lt;p>这里我还加入了&lt;a href="http://share.baidu.com/code">百度分享&lt;/a>的功能。直接定制个人想要的代码， 放在你需要出现分享按钮的地方即可，我放在了文章的下面。&lt;/p>
&lt;pre>&lt;code>&amp;lt;div class=&amp;quot;bdsharebuttonbox&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_more&amp;quot; data-cmd=&amp;quot;more&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_qzone&amp;quot; data-cmd=&amp;quot;qzone&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_tsina&amp;quot; data-cmd=&amp;quot;tsina&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_tqq&amp;quot; data-cmd=&amp;quot;tqq&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_renren&amp;quot; data-cmd=&amp;quot;renren&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;bds_weixin&amp;quot; data-cmd=&amp;quot;weixin&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;window._bd_share_config={&amp;quot;common&amp;quot;:{&amp;quot;bdSnsKey&amp;quot;:{},&amp;quot;bdText&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;bdMini&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;bdPic&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;bdStyle&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;bdSize&amp;quot;:&amp;quot;16&amp;quot;},&amp;quot;share&amp;quot;:{},&amp;quot;image&amp;quot;:{&amp;quot;viewList&amp;quot;:[&amp;quot;qzone&amp;quot;,&amp;quot;tsina&amp;quot;,&amp;quot;tqq&amp;quot;,&amp;quot;renren&amp;quot;,&amp;quot;weixin&amp;quot;],&amp;quot;viewText&amp;quot;:&amp;quot;分享到：&amp;quot;,&amp;quot;viewSize&amp;quot;:&amp;quot;16&amp;quot;},&amp;quot;selectShare&amp;quot;:{&amp;quot;bdContainerClass&amp;quot;:null,&amp;quot;bdSelectMiniList&amp;quot;:[&amp;quot;qzone&amp;quot;,&amp;quot;tsina&amp;quot;,&amp;quot;tqq&amp;quot;,&amp;quot;renren&amp;quot;,&amp;quot;weixin&amp;quot;]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>&lt;p>还有加入了 &lt;a href="http://www.google.com/analytics/">Google Analytics&lt;/a> 谷歌站内搜索 以及七牛提供的云存储 等。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Pelican/" term="Pelican" label="Pelican"/><category scheme="https://moelove.info/tags/Blog/" term="Blog" label="Blog"/><category scheme="https://moelove.info/tags/Web/" term="Web" label="Web"/></entry><entry><title type="text">Hello World !</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/04/18/Hello-World/"/><id>https://moelove.info/2014/04/18/Hello-World/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-04-18T21:46:06+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">几乎所有的程序猿的第一个演示程序都是Hello World .那我也就一样咯， 也写一个同样的吧。 其实我的博客从很早前就已经开始在写了， 换了很……</summary><content type="html">&lt;blockquote>
&lt;p>几乎所有的程序猿的第一个演示程序都是Hello World .那我也就一样咯， 也写一个同样的吧。
其实我的博客从很早前就已经开始在写了， 换了很多的平台：&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>从腾讯空间--&amp;gt; 百度空间--&amp;gt; 新浪博客--&amp;gt; 自己搭建的Wordpress博客--&amp;gt; 点点（点点我其实是用来碎碎念的）
--&amp;gt; 博客园（个人感觉体验不是很好的说）--&amp;gt; 静态博客
&lt;/code>&lt;/pre>
&lt;p>选择了这么多，我最后决定还是使用 &lt;strong>静态博客&lt;/strong> 来做个人博客。&lt;/p>
&lt;blockquote>
&lt;p>原因有以下几个：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>使用其他平台提供的博客不是很爽， 可个性化的方面不是很多， 点点相对来说做的还是很不错的
不仅提供个性化定制而且还支持绑定个人域名之类的。但是其他网站就不是那么人性化了。&lt;/li>
&lt;li>写博客总是需要贴代码的，但是除了WP外，其他的我不是很满意。&lt;/li>
&lt;li>用静态博客方便备份，而且是本地编辑就可以了，在线编辑的，感觉会被束缚很多。&lt;/li>
&lt;li>本人属于折腾党，喜欢可以个人定制的， 直到符合个人满意的程度为止。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>接下来说说这次博客的安装：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>选择&lt;strong>Pelica&lt;/strong>是因为我对Python 比较熟悉，之前尝试过用Jekyll 和 Octopress 搭建，都比较方便
尤其是Jekyll 用户很多，文档什么的都很多了。只不过我更喜欢Python 多一些（虽然我有用ROR开发过WEB应用程序）
因为如果有什么需要的话，我也可以自己来开发插件或者自己再尝试做一个系统。&lt;/li>
&lt;li>Pelican 相对来说配置也很方便， 很简单， 虽然用户不是很多，但是基本上的问题也都可以解决的&lt;/li>
&lt;li>&lt;a href="https://github.com/getpelican/pelican">Pelican&lt;/a> 支持restructuredText和Markdown写文章，配置灵活，扩展性强。我用的是3.3.0。&lt;/li>
&lt;/ol></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Pelican/" term="Pelican" label="Pelican"/><category scheme="https://moelove.info/tags/Blog/" term="Blog" label="Blog"/></entry><entry><title type="text">Linux 安装Android 驱动</title><link rel="alternate" type="text/html" href="https://moelove.info/2014/03/10/Linux-%E5%AE%89%E8%A3%85Android-%E9%A9%B1%E5%8A%A8/"/><id>https://moelove.info/2014/03/10/Linux-%E5%AE%89%E8%A3%85Android-%E9%A9%B1%E5%8A%A8/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2014-03-10T21:44:06+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在Linux下非常适合做一些对Rom 的定制以及其他的一些操作，甚至是自己制作Rom 或者从源码编译Rom 也是OK的。 不过最开始的应……</summary><content type="html">&lt;p>在Linux下非常适合做一些对Rom 的定制以及其他的一些操作，甚至是自己制作Rom 或者从源码编译Rom 也是OK的。&lt;/p>
&lt;p>不过最开始的应该就是搭建开发环境了，我先从装驱动开始说（只是做个笔记而已）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用数据线连接手机，打开&lt;strong>adb调试模式&lt;/strong>。(在Linux上搭建开发环境， 以及adb 命令之类的， 就自行搜索吧，如果哪天更新了 我会附上链接的)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入&lt;code>adb devices&lt;/code> 查看设备
如果有机型的话就说明是已经有驱动了
如果没有显示的话， 就是说明需要进行驱动安装了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个时候， &lt;code>lsusb&lt;/code> 查看， 会看到下面这样的信息&lt;/p>
&lt;pre>&lt;code>[tao@localhost ~]$ lsusb
Bus 001 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 002: ID 8087:0020 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 006: ID 12d1:2229 Huawei Technologies Co., Ltd.
Bus 002 Device 004: ID 04f2:b1c1 Chicony Electronics Co., Ltd
Bus 002 Device 005: ID 062a:4101 Creative Labs
&lt;/code>&lt;/pre>&lt;p>可以在&lt;a href="https://developer.android.com/tools/device.html">Android Developer&lt;/a> ， 看到对其他的产品的支持，窝的手机是Huawei的所以就是要输入对应的ID ：&lt;strong>12d1&lt;/strong> 然后，再新建一个文件，&lt;/p>
&lt;pre>&lt;code>vim /etc/udev/rules.d/50-android.rules
写入内容：
SUBSYSTEM==&amp;quot;usb&amp;quot;, ATTR{idVendor}==&amp;quot;12d1&amp;quot;, ATTR{idProduct}==&amp;quot;2229&amp;quot;, MODE=&amp;quot;0600&amp;quot;, OWNER=&amp;quot;tao&amp;quot;,GROUP =&amp;quot;plugdev&amp;quot;
&lt;/code>&lt;/pre>&lt;p>50是说是手机， 其他的命名也有各自的解释&lt;/p>
&lt;p>然后我们就可以新建这个文件， 修改权限&lt;/p>
&lt;pre>&lt;code>chmod a+x /etc/udev/rules.d/50-android.rules
&lt;/code>&lt;/pre>&lt;p>这个时候 就成功了，我们使用&lt;code>adb devices&lt;/code> 命令就可以看到我们的设备了， 使用&lt;code>adb shell&lt;/code> 就可以对手机进行操作了&lt;/p>
&lt;p>当然我在这里进行了一次重启，就可以使用了
(话说这篇文章虽然一直在云端编辑，但是一直木有结束，现在才发出来。。一定要提高效率！)&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Android/" term="Android" label="Android"/></entry><entry><title type="text">fedora 18 Kernel driver not installed (rc=-1908)处理办法</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/12/21/fedora-18-Kernel-driver-not-installed-rc-1908%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/><id>https://moelove.info/2013/12/21/fedora-18-Kernel-driver-not-installed-rc-1908%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-12-21T21:42:18+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">fedora 18 升级内核之后 使用VirtualBox 可以正常打开软件,但是不能启动虚拟机系统.提示信息如下: Kernel driver not installed (rc=-1908) 经过一系列的看文档还有……</summary><content type="html">&lt;h4 id="fedora-18-升级内核之后-使用virtualbox-可以正常打开软件但是不能启动虚拟机系统提示信息如下">fedora 18 升级内核之后 使用&lt;em>VirtualBox&lt;/em> 可以正常打开软件,但是不能启动虚拟机系统.提示信息如下:&lt;/h4>
&lt;pre>&lt;code>Kernel driver not installed (rc=-1908)
&lt;/code>&lt;/pre>&lt;p>经过一系列的看文档还有google 之后,很多地方写着这个问题的处理方法是&lt;/p>
&lt;ul>
&lt;li>第一种&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo /etc/init.d/vboxdrv setup
&lt;/code>&lt;/pre>&lt;p>经过实验,对feora 18 不可行&lt;/p>
&lt;ul>
&lt;li>第二种&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo apt-get install dkms
sudo /etc/init.d/vboxdrv setup
&lt;/code>&lt;/pre>&lt;p>但是情况继续&lt;/p>
&lt;ul>
&lt;li>第三种&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo aptitude update
sudo aptitude install dkms
sudo /etc/init.d/vboxdrv setup
&lt;/code>&lt;/pre>&lt;h3 id="最后正确的解决方法应该是酱紫的">最后正确的解决方法应该是酱紫的&lt;/h3>
&lt;ul>
&lt;li>先看看系统的内核&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>uname -r
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>找对应的包&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo yum search kmod-VirtualBox
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>然后安装和你系统内核对应的包&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo yum install kmod-VirtualBox-XXXX
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>运行&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>/etc/sysconfig/modules/VirtualBox.modules
&lt;/code>&lt;/pre>&lt;p>一切OK了&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">Ruby on Rails 环境</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/09/21/Ruby-on-Rails-%E7%8E%AF%E5%A2%83/"/><id>https://moelove.info/2013/09/21/Ruby-on-Rails-%E7%8E%AF%E5%A2%83/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-09-21T21:39:55+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">就这次的尝试写一下自己的记录 安装ruby 和 ruby-devel(安装ruby-devel是因为后续的工作如果没有ruby-dev……</summary><content type="html">&lt;h4 id="就这次的尝试写一下自己的记录">就这次的尝试写一下自己的记录&lt;/h4>
&lt;p>安装ruby 和 ruby-devel(安装ruby-devel是因为后续的工作如果没有ruby-devel的话，会报错)&lt;/p>
&lt;pre>&lt;code>sudo yum install ruby ruby-devel rubygems sqlite -y
&lt;/code>&lt;/pre>&lt;p>需要的环境有了，那么就可以开始正式的工作了&lt;/p>
&lt;pre>&lt;code>sudo gem install rails
&lt;/code>&lt;/pre>&lt;p>找到一个合适的目录来放自己的代码.然后执行&lt;/p>
&lt;pre>&lt;code>$ rails new mysite
// 这个是建立一个叫mysite 的rails程式 ，在当前目录下面
$ cd mysite
//进入这个目录
$ bundle install
//因为在做测试 所以 也没有必要安装其他的gem
&lt;/code>&lt;/pre>&lt;p>接下来看看它的数据库 配置文件是 &lt;code>config/database.yml&lt;/code> 默认的支持是是&lt;strong>SQLite3&lt;/strong>(当然也支持其他的比如mysql之类的)它有三种模式:&lt;/p>
&lt;ul>
&lt;li>development environment开发模式，用在你的开发的时候&lt;/li>
&lt;li>test environment测试模式，用在自动测试时&lt;/li>
&lt;li>production environment正式上线模式，用在实际的上线运作环境&lt;/li>
&lt;/ul>
&lt;p>SQLite配置大致是这样的:&lt;/p>
&lt;pre>&lt;code>development:
adapter: sqlite3
database: db/development.sqlite3
pool: 5
timeout: 5000
&lt;/code>&lt;/pre>&lt;p>接下来建立自己的数据库&lt;/p>
&lt;pre>&lt;code>rake db:create
&lt;/code>&lt;/pre>&lt;p>&lt;strong>在这里我遇到一个错误&lt;/strong>&lt;/p>
&lt;pre>&lt;code>rake aborted!
Could not find a JavaScript runtime. See https://github.com/sstephenson/execjs for a list of available runtimes.
(See full trace by running task with --trace)
&lt;/code>&lt;/pre>&lt;p>我的解决办法是&lt;/p>
&lt;pre>&lt;code>sudo yum install nodejs
&lt;/code>&lt;/pre>&lt;p>然后启动服务器&lt;/p>
&lt;pre>&lt;code>rails server
&lt;/code>&lt;/pre>&lt;p>要看结果就打开&lt;a href="http://localhost:3000">http://localhost:3000&lt;/a>就会看见rails 的默认首页了&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Ruby/" term="Ruby" label="Ruby"/><category scheme="https://moelove.info/tags/Rails/" term="Rails" label="Rails"/></entry><entry><title type="text">利用百度BAE搭建discuz论坛</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/09/06/%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6BAE%E6%90%AD%E5%BB%BAdiscuz%E8%AE%BA%E5%9D%9B/"/><id>https://moelove.info/2013/09/06/%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6BAE%E6%90%AD%E5%BB%BAdiscuz%E8%AE%BA%E5%9D%9B/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-09-06T21:38:39+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近尝试了利用百度云应用管理BAE搭建discuz论坛， 这里做简要记录 创建应用 在 百度开发者中心 创建一个应用，选择WEB应用下的P……</summary><content type="html">&lt;p>最近尝试了利用百度云应用管理&lt;em>BAE&lt;/em>搭建discuz论坛， 这里做简要记录&lt;/p>
&lt;h3 id="创建应用">创建应用&lt;/h3>
&lt;p>在 &lt;a href="http://developer.baidu.com/">百度开发者中心&lt;/a> 创建一个应用，选择WEB应用下的PC &lt;strong>Iframe应用&lt;/strong>&lt;/p>
&lt;h3 id="托管设置">托管设置&lt;/h3>
&lt;p>之后进行托管设置， 确定域名XXX.duapp.com&lt;/p>
&lt;p>创建一个版本，并上传PHP代码包&lt;/p>
&lt;p>(BAE有些函数规则发生改变，所以需要使用为BAE环境做过调整的&lt;a href="http://pan.baidu.com/s/1hqsYVre">discuz for BAE&lt;/a> 版本)&lt;/p>
&lt;p>需要注意的是在上传的代码包里面的 &lt;em>bcs/config.php&lt;/em> 中的内容应该修改为&lt;/p>
&lt;pre>&lt;code>&amp;lt;?php
define('BAIDU_BCS_BUCKET', '创建的bucket名称');
define('BAIDU_BCS_AK', getenv('HTTP_BAE_ENV_AK'));
define('BAIDU_BCS_SK', getenv('HTTP_BAE_ENV_SK'));
?&amp;gt;
&lt;/code>&lt;/pre>&lt;p>同时在数据库中设置为UTF-8,&lt;/p>
&lt;p>注意开启缓存 cache 最少30M(亲测50M完全是OK的)&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>之后上线应用，访问&lt;a href="http://%E4%BD%A0%E7%9A%84%E5%9F%9F%E5%90%8D.duapp.com/install/index.php">http://你的域名.duapp.com/install/index.php&lt;/a>&lt;/p>
&lt;p>即可完成安装(需要用到创建的数据库名称)&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/BAE/" term="BAE" label="BAE"/></entry><entry><title type="text">fedora下安装sublime text 2的方法</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/08/30/fedora%E4%B8%8B%E5%AE%89%E8%A3%85sublime-text-2%E7%9A%84%E6%96%B9%E6%B3%95/"/><id>https://moelove.info/2013/08/30/fedora%E4%B8%8B%E5%AE%89%E8%A3%85sublime-text-2%E7%9A%84%E6%96%B9%E6%B3%95/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-08-30T21:36:09+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">首先去官网下载最新的压缩包 把文件解压到$HOME/.sublime_text_2文件夹中： tar -xf (sublime压缩包的文件名).……</summary><content type="html">&lt;h3 id="首先去官网httpwwwsublimetextcom下载最新的压缩包">首先去&lt;a href="http://www.sublimetext.com/">官网&lt;/a>下载最新的压缩包&lt;/h3>
&lt;ul>
&lt;li>把文件解压到$HOME/.sublime_text_2文件夹中：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>tar -xf (sublime压缩包的文件名).tar.bz2
sudo mv (解压后的文件夹) tools/Sublime_Text_2
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在/usr/bin目录下面创建一个链接&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>vim sublime
&lt;/code>&lt;/pre>&lt;p>在文件中写入这些代码：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
export SUBLIME_HOME=&amp;quot;~/tools/Sublime_Text_2&amp;quot;
$SUBLIME_HOME/sublime_text $*
&lt;/code>&lt;/pre>&lt;p>修改文件权限并且移动&lt;/p>
&lt;pre>&lt;code>chmod 555 sublime &amp;amp;&amp;amp; mv sublime /usr/bin/sublime
&lt;/code>&lt;/pre>&lt;p>这样就可以在终端中直接执行sublime了&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/Sublime-Text/" term="Sublime Text" label="Sublime Text"/></entry><entry><title type="text">Vim7.3 for Windows 配置</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/08/10/Vim7.3-for-Windows-%E9%85%8D%E7%BD%AE/"/><id>https://moelove.info/2013/08/10/Vim7.3-for-Windows-%E9%85%8D%E7%BD%AE/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-08-10T21:34:17+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">一直是在Linux下用Vim，但是有些时候在别人电脑或者机房又不得不用windows来写代码，所以也就下载了vim for window……</summary><content type="html">&lt;blockquote>
&lt;p>一直是在Linux下用Vim，但是有些时候在别人电脑或者机房又不得不用windows来写代码，所以也就下载了vim for windows。但是今天打开一个朋友写的网页的时候，出现了乱码的问题，所以把解决方法记录一下，也就是和在linux下面一样，修改配置文件就可以了。接下来进入正题。&lt;/p>
&lt;/blockquote>
&lt;h3 id="选项意义概述">选项意义概述&lt;/h3>
&lt;p>Vim有四个跟字符编码方式有关的选项，分别是:&lt;code>encoding&lt;/code>、&lt;code>fileencoding&lt;/code>、&lt;code>fileencodings&lt;/code>、&lt;code>termencoding&lt;/code> (这些选项可能的取值可以参考 Vim 的帮助 :&lt;em>help encoding-names&lt;/em>)，它们各自的意义:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>encoding&lt;/strong>: Vim 内部使用的字符编码方式，包括Vim的buffer(缓冲区)、菜单文本、消息文本等。用户手册上建议只在*.vimrc*中改变它的值，事实上似乎也只有在*.vimrc* 中改变它的值才有意义。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>fileencoding&lt;/strong>: Vim 中当前编辑的文件的字符编码方式，Vim 保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>fileencodings&lt;/strong>: Vim 启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。因此最好将 Unicode 编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1 放到最后面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>termencoding&lt;/strong>: Vim 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的 Vim 而言就是Windows控制台的代码页，并且通常我们不需要改变它。（我尝试改变了它为UTF-8，但对于console模式的编码方式却没有改变）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="配置说明">配置说明&lt;/h3>
&lt;p>由于 Unicode 能包含几乎所有的语言的字符，Unicode的UTF-8编码方式又是非常具有性价比和通用的编码方式，所以把&lt;em>encoding&lt;/em>的值设置为&lt;strong>utf-8&lt;/strong>。同时将encoding设置为utf-8时，Vim自动探测文件的编码方式会更准确。在中文Windows里编辑的文件，为了兼顾与其他软件的兼容性，文件编码还是设置为GB2312/GBK比较合适，因此&lt;em>fileencoding&lt;/em>建议设置为&lt;strong>chinese&lt;/strong> (&lt;em>chinese是个别名，在Unix里表示&lt;code>gb2312&lt;/code>，在Windows里表示&lt;code>cp936&lt;/code>，也就是GBK的代码页&lt;/em>)。&lt;/p>
&lt;h3 id="具体配置">具体配置&lt;/h3>
&lt;p>最后对于文件中显示乱码、菜单乱码、右键菜单乱码以及Conlse输出乱码问题的解决方案，修改Vim编辑器所对应的配置文件**_vimrc**（这个文件在你安装vim 的那个目录下），添加如下配置：&lt;/p>
&lt;ul>
&lt;li>关于常规设置：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>&amp;quot;总是显示标签。0：不显示；1：多于1个时显示&amp;quot;
set showtabline=2
&amp;quot;开启行号&amp;quot;
set number
&amp;quot;开启自动缩进, 7.3以上版本已自动开启&amp;quot;
set autoindent
&amp;quot;缩进宽度为4个字符&amp;quot;
set shiftwidth=4
&amp;quot;tab宽度为4个字符&amp;quot;
set tabstop=4
&amp;quot;编辑时将所有tab替换为空格&amp;quot;
set et
&amp;quot;按一次Backspace就删除4个空格&amp;quot;
set smarttab
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>关于色彩和字体之类的设置：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>&amp;quot;配色方案（这里可以自选，我比较喜欢这个配色方案）&amp;quot;
colo desert
&amp;quot;开启语法高亮, 7.3版本已自动开启&amp;quot;
syntax on
&amp;quot;字体设置&amp;quot;
set guifont=courier_new:h10
&amp;quot;关闭兼容模式&amp;quot;
set nocompatible
&amp;quot;以下三行模拟Windows操作，如Ctrl-C复制&amp;quot;
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin
&amp;quot;不生成备份文件，下面这句要写在behave mswin下面，否则还是会生成备份，情况不明&amp;quot;
set nobackup
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>关于编码部分的设置：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>&amp;quot;GVIM内部编码&amp;quot;
set encoding=utf-8
&amp;quot;当前编辑的文件编码&amp;quot;
set fileencoding=utf-8
&amp;quot;GVIM支持打开的文件编码（这里也是参考帮助手册来的）&amp;quot;
set fileencodings=utf-8,gbk,gb2312,big5,latin1
&amp;quot;解决菜单及右键菜单乱码&amp;quot;
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim
&amp;quot;解决consle输出乱码&amp;quot;
language messages zh_CN.utf-8
&amp;quot;防止特殊符号无法正常显示，如五角星等1&amp;quot;
set ambiwidth=double
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>主体设置部分：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>set diffexpr=MyDiff()
function MyDiff()
let opt = '-a --binary '
if &amp;amp;diffopt =~ 'icase' | let opt = opt . '-i ' | endif
if &amp;amp;diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
let arg1 = v:fname_in
if arg1 =~ ' ' | let arg1 = '&amp;quot;' . arg1 . '&amp;quot;' | endif
let arg2 = v:fname_new
if arg2 =~ ' ' | let arg2 = '&amp;quot;' . arg2 . '&amp;quot;' | endif
let arg3 = v:fname_out
if arg3 =~ ' ' | let arg3 = '&amp;quot;' . arg3 . '&amp;quot;' | endif
let eq = ''
if $VIMRUNTIME =~ ' '
if &amp;amp;sh =~ '\&amp;lt;cmd'
let cmd = '&amp;quot;&amp;quot;' . $VIMRUNTIME . '\diff&amp;quot;'
let eq = '&amp;quot;'
else
let cmd = substitute($VIMRUNTIME, ' ', '&amp;quot; ', '') . '\diff&amp;quot;'
endif
else
let cmd = $VIMRUNTIME . '\diff'
endif
silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' &amp;gt; ' . arg3 . eq
endfunction
&lt;/code>&lt;/pre>&lt;p>以上就是我关于windows下VIM的配置修改了。我使用的配置文件可以在&lt;a href="https://github.com/tao12345666333/VimforWindowssetting">Vim for Windows setting&lt;/a>下载得到。&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Vim/" term="Vim" label="Vim"/></entry><entry><title type="text">LAMP环境的快速搭建</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/08/07/LAMP%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/><id>https://moelove.info/2013/08/07/LAMP%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-08-07T21:30:59+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">这是我在我的centos 吧专门写的教程帖，目的也就是为了让新手可以更快的搭建起来环境，而不是一直在门外徘徊。所以就搬过来了，时间……</summary><content type="html">&lt;blockquote>
&lt;p>这是我在我的&lt;a href="http://tieba.baidu.com/f?kw=centos">centos 吧&lt;/a>专门写的教程帖，目的也就是为了让新手可以更快的搭建起来环境，而不是一直在门外徘徊。所以就搬过来了，时间神马的就按照&lt;a href="http://tieba.baidu.com/p/2514694347">原帖&lt;/a>来吧。&lt;/p>
&lt;/blockquote>
&lt;h3 id="写在前面">写在前面&lt;/h3>
&lt;p>本篇文章是面向linux新手，文中采用环境是&lt;em>Win7+V-BOX&lt;/em>，配置过程用putty进行操作（个人习惯而已），linux系统使用CentOS6.3版本。CentOS的安装方法及虚拟机中网络配置请参阅centos吧精品帖&lt;a href="http://tieba.baidu.com/p/2068921476">【教程】最全centos 安装方法及内容详解&lt;/a>。为了尽量一次性可以让读者完成LAMP环境的搭建，本次安装过程都采用&lt;code>yum&lt;/code>包管理机制进行安装。当然生产环境下一般都是采用源码编译的。在近期我也会再出连载文，使用源码包进行LAMP环境的搭建，欢迎关注。如果有任何意见或者建议都可以到centos吧发帖询问。
Ps:本文LAMP = Linux + Apache + Mysql + PHP&lt;/p>
&lt;h3 id="安装过程先确保你的系统网络正常或者搭建好了本地源">安装过程（先确保你的系统网络正常或者搭建好了本地源）&lt;/h3>
&lt;h4 id="1-首先安装apache使用命令">1. 首先安装Apache，使用命令：&lt;/h4>
&lt;p>&lt;code>sudo yum install httpd –y&lt;/code>&lt;/p>
&lt;h4 id="2-然后安装mysql使用命令">2. 然后安装Mysql，使用命令&lt;/h4>
&lt;p>&lt;code>sudo yum install mysql mysql-server –y&lt;/code>&lt;/p>
&lt;h4 id="3-再安装php-使用命令">3. 再安装php ，使用命令&lt;/h4>
&lt;p>&lt;code>sudo yum install php –y&lt;/code>&lt;/p>
&lt;h4 id="4-安装完毕之后启动apache-使用">4. 安装完毕之后启动apache. 使用&lt;/h4>
&lt;p>&lt;code>sudo service httpd start&lt;/code>&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/serverstart.jpg" width="70%" />&lt;/p>
&lt;p>启动成功了，我们访问一下，在浏览器的地址栏输入虚拟机IP。&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/view.jpg" width="70%" />&lt;/p>
&lt;p>好，这里遇到了我们的第一个问题， &lt;strong>无法访问&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>apache服务已经打开，但是却无法访问
这里很可能是&lt;strong>iptables&lt;/strong>的防御规则导致的。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>执行&lt;code>iptables –L &lt;/code>查看所有的iptables的规则。&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampiptables.jpg" width="70%" />&lt;/p>
&lt;p>关于iptables的知识可以自行了解或者关注后续讲解
我们执行 &lt;code>sudo iptables –F&lt;/code> 清除所有规则&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampcleariptables.jpg" width="70%" />&lt;/p>
&lt;p>接下来在浏览器输入虚拟机地址 ，我们看到如下：&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampsuccess.jpg" width="70%" />&lt;/p>
&lt;p>我们已经访问成功了！&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;s>当然在这里的时候也许还有人是访问不了的，&lt;/s>可能是因为CentOS自带的&lt;strong>SElinux&lt;/strong>机制影响的&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>我们执行&lt;code>getenforce&lt;/code>命令来查看SElinux的状态，使用&lt;code>sudo setenforce 0&lt;/code>来改变SElinux为&lt;em>permission&lt;/em>状态。&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampSELinuxstatus.jpg" width="70%" />&lt;/p>
&lt;p>都执行完成后，&lt;s>应该&lt;/s>就可以访问了。&lt;/p>
&lt;h4 id="5测试是否可以执行php代码">5.测试是否可以执行php代码&lt;/h4>
&lt;p>执行 &lt;code>vim /var/www/html/test.php&lt;/code> 写入测试代码&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampphpinfo.jpg" width="70%" />&lt;/p>
&lt;p>保存退出，用浏览器进行访问&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampviewstatus.jpg" width="70%" />&lt;/p>
&lt;p>成功！&lt;/p>
&lt;p>但是向后看，发现组成模块里面没有&lt;strong>mysql&lt;/strong>。说明现在还不支持mysql模块，因为我们少安装了一个东西 现在执行&lt;/p>
&lt;pre>&lt;code>sudo yum install php-mysql
&lt;/code>&lt;/pre>&lt;p>添加php和mysql的中间模块，重启apache服务:&lt;code>sudo service httpd restart&lt;/code> 再次访问，发现组成模块中有了mysql的信息，说明可以访问mysql的数据库了。&lt;/p>
&lt;p>接下来执行&lt;code>sudo service mysqld start&lt;/code> 启动mysql服务。
执行&lt;/p>
&lt;pre>&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>访问mysql数据库&lt;/p>
&lt;p>&lt;img src="http://moelove.qiniudn.com/lampmysqlstatus.jpg" width="70%" />&lt;/p>
&lt;p>表示mysql数据库也正常，到此，&lt;strong>LAMP环境初步建成&lt;/strong>。&lt;/p>
&lt;h4 id="6设置服务的开机自动启动s可以不做s">6.设置服务的开机自动启动&lt;s>（可以不做）&lt;/s>&lt;/h4>
&lt;p>使用&lt;/p>
&lt;pre>&lt;code>sudo chkconfig httpd on
sudo chkconfig mysqld on
&lt;/code>&lt;/pre>&lt;h4 id="7lamp环境的配置文件">7.LAMP环境的配置文件&lt;/h4>
&lt;pre>&lt;code>Apache: /etc/httpd/conf/httpd.conf
Php: /etc/php.ini
Mysql: /etc/my.cnf
&lt;/code>&lt;/pre>&lt;h3 id="lamp环境搭建小结">LAMP环境搭建小结&lt;/h3>
&lt;p>通过以上过程，你就已经成功的搭建好了LAMP环境，剩下的配置就是修改你的配置文件，进而达到效果。类似启动类型，模块，超时，地址，状态之类的，都会在下篇文章中写出。
使用&lt;em>yum&lt;/em>安装LAMP环境是最简单的，也是最方便的。不过生产环境都是用的源码包，因为源码包可以更加个性化的定义你需要的模块。&lt;/p>
&lt;p>&lt;a href="http://wenku.baidu.com/view/fd825c8551e79b8969022614.html">CentOS安装方法&lt;/a>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/><category scheme="https://moelove.info/tags/LAMP/" term="LAMP" label="LAMP"/></entry><entry><title type="text">cat 命令研究</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/03/20/cat-%E5%91%BD%E4%BB%A4%E7%A0%94%E7%A9%B6/"/><id>https://moelove.info/2013/03/20/cat-%E5%91%BD%E4%BB%A4%E7%A0%94%E7%A9%B6/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-03-20T21:24:20+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">有人问我关于centos里面使用cat命令的问题，我在这里简单记录一下。 在linux下，cat应该是使用最频繁的命令之一了吧。 c……</summary><content type="html">&lt;blockquote>
&lt;p>有人问我关于centos里面使用cat命令的问题，我在这里简单记录一下。
在linux下，cat应该是使用最频繁的命令之一了吧。&lt;/p>
&lt;/blockquote>
&lt;h3 id="cat命令在linux作以下用途">cat命令在Linux作以下用途：&lt;/h3>
&lt;ul>
&lt;li>在屏幕上显示文本文件。&lt;/li>
&lt;li>复制文本文件。&lt;/li>
&lt;li>合并文本文件。&lt;/li>
&lt;li>创建新的文本文件。&lt;/li>
&lt;/ul>
&lt;h3 id="cat命令支持的语法如下">cat命令支持的语法如下：&lt;/h3>
&lt;pre>&lt;code>cat filename
cat options filename
cat file1 file2
cat file1 file2 &amp;gt; newcombinedfile
&lt;/code>&lt;/pre>&lt;h4 id="显示文件的内容">显示文件的内容：&lt;/h4>
&lt;pre>&lt;code>cat /tmp/test
&lt;/code>&lt;/pre>&lt;p>上面的命令就是查看文件&lt;code>/tmp/test&lt;/code>的内容，把内容输出到屏幕。
但是也可以使用&lt;/p>
&lt;pre>&lt;code>cat /tmp/test &amp;gt; /tmp/test2
&lt;/code>&lt;/pre>&lt;p>使用上面的命令，可以把文件内容**&lt;a href="http://linux-wiki.cn/wiki/zh-hans/Bash%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">重定向&lt;/a>**到/tmp/test2文件中&lt;/p>
&lt;h4 id="串联文件">串联文件：&lt;/h4>
&lt;p>串联文件是把文件内容一起输出，但是不会改变源文件的内容&lt;/p>
&lt;pre>&lt;code>cat /tmp/test1 /tmp/test2 /tmp/test3
&lt;/code>&lt;/pre>&lt;p>以上命令会将/tmp 目录下的 test1 ,test2 ,test3 三个文件的内容一起输出，当然也可以使用重定向命令查看输出内容&lt;/p>
&lt;pre>&lt;code>cat /tmp/test1 /tmp/test2 /tmp/test3 &amp;gt;/tmp/testoutputs
&lt;/code>&lt;/pre>&lt;p>重定向至/tmp 下的testoutputs 文件中&lt;/p>
&lt;p>当然查看的时候可以配合管道命令使用&lt;/p>
&lt;p>&lt;code>cat /tmp/test1 /tmp/test2 /tmp/test3 | less&lt;/code>&lt;/p></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry><entry><title type="text">fedora安装后最初的事情</title><link rel="alternate" type="text/html" href="https://moelove.info/2013/03/09/fedora%E5%AE%89%E8%A3%85%E5%90%8E%E6%9C%80%E5%88%9D%E7%9A%84%E4%BA%8B%E6%83%85/"/><id>https://moelove.info/2013/03/09/fedora%E5%AE%89%E8%A3%85%E5%90%8E%E6%9C%80%E5%88%9D%E7%9A%84%E4%BA%8B%E6%83%85/</id><updated>2021-05-07T06:32:34+08:00</updated><published>2013-03-09T21:21:14+00:00</published><author><name>张晋涛</name><uri>https://moelove.info/</uri><email>zhangjintao9020@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">更新源 sudo yum localinstall --nogpgcheck http://mirrors.163.com/rpmfusion/free/fedora/rpmfusion-free-release-stable.noarch.rpm http://mirrors.163.com/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm (这个是添加国内的软件源) sudo yum update 网络相关 firefox sudo yum install firefox chrome / chromium 我本人比较习惯用chrome的 不过最近网络不是很稳定 先……</summary><content type="html">&lt;h3 id="更新源">更新源&lt;/h3>
&lt;pre>&lt;code>sudo yum localinstall --nogpgcheck http://mirrors.163.com/rpmfusion/free/fedora/rpmfusion-free-release-stable.noarch.rpm http://mirrors.163.com/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm (这个是添加国内的软件源)
sudo yum update
&lt;/code>&lt;/pre>&lt;h3 id="网络相关">网络相关&lt;/h3>
&lt;h4 id="firefox">firefox&lt;/h4>
&lt;pre>&lt;code>sudo yum install firefox
&lt;/code>&lt;/pre>&lt;h4 id="chrome--chromium">chrome / chromium&lt;/h4>
&lt;p>我本人比较习惯用chrome的 &lt;s>不过最近网络不是很稳定 &lt;/s>先补充chromium 的安装方法吧&lt;/p>
&lt;ul>
&lt;li>chromium的安装
首先添加&lt;a href="http://pan.baidu.com/s/1kTIBvUZ">chromium的fedora源&lt;/a>,将下载好的 &lt;strong>.repo&lt;/strong> 文件移动到&lt;code>/etc/yum.repos.d/&lt;/code>下， 执行&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo yum install chromium
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>chrome的安装
从&lt;a href="http://www.google.com/intl/zh-CN/chrome/">官网&lt;/a>上下载chrome 的rpm包，或者从我的网盘下载对应的&lt;a href="http://pan.baidu.com/s/1ntmdqtz">32位&lt;/a> 或 &lt;a href="http://pan.baidu.com/s/1jGuqRdG">64位&lt;/a> 的rpm 包
执行&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo rpm -ivh google-chrome.rpm
&lt;/code>&lt;/pre>&lt;h3 id="安装证书">安装证书&lt;/h3>
&lt;pre>&lt;code>sudo yum localinstall --nogpgcheck http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-branched.noarch.rpm http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-branched.noarch.rpm
&lt;/code>&lt;/pre>&lt;h3 id="压缩解压软件">压缩/解压软件&lt;/h3>
&lt;pre>&lt;code>sudo yum install unrar
sudo yum install p7zip
&lt;/code>&lt;/pre>&lt;h3 id="影音播放">影音播放&lt;/h3>
&lt;pre>&lt;code>sudo yum install gstreamer-plugins-good gstreamer-plugins-bad gstreamer-plugins-ugly libtunepimp-extras-freeworld xine-lib-extras-freeworld(安装音频解码器)
sudo yum install ffmpeg ffmpeg-libs gstreamer-ffmpeg libmatroska xvidcore(安装视频解码器)
&lt;/code>&lt;/pre>&lt;h3 id="编辑器">编辑器&lt;/h3>
&lt;ul>
&lt;li>vim&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>sudo yum install vim
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Sublime Text
我也很喜欢因为运行速度快，而且免费。安装方法可以参考我的&lt;a href="http://moelove.info/articles/2013/08/30/fedoraxia-an-zhuang-sublime-text-2de-fang-fa/">fedora下安装sublime text 2&lt;/a>这篇文章。&lt;/li>
&lt;/ul></content><category scheme="https://moelove.info/post/" term="post" label="post"/><category scheme="https://moelove.info/tags/Linux/" term="Linux" label="Linux"/></entry></feed>